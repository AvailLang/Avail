/*
 * Tuples.avail
 * Copyright © 1993-2015, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Tuples"
Versions
	"1.0.0 DEV 2014-04-28"
Extends
	"Collections",
	"Early Tuples"
Uses
	"Bootstrap",
	"Control Structures",
	"Definers",
	"Early Assertions",
	"Early Conditionals",
	"Early Functions",
	"Early Maps",
	"Enumeration Support",
	"Literals",
	"Logic",
	"Macro Support",
	"Math",
	"Types",
	"Variables"
Names
	"Require:_accepts_«(check indices)»?",
	"a tuple iteration prefix function",
	"a two-input tuple iteration prefix function",
	"a two-input tuple prefix function",
	"all indices of_in_",
	"all indices of_where_",
	"all indices of…in_§where_",
	"distinct_",
	"drop from_until_",
	"drop from_while_",
	"drop…from_§until_",
	"drop…from_§while_",
	"drop_from_",
	"first index of_in_",
	"first index of_where_",
	"first index of…in_§where_",
	"For each…,…in|of_§do_",
	"last index of_where_",
	"last index of…in_§where_",
	"left fold_through_",
	"map each…,…in|of_§through_",
	"merge sort_",
	"merge sort_with_",
	"merge sort…,…in|of_§by_",
	"quicksort_",
	"quicksort_with_",
	"quicksort…,…in|of_§by_",
	"replace all occurrences of_in_with_",
	"replace the first occurrence of_in_with_",
	"right fold_through_",
	"select each…,…from_§where_",
	"split_after_",
	"split_before_",
	"stripe_at_",
	"take from_until_",
	"take from_while_",
	"take…from_§until_",
	"take…from_§while_",
	"take_from_",
	"tuple body function(_,_)",
	"zip_",
	"∑_",
	"∏_",
	"_ends with_",
	"_padded with_to a multiple of_",
	"_starts with_",
	"_to_",
	"_'s⁇head",
	"_'s⁇last",
	"_'s⁇strengthening function",
	"_'s⁇tail",
	"_[_.._]else_",
	"_[_..]else_",
	"_[.._]else_",
	"_[_.._]→_",
	"_[_↔_]",
	"_↑-=_",
	"_-=_",
	"«_‡zip»"
Body

/**
 * @method "“_”"
 * @param "t" "tuple meta"
 * @returns "string"
 * @category "Tuples" "Stringification"
 */
Method "“_”" is
[
	t : tuple meta
|
	if |t| < ∞ then [primitive description of t] 
	else 
	[
		s : nonempty string := "<";
		leadingTypes ::= t's leading types;
		index : natural number := 1;
		While index ≤ |leadingTypes|
		do [s := eject s ++ “leadingTypes[(index++)]” ++ ", ";];
		s := eject s ++ “t's default type” ++ "…|";
		lower ::= ⎣t⎦;
		upper ::= ⎡t⎤;
		s := eject s ++ “||t||” (cardinality restriction);
		s := eject s ++ ">";
		s
	]
] : string;

/**
 * Is the specified {@param "tuple"} empty?
 * 
 * @method "_is empty"
 * @param "aTuple" "tuple"
 * @returns "boolean"
 *          {@method "true"} if the argument is empty, {@method "false"} 
 *          otherwise.
 * @category "Tuples" "Queries" "Collections"
 */
Stable method "_is empty" is
[
	aTuple : tuple
|
	|aTuple| = 0
] : boolean;

/**
 * Iteratively apply `action` to each consecutive element of `aTuple`.
 * 
 * @method "For each of⁇_do_"
 * @param "aTuple" "tuple"
 * @param "action" "[⊥]→⊤"
 *        A function that accepts the elements of the tuple.
 * @returns "⊤"
 * @category "Tuples" "Collections" "Control Structures"
 */
Method "For each of⁇_do_" is
[
	aTuple : tuple,
	action : [⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			action(aTuple[index]);
			index++;
			Restart loop
		];
	]();
] : ⊤;

/**
 * Iteratively apply `action` to each consecutive element of `aTuple`.
 * 
 * @method "For each of⁇_do_"
 * @param "aTuple" "tuple"
 * @param "action" "[⊥, ⊥]→⊤"
 *        A function that accepts 1) an element of the tuple and 2) the index of
 *        that element.
 * @returns "⊤"
 * @category "Tuples" "Collections" "Control Structures"
 */
Method "For each of⁇_do_" is
[
	aTuple : tuple,
	action : [⊥, ⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			action(aTuple[index], index);
			index++;
			Restart loop
		];
	]();
] : ⊤;

/**
 * Helper method for semantic restrictions: If {@param "action"} does not accept 
 * the type union of all element types of {@param "tupleType"} and their
 * indices, then reject the current parse.
 * 
 * @method "Require:_accepts_«(check indices)»?"
 * @param "action" "function meta"
 *        A function type whose first parameter must correspond to the type
 *        union of the element types of {@param "tupleType"} and whose second 
 *        parameter, if provided, must correspond to their indices.
 * @param "tupleType" "tuple meta"
 *        A tuple type.
 * @returns "⊤"
 * @category "Tuples" "Collections" "Types" "Assertions"
 */
Method "Require:_accepts_«(check indices)»?" is
[
	action : function meta,
	tupleType : tuple meta,
	checkIndices : boolean
|
	If ⎣action's parameters' type⎦ < 1 then
	[
		Reject parse, expected:
			"repeatedly applied function to accept at least one argument"
	];
	union ::= ∪ tupleType[1..|tupleType's leading types| + 1];
	If action[1] ≠ ⊥ ∧ ¬union ⊆ action[1] then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all elements of the tuple ⊆ "
			++ “tupleType”
			++ " (but it only accepts "
			++ “action[1]”
			++ ")"
	];
	If checkIndices
		∧ ⎣action's parameters' type⎦ ≥ 2
		∧ action[2] ≠ ⊥
		∧ ¬[1..⎡tupleType⎤ + 1) ⊆ action[2]
	then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all indices of the tuple ⊆ "
			++ “tupleType”
			++ " (but it only accepts "
			++ “action[2]”
			++ ")"
	];
] : ⊤;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * If the tuple is certainly nonempty and the function certainly does not
 * complete if applied, then answer ⊥.
 * 
 * @method "For each of⁇_do_"
 * @restricts "tuple meta"
 * @restricts "function meta"
 */
Semantic restriction "For each of⁇_do_" is
[
	tupleType : tuple meta,
	action : function meta
|
	Require: action accepts tupleType;
	if ⎣tupleType⎦ > 0 ∧ action's return type = ⊥ then [⊥] else [⊤]
];

/*
 * A method that returns a function that returns the strongest type of all the
 * elements in aTuple.
 */
Public method "_'s⁇strengthening function" is
[
	aTuple : expression phrase ⇒ tuple
|
 	[
		/* Determine the strongest type of the loop variable for aTuple */
		aTupleType ::= aTuple's semantic type;
		tupleOfTypes ::= aTupleType's leading types ++ 
			<aTupleType's default type>;
		∪ tupleOfTypes
	] : any's type
]:[]→(any's type);

/**
 * Answer a function that computes a prefix function.
 * 
 * @method "a tuple iteration prefix function"
 * @returns "[literal phrase ⇒ token, expression phrase ⇒ tuple]→⊤"
 *          The requested function.
 */
Public method "a tuple iteration prefix function" is
[
	[
		elementPhrase : literal phrase ⇒ token,
		aTuple : expression phrase ⇒ tuple
	|
		/* Establish local loop variable is unique*/
		Declare loop variable elementPhrase as aTuple's strengthening function;
	]
]: [literal phrase ⇒ token, expression phrase ⇒ tuple]→⊤;
	
/**
 * Answer a function that computes a prefix function for an input type
 * of the tuple and the index type.
 * 
 * @method "a two-input tuple iteration prefix function"
 * @returns "[literal phrase ⇒ token, expression phrase ⇒ tuple]→⊤"
 *          The requested function.
 */
Public method "a two-input tuple iteration prefix function" is
[
	[
		elementPhrase : literal phrase ⇒ token,
		indexPhrase : literal phrase ⇒ token,
		aTuple : expression phrase ⇒ tuple
	|
		Declare loop variable elementPhrase as aTuple's strengthening function;
		aTupleType ::= aTuple's semantic type;
		Declare loop variable indexPhrase as [(0 .. ⎡aTupleType⎤+1)];
	]
]: [literal phrase ⇒ token, 
    literal phrase ⇒ token,
    expression phrase ⇒ tuple]→⊤;
	
/**
 * Answer a function that computes a prefix function that takes two
 * inputs, both to be of types of the elements of the tuple.
 * 
 * @method "a tuple iteration prefix function"
 * @returns "[literal phrase ⇒ token, expression phrase ⇒ tuple]→⊤"
 *          The requested function.
 */
Public method "a two-input tuple prefix function" is
[
	[
		firstInputPhrase : literal phrase ⇒ token,
		secondInputPhrase : literal phrase ⇒ token,
		aTuple : expression phrase ⇒ tuple
	|
		Declare loop variable firstInputPhrase as 
			aTuple's strengthening function;
		Declare loop variable secondInputPhrase as 
			aTuple's strengthening function;
	]
]: [literal phrase ⇒ token, 
    literal phrase ⇒ token,
    expression phrase ⇒ tuple]→⊤;

/*The following methods, 
 * 	"return type(_,_,_,_)"
 * 	"index return type(_,_,_,_)"
 * evaluate the return types of methods given a tuple input to a block.*/
Private method "«two input»?«indexed»?return type(_,_,_,_)" is
[
 	twoInput : boolean,
 	indexed : boolean,
	aTuple : expression phrase ⇒ tuple,
	action : block phrase ⇒ []→⊤,
	baseReturnType : type,
	anAtom : atom
|
	elementType ::= aTuple's strengthening function();
	aTupleType ::= aTuple's semantic type;
	blockType ::= if twoInput then
	[
		if indexed then
		[
			indexingType ::= (0 .. ⎡aTupleType⎤+1);
			[elementType, indexingType]→(action's semantic type's return type)
		] else [
		    [elementType, elementType]→(action's semantic type's return type)
		]
	] else
	[
		[elementType]→(action's semantic type's return type)
	];
	
	strengthen baseReturnType for call of anAtom using <aTupleType, blockType> 

]:type;
	
/**
 * Answer a function that computes a body function.
 * 
 * @method "tuple body function(_,_)"
 * @param "anAtom" "atom" the atom that represents the function that the
 * 		macro builds
 * @param "baseReturnType" "type" the base return type of the method
 * @returns "[literal phrase ⇒ token, expression phrase ⇒ tuple, 
 *   block phrase ⇒ []→ boolean]→send phrase ⇒ ⊤"
 *          The requested function.
 */
Public method "tuple body function(_,_)" is
[
 	anAtom : atom,
 	baseReturnType : type
|
	[
		elementPhrase : literal phrase ⇒ token,
		aTuple : expression phrase ⇒ tuple,
		action : block phrase ⇒ []→⊤
	|
		returnType ::= 
				return type(aTuple, action, baseReturnType, anAtom);
		statements ::= action's statements;
		blockReturnType ::= cast statements
			into [t : phrase+ | t[|t|]'s semantic type]
			else [⊤];
		name ::= elementPhrase's token's lexeme;
		declaration ::= scope map[name];
		Undeclare name;
		restricted send anAtom with
			«<
				aTuple, 
				«[
					<cast declaration into [d : argument phrase | d]>
				 | 
					statements
				] : blockReturnType»
			>» : returnType
	] : send phrase ⇒ ⊤
] : [literal phrase ⇒ token, expression phrase ⇒ tuple, 
     block phrase ⇒ []→ ⊤]→send phrase ⇒ ⊤;
			 
/**
 * Answer a function that computes a two-input body function.
 * 
 * @method "two-input tuple body function(_,_)"
 * @param "anAtom" "atom" the atom that represents the function that the
 * 		macro builds
 * @param "baseReturnType" "type" the base return type of the method
 * @returns "[literal phrase ⇒ token, expression phrase ⇒ tuple, 
 *   block phrase ⇒ []→ boolean]→send phrase ⇒ ⊤"
 *          The requested function.
 */
Private method "«indexed»?two-input tuple body function(_,_)" is
[
	indexed : boolean,
	anAtom : atom,
	baseReturnType : type
|
	[
		firstInputPhrase : literal phrase ⇒ token,
		secondInputPhrase : literal phrase ⇒ token,
		aTuple : expression phrase ⇒ tuple,
		action : block phrase ⇒ []→⊤
	|
		/* Build the block function */
		returnType ::= if indexed then
			[
			 	two input indexed return type(
					aTuple, action, baseReturnType, anAtom)
			] else [
			    two input return type(
			    	aTuple, action, baseReturnType, anAtom)        
			];
		statements ::= action's statements;
		blockReturnType ::= cast statements
			into [t : phrase+ | t[|t|]'s semantic type]
			else [⊤];
	
		castToPhrase ::= [s : nonempty string | 
			cast scope map[s] into [d : argument phrase | d]];
		
		firstInputName ::= firstInputPhrase's token's lexeme;
		secondInputName ::= secondInputPhrase's token's lexeme;
		firstInputDeclaration ::= castToPhrase(firstInputName);
		secondInputDeclaration ::= castToPhrase(secondInputName);
		Undeclare firstInputName;
		Undeclare secondInputName;

		restricted send anAtom with
			«<
				aTuple,
				«[
					<firstInputDeclaration, secondInputDeclaration>
				|
					statements
				] : blockReturnType»
			>» : returnType
	] : send phrase ⇒ ⊤
]:[literal phrase ⇒ token, literal phrase ⇒ token, expression phrase ⇒ tuple, 
   block phrase ⇒ []→ ⊤]→send phrase ⇒ ⊤;
	
/**
 * Tuple iterating-loop that invokes {@param "action"} once for every
 * {@param "elementPhrase"} in {@param "aTuple"} 
 * 
 * @macro "For each…in|of_§do_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aTuple"}.
 * @param "aTuple" "expression phrase ⇒ tuple"
 *        An {@type "expression phrase"} that yields the tuple to iterate over
 * @param "action" "block phrase ⇒ []→⊤"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        loop.
 * @returns "send phrase ⇒ ⊤"
 * @category "Control Structures" "Loops" "Collections" "Tuples"
 */
Macro "For each…in|of_§do_" is a tuple iteration prefix function,
	tuple body function($"For each of⁇_do_",⊤);
		
/**
 * Tuple iterating-loop that invokes {@param "action"} once for every
 * {@param "elementPhrase"} in {@param "aTuple"}, making available the index
 * of the {@param "elementPhrase"} in the scope of the function body.
 * 
 * @macro "For each…,…in|of_§do_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aTuple"}.
 * @param "indexPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop index variable. The generated
 *        loop variable is given the strongest possible type based on the 
 *        cardinality of {@param "aTuple"}.
 * @param "aTuple" "expression phrase ⇒ tuple"
 *        An {@type "expression phrase"} that yields the tuple to iterate over
 * @param "action" "block phrase ⇒ []→⊤"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        loop.
 * @returns "send phrase ⇒ ⊤"
 * @category "Control Structures" "Loops" "Collections" "Tuples"
 */
Macro "For each…,…in|of_§do_" is a two-input tuple iteration prefix function,
	indexed two-input tuple body function($"For each of⁇_do_", ⊤);

/**
 * Iteratively apply {@param "transformer"} to each consecutive element of 
 * {@param "aTuple"}, collecting the results into a new tuple (and preserving 
 * ordering of the transformed elements). Answer this tuple.
 * 
 * @method "map_through_"
 * @param "aTuple" "tuple"
 * @param "transformer" "[⊥]→any"
 *        A function that accepts the elements of the tuple.
 * @returns "tuple"
 *          A tuple of results of applications of {@param "transformer"} to the
 *          elements of {@param "aTuple"}.
 * @category "Tuples" "Control Structures" "Collections" "Transformers"
 */
Method "map_through_" is
[
	aTuple : tuple,
	transformer : [⊥]→any
|
	index : natural number := 1;
	result : tuple := <>;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			result := eject result ++ <transformer(aTuple[index])>;
			index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Iteratively apply {@param "transformer"} to each consecutive element of 
 * {@param "aTuple"}, collecting the results into a new tuple (and preserving 
 * ordering of the transformed elements). Answer this {@type "tuple"}.
 * 
 * @method "map_through_"
 * @param "aTuple" "tuple"
 * @param "transformer" "[⊥, ⊥]→any"
 *        A function that accepts 1) an element of the tuple and 2) the index of
 *        that element.
 * @returns "tuple"
 *          A tuple of results of applications of {@param "transformer"} to the
 *          elements and indices of {@param "aTuple"}.
 * @category "Tuples" "Control Structures" "Collections" "Transformers"
 */
Method "map_through_" is
[
	aTuple : tuple,
	transformer : [⊥, ⊥]→any
|
	index : natural number := 1;
	result : tuple := <>;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			result := eject result ++ <transformer(aTuple[index], index)>;
			index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * If the tuple is certainly nonempty, then the function cannot answer ⊥.
 * 
 * @method "map_through_"
 * @restricts "tuple meta"
 * @restricts "[…]→any's type"
 */
Semantic restriction "map_through_" is
[
	tupleType : tuple meta,
	transformer : […]→any's type
|
	Require: transformer accepts tupleType (check indices);
	If ⎣tupleType⎦ > 0 then
	[
		If transformer's return type = ⊥ then
		[
			Reject parse, expected:
				"repeatedly applied function to have a return type other than\
				\| ⊥"
		];
	];
	<<>, transformer's return type… | ||tupleType||>
];

/**
 * Iteratively apply {@param "transformer"} to each consecutive element of 
 * {@param "aTuple"}, collecting the results into a new tuple (and preserving 
 * ordering of the transformed elements). Answer this tuple.
 * 
 * @macro "map each…in|of_§through_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aTuple"}.
 * @param "aTuple" "expression phrase ⇒ any"
 *        An {@type "expression phrase"} that yields the tuple to iterate over
 * @param "action" "block phrase ⇒ []→⊤"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        loop.
 * @returns "send phrase ⇒ ⊤"
 * @category "Control Structures" "Loops" "Collections" "Tuples"
 */
Macro "map each…in|of_§through_" is a tuple iteration prefix function,
	tuple body function($"map_through_",tuple);

/**
 * Iteratively apply {@param "transformer"} to each consecutive element of 
 * {@param "aTuple"}, collecting the results into a new tuple (and preserving 
 * ordering of the transformed elements). Answer this {@type "tuple"}.
 * 
 * @macro "map each…,…in|of_§through_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aTuple"}.
 * @param "indexPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop index variable. The generated
 *        loop variable is given the strongest possible type based on the 
 *        cardinality of {@param "aTuple"}.
 * @param "aTuple" "expression phrase ⇒ tuple"
 *        An {@type "expression phrase"} that yields the tuple to iterate over
 * @param "action" "block phrase ⇒ []→⊤"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        loop.
 * @returns "send phrase ⇒ ⊤"
 * @category "Loops" "Collections" "Tuples"
 */
Macro "map each…,…in|of_§through_" is 
	a two-input tuple iteration prefix function,
	indexed two-input tuple body function($"map_through_",tuple);

/**
 * Iteratively apply {@param "predicate"} to each consecutive element of 
 * {@param "aTuple"}, collecting those elements for which {@param "predicate"} 
 * answers {@method "true"} into a new tuple (and preserving ordering). Answer 
 * the new tuple.
 * 
 * @method "filter_by_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥]→boolean"
 *        A function that accepts the elements of the tuple and answers 
 *        {@method "true"} iff they should be accumulated into the output tuple.
 * @returns "tuple"
 *          A tuple containing exactly those elements of {@param "aTuple"} for 
 *          which {@param "predicate"} answered {@method "true"}.
 * @category "Tuples" "Control Structures" "Collections" "Transformers"
 */
Method "filter_by_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop;
		If index ≤ end then
		[
			element ::= aTuple[index];
			If predicate(element) then
			[
				result := eject result ++ <element>;
			];
			index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Iteratively apply {@param "predicate"} to each consecutive element and index
 * of {@param "aTuple"}, collecting those elements for which {@param 
 * "predicate"} answers {@method "true"} into a new tuple (and preserving 
 * ordering). Answer the new tuple.
 * 
 * @method "filter_by_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥, ⊥]→boolean"
 *        A function that accepts 1) an element of the tuple and 2) the index of
 *        that element and which answers {@method "true"} iff the elements 
 *        should be accumulated into the output tuple.
 * @returns "tuple"
 *          A tuple containing exactly those elements of {@param "aTuple"} for 
 *          which {@param "predicate"} answered {@method "true"}.
 * @category "Tuples" "Control Structures" "Collections" "Transformers"
 */
Method "filter_by_" is
[
	aTuple : tuple,
	predicate : [⊥, ⊥]→boolean
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop;
		If index ≤ end then
		[
			element ::= aTuple[index];
			If predicate(element, index) then
			[
				result := eject result ++ <element>;
			];
			index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * 
 * @method "filter_by_"
 * @restricts "tuple meta"
 * @restricts "[…]→boolean's type"
 */
Semantic restriction "filter_by_" is
[
	tupleType : tuple meta,
	predicate : […]→boolean's type
|
	Require: predicate accepts tupleType (check indices);
	if predicate's return type = true's type then [tupleType]
	else
	[
		union ::= ∪ tupleType[1..|tupleType's leading types| + 1];
		sizes ::=
			if predicate's return type = false's type then [0's type]
			else [[0..⎡tupleType⎤ + 1)];
		<<>, union…|sizes>
	]
];

/**
 * Iteratively apply {@param "predicate"} to each consecutive element of 
 * {@param "aTuple"}, collecting those elements for which {@param "predicate"} 
 * answers {@method "true"} into a new tuple (and preserving ordering). Answer 
 * the new tuple.
 * 
 * @macro "select each…from_§where_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aTuple"}.
 * @param "aTuple" "expression phrase ⇒ any"
 *        An {@type "expression phrase"} that yields the tuple to iterate over
 * @param "action" "block phrase ⇒ []→⊤"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        loop.
 * @returns "send phrase ⇒ ⊤"
 * @category "Control Structures" "Loops" "Collections" "Tuples"
 */
Macro "select each…from_§where_" is a tuple iteration prefix function,
	tuple body function($"filter_by_",tuple);

/**
 * Iteratively apply {@param "predicate"} to each consecutive element and index
 * of {@param "aTuple"}, collecting those elements for which {@param 
 * "predicate"} answers {@method "true"} into a new tuple (and preserving 
 * ordering). Answer the new tuple.
 * 
 * @macro "select each…,…from_§where_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aTuple"}.
 * @param "indexPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop index variable. The generated
 *        loop variable is given the strongest possible type based on the 
 *        cardinality of {@param "aTuple"}.
 * @param "aTuple" "expression phrase ⇒ tuple"
 *        An {@type "expression phrase"} that yields the tuple to iterate over
 * @param "action" "block phrase ⇒ []→⊤"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        loop.
 * @returns "send phrase ⇒ ⊤"
 * @category "Loops" "Collections" "Tuples"
 */
Macro "select each…,…from_§where_" is a two-input tuple iteration prefix function,
	indexed two-input tuple body function($"filter_by_",tuple);

/**
 * Iteratively apply {@param "action"} to each consecutive element of 
 * {@param "aTuple"}, rejecting those elements for which {@param "action"} 
 * answers {@method "true"} into a new tuple (and preserving ordering). Answer 
 * the new tuple.
 * 
 * @macro "reject each…from_§where_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aTuple"}.
 * @param "aTuple" "expression phrase ⇒ any"
 *        An {@type "expression phrase"} that yields the tuple to iterate over
 * @param "action" "block phrase ⇒ []→⊤"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        loop.
 * @returns "send phrase ⇒ ⊤"
 * @category "Control Structures" "Loops" "Collections" "Tuples"
 */
Macro "reject each…from_§where_" is a tuple iteration prefix function,
[
	elementPhrase : literal phrase ⇒ token,
	aTuple : expression phrase ⇒ tuple,
	action : block phrase ⇒ []→⊤
|
	returnType ::= 
			return type(aTuple, action, tuple, $"filter_by_");

	statements ::= action's statements;
	name ::= elementPhrase's token's lexeme;
	size ::= |statements|;
	newStatements ::= if size = 0 then [<>] else 
	[
	 	end : whole number := cast size-1 into [w : whole number | w];
	 	i : natural number := cast size into [n : natural number | n];
	 	c : expression phrase⇒any := cast statements[i] into 
		 	[e : expression phrase⇒any | e];
	 	statements[..end] ++ <restricted send $"¬_" with «<c>» : boolean>
	];
	blockReturnType ::= cast newStatements
		into [t : phrase+ | t[|t|]'s semantic type]
		else [⊤];

	declaration ::= scope map[name];
	Undeclare name;

	restricted send $"filter_by_" with
		«<
			aTuple, 
			«[
				<cast declaration into [d : argument phrase | d]>
			 | 
			 	newStatements
			] : blockReturnType»
		>» : returnType
] : send phrase ⇒ ⊤;

/**
 * Iteratively apply {@param "action"} to each consecutive element and index
 * of {@param "aTuple"}, rejecting those elements for which {@param 
 * "action"} answers {@method "true"} into a new tuple (and preserving 
 * ordering). Answer the new tuple.
 * 
 * @macro "reject each…,…from_§where_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aTuple"}.
 * @param "indexPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop index variable. The generated
 *        loop variable is given the strongest possible type based on the 
 *        cardinality of {@param "aTuple"}.
 * @param "aTuple" "expression phrase ⇒ tuple"
 *        An {@type "expression phrase"} that yields the tuple to iterate over
 * @param "action" "block phrase ⇒ []→⊤"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        loop.
 * @returns "send phrase ⇒ ⊤"
 * @category "Loops" "Collections" "Tuples"
 */
Macro "reject each…,…from_§where_" is 
	a two-input tuple iteration prefix function,
[
	elementPhrase : literal phrase ⇒ token,
	indexPhrase : literal phrase ⇒ token,
	aTuple : expression phrase ⇒ tuple,
	action : block phrase ⇒ []→⊤
|
	/* Build the block function */
	returnType ::= 
		indexed return type(aTuple, action, tuple, $"filter_by_");
	statements ::= action's statements;
	blockReturnType ::= cast statements
		into [t : phrase+ | t[|t|]'s semantic type]
		else [⊤];

	castToPhrase ::= [s : nonempty string | 
		cast scope map[s] into [d : argument phrase | d]];
	
	elementName ::= elementPhrase's token's lexeme;
	indexName ::= indexPhrase's token's lexeme;
	size ::= |statements|;

	newStatements ::= if size = 0 then [<>]
	else if size = 1 then
	[
	 	i : natural number := cast size into [n : natural number | n];
	 	c : expression phrase⇒any := cast statements[i] into 
	 		[e : expression phrase⇒any | e];
	 	<restricted send $"¬_" with «<c>» : boolean>
	] else 
	[
	 	end : natural number := cast size-1 into [n : natural number | n];
	 	i : natural number := cast size into [n : natural number | n];
	 	c : expression phrase⇒any := cast statements[i] into 
		 	[e : expression phrase⇒any | e];
	 	statements[..end] ++ <restricted send $"¬_" with «<c>» : boolean>
	];
	
	elementDeclaration ::= castToPhrase(elementName);
	indexDeclaration ::= castToPhrase(indexName);
	Undeclare elementName;
	Undeclare indexName;
	
	restricted send $"filter_by_" with
		«<
			aTuple,
			«[
				<elementDeclaration, indexDeclaration>
			|
				newStatements
			] : blockReturnType»
		>» : returnType
] : send phrase ⇒ ⊤;

/**
 * Iteratively apply {@param "accumulator"} to the consecutive elements of 
 * {@param "aTuple"} in order to transform and filter its elements into a new 
 * tuple. When {@param "accumulator"} is invoked, it is passed a "keeper" 
 * function. The keeper function may be invoked to "save" a particular value, 
 * i.e., a value that will be copied into the output tuple. The keeper function 
 * will save at most one value per element of {@param "aTuple"}, i.e., each time 
 * that {@param "accumulator"} is invoked, it may invoke the keeper function at 
 * most one time. Answer the new tuple.
 * 
 * @method "map and filter_by_"
 * @param "aTuple" "tuple"
 * @param "accumulator" "[⊥, ⊥]→⊤"
 *        A function that accepts 1) an element from {@param "aTuple"} and 2) a 
 *        keeper function. The keeper function accepts an argument of the type
 *        that should be saved.
 * @returns "tuple"
 *          A tuple whose elements are those saved by the {@param 
 *          "accumulator"}.
 * @category "Tuples" "Control Structures" "Collections" "Transformers"
 */
Method "map and filter_by_" is
[
	aTuple : tuple,
	accumulator : [⊥, ⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop;
		If index ≤ end then
		[
			hasAlreadyKept : boolean := false;
			accumulator
			(
				aTuple[index],
				[
					transformed : any
				|
					If ¬hasAlreadyKept then
					[
						result := eject result ++ <transformed>;
						hasAlreadyKept := true;
					];
				]
			);
			index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Iteratively apply {@param "accumulator"} to the consecutive elements and 
 * indices of {@param "aTuple"} in order to transform and filter its elements 
 * into a new tuple. When {@param "accumulator"} is invoked, it is passed a 
 * "keeper" function. The keeper function may be invoked to "save" a particular 
 * value, i.e., a value that will be copied into the output tuple. The keeper 
 * function will save at most one value per element of {@param "aTuple"}, i.e., 
 * each time that {@param "accumulator"} is invoked, it may invoke the keeper 
 * function at most one time. Answer the new tuple.
 * 
 * @method "map and filter_by_"
 * @param "aTuple" "tuple"
 * @param "accumulator" "[⊥, ⊥, ⊥]→⊤"
 *        A function that accepts 1) an element from {@param "aTuple"}, 2) the 
 *        index of that element, and 3) a keeper function. The keeper function 
 *        accepts an argument of the type that should be saved.
 * @returns "tuple"
 *          A tuple whose elements are those saved by the {@param 
 *          "accumulator"}.
 * @category "Tuples" "Control Structures" "Collections" "Transformers"
 */
Method "map and filter_by_" is
[
	aTuple : tuple,
	accumulator : [⊥, ⊥, ⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop;
		If index ≤ end then
		[
			hasAlreadyKept : boolean := false;
			accumulator
			(
				aTuple[index],
				index,
				[
					transformed : any
				|
					If ¬hasAlreadyKept then
					[
						result := eject result ++ <transformed>;
						hasAlreadyKept := true;
					];
				]
			);
			index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Ensure that the function will accept all elements of the tuple and also an
 * appropriately typed keeper function.
 * 
 * @method "map and filter_by_"
 * @restricts "tuple meta"
 * @restricts "[⊥, ⊥]→⊤'s type"
 */
Semantic restriction "map and filter_by_" is
[
	tupleType : tuple meta,
	accumulator : [⊥, ⊥]→⊤'s type
|
	Require: accumulator accepts tupleType;
	Require: accumulator's keeper is valid;
	If accumulator's return type ≠ ⊤ then
	[
		Reject parse, expected:
			"repeatedly applied function to have return type ⊤"
	];
	<
		<>,
		cast accumulator[2] into [ t : function meta | t[1] ]…
		| [0..⎡tupleType⎤ + 1)
	>
];

/**
 * Ensure that the function will accept all elements and indices of the tuple
 * and also an appropriately typed keeper function.
 * 
 * @method "map and filter_by_"
 * @restricts "tuple meta"
 * @restricts "[⊥, ⊥, ⊥]→⊤'s type"
 */
Semantic restriction "map and filter_by_" is
[
	tupleType : tuple meta,
	accumulator : [⊥, ⊥, ⊥]→⊤'s type
|
	Require: accumulator accepts tupleType (check indices);
	Require: accumulator's keeper is valid;
	If accumulator's return type ≠ ⊤ then
	[
		Reject parse, expected:
			"repeatedly applied function to have return type ⊤"
	];
	<
		<>,
		cast accumulator[3] into [ t : function meta | t[1] ]…
		| [0..⎡tupleType⎤ + 1)
	>
];

/**
 * Compute and answer whether any of the elements of {@param "aTuple"} satisfies
 * the specified function. Do not examine more elements than necessary.
 * 
 * @method "any of_satisfies_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥]→boolean"
 *        A function that accepts the elements of the tuple and answers a
 *        boolean.
 * @returns "boolean"
 *          {@method "true"} if {@param "predicate"} answers {@method "true"} 
 *          for any element of {@apram "aTuple"}, {@method "false"} otherwise.
 * @category "Tuples" "Control Structures" "Collections" "Queries"
 */
Method "any of_satisfies_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	$body : boolean;
	For each element of aTuple do
	[
		If predicate(element) then
		[
			Exit body with true
		];
	];
	false
] : boolean;

/**
 * Compute and answer whether any of the elements (and indices) of {@param 
 * "aTuple"} satisfies the specified function. Do not examine more elements than 
 * necessary.
 * 
 * @method "any of_satisfies_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥, ⊥]→boolean"
 *        A function that accepts 1) an element of the tuple and 2) the index of
 *        that element.
 * @returns "boolean"
 *          {@method "true"} if {@param "predicate"} answers {@method "true"} 
 *          for any element of {@apram "aTuple"}, {@method "false"} otherwise.
 * @category "Tuples" "Control Structures" "Collections" "Queries"
 */
Method "any of_satisfies_" is
[
	aTuple : tuple,
	predicate : [⊥, ⊥]→boolean
|
	$body : boolean;
	For each element, index of aTuple do
	[
		If predicate(element, index) then
		[
			Exit body with true
		];
	];
	false
] : boolean;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * 
 * @method "any of_satisfies_"
 * @restricts "tuple meta"
 * @restricts "[…]→boolean's type"
 */
Semantic restriction "any of_satisfies_" is
[
	tupleType : tuple meta,
	predicate : […]→boolean's type
|
	Require: predicate accepts tupleType (check indices);
	predicate's return type
];

/**
 * Compute and answer whether each of the elements of {@param "aTuple"} 
 * satisfies the specified function. Do not examine more elements than 
 * necessary.
 * 
 * @method "each of_satisfies_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥]→boolean"
 *        A function that accepts the elements of the tuple and answers a
 *        boolean.
 * @returns "boolean"
 *          {@method "true"} if {@param "predicate"} answers {@method "true"} 
 *          for each element of {@apram "aTuple"}, {@method "false"} otherwise.
 * @category "Tuples" "Control Structures" "Collections" "Queries"
 */
Method "each of_satisfies_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	$body : boolean;
	For each element of aTuple do
	[
		Unless predicate(element) then
		[
			Exit body with false
		];
	];
	true
] : boolean;

/**
 * Compute and answer whether each of the elements (and indices) of {@param 
 * "aTuple"} satisfy the specified function. Do not examine more elements than 
 * necessary.
 * 
 * @method "each of_satisfies_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥, ⊥]→boolean"
 *        A function that accepts 1) an element of the tuple and 2) the index of
 *        that element and answers a boolean.
 * @returns "boolean"
 *          {@method "true"} if {@param "predicate"} answers {@method "true"} 
 *          for each element of {@apram "aTuple"}, {@method "false"} otherwise.
 * @category "Tuples" "Control Structures" "Collections" "Queries"
 */
Method "each of_satisfies_" is
[
	aTuple : tuple,
	predicate : [⊥, ⊥]→boolean
|
	$body : boolean;
	For each element, index of aTuple do
	[
		Unless predicate(element, index) then
		[
			Exit body with false
		];
	];
	true
] : boolean;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * 
 * @method "each of_satisfies_"
 * @restricts "tuple meta"
 * @restricts "[…]→boolean's type"
 */
Semantic restriction "each of_satisfies_" is
[
	tupleType : tuple meta,
	predicate : […]→boolean's type
|
	Require: predicate accepts tupleType (check indices);
	predicate's return type
];

/**
 * Compute and answer whether any of the elements of {@param "aTuple"} satisfies
 * the specified function. Do not examine more elements than necessary.
 * 
 * @macro "any…in|of_§satisfies_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aTuple"}.
 * @param "aTuple" "expression phrase ⇒ tuple"
 *        An {@type "expression phrase"} that yields the tuple to iterate over
 * @param "predicateBlock" "block phrase ⇒ []→boolean"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        predicate function.
 * @returns "send phrase ⇒ ⊤"
 * @category "Collections" "Tuples" "Queries"
 */
Macro "any…in|of_§satisfies_" is a tuple iteration prefix function,
	tuple body function($"any of_satisfies_", boolean);

/**
 * Compute and answer whether all of the elements of {@param "aTuple"} satisfies
 * the specified function. Do not examine more elements than necessary.
 * 
 * @macro "each…in|of_§satisfies_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aTuple"}.
 * @param "aTuple" "expression phrase ⇒ tuple"
 *        An {@type "expression phrase"} that yields the tuple to iterate over
 * @param "predicateBlock" "block phrase ⇒ []→boolean"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        predicate function.
 * @returns "send phrase ⇒ ⊤"
 * @category "Collections" "Tuples" "Queries"
 */
Macro "each…in|of_§satisfies_" is a tuple iteration prefix function,
	tuple body function($"each of_satisfies_", boolean);

/**
 * Compute and answer the count of elements of {@param "aTuple"} that satisfy 
 * the given predicate.
 * 
 * @method "count of_where_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥]→boolean"
 *        A function that accepts the elements of the tuple and answers {@method 
 *        "true"} if the element should be represented in the resulting count.
 * @returns "whole number"
 *          The number of elements of {@apram "aTuple"} for which {@param 
 *          "predicate"} answers {@method "true"}
 * @category "Tuples" "Control Structures" "Collections" "Queries"
 */
Method "count of_where_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	|filter aTuple by predicate|
] : whole number;

/**
 * Compute and answer the count of elements (and indices) of {@param "aTuple"}
 * that satisfy the given predicate.
 * 
 * @method "count of_where_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥, ⊥]→boolean"
 *        A function that accepts 1) an element of the tuple and 2) the index of
 *        that element and answers {@method "true"} if the element should be 
 *        represented in the resulting count.
 * @returns "whole number"
 *          The number of elements of {@param "aTuple"} for which {@param 
 *          "predicate"} answers {@method "true"}.
 * @category "Tuples" "Control Structures" "Collections" "Queries"
 */
Method "count of_where_" is
[
	aTuple : tuple,
	predicate : [⊥, ⊥]→boolean
|
	|filter aTuple by predicate|
] : whole number;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * 
 * @method "count of_where_"
 * @restricts "tuple meta"
 * @restricts "[…]→boolean's type"
 */
Semantic restriction "count of_where_" is
[
	tupleType : tuple meta,
	predicate : […]→boolean's type
|
	Require: predicate accepts tupleType (check indices);
	[0..⎡tupleType⎤ + 1)
];
	
/**
 * Compute and answer the count of elements of {@param "aTuple"} that satisfy 
 * the given predicate.
 * 
 * @macro "count of…from|in|of_§where_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aTuple"}.
 * @param "aTuple" "expression phrase ⇒ tuple"
 *        An {@type "expression phrase"} that yields the tuple to iterate over
 * @param "predicateBlock" "block phrase ⇒ []→boolean"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        predicate function.
 * @returns "send phrase ⇒ ⊤"
 * @category "Queries" "Collections" "Tuples"
 */
Macro "count of…from|in|of_§where_" is a tuple iteration prefix function,
	tuple body function($"count of_where_", whole number);	

/**
 * Compute and answer the distinct elements of {@param "aTuple"}, preserving 
 * order.
 * 
 * @method "distinct_"
 * @param "aTuple" "tuple"
 * @returns "tuple"
 *          A tuple that contains only the distinct elements of {@param 
 *          "aTuple"}, and in the order in which they were encountered.
 * @category "Tuples" "Transformers"
 */
Public stable method "distinct_" is
[
	aTuple : tuple
|
	seen : set := ∅;
	select each element from aTuple where
	[
		if ¬element ∈ seen then
		[
			seen := eject seen + element;
			true
		]
		else
		[
			false
		]
	]
] : tuple;

/* No decent semantic restrictions can be written yet for `distinct_` and
 * `_→set`. An efficient algorithm involves construction and evaluation of a
 * chromatic polynomial over the type intersection graph of the tuple type's
 * element types (the vertices represent the element types and an edge between
 * two vertices indicates that the type intersection of the element types is ⊥).
 * We cannot conveniently build graphs yet. We need object types and objects
 * first.
 */

/**
 * Answer a function that computes the zip of a tuple of tuples.
 * 
 * @method "zip function"
 * @returns "[tuple+]→tuple"
 *          The requested function.
 */
Private method "zip function" is
[
	[
		tuples : tuple+
	|
		accumulator : tuple* := <>;
		limit ::= min map each aTuple in tuples through [|aTuple| ];
		For each index from 1 to limit do
		[
			group : tuple := <>;
			For each aTuple of tuples do
			[
				group := eject group ++ <aTuple[index]>;
			];
			accumulator := eject accumulator ++ <group>;
		];
		accumulator
	] : tuple
] : [tuple+]→tuple;

/**
 * Compute and answer the zip of the specified tuples. Given N input tuples, the
 * output is the tuple whose i-th element contains the i-th element from each
 * consecutive input tuple. The size of the output equals to the smallest size
 * of the inputs. Each of the output's tuples has length equal to the number of
 * inputs.
 * 
 * @method "zip_"
 * @param "tuples" "tuple+"
 *        A tuple of tuples.
 * @returns "tuple"
 *          The zip of the input tuples.
 * @category "Tuples" "Transformers"
 */
Public method "zip_" is zip function;

/**
 * Compute and answer the zip of the specified tuples. Given N input tuples, the
 * output is the tuple whose i-th element contains the i-th element from each
 * consecutive input tuple. The size of the output equals to the smallest size
 * of the inputs. Each of the output's tuples has length equal to the number of
 * inputs.
 * 
 * @method "«_‡zip»"
 * @param "tuples" "tuple+"
 *        A tuple of tuples.
 * @returns "tuple"
 *          The zip of the input tuples.
 * @category "Tuples" "Transformers"
 */
Public method "«_‡zip»" is zip function;

/** 
 * Don't parse {@param "«_‡zip»"} recursively. 
 * 
 * @method "«_‡zip»"
 * @forbids "1" "«_‡zip»"
 */
Grammatical restriction {"«_‡zip»"} is <{"«_‡zip»"}>;

/**
 * Answer the semantic restriction function for zipping tuples.
 * 
 * @method "zip semantic restriction"
 * @returns "[tuple+'s type]→type"
 *          The semantic restriction function.
 */
Private method "zip semantic restriction" is
[
	[
		tuplesType : tuple+'s type
	|
		/* Leverage an instance type if possible. */
		if |tuplesType| = 1 then
		[
			(zip tuplesType's instance)'s type
		]
		else
		[
			types ::= cast tuplesType[1..relevant |tuplesType|]
				into [ t : <tuple meta…|1..> | t ];
			/* Find the smallest of the lower bounds of the inputs. */
			lower ::= min map each tupleType in types through[⎣tupleType⎦];
			
			/* Find the smallest of the upper bounds of the inputs. */
			upper ::= min map each tupleType in types through [⎡tupleType⎤];
			
			/* Find the maximum number of element types to scan. */
			limit ::= max map each tupleType in types through
				[|tupleType's leading types| + 1];
				 
			resultTypes : <tuple meta…|> := <>;
			/* Examine the relevant element types of all inputs. */
			For each index from 1 to limit do
			[
				zipped : tuple of any meta := <>;
				/* Examine the `index`-th element type of each input. Accumulate
				 * the results into `zipped`.
				 */
				For each tupleType of types do
				[
					zipped := eject zipped ++ <tupleType[index]>;
				];
				nonempty ::= cast zipped
					into [ t : <any meta…|1..> | t ];
				zippedType ::=
					<nonempty[1..|nonempty| - 1], nonempty[|nonempty|]…
						| ||tuplesType||>;
				resultTypes := eject resultTypes ++ <zippedType>;
			];
			nonempty ::= cast resultTypes into [ t : <tuple meta…|1..> | t ];
			resultSizes ::= [lower..upper + 1);
			<nonempty[1..|nonempty| - 1], nonempty[|nonempty|]… | resultSizes>
		]
	] : type
] : [tuple+'s type]→type;

/**
 * @method "zip_"
 * @restricts "tuple+'s type"
 */
Semantic restriction "zip_" is zip semantic restriction;

/**
 * @method "«_‡zip»"
 * @restricts "tuple+'s type"
 */
Semantic restriction "«_‡zip»" is zip semantic restriction;

/**
 * Reduce {@param "aTuple"} via the binary function, traversing the tuple from 
 * left to right. Answer the result of the reduction.
 *
 * @method "left fold_through_"
 * @param "aTuple" "any+"
 *        A nonempty tuple.
 * @param "transformer" "[⊥, ⊥]→any"
 *        A binary function whose second parameter type matches its return type.
 *        The first parameter type must be general enough to accept each element
 *        of {@param "aTuple"}.
 * @returns "any"
 *          The only element of {@param "aTuple"} if {@param "aTuple"} contains 
 *          only one element. Otherwise, the result of iteratively applying 
 *          {@param "transformer"} to 1) the left-to-right consecutive elements 
 *          of {@param "aTuple"} and 2) the previous results of applying 
 *          {@param "transformer"}.
 * @category "Tuples" "Transformers"
 */
Public method "left fold_through_" is
[
	aTuple : any+,
	transformer : [⊥, ⊥]→any
|
	result : any := aTuple[1];
	For each index from 2 to |aTuple| do
	[
		result := transformer(aTuple[index], eject result);
	];
	result
] : any;

/**
 * Left fold has the following requirements:
 *
 * - The function's first parameter must accept every element of the tuple
 *   except for the first (with which it will not be applied at this position).
 * - The function's second parameter must accept the tuple's first element and
 *   also every value producible by the function.
 *
 * Left fold answers either the tuple's first element or the value produced by
 * the final application of the function.
 * 
 * @method "left fold_through_"
 * @restricts "any+'s type"
 * @restricts "[⊥, ⊥]→any's type"
 */
Semantic restriction "left fold_through_" is
[
	tupleType : any+'s type,
	transformer : [⊥, ⊥]→any's type
|
	headType ::= tupleType[1];
	restType ::= if |tupleType's leading types| > 0
		then [ ∪ tupleType[2..|tupleType's leading types| + 1] ]
		else [ headType ];
	returnType ::= transformer's return type;
	finalType ::= headType ∪ returnType;
	If transformer[1] ≠ ⊥ ∧ ¬restType ⊆ transformer[1] then
	[
		Reject parse, expected:
			"repeatedly applied function's first parameter to accept all\
			\| non-first elements of the tuple ⊆ "
			++ “restType”
			++ " (but it only accepts "
			++ “transformer[1]”
			++ ")"
	];
	If transformer[2] ≠ ⊥ ∧ ¬finalType ⊆ transformer[2] then
	[
		Reject parse, expected:
			"repeatedly applied function's second parameter to accept the\
			\| type union ⊆ "
			++ “finalType”
			++ " of the first element ⊆ "
			++ “headType”
			++ " of the tuple and its own return type ⊆ "
			++ “returnType”
			++ " (but it only accepts "
			++ “transformer[2]”
			++ ")"
	];
	finalType
];

/**
 * Reduce {@param "aTuple"} via the binary function, traversing the tuple from 
 * right to left. Answer the result of the reduction.
 *
 * @method "right fold_through_"
 * @param "aTuple" "any+"
 *        A nonempty tuple.
 * @param "transformer" "[⊥, ⊥]→any"
 *        A binary function whose second parameter type matches its return type.
 *        The first parameter type must be general enough to accept each element
 *        of {@param "aTuple"}.
 * @returns "any"
 *          The only element of {@param "aTuple"} if {@param "aTuple"} contains 
 *          only one element. Otherwise, the result of iteratively applying 
 *          {@param "transformer"} to 1) the right-to-left consecutive elements 
 *          of {@param "aTuple"} and 2) the previous results of applying 
 *          {@param "transformer"}.
 * @category "Tuples" "Transformers"
 */
Public method "right fold_through_" is
[
	aTuple : any+,
	transformer : [⊥, ⊥]→any
|
	result : any := aTuple[|aTuple|];
	For each index from |aTuple| - 1 to 1 by -1 do
	[
		result := transformer(aTuple[index], eject result);
	];
	result
] : any;

/**
 * Right fold has the following requirements:
 *
 * - The function's first parameter must accept every element of the tuple
 *   except for the last (with which it will not be applied at this position).
 * - The function's second parameter must accept the tuple's last element and
 *   also every value producible by the function.
 *
 * Right fold answers either the tuple's last element or the value produced by
 * the final application of the function.
 * 
 * @method "right fold_through_"
 * @restricts "any+'s type"
 * @restricts "[⊥, ⊥]→any's type"
 */
Semantic restriction "right fold_through_" is
[
	tupleType : any+'s type,
	transformer : [⊥, ⊥]→any's type
|
	sizes ::= ||tupleType||;

	lastIndexStart ::= 1 max relevant |tupleType|;
	lastIndexEnd ::= lastIndexStart
		max (⎡sizes⎤ min (|tupleType's leading types| + 1));
	lastType ::= ∪ tupleType[lastIndexStart..lastIndexEnd];
	restType ::= ∪ tupleType[1..lastIndexEnd - 1];
	returnType ::= transformer's return type;
	finalType ::= lastType ∪ returnType;
	If transformer[1] ≠ ⊥ ∧ ¬restType ⊆ transformer[1] then
	[
		Reject parse, expected:
			"repeatedly applied function's first parameter to accept all\
			\| non-last elements of the tuple ⊆ "
			++ “restType”
			++ " (but it only accepts "
			++ “transformer[1]”
			++ ")"
	];
	If transformer[2] ≠ ⊥ ∧ ¬finalType ⊆ transformer[2] then
	[
		Reject parse, expected:
			"repeatedly applied function's second parameter to accept the\
			\| type union ⊆ "
			++ “finalType”
			++ " of the last element ⊆ "
			++ “lastType”
			++ " of the tuple and its own return type ⊆ "
			++ “returnType”
			++ " (but it only accepts "
			++ “transformer[2]”
			++ ")"
	];
	finalType
];

/**
 * Compute and answer the index of the first element of {@param "aTuple"} that
 * satisfies the specified predicate.
 * 
 * @method "first index of_where_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥]→boolean"
 *        A function that accepts the elements of the tuple.
 * @returns "whole number"
 *          The index of the first satisfactory element, or 0 if no element
 *          satisfied the predicate.
 * @category "Tuples" "Queries"
 */
Public method "first index of_where_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	$body : natural number;
	For each index from 1 to |aTuple| do
	[
		If predicate(aTuple[index]) then
		[
			Exit body with index
		];
	];
	0
] : whole number;

/**
 * Ensure that the function will accept all elements of the tuple.
 * 
 * @method "first index of_where_"
 * @restricts "tuple meta"
 * @restricts "[⊥]→boolean's type"
 */
Semantic restriction "first index of_where_" is
[
	tupleType : tuple meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts tupleType (check indices);
	[0..⎡tupleType⎤ + 1)
];
	
/**
 * Compute and answer the index of the first element of {@param "aTuple"} that 
 * satisfies the specified predicate.
 * 
 * @macro "first index of…in_§where_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aTuple"}.
 * @param "aTuple" "expression phrase ⇒ tuple"
 *        An {@type "expression phrase"} that yields the tuple to iterate over
 * @param "predicateBlock" "block phrase ⇒ []→boolean"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        predicate function.
 * @returns "send phrase ⇒ ⊤"
 * @category "Queries" "Collections" "Tuples"
 */
Macro "first index of…in_§where_" is a tuple iteration prefix function,
	tuple body function($"first index of_where_", whole number);

/**
 * Compute and answer the index of the last element of {@param "aTuple"} that 
 * satisfies the specified predicate.
 * 
 * @method "last index of_where_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥]→boolean"
 *        A function that accepts the elements of the tuple.
 * @returns "whole number"
 *          The index of the last satisfactory element, or 0 if no element
 *          satisfied the predicate.
 * @category "Tuples" "Queries"
 */
Public method "last index of_where_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	$body : natural number;
	For each index from |aTuple| to 1 by -1 do
	[
		If predicate(aTuple[index]) then
		[
			Exit body with index
		];
	];
	0
] : whole number;

/**
 * Ensure that the function will accept all elements of the tuple.
 * 
 * @method "last index of_where_"
 * @restricts "tuple meta"
 * @restricts "[⊥]→boolean's type"
 */
Semantic restriction "last index of_where_" is
[
	tupleType : tuple meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts tupleType (check indices);
	[0..⎡tupleType⎤ + 1)
];

/**
 * Compute and answer the index of the last element of {@param "aTuple"} that 
 * satisfies the specified predicate.
 * 
 * @macro "last index of…in_§where_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aTuple"}.
 * @param "aTuple" "expression phrase ⇒ tuple"
 *        An {@type "expression phrase"} that yields the tuple to iterate over
 * @param "predicateBlock" "block phrase ⇒ []→boolean"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        predicate function.
 * @returns "send phrase ⇒ ⊤"
 * @category "Queries" "Collections" "Tuples"
 */
Macro "last index of…in_§where_" is a tuple iteration prefix function,
	tuple body function($"last index of_where_", whole number);

/**
 * Compute and answer the indices of all the elements of {@param "aTuple"} that 
 * satisfies the specified predicate.
 * 
 * @method "all indices of_where_"
 * @param "aTuple" "tuple"
 * 		The tuple to search
 * @param "predicate" "[⊥]→boolean"
 *        A function that accepts the elements of the tuple.
 * @returns "natural number*"
 *          The indices of all the satisfactory elements of the predicate.
 * @category "Tuples" "Queries"
 */
Public method "all indices of_where_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	indices : natural number* := <>;
	For each index from 1 to |aTuple| by 1 do
	[
		If predicate(aTuple[index]) then
		[
			indices ++= <index>;
		];
	];
	indices
] : natural number*;

/**
 * Ensure that the function will accept all elements of the tuple.
 * 
 * @method "all indices of_where_"
 * @restricts "tuple meta"
 * @restricts "[⊥]→boolean's type"
 */
Semantic restriction "all indices of_where_" is
[
	tupleType : tuple meta,
	predicateType : [⊥]→boolean's type
|
	Require: predicateType accepts tupleType (check indices);
	<natural number…|0..⎡tupleType⎤ + 1>
];

/**
 * Compute and answer the indices of all the elements of {@param "aTuple"} that 
 * satisfies the specified predicate.
 * 
 * @macro "all indices of…in_§where_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aTuple"}.
 * @param "aTuple" "expression phrase ⇒ tuple"
 *        An {@type "expression phrase"} that yields the tuple to iterate over
 * @param "predicateBlock" "block phrase ⇒ []→boolean"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        predicate function.
 * @returns "send phrase ⇒ ⊤"
 * @category "Queries" "Collections" "Tuples"
 */
Macro "all indices of…in_§where_" is a tuple iteration prefix function,
	tuple body function($"all indices of_where_", natural number*);

Method "_occurrences⁇of_" is stable at [whole number, any]→tuple;

/**
 * @method "_occurrences⁇of_"
 * @restricts "whole number's type"
 * @restricts "any meta"
 */
Semantic restriction "_occurrences⁇of_" is
[
	countType : whole number's type,
	valueType : any meta
|
	<<>, valueType…|countType>
];

/**
 * Construct and answer a tuple that contains the consecutive integers from
 * {@param "start"} (inclusive) up to {@param "end"} (inclusive), counting up by 
 * 1. If {@param "end"}{@code " < "}{@param "start"}, then answer the empty 
 * tuple.
 * 
 * @method "_to_"
 * @param "start" "integer"
 *        The first value of the resulting tuple.
 * @param "end" "integer"
 *        The last value of the resulting tuple.
 * @returns "integer*"
 *          The interval from {@param "start"} (inclusive) up to {@param "end"} 
 *          (inclusive).
 * @category "Tuples" "Constructors"
 */
Public stable method "_to_" is
[
	start : integer,
	end : integer
|
	start to end by 1
] : integer*;

/**
 * Construct and answer a string that contains the consecutive characters from
 * {@param "start"} (inclusive) to {@param "end"} (inclusive). If 
 * {@param "start"}{@code "'s code point ≤ "}{@param "end"}{@code "'s code 
 * point"}, then {@code "result[i]'s code point < result[i+1]'s code point"}; 
 * otherwise, {@code "result[i]'s code point > result[i+1]'s code point"}.
 * 
 * @method "_to_"
 * @param "start" "character"
 *        The first value of the resulting tuple.
 * @param "end" "character"
 *        The last value of the resulting tuple.
 * @returns "character*"
 *          The interval from {@param "start"} (inclusive) up to {@param "end"}
 *          (inclusive).
 * @category "Tuples" "Constructors"
 */
Public stable method "_to_" is
[
	start : character,
	end : character
|
	accumulator : string := <>;
	startCodePoint ::= start's code point;
	endCodePoint ::= end's code point;
	For each value from startCodePoint to endCodePoint do
	[
		accumulator := eject accumulator ++ <value→character>;
	];
	accumulator
] : string;

/**
 * Leverage the uncertainty of {@param "start"} to produce good leading types 
 * when the upper bound of the result's cardinality can be determined.
 * 
 * @method "_to_"
 * @restricts "integer's type"
 * @restricts "integer's type"
 */
Semantic restriction "_to_" is
[
	start : integer's type,
	end : integer's type
|
	$body : type;
	/* If the arguments are instance types, then bail immediately; let the
	 * stable semantic restriction produce an instance type.
	 */
	If {|start|, |end|} = {1} then [Exit body with ⊤];
	min ::= ⎣start⎦;
	max ::= ⎡end⎤;
	uncertainty ::= ⎡start⎤ - ⎣start⎦;
	sizes ::= [0 max (⎣end⎦ - ⎡start⎤ + 1) .. max - min + 2);
	if uncertainty is finite ∧ sizes ≠ ⊥ ∧ ⎡sizes⎤ is finite then
	[
		finiteMin ::= cast min into [t : integer | t];
		finiteMax ::= cast max into [t : integer | t];
		
		/* Don't obsess — just compute the first 100 prefix types. */
		limitedMax ::= finiteMax min (finiteMin + 100);
		types ::= map each x in finiteMin to limitedMax through
			[[x .. (finiteMax min (x + uncertainty)) + 1)];
		defaultType ::=
			if finiteMax ≠ limitedMax then
			[
				[limitedMax .. finiteMax + 1)
			]
			else
			[
				types[|types|] else [⊥]
			];
		cast types
		into [t : <integer's type…|1..> | <t[1..|t|-1], defaultType…|sizes>]
		else [<>'s type]
	]
	else if sizes = ⊥ then
	[
		<>'s type
	]
	else
	[
		<<>, [min..max + 1)…|sizes>
	]
] : type;

Method "_to_by_" is stable at [integer, integer, integer]→integer*;

Method "_to_by_" is
[
	start : integer,
	end : integer,
	delta : 0's type
|
	early failure function(incorrect-argument-type code)
] : ⊥;

/**
 * Reject invocations with size-zero step, and narrow the return type if 
 * possible.
 * 
 * @method "_to_by_"
 * @restricts "integer's type"
 * @restricts "integer's type"
 * @restricts "integer's type"
 */
Semantic restriction "_to_by_" is
[
	start : integer's type,
	end : integer's type,
	delta : integer's type
|
	low : extended integer;
	high : extended integer;
	sizes : whole number's type;

	If delta ⊆ [0..0] then
	[
		Reject parse, expected: "delta value not to be zero"
	];

	If delta ⊆ [0..∞) then
	[
		low := ⎣start⎦;
		high := ⎡end⎤;
		diff ::= ⎣end⎦ - ⎡start⎤;
		rangeFrom ::= if diff is infinite ∧ ⎡delta⎤ is infinite
			then [0]
			else [0 max (diff ÷ ⎡delta⎤ + 1)];
		rangeTo ::= (high - low) ÷ ⎣delta⎦ + 1;
		sizes := [rangeFrom .. rangeTo + 1);
	]
	else if delta ⊆ (-∞..-1] then
	[
		low := ⎣end⎦;
		high := ⎡start⎤;
		diff ::= ⎣start⎦ - ⎡end⎤;
		rangeFrom ::= if diff is infinite ∧ ⎡delta⎤ is infinite
			then [0]
			else [0 max (diff ÷ -⎡delta⎤ + 1)];
		rangeTo ::= (high - low) ÷ -⎣delta⎦ + 1;
		sizes := [rangeFrom .. rangeTo + 1);
	]
	else
	[
		/* There is no need to divide by any value of delta here because if
		 * delta's value cannot be determined, then 1 and -1 are possible
		 * values. So, the largest possible size should remain.
		 */
		low := ⎣start⎦ min ⎣end⎦;
		high := ⎡start⎤ max ⎡end⎤;
		sizes := [0 .. high - low + 2);
	];
	<<>, [low..high + 1)…|sizes>
];

/**
 * Is {@param "value"} an element of {@param "aTuple"}?
 * 
 * @method "_∈_"
 * @param "value" "any"
 *        An arbitrary value.
 * @param "aTuple" "tuple"
 * @returns "boolean"
 *          {@method "true"} if {@param "value"} is an element of {@param 
 *          "aTuple"}, {@method "false"} otherwise.
 * @category "Tuples" "Collections" "Queries"
 */
Stable method "_∈_" is
[
	value : any,
	aTuple : tuple
|
	any element of aTuple satisfies [element = value]
] : boolean;

/**
 * @method "_∈_"
 * @restricts "any meta"
 * @restricts "tuple meta"
 */
Semantic restriction "_∈_" is
[
	valueType : any meta,
	tupleType : tuple meta
|
	if valueType ∩ (∪ tupleType[1..∞]) = ⊥ then
	[
		false's type
	]
	else
	[
		/* Can't strengthen. */
		⊤
	]
];

/**
 * Is {@param "subtuple"} a subsequence of {@param "aTuple"}?
 * 
 * @method "_⊆_"
 * @param "subtuple" "tuple"
 *        The search tuple.
 * @param "aTuple" "tuple"
 *        The tuple which should be searched for {@param "subtuple"}.
 * @returns "boolean"
 *          {@method "true"} if some subsequence of {@param "aTuple"} equals 
 *          {@param "subtuple"}, {@method "false"} otherwise.
 * @category "Tuples" "Collections" "Queries"
 */
Stable method "_⊆_" is
[
	subtuple : tuple,
	aTuple : tuple
|
	matched : boolean := false;
	For each index from 1 to |aTuple| - |subtuple| + 1 do
	[
		matched := aTuple[index..index + |subtuple| - 1] = subtuple;
		¬matched
	];
	matched
] : boolean;

/**
 * Is {@param "subtuple"} a subsequence of {@param "aTuple"}?
 * 
 * @method "_⊆_"
 * @param "aTuple" "tuple"
 *        The tuple which should be searched for {@param "subtuple"}.
 * @param "subtuple" "tuple"
 *        The search tuple.
 * @returns "boolean"
 *          {@method "true"} if some subsequence of {@param "aTuple"} equals 
 *          {@param "subtuple"}, {@method "false"} otherwise.
 * @category "Tuples" "Collections" "Queries"
 */
Stable method "_⊇_" is
[
	aTuple : tuple,
	subtuple : tuple
|
	subtuple ⊆ aTuple
] : boolean;

/**
 * Answer a function suitable for use as the semantic restriction for
 * subsequence containment.
 *
 * @method "subsequence restriction function"
 * @returns "[tuple meta, tuple meta]→type"
 *          A function suitable for use as the semantic restriction of `_⊆_` and
 *          `_⊇_`.
 */
Private method "subsequence restriction function" is
[
	[
		subtuple : tuple meta,
		aTuple : tuple meta
	|
		if ⎣subtuple⎦ > ⎡aTuple⎤ then
		[
			false's type
		]
		else
		[
			subtupleElementType ::=
				∪ subtuple[1..|subtuple's leading types| + 1];
			elementType ::= ∪ aTuple[1..|aTuple's leading types| + 1];
			if subtupleElementType ∩ elementType = ⊥ then [false's type]
			else [⊤]
		]
	] : type
] : [tuple meta, tuple meta]→type;

/**
 * Does {@param "aTuple"} start with the subsequence {@param "prefix"}?
 * 
 * @method "_starts with_"
 * @param "aTuple" "tuple"
 *        The tuple whose prefix should be checked against {@param "prefix"}.
 * @param "prefix" "tuple"
 *        The search tuple.
 * @returns "boolean"
 *          {@method "true"} if {@param "aTuple"} starts with the subsequence 
 *          {@param "prefix"}, {@method "false"} otherwise.
 * @category "Tuples" "Queries"
 */
Public stable method "_starts with_" is
[
	aTuple : tuple,
	prefix : tuple
|
	aTuple[..|prefix| min |aTuple|] = prefix
] : boolean;

/**
 * Does {@param "aTuple"} end with the subsequence {@param "suffix"}?
 * 
 * @method "_ends with_"
 * @param "aTuple" "tuple"
 *        The tuple whose suffix should be checked against {@param "suffix"}.
 * @param "suffix" "tuple"
 *        The search tuple.
 * @returns "boolean"
 *          {@method "true"} if {@param "aTuple"} ends with the subsequence 
 *          {@param "suffix"}, {@method "false"} otherwise.
 * @category "Tuples" "Queries"
 */
Public stable method "_ends with_" is
[
	aTuple : tuple,
	suffix : tuple
|
	aTuple[1 max (|aTuple| - (|suffix| min |aTuple|) + 1)..] = suffix
] : boolean;

/**
 * If {@param "subtuple"} is guaranteed longer than {@param "aTuple"} or if the 
 * element types of {@param "subtuple"} and {@param "aTuple"} are completely 
 * disjoint, then {@param "subtuple"}'s instance cannot possibly be a 
 * subsequence of {@param "aTuple"}'s instance.
 * 
 * @method "_⊆_"
 * @restricts "tuple meta"
 * @restricts "tuple meta"
 */
Semantic restriction "_⊆_" is subsequence restriction function;

/**
 * If {@param "subtuple"} is guaranteed longer than {@param "aTuple"} or if the 
 * element types of {@param "subtuple"} and {@param "aTuple"} are completely 
 * disjoint, then {@param "subtuple"}'s instance cannot possibly be a 
 * subsequence of {@param "aTuple"}'s instance.
 * 
 * @method "_⊇_"
 * @restricts "tuple meta"
 * @restricts "tuple meta"
 */
Semantic restriction "_⊇_" is
[
	aTuple : tuple meta,
	subtuple : tuple meta
|
	subsequence restriction function(subtuple, aTuple)
];

/**
 * If {@param "subtuple"} is guaranteed longer than {@param "aTuple"} or if the 
 * element types of {@param "subtuple"} and {@param "aTuple"} are completely 
 * disjoint, then {@param "subtuple"}'s instance cannot possibly be a 
 * prefix of {@param "aTuple"}'s instance.
 * 
 * @method "_starts with_"
 * @restricts "tuple meta"
 * @restricts "tuple meta"
 */
Semantic restriction "_starts with_" is
[
	aTuple : tuple meta,
	subtuple : tuple meta
|
	subsequence restriction function(subtuple, aTuple)
];

/**
 * If {@param "subtuple"} is guaranteed longer than {@param "aTuple"} or if the 
 * element types of {@param "subtuple"} and {@param "aTuple"} are completely 
 * disjoint, then {@param "subtuple"}'s instance cannot possibly be a 
 * suffix of {@param "aTuple"}'s instance.
 * 
 * @method "_ends with_"
 * @restricts "tuple meta"
 * @restricts "tuple meta"
 */
Semantic restriction "_ends with_" is
[
	aTuple : tuple meta,
	subtuple : tuple meta
|
	subsequence restriction function(subtuple, aTuple)
];

/**
 * Split a {@param "aTuple"} into two tuples between {@param "pivot"} and 
 * {@param "pivot"}{@code " + 1"} and answer a 2-tuple containing the results.
 *
 * @method "split_after_"
 * @param "aTuple" "tuple"
 * @param "pivot" "whole number"
 *        The index (inclusive) at which to split {@param "aTuple"}.
 * @returns "<tuple…|2>"
 *          A 2-tuple. The first tuple contains the first {@param "pivot"} 
 *          elements of {@param "aTuple"}. The second tuple contains the 
 *          remaining elements of {@param "aTuple"}.
 * @category "Tuples" "Transformers"
 */
Public stable method "split_after_" is
[
	aTuple : tuple,
	pivot : whole number
|
	<aTuple[..pivot], aTuple[pivot + 1..]>
] : <tuple…|2>;

/**
 * Construct the strongest possible 2-tuple type for the given arguments. The
 * first element type is a tuple type whose elements are drawn from the original
 * tuple type. The second element type is a tuple type whose element type are
 * smears (i.e., type unions) of the trailing element types of the original
 * tuple type. The pivot is used to determine the cardinality ranges of the
 * these element types.
 * 
 * @method "split_after_"
 * @restricts "tuple meta"
 * @restricts "whole number's type"
 */
Semantic restriction "split_after_" is
[
	tupleType : tuple meta,
	pivot : whole number's type
|
	If ⎣pivot⎦ > ⎡tupleType⎤ then
	[
		Reject parse, expected:
			"pivot ∈ "
			++ “pivot”
			++ " ever to be valid for the tuple ∈ "
			++ “tupleType”
	];
	pivotPlusOne ::= cast pivot + 1's type
		into [ t : natural number's type | t ];
	firstType ::= tuple type of tupleType[1's type..pivot];
	secondType ::= tuple type of tupleType[pivotPlusOne..||tupleType||];
	<firstType, secondType…|2>
];

/**
 * Split a {@param "aTuple"} into two tuples between {@param "pivot"}{@code 
 * " - 1"} and {@param "pivot"} and answer a 2-tuple containing the results.
 *
 * @method "split_before_"
 * @param "aTuple" "tuple"
 * @param "pivot" "natural number"
 *        The index (exclusive) at which to split {@param "aTuple"}.
 * @returns "<tuple…|2>"
 *          A 2-tuple. The first tuple contains the first {@param "pivot"}{@code
 *          " - 1"} elements of {@param "aTuple"}. The second tuple contains the 
 *          remaining elements of {@param "aTuple"}.
 * @category "Tuples" "Transformers"
 */
Public stable method "split_before_" is
[
	aTuple : tuple,
	pivot : natural number
|
	<aTuple[..pivot - 1], aTuple[pivot..]>
] : <tuple…|2>;

/**
 * Construct the strongest possible 2-tuple type for the given arguments. The
 * first element type is a tuple type whose elements are drawn from the original
 * tuple type. The second element type is a tuple type whose element type are
 * smears (i.e., type unions) of the trailing element types of the original
 * tuple type. The pivot is used to determine the cardinality ranges of the
 * these element types.
 * 
 * @method "split_before_"
 * @restricts "tuple meta"
 * @restricts "natural number's type"
 */
Semantic restriction "split_before_" is
[
	tupleType : tuple meta,
	pivot : natural number's type
|
	If ⎣pivot⎦ > ⎡tupleType⎤ + 1 then
	[
		Reject parse, expected:
			"pivot ∈ "
			++ “pivot”
			++ " ever to be valid for the tuple ∈ "
			++ “tupleType”
	];
	pivotMinusOne ::= cast pivot - 1's type
		into [ t : whole number's type | t ];
	firstType ::= tuple type of tupleType[1's type..pivotMinusOne];
	secondType ::= tuple type of tupleType[pivot..||tupleType||];
	<firstType, secondType…|2>
];

/**
 * Split a {@param "aTuple"} into two tuples.
 *
 * @method "split_before_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥]→boolean"
 *        A function that accepts each element of the tuple. It must answer
 *        {@method "true"} when the pivot position has been reached. The 
 *        function will not be applied again after it has answered {@param 
 *        "true"}.
 * @returns "<tuple…|2>"
 *          A 2-tuple. The first tuple contains the elements of {@param 
 *          "aTuple"} to which {@param "predicate"} was applied without a 
 *          {@method "true"} result. The second tuple contains the element for 
 *          which a {@method "true"} result was obtained along with the 
 *          remaining, untested, elements of {@param "aTuple"}.
 * @category "Tuples" "Transformers"
 */
Method "split_before_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	firstIndex ::= first index of aTuple where predicate;
	splitIndex ::=
		if firstIndex = 0
		then [ |aTuple| ]
		else [ cast firstIndex - 1 into [ t : whole number | t ] ];
	split aTuple after splitIndex
] : <tuple…|2>;

/**
 * Construct the strongest possible 2-tuple type for the given arguments. The
 * first element type is a tuple type whose elements are drawn from the original
 * tuple type. The second element type is a tuple type whose element type are
 * smears (i.e., type unions) of the trailing element types of the original
 * tuple type. The cardinality of each tuple varies from 0 to the upper bound of
 * {@param "tupleType"}'s cardinality range.
 * 
 * @method "split_before_"
 * @restricts "tuple meta"
 * @restricts "[⊥]→boolean's type"
 */
Semantic restriction "split_before_" is
[
	tupleType : tuple meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts tupleType (check indices);
	returnType ::= predicate's return type;
	if ⎡tupleType⎤ = 0 then
	[
		<<>, <>>'s type
	]
	else
	[
		sizes ::= ||tupleType||;
		upper ::= [0..⎡sizes⎤ + 1);
		firstType ::=
			<tupleType's leading types, tupleType's default type…|upper>;
		secondType ::=
			tuple type of tupleType[[1..⎡sizes⎤ + 1)..upper];
		<firstType, secondType…|2>
	]
];

/**
 * Compute and answer the specified stripe of {@param "aTuple"}.
 * 
 * @method "stripe_at_"
 * @param "aTuple" "<any+…|>"
 *        A tuple of non-empty tuples.
 * @param "index" "natural number"
 *        The stripe index.
 * @returns "tuple"
 *          A tuple comprising the {@param "index"}-th elements of each element 
 *          of {@param "aTuple"}.
 * @category "Tuples" "Transformers"
 */
Public stable method "stripe_at_" is
[
	aTuple : <any+…|>,
	index : natural number
|
	map each inner in aTuple through [inner[index] ]
] : tuple;

/**
 * Reject the parse if the stripe index could never be valid.
 * 
 * @method "stripe_at_"
 * @restricts "<any+…|>'s type"
 * @restricts "natural number's type"
 */
Semantic restriction "stripe_at_" is
[
	tupleType : <any+…|>'s type,
	index : natural number's type
|
	uncertainty ::= cast ⎡index⎤ - ⎣index⎦
		into [ t : [0..∞] | t ];
	stripeTypes : <any meta…|> := <>;
	For each typeIndex from 1 to |tupleType's leading types| + 1 do
	[
		innerType ::= tupleType[typeIndex];
		If ⎣index⎦ > ⎡innerType⎤ then
		[
			Reject parse, expected:
				"a subscript ("
				++ “⎣index⎦”
				++ " ≤ theSubscript ≤ "
				++ “⎡index⎤”
				++ ") that could ever be valid ("
				++ “⎣innerType⎦”
				++ " ≤ |theTuple| ≤ "
				++ “⎡innerType⎤”
				++ ")"
		];
		union : any meta := ⊥;
		limit ::= uncertainty min (|innerType's leading types| + 1);
		For each delta from 0 to limit do
		[
			innerIndex ::= ⎣index⎦ + delta;
			union := eject union ∪ innerType[innerIndex];
		];
		stripeTypes := eject stripeTypes ++ <union>;
	];
	nonemptyTypes ::= cast stripeTypes into [ t : <any meta…|1..> | t ];
	<nonemptyTypes[1..|nonemptyTypes| - 1], nonemptyTypes[|nonemptyTypes|]…
		| ||tupleType||>
];

/**
 * Answer a tuple containing the first {@param "count"} elements of {@param 
 * "aTuple"}.
 * 
 * @method "take_from_"
 * @param "count" "whole number"
 *        The size of the requested tuple.
 * @param "aTuple" "tuple"
 *        The source tuple.
 * @returns "tuple"
 *          A tuple containing the first {@param "count"} elements of {@param 
 *          "aTuple"}, preserving the original order.
 * @category "Tuples" "Transformers"
 */
Public stable method "take_from_" is
[
	count : whole number,
	aTuple : tuple
|
	aTuple[1..count]
] : tuple;

/**
 * @method "take_from_"
 * @restricts "whole number's type"
 * @restricts "tuple's type"
 */
Semantic restriction "take_from_" is
[
	count : whole number's type,
	tupleType : tuple's type
|
	tuple type of tupleType[1's type..count]
];

/**
 * Answer a tuple containing the prefix of {@param "aTuple"} that answered 
 * {@method "true"} to {@param "predicate"}.
 *
 * @method "take from_while_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥]→boolean"
 *        A function that can accept each element of the specified tuple. It
 *        should answer {@method "true"} to keep the element (and continue 
 *        scanning) or {@method "false"} to abort.
 * @returns "tuple"
 *          A tuple containing the prefix of {@param "aTuple"} that satisfied 
 *          {@param "predicate"}.
 * @category "Tuples" "Transformers"
 */
Public method "take from_while_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	firstIndex ::= first index of aTuple where
		[value : any | ¬predicate(value)];
	splitIndex ::=
		if firstIndex = 0
		then [ |aTuple| ]
		else [ cast firstIndex - 1 into [ t : whole number | t ] ];
	aTuple[1..splitIndex]
] : tuple;

/**
 * Answer a semantic restriction suitable for use by the predicated-based
 * take/drop methods.
 *
 * @category "Data Abstractions"
 * @method "take|drop-while|until semantic restriction"
 * @param "tupleType" "tuple meta"
 * @param "predicate" "[⊥]→boolean's type"
 * @returns "[tuple meta, [⊥]→boolean's type]→⊤"
 *    The requested function.
 */
Private method "take|drop-while|until semantic restriction" is
[
	[
		tupleType : tuple meta,
		predicate : [⊥]→boolean's type
	|
		Require: predicate accepts tupleType (check indices);
		<∪ tupleType[1..|tupleType's leading types| + 1]…|0..⎡tupleType⎤>
	]
];

/**
 * @method "take from_while_"
 * @restricts "tuple meta"
 * @restricts "[⊥]→boolean's type"
 */
Semantic restriction "take from_while_" is take-while semantic restriction;

/**
 * Answer a tuple containing the prefix of `aTuple` that answered `false` to
 * `predicate`.
 *
 * @method "take from_until_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥]→boolean"
 *        A function that can accept each element of the specified tuple. It 
 *        should answer {@method "false"} to keep the element (and continue 
 *        scanning) or {@method "true"} to abort.
 * @returns "tuple"
 *          A tuple containing the prefix of {@param "aTuple"} that satisfied
 *          {@param "predicate"}.
 * @category "Tuples" "Transformers"
 */
Public method "take from_until_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	firstIndex ::= first index of aTuple where predicate;
	splitIndex ::=
		if firstIndex = 0
		then [ |aTuple| ]
		else [ cast firstIndex - 1 into [ t : whole number | t ] ];
	aTuple[1..splitIndex]
] : tuple;

/**
 * @method "take from_until_"
 * @restricts "tuple meta"
 * @restricts "[⊥]→boolean's type"
 */
Semantic restriction "take from_until_" is take-until semantic restriction;

/**
 * Compute and answer the suffix of {@param "aTuple"} that begins with the 
 * element that answers {@method "false"} to {@param "predicate"}.
 * 
 * @method "drop from_while_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥]→boolean"
 *        A function that can accept each element of the specified tuple. It 
 *        should answer {@method "true"} to discard the element (and continue 
 *        scanning) or {@method "false"} to abort.
 * @returns "tuple"
 *          The requested suffix.
 * @category "Tuples" "Transformers"
 */
Public method "drop from_while_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	firstIndex ::= first index of aTuple where
		[value : any | ¬predicate(value)];
	splitIndex ::=
		if firstIndex = 0
		then [ |aTuple| + 1 ]
		else [ cast firstIndex into [ t : natural number | t ] ];
	aTuple[splitIndex..]
] : tuple;

/**
 * @method "drop from_while_"
 * @restricts "tuple meta"
 * @restricts "[⊥]→boolean's type"
 */
Semantic restriction "drop from_while_" is drop-while semantic restriction;

/**
 * Compute and answer the suffix of {@param "aTuple"} that begins with the 
 * element that answers {@method "true"} to {@param "predicate"}.
 * 
 * @method "drop from_until_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥]→boolean"
 *        A function that can accept each element of the specified tuple. It
 *        should answer {@method "false"} to discard the element (and continue 
 *        scanning) or {@method "true"} to abort.
 * @returns "tuple"
 *          The requested suffix.
 * @category "Tuples" "Transformers"
 */
Public method "drop from_until_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	firstIndex ::= first index of aTuple where predicate;
	splitIndex ::=
		if firstIndex = 0
		then [ |aTuple| + 1 ]
		else [ cast firstIndex into [ t : natural number | t ] ];
	aTuple[splitIndex..]
] : tuple;

/**
 * @method "drop from_until_"
 * @restricts "tuple meta"
 * @restricts "[⊥]→boolean's type"
 */
Semantic restriction "drop from_until_" is drop-until semantic restriction;

/**
 * Answer a tuple containing the prefix of {@param "aTuple"} that answered
 * {@method "true"} to {@param "predicateBlock"}.
 * 
 * @macro "take…from_§while_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on of 
 *        {@param "aTuple"}'s element type.
 * @param "aTuple" "expression phrase ⇒ tuple"
 *        An {@type "expression phrase"} that yields the tuple to iterate over
 * @param "predicateBlock" "block phrase ⇒ []→boolean"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        predicate function.
 * @returns "send phrase ⇒ ⊤"
 * @category "Transformers" "Tuples" "Data Abstractions"
 */
Public macro "take…from_§while_" is a tuple iteration prefix function,
	tuple body function($"take from_while_", tuple);

/**
 * Answer a tuple containing the prefix of {@param "aTuple"} that answered
 * {@method "false"} to {@param "predicateBlock"}.
 * 
 * @macro "take…from_§until_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on of 
 *        {@param "aTuple"}'s element type.
 * @param "aTuple" "expression phrase ⇒ tuple"
 *        An {@type "expression phrase"} that yields the tuple to iterate over
 * @param "predicateBlock" "block phrase ⇒ []→boolean"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        predicate function.
 * @returns "send phrase ⇒ ⊤"
 * @category "Transformers" "Tuples" "Data Abstractions"
 */
Public macro "take…from_§until_" is a tuple iteration prefix function,
	tuple body function($"take from_until_", tuple);

/**
 * Compute and answer the suffix of {@param "aTuple"} that begins with the 
 * element that answers {@method "false"} to {@param "predicateBlock"}.
 * 
 * @macro "take…from_§while_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on of 
 *        {@param "aTuple"}'s element type.
 * @param "aTuple" "expression phrase ⇒ tuple"
 *        An {@type "expression phrase"} that yields the tuple to iterate over
 * @param "predicateBlock" "block phrase ⇒ []→boolean"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        predicate function.
 * @returns "send phrase ⇒ ⊤"
 * @category "Transformers" "Tuples" "Data Abstractions"
 */
Public macro "drop…from_§while_" is a tuple iteration prefix function,
	tuple body function($"drop from_while_", tuple);

/**
 * Compute and answer the suffix of {@param "aTuple"} that begins with the 
 * element that answers {@method "true"} to {@param "predicateBlock"}.
 * 
 * @macro "take…from_§until_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on of 
 *        {@param "aTuple"}'s element type.
 * @param "aTuple" "expression phrase ⇒ tuple"
 *        An {@type "expression phrase"} that yields the tuple to iterate over
 * @param "predicateBlock" "block phrase ⇒ []→boolean"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        predicate function.
 * @returns "send phrase ⇒ ⊤"
 * @category "Transformers" "Tuples" "Data Abstractions"
 */
Public macro "drop…from_§until_" is a tuple iteration prefix function,
	tuple body function($"drop from_until_", tuple);

/**
 * Answer a tuple containing every element of {@param "aTuple"} except for the 
 * first {@param "count"} elements.
 * 
 * @method "drop_from_"
 * @param "count" "whole number"
 *        The size of the prefix of {@param "aTuple"} that should be omitted 
 *        from the result tuple.
 * @param "aTuple" "tuple"
 *        The source tuple.
 * @returns "tuple"
 *          A tuple containing every element but the first {@param "count"} 
 *          elements of {@param "aTuple"}, preserving the original order.
 * @category "Tuples" "Transformers"
 */
Public stable method "drop_from_" is
[
	count : whole number,
	aTuple : tuple
|
	aTuple[count + 1..]
] : tuple;

/**
 * @method "drop_from_"
 * @restricts "whole number's type"
 * @restricts "tuple's type"
 */
Semantic restriction "drop_from_" is
[
	count : whole number's type,
	tupleType : tuple's type
|
	startType ::= cast count + 1's type into [ t : [1..∞)'s type | t ];
	tuple type of tupleType[startType..||tupleType||]
];

Method "_[_]→_" is stable at [tuple, natural number, any]→tuple;

/**
 * Tuple element replacement affects only those elements whose subscripts are
 * instances of the index's type. If multiple subscripts could be affected, then
 * update the element types via type union with the result type. If only a 
 * single subscript could be affected, then simply replace the corresponding 
 * element type with the result type. Leverage instance types if possible.
 * 
 * @method "_[_]→_"
 * @restricts "tuple meta"
 * @restricts "natural number's type"
 * @restricts "any meta"
 */
Semantic restriction "_[_]→_" is
[
	tupleType : tuple meta,
	indexType : natural number's type,
	valueType : any meta
|
	indexLower ::= ⎣indexType⎦;
	If indexLower > ⎡tupleType⎤ then
	[
		Reject parse, expected:
			"a subscript ("
			++ “⎣indexType⎦”
			++ " ≤ theSubscript ≤ "
			++ “⎡indexType⎤”
			++ ") that could ever be valid ("
			++ “⎣tupleType⎦”
			++ " ≤ |theTuple| ≤ "
			++ “⎡tupleType⎤”
			++ ")"
	];
	indexUpper ::= ⎡indexType⎤;
	leadingTypes : <any meta…|> := tupleType's leading types;
	defaultType : any meta := tupleType's default type;
	/* Update any leading types possibly affected by `index`. */
	If indexLower ≤ |leadingTypes| then
	[
		limit ::= indexUpper min |leadingTypes|;
		For each leadingIndex from indexLower to limit do
		[
			original ::= leadingTypes[leadingIndex];
			/* If only one possible element is affected (because the lower and
			 * upper bound of `index` are equal), then we can simply replace the
			 * element type with `valueType`. Otherwise we have to weaken the
			 * affected elements via type union with `valueType`.
			 */
			replacement ::= if |{indexLower, indexUpper}| = 1
				then [ valueType ]
				else [ original ∪ valueType ];
			newLeadingTypes ::= leadingTypes[leadingIndex]→replacement;
			leadingTypes := cast newLeadingTypes into [ t : <any meta…|> | t ];
		];
	];
	/* Extend the leading types. */
	If indexUpper > |leadingTypes| then
	[
		/* If the lower bound of `index` is greater than the number of leading
		 * types, i.e., the leading types are unaffected by this operation *and*
		 * there may be intervening element types between the last leading type
		 * and the first element type affected, then pad the leading types with
		 * the default type up to the lower bound (exclusive) of `index`.
		 */
		padCount ::= indexLower - |leadingTypes| - 1;
		If padCount > 0 then
		[
			count ::= cast padCount into [ t : natural number | t ];
			leadingTypes := eject leadingTypes ++ count of defaultType;
		];
		/* If the upper bound of `index` is less than the maximum length of the
		 * tuple, then some elements of the result tuple may have the original
		 * default type. Extend the leading types to account for the new
		 * element.
		 */
		If indexUpper < ⎡tupleType⎤ then
		[
			newType ::= if |{indexLower, indexUpper}| = 1
				then [ valueType ]
				else [ defaultType ∪ valueType ];
			delta ::= if indexLower ≤ |leadingTypes| then [ 0 ] else [ 1 ];
			count ::= cast indexUpper - (|leadingTypes| max indexLower)
				into [ t : whole number | t + delta ];
			leadingTypes := eject leadingTypes ++ count of newType;
		]
		/* The upper bound of `index` exceeds the minimum length of the tuple,
		 * so just update the default type.
		 */
		else
		[
			defaultType := eject defaultType ∪ valueType;
		];
	];
	<leadingTypes, defaultType… | ||tupleType||>
];

/**
 * Compute and answer a tuple that is the result of replacing the specified
 * slice of {@param "aTuple"} with {@param "replacement"}.
 * 
 * @method "_[_.._]→_"
 * @param "aTuple" "tuple"
 * @param "sliceStart" "natural number"
 *        The subscript of the first element of the target slice.
 * @param "sliceEnd" "whole number"
 *        The subscript of the last element of the target slice.
 * @param "replacement" "tuple"
 *        The tuple that should be spliced into {@param "aTuple"} instead of the
 *        specified slice.
 * @returns "tuple"
 *          A variant of {@param "aTuple"} whose elements from {@param 
 *          "sliceStart"} (inclusive) to {@param "sliceEnd"} (inclusive) have 
 *          been replaced with those of {@param "replacement"}. Elements before 
 *          {@param "sliceStart"} and after {@param "sliceEnd"} will be present 
 *          in the answer.
 * @category "Tuples" "Transformers"
 */
Public stable method "_[_.._]→_" is
[
	aTuple : tuple,
	sliceStart : natural number,
	sliceEnd : whole number,
	replacement : tuple
|
	If sliceEnd < sliceStart - 1 then
	[
		early failure function(subscript-out-of-bounds code)
	];
	aTuple[..sliceStart - 1] ++ replacement ++ aTuple[sliceEnd + 1..]
] : tuple;

/**
 * Reject the parse if the target slice would never be valid.
 * 
 * @method "_[_.._]→_"
 * @restricts "tuple meta"
 * @restricts "natural number's type"
 * @restricts "whole number's type"
 * @restricts "tuple meta"
 */
Semantic restriction "_[_.._]→_" is
[
	aTuple : tuple meta,
	sliceStart : natural number's type,
	sliceEnd : whole number's type,
	replacement : tuple meta
|
	Require: aTuple[sliceStart..sliceEnd] is ever valid;
	prefixEnd ::= cast sliceStart - 1's type
		into [ t : whole number's type | t ];
	prefix ::= tuple type of aTuple[1's type..prefixEnd];
	suffixStart ::= cast sliceEnd + 1's type
		into [ t : natural number's type | t ];
	suffix ::= tuple type of aTuple[suffixStart..||aTuple||];
	prefix ++ replacement ++ suffix
];

/**
 * Compute an answer that is the result of swapping the elements of {@param
 * "aTuple"} at {@param "index1"} and {@param "index2"}.
 *
 * @method "_[_↔_]"
 * @param "aTuple" "tuple"
 *        A tuple.
 * @param "index1" "natural number"
 *        A subscript.
 * @param "index2" "natural number"
 *        A subscript.
 * @returns "tuple"
 *          A variant of {@param "aTuple"} whose elements at indices {@param
 *          "index1"} and {@param "index2"} have been exchanged. No other
 *          elements are affected.
 * @category "Tuples" "Transformers"
 */
Public stable method "_[_↔_]" is
[
	aTuple : tuple,
	index1 : natural number,
	index2 : natural number
|
	element2 ::= aTuple[index2];
	temp ::= aTuple[index2]→aTuple[index1];
	temp[index1]→element2
] : tuple;

/**
 * @method "_[_↔_]"
 * @restricts "tuple's type"
 * @restricts "natural number's type"
 * @restricts "natural number's type"
 */
Semantic restriction "_[_↔_]" is
[
	aTuple : tuple's type,
	index1 : natural number's type,
	index2 : natural number's type
|
	If ⎣index1⎦ > ⎡aTuple⎤ then
	[
		Reject parse, expected:
			"a subscript ("
			++ “⎣index1⎦”
			++ " ≤ theSubscript ≤ "
			++ “⎡index1⎤”
			++ ") that could ever be valid ("
			++ “⎣aTuple⎦”
			++ " ≤ |theTuple| ≤ "
			++ “⎡aTuple⎤”
			++ ")"
	];
	If ⎣index2⎦ > ⎡aTuple⎤ then
	[
		Reject parse, expected:
			"a subscript ("
			++ “⎣index2⎦”
			++ " ≤ theSubscript ≤ "
			++ “⎡index2⎤”
			++ ") that could ever be valid ("
			++ “⎣aTuple⎦”
			++ " ≤ |theTuple| ≤ "
			++ “⎡aTuple⎤”
			++ ")"
	];
	limit ::= ⎣index1⎦ min ⎣index2⎦;
	leadingTypes ::= aTuple[1..limit - 1];
	defaultType ::= ∪ aTuple[limit..|aTuple's leading types| + 1];
	<leadingTypes, defaultType… | ||aTuple||>
];

/**
 * Obtain the first element of the specified tuple.
 *
 * @method "_'s⁇head"
 * @param "aTuple" "any+"
 * @returns "any"
 *          The first element of {@param "aTuple"}.
 * @category "Tuples" "Queries"
 */
Public stable method "_'s⁇head" is
[
	aTuple : any+
|
	aTuple[1]
] : any;

/**
 * @method "_'s⁇head"
 * @restricts "any+'s type"
 */
Semantic restriction "_'s⁇head" is
[
	aTupleType : any+'s type
|
	aTupleType[1]
];

/**
 * Construct and answer a tuple slice that contains all but the first element of
 * the specified tuple. If the argument contains only one element, then answer
 * an empty tuple.
 *
 * @method "_'s⁇tail"
 * @param "aTuple" "any+"
 *        A nonempty tuple.
 * @returns "tuple"
 *          The requested tuple slice.
 * @category "Tuples" "Queries"
 */
Public stable abstract method "_'s⁇tail" is [any+]→tuple;

Method "_'s⁇tail" is
[
	aTuple : <any…|1>
|
	<>
] : <>'s type;

Method "_'s⁇tail" is
[
	aTuple : <any…|2..>
|
	aTuple[2..]
] : tuple;

/**
 * @method "_'s⁇tail"
 * @restricts "any+'s type"
 */
Semantic restriction "_'s⁇tail" is
[
	aTupleType : any+'s type
|
	leadingTypes ::= aTupleType's leading types;
	defaultType ::= aTupleType's default type;
	sizeLeadingTypes ::= |leadingTypes|;
	bound ::= ⎡aTupleType⎤;
	lower ::= ⎣aTupleType⎦ - 1;
	if sizeLeadingTypes > 1 then
	[
		<leadingTypes[2..sizeLeadingTypes], defaultType…|[lower..bound)>
	]
	else
	[
		<defaultType…|lower..bound-1>
	]
];

/**
 * Obtain the last element of the specified tuple.
 *
 * @method "_'s⁇last"
 * @param "aTuple" "any+"
 * @returns "any"
 *          The last element of a {@param "aTuple"}.
 * @category "Tuples" "Queries"
 */
Public stable method "_'s⁇last" is
[
	aTuple : any+
|
	aTuple[|aTuple|]
] : any;

/**
 * @method "_'s⁇last"
 * @restricts "any+'s type"
 */
Semantic restriction "_'s⁇last" is
[
	aTupleType : any+'s type
|
	upper ::= ⎡aTupleType⎤ min (|aTupleType's leading types| + 1);
	∪ aTupleType[⎣aTupleType⎦..upper max ⎣aTupleType⎦]
];

/**
 * Sum the elements of the specified tuple of integers.
 *
 * @method "∑_"
 * @param "intTuple" "extended integer*"
 *        A tuple of integers.
 * @returns "extended integer"
 *          An integer.
 * @category "Tuples" "Integers" "Mathematics"
 */
Public stable method "∑_" is
[
	intTuple : extended integer*
|
	0
] : extended integer;

Public stable method "∑_" is
[
	intTuple : extended integer+
|
	left fold intTuple through
		[i : extended integer, ri : extended integer | i + ri]
] : extended integer;

/**
 * Compute and answer the best bounds of the specified summation.
 * 
 * The basic strategy is to first compute the integer range type r representing
 * the shortest tuple, then keep adding in the range of successive elements to
 * produce a series of integer range types in r, accumulating the type union of
 * each such r into a range type representing the range of all possible sums.
 * We actually use a faster technique over the homogenous part of the tuple.
 *
 * @method "∑_"
 * @param "intTupleType" "extended integer*'s type"
 *        A tuple type whose default type is {@type "extended integer"}.
 * @returns "extended integer's type"
 *          The strongest integer range that can be computed for the argument.
 * @category "Tuples" "Mathematics" "Types"
 */
Method "∑_" is
[
	intTupleType : extended integer*'s type
|
	leading ::= intTupleType's leading types;
	defaultType ::= intTupleType's default type;
	leadingSize ::= |leading|;
	minTupleSize ::= ⎣intTupleType⎦;
	maxTupleSize ::= ⎡intTupleType⎤;
	range : extended integer's type := [0..0];
	firstLimit ::= minTupleSize min leadingSize;
	/* Account for elements up to firstLimit: the end of leading or the smallest
	 * tuple, whichever comes first.
	 */
	For each elementIndex from 1 to firstLimit do
	[
		range := range + intTupleType[elementIndex];
	];
	/* Account for elements from firstLimit + 1 up to the smallest tuple.  The
	 * resulting range is the first range to include in the type union.
	 */
	If minTupleSize > firstLimit then
	[
		range := range + (minTupleSize - firstLimit)'s type × defaultType;
	];
	union : extended integer's type := range;
	/* Account for elements from the smallest tuple up to leadingSize. */
	For each elementIndex from minTupleSize + 1 to leadingSize do
	[
		range := range + intTupleType[elementIndex];
		union := union ∪ range;
	];
	/* Account for the remaining elements in the homogenous range. */
	span ::= maxTupleSize - (minTupleSize max leadingSize);
	If span > 0 then
	[
		/* Since the tuple can't have infinite length, we mustn't get an
		 * *inclusive* infinity just by adding an arbitrarily large number of
		 * finite elements.  Integer range multiplication deals with that.
		 */
		spanRange ::= [0..span + 1);
		range := range + spanRange × defaultType;
		union := union ∪ range;
	];
	union
] : extended integer's type;

/**
 * Strengthen the return type
 *
 * @method "∑_"
 * @restricts "extended integer+'s type"
 */
Semantic restriction "∑_" is
[
	intTupleType : extended integer*'s type
|
	∑ intTupleType
];

/**
 * Take the product of the elements of a tuple of integers.
 *
 * @method "∏_"
 * @param "intTuple" "extended integer+"
 *        A tuple of integers.
 * @returns "extended integer"
 *          An integer.
 * @category "Tuples" "Mathematics" "Integers"
 */
Public stable method "∏_" is
[
	intTuple : extended integer+
|
	left fold intTuple through 
	[
		i : extended integer,
		ri : extended integer
	|
		i × ri
	]
] : extended integer;

/* TODO [RAA]
 * 
 * Strengthen the return type
 *
 * @method "∏_"
 * @restricts "integer+'s type"
 *
Semantic restriction "∏_" is
[
	intTupleType : integer+'s type
|
	leading ::= intTupleType's leading types;
	defaultType ::= intTupleType's default type;
	leadingSize ::= |leading|;
	lowIndex ::= leadingSize min ⎣leading's type⎦;
	lowBound ::= if leadingSize > 0 then 
	[
		m ::=  map each i in leading[1..lowIndex] through
		[
			x::=cast i into [it : integer's type | it];
Print: "x=";
Print: “x”;
			y::= cast (⎣x⎦) into [n : integer | n]
		];
		∏ (cast x into [iTuple : integer+ | iTuple] )); 
Print: "y=";
Print: “y”;

		z::=y × (⎣defaultType⎦ ^ 
				((⎣intTupleType⎦ - lowIndex) max 0));
Print: "z=";
Print: “z”;
		z
			
	]
	else
	[
		⎣defaultType⎦ ^ 
				((⎣intTupleType⎦ - lowIndex) max 0)
	];
	upBound ::= if leadingSize > 0 then 
	[
		(∏ (cast (map each i in leading[1..lowIndex] through
		[
			x ::= cast i into [it : integer's type | it];
			cast (⎡x⎤) into [n : integer | n]
		]) into [iTuple : integer+ | iTuple] )) × 
			((⎡intTupleType's default type⎤) ^
			(⎡intTupleType⎤ - leadingSize))
	]
	else
	[
		((⎡intTupleType's default type⎤) ^
			(⎡intTupleType⎤ - leadingSize))
	];
	[lowBound..upBound+1)
];*/

/**
 * An implementation of insertion sort that accepts a tuple to be sorted and
 * the predicate that defines how sorting occurs. This only used for sorting
 * small tuples.
 *
 * @method "insertion sort_with_"
 * @param "aTuple" "<any…|2..15>" 
 *        The tuple to be sorted.
 * @param "comparator" "[⊥, ⊥]→boolean"
 *        A comparison function that accepts two elements of {@param "aTuple"}
 *        and answers {@method "true"} if the first ≤ second and {@method
 *        "false"} otherwise.
 * @returns "<any|2..15>"
 *          The sorted tuple.
 * @category "Tuples" "Transformers" "Sorting"
 */
Private method "insertion sort_with_" is
[
	aTuple : <any…|2..10>,
	comparator : [⊥, ⊥]→boolean
|
	output : <any…|2..> := aTuple;
	For each i from 2 to |aTuple| do
	[
		j : [1..9] := i-1;
		k : [2..10] := i;
		While j > 1 ∧ comparator(output[k], output[j]) do
		[
			output := output[k↔j];
			k--;
			j--;
		];
		output := if j = 1 ∧ comparator(output[k], output[j])
			then [output[k↔j]]
			else [output];
	];
	output
] : <any…|2..>;

/**
 * @method "insertion sort_with_"
 * @restricts "<any…|2..10>'s type"
 * @restricts "[⊥, ⊥]→boolean's type"
 */
Semantic restriction "insertion sort_with_" is
[
	tupleType : <any…|2..10>'s type,
	comparator : [⊥, ⊥]→boolean's type
|
	union ::= ∪ tupleType[1..|tupleType's leading types|+1];
	If comparator[1] ≠ ⊥ ∧ ¬union ⊆ comparator[1] then
	[
		Reject parse, expected:
			"first parameter of comparison function to accept all elements ∈ "
			++ “union”
			++ " of the specified tuple (but it only accepts "
			++ “comparator[1]”
			++ ")"
	];
	If comparator[2] ≠ ⊥ ∧ ¬union ⊆ comparator[2] then
	[
		Reject parse, expected:
			"second parameter of comparison function to accept all elements ∈ "
			++ “union”
			++ " of the specified tuple (but it only accepts "
			++ “comparator[2]”
			++ ")"
	];
	<union… | ⎣tupleType⎦..⎡tupleType⎤>
];

/**
 * Construct and answer a sorted variant of {@param "numbers"} using the
 * quicksort algorithm.
 *
 * When overriding {@method "quicksort_"}, only target tuple types that contain
 * at least two elements. Not only do the trivial cases of 0 and 1 elements have
 * a simple universal implementation, the 0-element (i.e., empty tuple) case
 * causes ambiguous resolution if multiple overrides exist that will accept it.
 *
 * @method "quicksort_"
 * @category "Tuples" "Sorting"
 * @param "numbers" "number*"
 *        A tuple of numbers.
 * @returns "number*"
 *          A tuple of numbers in ascending order.
 */
Public abstract method "quicksort_" is [number*]→number*;

/** 
 * Give quicksort higher precedence than concatenation. 
 * 
 * @method "quicksort_"
 * @forbids "1" "_++_"
 */
Grammatical restriction "quicksort_" is <{"_++_"}>;

/**
 * @method "quicksort_"
 * @restricts "tuple meta"
 */
Semantic restriction "quicksort_" is
[
	tupleType : tuple meta
|
	union ::= ∪ tupleType[1..|tupleType's leading types|+1];
	<<>, union… | ||tupleType||>
];

Method "quicksort_" is
[
	trivial : <⊥…|0>
|
	trivial
] : <number…|0>;

Method "quicksort_" is
[
	trivial : <number…|1>
|
	trivial
] : <number…|1>;

Seal method "quicksort_" at <<any…|0..1>>;

Method "quicksort_" is
[
	numbers : <number…|2..>
|
	/* Choose the median of the first, middle, and last elements as the
	 * pivot.
	 */
	size ::= |numbers|;
	halfSize ::= |numbers| ÷ 2;
	pivotIndex : natural number :=
		if numbers[1] > numbers[size]
		then [1]
		else [size];
	pivotIndex :=
		if numbers[pivotIndex] < numbers[halfSize]
		then [pivotIndex]
		else [
			nonpivotBoundaryIndex : natural number :=
				cast size + 1 - pivotIndex into [t : natural number | t];
			if numbers[nonpivotBoundaryIndex] < numbers[halfSize]
			then [halfSize]
			else [nonpivotBoundaryIndex]];
	pivot ::= numbers[pivotIndex];
	withoutPivot ::= numbers[..pivotIndex-1] ++ numbers[pivotIndex+1..];
	lesser ::= select each n from withoutPivot where [n ≤ pivot];
	greater ::= select each n from withoutPivot where [n > pivot];
	quicksort lesser ++ <pivot> ++ quicksort greater
];

/**
 * Construct and answer a sorted variant of {@param "aTuple"} using the
 * quicksort algorithm and specified comparison function.
 *
 * @method "quicksort_with_"
 * @category "Tuples" "Transformers" "Sorting"
 * @param "aTuple" "tuple"
 *        A tuple.
 * @param "comparator" "[⊥, ⊥]→boolean"
 *        A comparison function that accepts two elements of {@param "aTuple"}
 *        and answers {@method "true"} if the first ≤ second and {@method 
 *        "false"} otherwise.
 * @returns "tuple"
 *          A sorted variant of {@param "aTuple"}.
 */
Public abstract method "quicksort_with_" is [tuple, [⊥, ⊥]→boolean]→tuple;

/**
 * @method "quicksort_with_"
 * @restricts "tuple meta"
 * @restricts "[⊥, ⊥]→boolean's type"
 */
Semantic restriction "quicksort_with_" is
[
	tupleType : tuple meta,
	comparator : [⊥, ⊥]→boolean's type
|
	union ::= ∪ tupleType[1..|tupleType's leading types|+1];
	If comparator[1] ≠ ⊥ ∧ ¬union ⊆ comparator[1] then
	[
		Reject parse, expected:
			"first parameter of comparison function to accept all elements ∈ "
			++ “union”
			++ " of the specified tuple (but it only accepts "
			++ “comparator[1]”
			++ ")"
	];
	If comparator[2] ≠ ⊥ ∧ ¬union ⊆ comparator[2] then
	[
		Reject parse, expected:
			"second parameter of comparison function to accept all elements ∈ "
			++ “union”
			++ " of the specified tuple (but it only accepts "
			++ “comparator[2]”
			++ ")"
	];
	<<>, union… | ||tupleType||>
];

Method "quicksort_with_" is
[
	trivial : any?,
	comparator : [⊥, ⊥]→boolean
|
	trivial
] : any?;

Method "quicksort_with_" is
[
	aTuple : <any…|2..10>,
	comparator : [⊥, ⊥]→boolean
 |
	insertion sort aTuple with comparator
];

Method "quicksort_with_" is
[
	aTuple : <any…|11..>,
	comparator : [⊥, ⊥]→boolean
|
	/* Choose the median of the first, middle, and last elements as the
	 * pivot.
	 */
	size ::= |aTuple|;
	halfSize ::= |aTuple| ÷ 2;
	pivotIndex : natural number :=
		if comparator(aTuple[1], aTuple[size])
		then [1]
		else [size];
	pivotIndex :=
		if ¬comparator(aTuple[pivotIndex], aTuple[halfSize])
		then [pivotIndex]
		else [halfSize];
	pivot ::= aTuple[pivotIndex];
	withoutPivot ::= aTuple[..pivotIndex-1] ++ aTuple[pivotIndex+1..];
	lesser ::= select each a from withoutPivot where [comparator(a, pivot)];
	greater ::= reject each a from withoutPivot where [comparator(a, pivot)];
	quicksort lesser with comparator
		++ <pivot>
		++ quicksort greater with comparator
];

Seal method "quicksort_with_" at <tuple, [⊥, ⊥]→boolean>;

/**
 * Construct and answer a sorted variant of {@param "aTuple"} using the
 * quicksort algorithm and specified comparison function.
 *
 * @method "quicksort…,…in|of_§by_"
 * @category "Tuples" "Transformers" "Sorting"
 * @param "firstInputPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the first loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aTuple"}.
 * @param "secondInputPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the second loop variable. The generated
 *        loop variable is given the strongest possible type based on the type
 *        union of the leading types and default type of {@param "aTuple"}.
 * @param "aTuple" "expression phrase ⇒ tuple"
 *        An {@type "expression phrase"} that yields the tuple to sort
 * @param "comparatorBlock" "block phrase ⇒ []→boolean"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        comparison function.
 * @returns "tuple"
 *          A sorted variant of {@param "aTuple"}.
 */
Public macro "quicksort…,…in|of_§by_" is 
	a two-input tuple prefix function,
	two-input tuple body function($"merge sort_with_",tuple);


/**
 * Take two sorted tuples and merge them into one sorted tuple based upon the
 * criteria provided in the comparison function.
 *
 * @method "merge_with_"
 * @category "Tuples" "Sorting"
 * @param "splitInput" "<tuple…|2>>" 
 *        The two ordered tuples to merge.
 * @param "comparator" "[⊥, ⊥]→boolean"
 *        A comparison function that accepts two elements of {@param "aTuple"}
 *        and answers {@method "true"} if the first ≤ second and {@method 
 *        "false"} otherwise.
 * @returns "tuple"
 *          The merged tuple.
 * @author "Richard Arriaga"
 */
Private method "merge_with_" is
[
	splitInput : <tuple…|2>,
	comparator : [⊥, ⊥]→boolean
 |
	i : natural number := 1;
	j : natural number := 1;
	k : natural number := 1;

	input1 : tuple := splitInput[1];
	input2 : tuple := splitInput[2];
	output : tuple := input1 ++ input2;

	input1_size ::= |input1|;
	input2_size ::= |input2|;

	While i ≤ input1_size ∧ j ≤ input2_size
	do
	[
		i1 ::= input1[i];
		i2 ::= input2[j];
		
		If comparator(i1, i2) then
		[
			output := output[k]→i1;
			i++;
		]
		else
		[
			output := output[k]→i2;
			j++;
		];
		k++;
	];
	
	/* concatenate remaining input */
	if i ≤ input1_size then [output[..k-1] ++ input1[i..]]
	else [output[..k-1] ++ input2[j..]]
]: tuple;

/**
 * Construct and answer a sorted variant of {@param "aTuple"} using the
 * merge sort algorithm and specified comparison function.
 *
 * @method "merge sort_with_"
 * @param "aTuple" "tuple" 
 *        The tuple to sort.
 * @param "comparator" "[⊥, ⊥]→boolean"
 *       A comparison function that accepts two elements of {@param "aTuple"}
 *       and answers {@method "true"} or {@method "false"} depending on the 
 *       outcome of the block.
 * @returns "tuple"
 *          The sorted tuple.
 * @author "Richard Arriaga"
 * @category "Tuples" "Sorting"
 */
Public abstract method "merge sort_with_" is [tuple, [⊥, ⊥]→boolean]→tuple;

/**
 * @method "merge sort_with_"
 * @restricts "tuple meta"
 * @restricts "[⊥, ⊥]→boolean's type"
 */
Semantic restriction "merge sort_with_" is
[
	tupleType : tuple meta,
	comparator : [⊥, ⊥]→boolean's type
|
	union ::= ∪ tupleType[1..|tupleType's leading types|+1];
	If comparator[1] ≠ ⊥ ∧ ¬union ⊆ comparator[1] then
	[
		Reject parse, expected:
			"first parameter of comparison function to accept all elements ∈ "
			++ “union”
			++ " of the specified tuple (but it only accepts "
			++ “comparator[1]”
			++ ")"
	];
	If comparator[2] ≠ ⊥ ∧ ¬union ⊆ comparator[2] then
	[
		Reject parse, expected:
			"second parameter of comparison function to accept all elements ∈ "
			++ “union”
			++ " of the specified tuple (but it only accepts "
			++ “comparator[2]”
			++ ")"
	];
	<union… | ⎣tupleType⎦..⎡tupleType⎤>
];

Method "merge sort_with_" is
[
	trivial : any?,
	comparator : [⊥, ⊥]→boolean
|
	trivial
] : any?;

Method "merge sort_with_" is
[
	aTuple : <any…|2..10>,
	comparator : [⊥, ⊥]→boolean
 |
	insertion sort aTuple with comparator
]: tuple;

Public method "merge sort_with_" is
[
	aTuple : <any…|11..>,
	comparator : [⊥, ⊥]→boolean
 |
		left : tuple := merge sort aTuple[..|aTuple| ÷ 2] with comparator;
		right: tuple := merge sort aTuple[|aTuple| ÷ 2 + 1..] with comparator;
		merge: tuple := merge <left,right> with comparator;
		
		Assert: (|left| + |right|) = |merge|;
		
		merge
]: tuple;

/**
 * Construct and answer a sorted variant of {@param "aTuple"} using the
 * merge sort algorithm and specified comparison function.
 *
 * @method "merge sort…,…in|of_§by_"
 * @param "firstInputPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the first loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aTuple"}.
 * @param "secondInputPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the second loop variable. The generated
 *        loop variable is given the strongest possible type based on the type
 *        union of the leading types and default type of {@param "aTuple"}.
 * @param "aTuple" "expression phrase ⇒ tuple"
 *        An {@type "expression phrase"} that yields the tuple to sort
 * @param "comparatorBlock" "block phrase ⇒ []→boolean"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        comparison function.
 * @returns "tuple"
 *          The sorted tuple.
 * @author "Richard Arriaga"
 * @category "Tuples" "Sorting"
 */
Public macro "merge sort…,…in|of_§by_" is 
	a two-input tuple prefix function,
	two-input tuple body function($"merge sort_with_",tuple);

/**
 * Construct and answer a sorted variant of {@param "aTuple"} of numbers using
 * the merge sort algorithm where n ≤ m.
 *
 * @method "merge sort_"
 * @param "aTuple" "number*" 
 *         A tuple.
 * @returns "number*"
 *          The sorted tuple.
 * @author "Richard Arriaga"
 * @category "Tuples" "Sorting"
 */
Public abstract method "merge sort_" is [number*]→number*;

/**
 * Give merge sort higher precedence than concatenation.
 * 
 * @method "merge sort_"
 * @forbids "1" "_++_"
 */
Grammatical restriction "merge sort_" is <{"_++_"}>;

/**
 * @method "merge sort_"
 * @restricts "tuple meta"
 */
Semantic restriction "merge sort_" is
[
	tupleType : tuple meta
|
	union ::= ∪ tupleType[1..|tupleType's leading types|+1];
	<<>, union… | ||tupleType||>
];

/*
 * An empty tuple is already sorted.
 */
Method "merge sort_" is
[
	trivial : <⊥…|0>
|
	trivial
] : <number…|0>;

/*
 * A tuple with one element is already sorted.
 */
Method "merge sort_" is
[
	trivial : <number…|1>
|
	trivial
] : <number…|1>;

Method "merge sort_" is
[
	aTuple : <number…|2..>
 |
	merge sort n, m of aTuple by [n ≤ m]
];

/**
 * Construct and answer a tuple like {@param "aTuple"}, but with the leftmost
 * occurrence of {@param "doomed"} removed.
 *
 * @method "_-_"
 * @param "aTuple" "tuple"
 *        A tuple.
 * @param "doomed" "any"
 *        A value.
 * @returns "tuple"
 *          The requested tuple, which will be {@param "aTuple"} if there were
 *          no occurrences of {@param "doomed"}.
 * @category "Tuples"
 */
Method "_-_" is
[
	aTuple : tuple,
	doomed : any
|
	index ::= first index of aTuple where [a : any | a = doomed];
	cast index into [i : natural number | aTuple[..i-1] ++ aTuple[i+1..]]
	else [aTuple]
] : tuple;

/**
 * @method "_-_"
 * @restricts "tuple meta"
 * @restricts "any meta"
 */
Semantic restriction "_-_" is
[
	tupleType : tuple meta,
	element : any meta
|
	allDisjoint : boolean := true;
	For each index from 1 to |tuple's leading types| + 1 do
	[
		If tupleType[index] ∩ element ≠ ⊥ then
		[
			allDisjoint := false;
		];
		allDisjoint
	];
	If allDisjoint then
	[
		Reject parse, expected:
			"tuple subtraction to have a possible effect (but "
			++ “element”
			++ " is disjoint from every element type)"
	]
	else
	[
		union ::= ∪ tupleType[1..|tupleType's leading types|+1];
		<union… | 0 max (⎣tupleType⎦-1).. ⎡tupleType⎤>
	]
];

/**
 * Construct a tuple like the one stored in {@param "var"}, but with the
 * leftmost occurrence of {@param "doomed"} removed, and store the result into
 * {@param "var"}.
 *
 * @method "_↑-=_"
 * @param "var" "read tuple/write ⊥"
 *        A {@type "variable"} containing a {@type "tuple"}.
 * @param "doomed" "any"
 *        A value.
 * @returns "⊤"
 * @category "Tuples" "Variables"
 */
Public method "_↑-=_" is
[
	var : read tuple/write ⊥,
	doomed : any
|
	value ::= eject var;
	var ?= value - doomed;
] : ⊤;

Alias "_-=_" to "_↑-=_";

/**
 * @method "_↑-=_"
 * @restricts "(read tuple/write ⊥)'s type"
 * @restricts "any meta"
 */
Semantic restriction "_↑-=_" is
[
	varType : (read tuple/write ⊥)'s type,
	element : any meta
|
	tupleType ::= varType's read type;
	allDisjoint : boolean := true;
	For each index from 1 to |tuple's leading types| + 1 do
	[
		If tupleType[index] ∩ element ≠ ⊥ then
		[
			allDisjoint := false;
		];
		allDisjoint
	];
	If allDisjoint then
	[
		Reject parse, expected:
			"tuple subtraction to have a possible effect (but "
			++ “element”
			++ " is disjoint from every element type)"
	]
	else
	[
		union ::= ∪ tupleType[1..|tupleType's leading types|+1];
		resultType ::= <union… | 0 max (⎣tupleType⎦-1).. ⎡tupleType⎤>;
		If ¬resultType ⊆ varType's write type then
		[
			Reject parse, expected: "variable to accept " ++ “resultType”
		];
	];
	⊤
];

/**
 * If {@param "start"} and {@param "end"} are valid subscripts representing a 
 * valid range for {@param "aTuple"}, then answer the corresponding subtuple. 
 * Otherwise, answer the result obtained by applying {@param "else"}.
 *
 * @method "_[_.._]else_"
 * @param "aTuple" "tuple"
 *        A {@type "tuple"}.
 * @param "start" "integer"
 *        An {@type "integer"}.
 * @param "end" "integer"
 *        An {@type "integer"}.
 * @param "else" "[]→any"
 *        The function to apply if {@param "start"} through {@param "end"} is not
 *        a valid range of {@param "aTuple"}.
 * @returns "any"
 *          The {@param "start"}-th throught the {@param "end"}-th elements of 
 *          {@param "aTuple"}, or the result of applying {@param "else"} 
 *          (if {@param "index"} is invalid).
 * @category "Tuples" "Queries"
 */
Public method "_[_.._]else_" is
[
	aTuple : tuple,
	start : integer,
	end : integer,
	else : function accepting <> and returning any
|
	if start ∈ [1..|aTuple| + 1] ∧ end  ∈ [0..|aTuple|] ∧ start - 1 ≤ end
	then [aTuple[cast start into [t : natural number | t]..
		cast end into [t : whole number | t]]]
	else else
] : any;

/**
 * @method "_[_.._]else_"
 * @restricts "tuple meta"
 * @restricts "integer's type"
 * @restricts "integer's type"
 * @restricts "(function accepting <> and returning any)'s type"
 */
Semantic restriction "_[_.._]else_" is
[
	tupleType : tuple meta,
	start : integer's type,
	end : integer's type,
	else : (function accepting <> and returning any)'s type
|
	if
		⎣start⎦ - 1 > ⎡tupleType⎤
		∨ ⎡start⎤ < 1
		∨ ⎣end⎦ > ⎡tupleType⎤
		∨ ⎡end⎤ < 0
		∨ ⎣start⎦ - 1 > ⎡end⎤
	then
	[
		Reject parse, expected: "slice to ever be valid"
	]
	else if
		⎣start⎦ ≥ 1
		∧ ⎣end⎦ ≥ 0
		∧ ⎡start⎤ ≤ ⎣tupleType⎦
		∧ ⎡end⎤ ≤ ⎣tupleType⎦
	then
	[
		Reject parse, expected:
			"alternative block to be necessary, but the slice is guaranteed \
			\|to be valid"
	]
	else
	[
		tuple type of tupleType[start ∩ natural number..end ∩ whole number]
			∪ else's return type
	]
];

/**
 * If {@param "end"} is a valid subscript representing the end of a valid range
 * for {@param "aTuple"}, then answer the corresponding subtuple. Otherwise,
 * answer the result obtained by applying {@param "else"}.
 *
 * @method "_[.._]else_"
 * @param "aTuple" "tuple"
 *        A {@type "tuple"}.
 * @param "end" "integer"
 *        An {@type "integer"}.
 * @param "else" "[]→any"
 *        The function to apply if 1 through {@param "end"} is not
 *        a valid range of {@param "aTuple"}.
 * @returns "any"
 *          The first through the {@param "end"}-th element of 
 *          {@param "aTuple"}, or the result of applying {@param "else"} 
 *          (if {@param "index"} is invalid).
 * @category "Tuples" "Queries"
 */
Public method "_[.._]else_" is
[
	aTuple : tuple,
	end : integer,
	else : function accepting <> and returning any
|
	aTuple[1..end] else else
] : any;

/**
 * @method "_[.._]else_"
 * @restricts "tuple meta"
 * @restricts "integer's type"
 * @restricts "(function accepting <> and returning any)'s type"
 */
Semantic restriction "_[.._]else_" is
[
	tupleType : tuple meta,
	end : integer's type,
	else : (function accepting <> and returning any)'s type
|
	if ⎣end⎦ > ⎡tupleType⎤ ∨ ⎡end⎤ < 0 then
	[
		Reject parse, expected: "slice to ever be valid"
	]
	else if
		⎣end⎦ ≥ 0
		∧ 1 ≤ ⎣tupleType⎦
		∧ ⎡end⎤ ≤ ⎣tupleType⎦
	then
	[
		Reject parse, expected:
			"alternative block to be necessary, but the slice is guaranteed \
			\|to be valid"
	]
	else
	[
		tuple type of tupleType[1's type..end ∩ whole number]
			∪ else's return type
	]
];

/**
 * If {@param "start"} is a valid subscript representing the start of a  
 * valid range for {@param "aTuple"}, then answer the corresponding subtuple. 
 * Otherwise, answer the result obtained by applying {@param "else"}.
 *
 * @method "_[_..]else_"
 * @param "aTuple" "tuple"
 *        A {@type "tuple"}.
 * @param "start" "integer"
 *        An {@type "integer"}.
 * @param "else" "[]→any"
 *        The function to apply if {@param "start"} through the end of aTuple 
 *        is not a valid range of {@param "aTuple"}.
 * @returns "any"
 *          The {@param "start"}-th through the last element of 
 *          {@param "aTuple"}, or the result of applying {@param "else"} 
 *          (if {@param "start"} is invalid).
 * @category "Tuples" "Queries"
 */
Public method "_[_..]else_" is
[
	aTuple : tuple,
	start : integer,
	else : function accepting <> and returning any
|
	aTuple[start..|aTuple|] else else
] : any;

/**
 * @method "_[_..]else_"
 * @restricts "tuple meta"
 * @restricts "integer's type"
 * @restricts "(function accepting <> and returning any)'s type"
 */
Semantic restriction "_[_..]else_" is
[
	tupleType : tuple meta,
	start : integer's type,
	else : (function accepting <> and returning any)'s type
|
	end ::= ||tupleType||;
	if
		⎣start⎦ - 1 > ⎡tupleType⎤
		∨ ⎡start⎤ < 1
		∨ ⎣start⎦ - 1 > ⎡end⎤
	then
	[
		Reject parse, expected: "slice to ever be valid"
	]
	else if
		⎣start⎦ ≥ 1
		∧ ⎡start⎤ ≤ ⎣tupleType⎦
		∧ ⎡end⎤ ≤ ⎣tupleType⎦
	then
	[
		Reject parse, expected:
			"alternative block to be necessary, but the slice is guaranteed \
			\|to be valid"
	]
	else
	[
		tuple type of tupleType[start ∩ natural number..end ∩ whole number]
			∪ else's return type
	]
];

/**
 * A method that calculates all instances of overlap that a tuple has with
 * itself. 
 *
 * @method "self overlap_"
 * @category "Tuples"
 * @param "aTuple" "tuple" 
 *        A tuple.
 * @returns "{tuple→natural number|}"
 *          A map keyed by the strict subtuples of the input tuple with values
 *          of the index on the full tuple that is one position beyond the 
 *          overlap.
 * @author "Richard Arriaga"
 */
Private method "self overlap_" is
[
	aTuple : any+
 |
	overlap : {tuple→natural number|} := {};
	position : natural number := 2;
	current : natural number := 1;
	While |aTuple| > position do
	[
		/*create a map for each state of a tuple, what it would be mapped back
		 * to.  The key is a subtuple of the input tuple, the value is the 
		 * index in the tuple it returns to for the most recent overlap
		 */
		If aTuple[current] = aTuple[position] then
		[
		 	current++;
		] 
		else
		[
			current := 1;
		];
		overlap := overlap + aTuple[..position]→current;
		position++;
	];
	overlap
] : {tuple→natural number|};

/**
 * Obtain the location of the start of the first occuring subtuple in a 
 * tuple.
 *
 * @method "first index of_in_"
 * @category "Tuples"
 * @param "aTuple" "tuple" 
 *        The tuple within which to search for the subtuple.
 * @param "subtuple" "tuple"
 *        The subtuple to locate in aTuple.
 * @returns "whole number"
 *          The index of the start of the first subtuple, 0 if none.
 * @author "Richard Arriaga"
 * @category "Tuples" "Queries"
 */
Public stable abstract method "first index of_in_" is [tuple,tuple]→whole number;

Method "first index of_in_" is
[
	subtuple : <any…|0>,
	aTuple : <any…|0>
 |
	0
] : 0's type;

Method "first index of_in_" is
[
	subtuple : any+,
	aTuple : <any…|0>
 |
	0
] : 0's type;

Method "first index of_in_" is
[
	subtuple : <any…|0>,
	aTuple : any+
 |
	0
] : 0's type;

/*
 * Obtain the location of the start of the first occuring subtuple in a 
 * tuple (a substring of a string).  The
 * {@link "http://en.wikipedia.org/wiki/Knuth-Morris-Pratt_algorithm" 
 * Knuth-Moris-Pratt algorithm} is used for this implementation. 
 */
Method "first index of_in_" is
[
	subtuple : any+,
	aTuple : any+
 |

	if |subtuple| > |aTuple| then [0]
	else if |subtuple| = 1 then
	[
		/* if the subtuple has only one element, no benefit from KMP, simply
		 * walk through aTuple searching for first element that matches the 
		 * single element of aSubtuple*/
		first index of aTuple where
		[
			a : any
		 |
			a = subtuple[1]
		]
	]
	else
	[
		found : boolean := false;
		subtupleStart : whole number := 0;
		tupleIndex : natural number := 1;
		subtupleIndex : natural number := 1;
		overlapTable : {tuple→natural number|} := self overlap subtuple;
		Until found ∨ tupleIndex + |subtuple| - subtupleIndex > |aTuple| do
		[
			If aTuple[tupleIndex] = subtuple[subtupleIndex] then
			[
				If subtupleIndex = |subtuple| then 
				[
					found := true;
					subtupleStart := cast tupleIndex - subtupleIndex + 1 into 
						[w : whole number | w];
				]
				else [subtupleIndex++;];
			]
			else
			[
			 	subtupleIndex := overlapTable[subtuple[..subtupleIndex]] 
			 		else [1];
			];
			tupleIndex++;
		];
		subtupleStart
	]
] : whole number;

/**
 * Obtain the location of the start of every instance of subtuple occuring in a 
 * tuple.
 *
 * @method "all indices of_in_"
 * @category "Tuples"
 * @param "aTuple" "tuple" 
 *        The tuple to search for the subtuple.
 * @param "subtuple" "tuple"
 *        The subtuple to locate in aTuple.
 * @returns "<natural number…|>"
 *          A tuple of the indices of the start of every instance of subtuple,
 *          <> if none.
 * @author "Richard Arriaga"
 * @category "Tuples" "Queries"
 * @see {@link "http://en.wikipedia.org/wiki/Knuth-Morris-Pratt_algorithm" 
 * "Knuth-Moris-Pratt algorithm"}
 */
Public stable abstract method "all indices of_in_" is 
	[tuple,tuple]→<natural number…|>;

Method "all indices of_in_" is
[
	subtuple : <any…|0>,
	aTuple : <any…|0>
 |
	<>
] : <>'s type;

Method "all indices of_in_" is
[
	subtuple : any+,
	aTuple : <any…|0>
 |
	<>
] : <>'s type;

Method "all indices of_in_" is
[
	subtuple : <any…|0>,
	aTuple : any+
 |
	<>
] : <>'s type;

/*
 * Obtain the location of the start of every instance of subtuple occuring in a 
 * tuple (a substring of a string).  The 
 * {@link "http://en.wikipedia.org/wiki/Knuth-Morris-Pratt_algorithm" 
 * "Knuth-Moris-Pratt algorithm"} is used for this implementation. 
 */
Method "all indices of_in_" is
[
	subtuple : any+,
	aTuple : any+
 |
	if |subtuple| > |aTuple| then [<>]
	else if |subtuple| = 1 then
	[
		/* if the subtuple has only one element, no benefit from KMP, simply
		 * walk through aTuple searching for first element that matches the 
		 * single element of aSubtuple*/
		all indices of aTuple where
		[
			a : any
		 |
			a = subtuple[1]
		]
	]
	else
	[
		index : natural number := 1;
		occurrences : <natural number…|> := <>;
		w : whole number := 0;
		While index + |subtuple| ≤ |aTuple| do
		[
			w := first index of subtuple in aTuple[index..];
			if w > 0 then 
			[
				occurrences ++= <cast w + index - 1 into 
					[n : natural number | n]>;
				index := index + w + |subtuple| - 1;
			]
			else [index := index + |aTuple|;];
		];
		occurrences
	]
] : <natural number…|>;

/**
 * Locate of the first instance of a nonempty subtuple occuring in a nonempty 
 * tuple and replace it with the supplied replacement tuple.
 *
 * @method "replace the first occurrence of_in_with_"
 * @category "Tuples"
 * @param "subtuple" "any+"
 *        The subtuple to locate.
 * @param "aTuple" "tuple" 
 *        The tuple to be searched.
 * @param "replacementTuple" "tuple"
 *        The tuple to be swapped with the search tuple.
 * @returns "tuple"
 *        The new tuple with the first occurrence of the subtuple replaced with
 *        the replacement tuple.
 * @author "Richard Arriaga"
 * @category "Tuples" "Transformers"
 */
Public stable abstract method "replace the first occurrence of_in_with_" is 
	[any+,tuple,tuple]→tuple;

Method "replace the first occurrence of_in_with_" is
[
	subtuple : any+,
	aTuple : <any…|0>,
	replacementTuple : tuple
|
	<>
] : <>'s type;

Method "replace the first occurrence of_in_with_" is
[
	subtuple : any+,
	aTuple : any+,
	replacementTuple : tuple
|
	if |subtuple| > |aTuple| then [aTuple]
	else if subtuple = aTuple then [replacementTuple]
	else
	[
		subtupleStart : whole number := first index of subtuple in aTuple;
		if subtupleStart = 0 then [aTuple]
		else
		[
			index : natural number := cast subtupleStart - 1 into 
				[n : natural number | n];
			nextIndex : natural number := subtupleStart + |subtuple|; 
			aTuple[..index] ++ replacementTuple ++ aTuple[nextIndex..]
		]
	]
] : tuple;

Semantic restriction "replace the first occurrence of_in_with_" is
[
	subtuple : any+'s type,
	aTuple : tuple's type,
	replacementTuple : tuple's type
|
	defaultType ::= ∪ aTuple[1..∞] ∪ ∪replacementTuple[1..∞];
	if ⎡aTuple⎤ = 0 then [<>'s type]
	else if ⎡aTuple⎤ < ⎣subtuple⎦ then [aTuple]
	else if ⎡replacementTuple⎤ < ⎣subtuple⎦ then
	[
		lower ::= cast 0 max (⎡aTuple⎤ + ⎡replacementTuple⎤ - ⎣subtuple⎦)
			into [w : [0..∞) | w];
		upper ::= ⎡aTuple⎤;
		<defaultType…|lower..upper>
	]
	else if ⎡subtuple⎤ < ⎣replacementTuple⎦ then
	[
		lower ::= cast ⎡aTuple⎤ into [w : [0..∞) | w];
		upper ::= cast 0 max (⎡aTuple⎤ + ⎣replacementTuple⎦ - ⎡subtuple⎤)
			into [w : [0..∞) | w];
		<defaultType…|lower..upper>
	]
	else if ⎡subtuple⎤ = ⎣replacementTuple⎦ ∧
		⎡replacementTuple⎤ = ⎣subtuple⎦ then
	[
		lower ::=  cast ⎡aTuple⎤ into [w : [0..∞) | w];
		upper ::= cast 0 max (⎡aTuple⎤ + ⎣replacementTuple⎦ - ⎡subtuple⎤)
			into [w : [0..∞) | w];
		<defaultType…|lower..upper>
	]
	else
	[
		lower ::= min <⎣aTuple⎦,⎣replacementTuple⎦>;
		upper ::= if ⎡replacementTuple⎤ ≤ ⎡subtuple⎤ then [⎡aTuple⎤]
			else [∞];
		<defaultType…|lower..upper>
	]
];

/**
 * Replace every instance of a nonempty subtuple occuring in a nonempty tuple 
 * and with the supplied replacement tuple.
 *
 * @method "replace all occurrences of_in_with_"
 * @category "Tuples"
 * @param "subtuple" "any+"
 *        The subtuple to be replaced.
 * @param "aTuple" "tuple" 
 *        The tuple to be searched.
 * @param "replacementTuple" "tuple"
 *        The replacement tuple.
 * @returns "tuple"
 *        The new tuple with the all occurrences of the subtuple replaced with
 *        the replacement tuple.
 * @author "Richard Arriaga"
 * @category "Tuples" "Transformers"
 */
Public stable abstract method "replace all occurrences of_in_with_" is 
	[any+,tuple,tuple]→tuple;

Method "replace all occurrences of_in_with_" is
[
	subtuple : any+,
	aTuple : <any…|0>,
	replacementTuple : tuple
|
	<>
] : <>'s type;

Method "replace all occurrences of_in_with_" is
[
	subtuple : any+,
	aTuple : any+,
	replacementTuple : tuple
|
	if |subtuple| > |aTuple| then [aTuple]
	else if subtuple = aTuple then [replacementTuple]
	else if |subtuple| = 1 then
	[
		newTuple : tuple := <>;
		index : natural number := 1;
		While index ≤ |aTuple| do
		[
			If <aTuple[index]> = subtuple then
			[
				newTuple ++= replacementTuple;
			]
			else
			[
				newTuple ++= <aTuple[index]>;
			];
			index++;
		];
		newTuple
	]
	else
	[
		index : natural number := 1;
		newTuple : tuple := <>;
		w : whole number := 0;
		While index + |subtuple| ≤ |aTuple| do
		[
			w := first index of subtuple in aTuple[index..];
			If w > 0 then 
			[
				lastPreSubtupleIndex : natural number := cast w - 2 + index into 
					[n : natural number | n];
				newTuple ++= aTuple[index..lastPreSubtupleIndex] ++
					replacementTuple;
				index := index + w + |subtuple|-1;
			]
			else 
			[
				newTuple ++= aTuple[index..];
				index := index + |aTuple|-1;
			];
		];
		newTuple
	]
] : tuple;

Semantic restriction "replace all occurrences of_in_with_" is
[
	subtuple : any+'s type,
	aTuple : tuple's type,
	replacementTuple : tuple's type
|
	defaultType ::= ∪ aTuple[1..∞] ∪ ∪replacementTuple[1..∞];
	if ⎡aTuple⎤ = 0 then [<>'s type]
	else if ⎡aTuple⎤ < ⎣subtuple⎦ then [aTuple]
	else
	[
		lower ::= min <⎣aTuple⎦,⎣replacementTuple⎦>;
		upper ::= if ⎡replacementTuple⎤ ≤ ⎡subtuple⎤ then [⎡aTuple⎤]
			else [∞];
		<defaultType…|lower..upper>
	]
];

/**
 * Derive a {@type "tuple"} from {@param "aTuple"} such that the end is padded
 * to a multiple of {@param "base"} with occurrences of {@param "pad"}.
 *
 * @method "_padded with_to a multiple of_"
 * @param "aTuple" "tuple"
 * @param "pad" "any"
 * @param "base" "whole number"
 * @returns "aTuple"
 * @category "Tuples"
 */
Method "_padded with_to a multiple of_" is
[
	aTuple : tuple,
	pad : any,
	base : whole number
|
	If base ≤ 1 then [aTuple]
	else
	[
		diff ::= 0 max (base - |aTuple| mod base);
		padSize ::= if diff = base then [0] else [diff];
		aTuple ++ padSize of pad
	]
] : tuple;

Semantic restriction "_padded with_to a multiple of_" is
[
	tupleType : tuple's type,
	padType : any's type,
	baseType : whole number's type
|
	unionType ::= ∪ tupleType[1..|tupleType's leading types| + 1] ∪ padType;
	min ::= ⎣tupleType⎦;
	max ::= 0 max (⎡tupleType⎤ + ⎡baseType⎤ - 1);
	<unionType…|min..max>
];
