/*
 * Math.avail
 * Copyright © 1993-2019, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Math"
Versions
	"1.4.0"
Extends
	"Early Math"
Uses
	"Bootstrap",
	"Definers",
	"Early Assertions",
	"Early Conditionals",
	"Early Control Structures",
	"Early Functions",
	"Early Logic",
	"Early Sets",
	"Early Tuples",
	"Enumeration Support",
	"Error Codes",
	"Literals",
	"Phrases",
	"Types",
	"Variables"
Names
	"greatest common denominator of_and_",
	"least common multiple of_and_",
	"negative integer",
	"nonpositive integer",
	"_is odd",
	"_is even",
	"-_",
	"«_‡«=|≤|<»!»",
	"«_‡«=|≥|>»!»",
	"comparison chain semantic restriction function"
Body

Method "[_.._]" is stable at
	[extended integer, extended integer]→extended integer meta;
Method "[_.._)" is stable at
	[extended integer, extended integer]→extended integer meta;
Method "(_.._]" is stable at
	[extended integer, extended integer]→extended integer meta;
Method "(_.._)" is stable at
	[extended integer, extended integer]→extended integer meta;

Stable forward method "_mod_" is [number, number]→number;
Public stable forward method "-_" is [number]→number;

/* Establish grammatical rules. */
[
	ext      ::= {"«_‡max»", "«_‡min»"};
	sum      ::= {"_+_", "_-_"};
	product  ::= {"_×_", "_÷_", "_mod_"};
	negation ::= {"-_"};
	abs      ::= {"`|_`|"};
	power    ::= {"_^_"};
	bounds   ::= {"⌊_⌋", "⌈_⌉"};

	sumAndProduct ::= sum ∪ product;

	/**
	 * Establish the standard grammatical rules for arithmetic.
	 *
	 * @method "_×_"
	 * @forbids "1" "_+_" "_-_"
	 * @forbids "2" "_×_" "_÷_" "_mod_" "_+_" "_-_"
	 */
	/**
	 * Establish the standard grammatical rules for arithmetic.
	 *
	 * @method "_÷_"
	 * @forbids "1" "_+_" "_-_"
	 * @forbids "2" "_×_" "_÷_" "_mod_" "_+_" "_-_"
	 */
	/**
	 * Establish the standard grammatical rules for arithmetic.
	 *
	 * @method "_mod_"
	 * @forbids "1" "_+_" "_-_"
	 * @forbids "2" "_×_" "_÷_" "_mod_" "_+_" "_-_"
	 */
	Grammatical restriction product is <sum, sumAndProduct>;

	/**
	 * @method "-_"
	 * @forbids "1" "_×_" "_÷_" "_mod_" "_+_" "_-_" "-_" "«_‡max»" "«_‡min»" "∞"
	 */
	Grammatical restriction negation is
		<sumAndProduct ∪ negation ∪ ext ∪ {"∞"}>;

	/**
	 * Establish the precedence of exponentiation.
	 *
	 * @method "_^_"
	 * @forbids "1" "_×_" "_÷_" "_mod_" "_+_" "_-_" "-_" "_^_"
	 * @forbids "2" "_×_" "_÷_" "_mod_" "_+_" "_-_"
	 */
	Grammatical restriction power is
		<sum ∪ product ∪ negation ∪ power, sum ∪ product>;

	/**
	 * Forbid nesting of absolute value.
	 *
	 * @method "`|_`|"
	 * @forbids "1" "`|_`|"
	 */
	Grammatical restriction abs is <abs>;

	/**
	 * Forbid nesting of floor and ceiling.
	 * @method "⌈_⌉"
	 * @forbids "1" "⌊_⌋" "⌈_⌉"
	 */
	/**
	 * Forbid nesting of floor and ceiling.
	 * @method "⌈_⌉"
	 * @forbids "1" "⌊_⌋" "⌈_⌉"
	 */
	Grammatical restriction bounds is <bounds>;

	/**
	 * Make left-associative.
	 * @method "_bit∧_"
	 * @forbids "2" "_bit∧_"
	 */
	Grammatical restriction "_bit∧_" is <∅, {"_bit∧_"}>;

	/**
	 * Make left-associative.
	 * @method "_bit∨_"
	 * @forbids "2" "_bit∨_"
	 */
	Grammatical restriction "_bit∨_" is <∅, {"_bit∨_"}>;

	/**
	 * Make left-associative.
	 * @method "_bit⊕_"
	 * @forbids "2" "_bit⊕_"
	 */
	Grammatical restriction "_bit⊕_" is <∅, {"_bit⊕_"}>;
]();

/* These messages describe arithmetic failure (integers only). */
cannotAddMessage ::= "terms not to be unlike infinities";
cannotSubtractMessage ::= "terms not to be like infinities";
cannotMultiplyMessage ::= "terms not be 0 and ±∞";
cannotDivideByZeroMessage ::= "denominator not to be 0";
cannotDivideTwoInfinitiesMessage ::=
	"either numerator or denominator to be finite";

/**
 * Answer the {@type "number" numeric} {@type "type"} produced by the modulus of
 * {@type "number" numeric} {@type "type"}s.
 *
 * @method "_mod_"
 * @param "a" "number's type"
 * @param "b" "number's type"
 * @returns "number's type"
 * @category "Mathematics" "Numbers" "Types"
 */
Method "_mod_" is type promotion function for
[
	a : number,
	b : number
|
	If b = 0 ∧ a ∈ extended integer then
	[
		Reject parse, expected: cannotDivideByZeroMessage
	];
	infinities ::= {∞, -∞};
	If a ∈ infinities ∧ b ∈ infinities then
	[
		Reject parse, expected: cannotDivideTwoInfinitiesMessage
	];
	a mod b
];

Semantic restriction "_mod_" is
	[a : number's type, b : number's type | a mod b];

negativeOne ::= 0 - 1;

/**
 * Negate the argument. Avail's system dialect has no negative numeric literals,
 * but the associated semantic restriction effectively overcomes this limitation
 * (for literal arguments).
 *
 * @method "-_"
 * @param "a" "number"
 *        A number.
 * @returns "number"
 *          The negation of the argument.
 * @category "Mathematics" "Numbers"
 */
Method "-_" is
[
	a : number
|
	a × negativeOne
];

/**
 * Answer the {@type "number" numeric} {@type "type"} produced by negating the
 * given {@type "number" numeric} {@type "type"}.
 *
 * @method "-_"
 * @param "a" "number's type"
 * @returns "number's type"
 */
Method "-_" is
[
	a : number's type
|
	if a ⊆ extended integer then [extended integer]
	else
	[
		if a ⊆ double then [double]
		else [if a ⊆ float then [float] else [number]]
	]
];

/**
 * Compute and answer the strongest possible type of the argument. In
 * particular, an instance type will result in a precise answer that has the
 * same force as a literal.
 *
 * @method "-_"
 * @restricts "number's type"
 */
Semantic restriction "-_" is [a : number's type | -a];

/**
 * Compute and answer the floor of the argument.
 *
 * @method "⌊_⌋"
 * @param "value" "number"
 * @returns "extended integer"
 *          The floor of the argument.
 * @category "Mathematics" "Numbers"
 */
Stable abstract method "⌊_⌋" is [number]→number;

Method "⌊_⌋" is
[
	value : extended integer
|
	value
] : extended integer;

/**
 * Integers and infinities are their own floors.
 *
 * @method "⌊_⌋"
 * @restricts "extended integer's type"
 */
Semantic restriction "⌊_⌋" is
[
	valueType : extended integer's type
|
	valueType
];

/**
 * Compute and answer the ceiling of the argument.
 *
 * @method "⌈_⌉"
 * @param "value" "number"
 * @returns "extended integer"
 *          The ceiling of the argument.
 * @category "Mathematics" "Numbers"
 */
Stable abstract method "⌈_⌉" is [number]→number;

Method "⌈_⌉" is
[
	value : extended integer
|
	value
] : extended integer;

/**
 * Integers and infinities are their own ceilings.
 *
 * @method "⌈_⌉"
 * @restricts "extended integer's type"
 */
Semantic restriction "⌈_⌉" is
[
	valueType : extended integer's type
|
	valueType
];

/**
 * Compute and answer the remainder after dividing {@param "dividend"} by
 * {@param "divisor"}.
 *
 * @method "_mod_"
 * @param "dividend" "number"
 * @param "divisor" "number"
 * @returns "number"
 *          The remainder.
 * @category "Mathematics" "Numbers"
 */
Method "_mod_" is
[
	dividend : number,
	divisor : number
|
	dividend - divisor × ⌊dividend ÷ divisor⌋
] : number;

Method "_mod_" is
[
	dividend : extended integer,
	divisor : ∞'s type
|
	dividend
] : extended integer;

/**
 * Is the argument odd?
 *
 * @method "_is odd"
 * @param "a" "integer"
 * @returns "boolean"
 *          {@method "true"} if the argument is odd, {@method "false"}
 *          otherwise.
 * @category "Mathematics" "Integers"
 */
Public stable method "_is odd" is
[
	a : integer
|
	a bit∧ 1 = 1
] : boolean;

/**
 * Is the argument even?
 *
 * @method "_is even"
 * @param "a" "integer"
 * @returns "boolean"
 *          {@method "true"} if the argument is even, {@method "false"}
 *          otherwise.
 * @category "Mathematics" "Integers"
 */
Public stable method "_is even" is
[
	a : integer
|
	a bit∧ 1 = 0
];

/**
* Compute the fused modular exponentiation of the base to the exponent, modulo
* the provided modulus. This method executes much faster than its unfused
* variant by leveraging iterated squaring and moduli.
*
* @method "_^_mod_"
* @param "base" "whole number"
* @param "exponent" "whole number"
* @param "modulus" "natural number"
* @returns "whole number"
*
* @category "Mathematics" "Integers" "Types"
*/
Public stable method "_^_mod_" is
[
	base : whole number,
	exponent : whole number,
	modulus : natural number
|
	moddedBase : whole number := base mod modulus;
	exponentRemaining : integer := exponent;
	result : whole number := 1;
	Until exponentRemaining = 0 do
	[
		If exponentRemaining bit∧ 1 = 1 then
		[
			result := (result × moddedBase) mod modulus;
		];
		exponentRemaining := (exponentRemaining >> 1);
		moddedBase := (moddedBase × moddedBase) mod modulus;
	];
	result
];

/**
* Restrict modular exponentiation to the combined restrictions upon the unfused
* exponentiation and modulus methods.
*
* @method "_^_mod_"
* @restricts "whole number's type"
* @restricts "whole number's type"
* @restricts "natural number's type"
*/
Semantic restriction "_^_mod_" is
[
	base : whole number's type,
	exponent : whole number's type,
	modulus : natural number's type
|
	(base ^ exponent) mod modulus
];

Grammatical restriction "_^_" is <∅, {"_mod_"}>;
Grammatical restriction "_mod_" is <{"_^_"}, ∅>;

/**
 * Determine if an integer is a "strong probable prime" to a given base (said to
 * be "b-SPRP" for short). Prime numbers will always return true for this test
 * but some composites will as well, known as "strong pseudoprimes".
 *
 * Evaluating whether a number is a strong probable prime is a relatively fast 
 * and useful component of several probabilistic techniques for determining
 * primality. Even checking against a random base in [2, n-2] returns
 * false for ~75% of composites -- this particular process is known as the
 * Miller-Rabin test.
 *
 * @method "_is a strong probable prime to base_"
 * @param "n" "natural number"
 * @param "base" "natural number"
 * @returns "boolean"
 *
 * @category "Mathematics" "Integers" "Types"
*/
Public stable method "_is a strong probable prime to base_" is
[
	n : natural number,
	base : natural number
|
	$body : boolean;
	If n = 1 ∨ n = base ∨ (n ≠ 2 ∧ n is even) then [Exit body with false];
	If base = 1 then [Exit body with true];
	d : whole number := n - 1;
	s : whole number := 0;
	While d is even do
	[
		s := s + 1;
		d := d >> 1;
	];

	test : whole number := base ^ d mod n;
	if test ∈ {1, n-1} then [true]
	else
	[
		first index of 1 to (s-1) where
		[
			i : natural number
		|
			test := test × test mod n;
			test = n - 1
		] > 0
	]
];

smallPrimes ::= {
	2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,
	73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127
};

/**
* Determine if a {@type "[0..130]" small integer} is prime. This method performs
* a lookup against a list of the first 31 primes.
*
* @method "_is prime"
* @param "x" "whole number"
* @returns "boolean"
*          {@method "true"} if {@param "x"} is prime, {@method "false"}
*          otherwise.
* @category "Mathematics" "Integers" "Numbers"
*/
Public method "_is prime" is
[
	x : [0..130]
|
	x∈smallPrimes
];

fj32bases ::= <
	15591, 2018, 166, 7429, 8064, 16045, 10503, 4399, 1949, 1295, 2776, 3620,
	560, 3128, 5212, 2657, 2300, 2021, 4652, 1471, 9336, 4018, 2398, 20462,
	10277, 8028, 2213, 6219, 620, 3763, 4852, 5012, 3185, 1333, 6227, 5298,
	1074, 2391, 5113, 7061, 803, 1269, 3875, 422, 751, 580, 4729, 10239, 746,
	2951, 556, 2206, 3778, 481, 1522, 3476, 481, 2487, 3266, 5633, 488, 3373,
	6441, 3344, 17, 15105, 1490, 4154, 2036, 1882, 1813, 467, 3307, 14042, 6371,
	658, 1005, 903, 737, 1887, 7447, 1888, 2848, 1784, 7559, 3400, 951, 13969,
	4304, 177, 41, 19875, 3110, 13221, 8726, 571, 7043, 6943, 1199, 352, 6435,
	165, 1169, 3315, 978, 233, 3003, 2562, 2994, 10587, 10030, 2377, 1902, 5354,
	4447, 1555, 263, 27027, 2283, 305, 669, 1912, 601, 6186, 429, 1930, 14873,
	1784, 1661, 524, 3577, 236, 2360, 6146, 2850, 55637, 1753, 4178, 8466, 222,
	2579, 2743, 2031, 2226, 2276, 374, 2132, 813, 23788, 1610, 4422, 5159, 1725,
	3597, 3366, 14336, 579, 165, 1375, 10018, 12616, 9816, 1371, 536, 1867,
	10864, 857, 2206, 5788, 434, 8085, 17618, 727, 3639, 1595, 4944, 2129, 2029,
	8195, 8344, 6232, 9183, 8126, 1870, 3296, 7455, 8947, 25017, 541, 19115,
	368, 566, 5674, 411, 522, 1027, 8215, 2050, 6544, 10049, 614, 774, 2333,
	3007, 35201, 4706, 1152, 1785, 1028, 1540, 3743, 493, 4474, 2521, 26845,
	8354, 864, 18915, 5465, 2447, 42, 4511, 1660, 166, 1249, 6259, 2553, 304,
	272, 7286, 73, 6554, 899, 2816, 5197, 13330, 7054, 2818, 3199, 811, 922,
	350, 7514, 4452, 3449, 2663, 4708, 418, 1621, 1171, 3471, 88, 11345, 412,
	1559, 194
>;

/**
* Determine if an integer in {@type "[0..2^32)"} is prime. This method uses the
* "FJ32_256" algorithm by Forǐsek and Jančina (2015).
*
* @method "_is prime"
* @param "x" "whole number"
* @returns "boolean"
*          {@method "true"} if {@param "x"} is prime, {@method "false"}
*          otherwise.
* @category "Mathematics" "Integers" "Numbers"
* @see "http://ceur-ws.org/Vol-1326/020-Forisek.pdf"
*/
Public method "_is prime" is
[
	x : [0..2^32)
|
	/* This algorithm uses the limited range of input to turn the SPRP test into
	* a deterministic test. In other approaches, this is often accomplished with
	* multiple rounds of tests -- for [0, 2^32) this could be accomplished with
	* a mere 3 -- however *this* approach reduces the number of SPRP checks to
	* only 1 by first hashing the number into 256 buckets which each have a
	* single base, defined above, proven to be correct for all hashed values. */
	$body : boolean;
	Assert: x > 130;
	/* Check small divisors and ensure x is coprime with 210 */
	If (x is even) ∨ (x mod 3 = 0) ∨ (x mod 5 = 0) ∨ (x mod 7 = 0) then
	[
		Exit body with false
	];
	hash : whole number := x;
	/* 73244475 = 0x45d9f3b */
	hash := ((hash >> 16) bit⊕ hash) × 73244475;
	hash := ((hash >> 16) bit⊕ hash) × 73244475;
	hash := ((hash >> 16) bit⊕ hash) bit∧ 255;
	x ?→ [122..2^32) is a strong probable prime
		to base fj32bases[hash + 1]
];

/**
* Determine if an integer in {@type "[0..2^64]"} is prime. This method uses a
* deterministic repeated Miller-Rabin test against Sinclair's (2011) 7 bases.
*
* @method "_is prime"
* @param "x" "whole number"
* @returns "boolean"
*          {@method "true"} if {@param "x"} is prime, {@method "false"}
*          otherwise.
* @category "Mathematics" "Integers" "Numbers"
* @see "http://ceur-ws.org/Vol-1326/020-Forisek.pdf"
*/
Public method "_is prime" is
[
	x : [0..2^64]
|
	Assert: x ≥ 2^32;
	k ::= x?→[2^32..2^64];
	/* This set of 7 probabilistic SPRP tests is guaranteed to provide a correct
	 * answer within the range [0..2^64]. The bases are arranged in ascending
	 * order to eliminate pseudoprimes with as few tests as possible. */
	sinclairBases ::= <2, 325, 9375, 28178, 450775, 9780504, 1795265022>;
	each b of sinclairBases satisfies [k is a strong probable prime to base b]
];

/**
 * Compute and answer the integer range type of the sum of the argument types.
 *
 * @method "_+_"
 * @param "a" "extended integer's type"
 * @param "b" "extended integer's type"
 * @returns "extended integer's type"
 *          The narrowest integer range type general enough to hold all possible
 *          sums of the arguments' instances.
 * @category "Mathematics" "Integers" "Types"
 */
Method "_+_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	if {[⌊a⌋..⌈a⌉], [⌊b⌋..⌈b⌉]} = {[-∞..-∞],[∞..∞]} then
	[
		/* The addition will always fail at runtime due to attempting to add
		 * infinities of unlike sign.
		 */
		⊥
	]
	else
	[
		lower ::= ⌊a⌋ + ⌊b⌋ - 1;
		lowerInclusive ::=
			(⌊a⌋ is inclusive ∧ ⌊a⌋ is infinite)
			∨ (⌊b⌋ is inclusive ∧ ⌊b⌋ is infinite);
		upper ::= ⌈a⌉ + ⌈b⌉ + 1;
		upperInclusive ::=
			(⌈a⌉ is inclusive ∧ ⌈a⌉ is infinite)
			∨ (⌈b⌉ is inclusive ∧ ⌈b⌉ is infinite);
		integer range
			from lower (inclusive=lowerInclusive)
			to upper (inclusive=upperInclusive)
	]
];

/**
 * Compute and answer the integer range type of the product of the argument
 * types.
 *
 * @method "_×_"
 * @param "a" "extended integer's type"
 * @param "b" "extended integer's type"
 * @returns "extended integer's type"
 *          The narrowest integer range type general enough to hold all possible
 *          products of the arguments' instances.
 * @category "Mathematics" "Integers" "Types"
 */
Method "_×_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	bounds ::=
	{
		{⌊a⌋, ⌈a⌉},
		{⌊b⌋, ⌈b⌉}
	};
	If bounds = {{0}, {∞}} ∨ bounds = {{0}, {-∞}} then
	[
		Reject parse, expected: cannotMultiplyMessage
	]
	else
	[
		negativeA : extended integer's type := a ∩ [-∞..-1];
		negativeB : extended integer's type := b ∩ [-∞..-1];
		positiveA : extended integer's type := a ∩ [1..∞];
		positiveB : extended integer's type := b ∩ [1..∞];
		result : extended integer's type := ⊥;
		If positiveA ≠ ⊥ then
		[
			If positiveB ≠ ⊥ then
			[
				lower ::= ⌊positiveA⌋ × ⌊positiveB⌋;
				upper ::= ⌈positiveA⌉ × ⌈positiveB⌉;
				isInfinite ::= ∞ ∈ positiveA ∨ ∞ ∈ positiveB;
				range ::= integer range
					from lower (inclusive=true)
					to upper + 1 (inclusive=isInfinite);
				result := eject result ∪ range;
			];
			If negativeB ≠ ⊥ then
			[
				lower ::= ⌈positiveA⌉ × ⌊negativeB⌋;
				isInfinite ::= ∞ ∈ positiveA ∨ -∞ ∈ negativeB;
				upper ::= ⌊positiveA⌋ × ⌈negativeB⌉;
				range ::= integer range
					from lower - 1 (inclusive=isInfinite)
					to upper (inclusive=true);
				result := eject result ∪ range;
			];
		];
		If negativeA ≠ ⊥ then
		[
			If positiveB ≠ ⊥ then
			[
				lower ::= ⌊negativeA⌋ × ⌈positiveB⌉;
				isInfinite ::= -∞ ∈ negativeA ∨ ∞ ∈ positiveB;
				upper ::= ⌈negativeA⌉ × ⌊positiveB⌋;
				range ::= integer range
					from lower - 1 (inclusive=isInfinite)
					to upper (inclusive=true);
				result := eject result ∪ range;
			];
			If negativeB ≠ ⊥ then
			[
				lower ::= ⌈negativeA⌉ × ⌈negativeB⌉;
				upper ::= ⌊negativeA⌋ × ⌊negativeB⌋;
				isInfinite ::= -∞ ∈ negativeA ∨ -∞ ∈ negativeB;
				range ::= integer range
					from lower (inclusive=true)
					to upper + 1 (inclusive=isInfinite);
				result := eject result ∪ range;
			];
		];
		/* Zero is handled specially, to prevent multiplication of 0 and ±∞ by
		 * one of the preceding clauses.
		 */
		If 0's type ⊆ a ∨ 0's type ⊆ b then
		[
			result := eject result ∪ 0's type;
		];
		result
	]
];

/**
 * Compute and answer the negation of the specified integral type.
 *
 * @method "-_"
 * @param "a" "extended integer's type"
 * @returns "extended integer's type"
 *          The negation of the argument, e.g., the negation of {@code "[3..5]"}
 *          is {@code "[-5..-3]"}.
 * @category "Mathematics" "Integers" "Types"
 */
Public method "-_" is
[
	a : extended integer's type
|
	a × (-1)'s type
];

/**
 * Strengthen negation.
 *
 * @method "-_"
 * @restricts "extended integer's type"
 */
Semantic restriction "-_" is
[
	a : extended integer's type
|
	-a
];

/**
 * Strangely, strengthen type-wise negation's own static type.  This allows us
 * to use type-wise negation of an integral type like natural number and get
 * back something that is statically of (-∞..-1]'s type.
 *
 * @method "-_"
 * @restricts "extended integer's type's type"
 */
Semantic restriction "-_" is
[
	a : extended integer's type's type
|
	(-(a's instance))'s type
];

/**
 * Compute and answer the integer range type of the difference of the argument
 * types.
 *
 * @method "_-_"
 * @param "a" "extended integer's type"
 * @param "b" "extended integer's type"
 * @returns "extended integer's type"
 *          The narrowest integer range type general enough to hold all possible
 *          differences of the arguments' instances.
 * @category "Mathematics" "Integers" "Types"
 */
Method "_-_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	a + (- b)
];

/**
 * Compute and answer the integer range type of the sum of the argument types.
 *
 * @method "_+_"
 * @restricts "extended integer's type"
 * @restricts "extended integer's type"
 */
Semantic restriction "_+_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	bounds ::=
	{
		{⌊a⌋, ⌈a⌉},
		{⌊b⌋, ⌈b⌉}
	};
	If bounds = {{-∞}, {∞}} then
	[
		Reject parse, expected: cannotAddMessage
	];
	a + b
];

/**
 * Compute and answer the integer range type of the difference of the argument
 * types.
 *
 * @method "_-_"
 * @restricts "extended integer's type"
 * @restricts "extended integer's type"
 */
Semantic restriction "_-_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	negated ::= - b;
	bounds ::=
	{
		{⌊a⌋, ⌈a⌉},
		{⌊negated⌋, ⌈negated⌉}
	};
	If bounds = {{-∞}, {∞}} then
	[
		Reject parse, expected: cannotSubtractMessage
	];
	a + negated
];

/**
 * Compute and answer the integer range type of the product of the argument
 * types.
 *
 * @method "_×_"
 * @restricts "extended integer's type"
 * @restricts "extended integer's type"
 */
Semantic restriction "_×_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	a × b
];

/**
 * Compute and answer the integer range type of the quotient.
 *
 * @method "_÷_"
 * @param "numeratorRange" "extended integer's type"
 * @param "denominator" "extended integer"
 * @returns "extended integer's type"
 *          The narrowest integer range type general enough to hold all possible
 *          quotients of {@param "numeratorRange"}'s instances and {@param
 *          "denominator"}.
 * @category "Mathematics" "Integers" "Types"
 */
Method "_÷_" is
[
	numeratorRange : extended integer's type,
	denominator : extended integer
|
	/* Produce ⊥ if the numerator range is ⊥ or the denominator is 0. */
	if numeratorRange = ⊥ ∨ denominator = 0 then [⊥]
	else
	[
		/* ±∞ divided by any finite nonzero value is 0. */
		if denominator is infinite then
		[
			0's type
		]
		else
		[
			/* The denominator is finite and nonzero. The numerator may be
			 * either finite or infinite. The following handles all cases.
			 */
			numeratorMin ::= ⌊numeratorRange⌋ ÷ denominator;
			lowerInclusive ::= ⌊numeratorRange⌋ is inclusive;
			numeratorMax ::= ⌈numeratorRange⌉ ÷ denominator;
			upperInclusive ::= ⌈numeratorRange⌉ is inclusive;
			if denominator < 0 then
			[
				integer range
					from numeratorMax (inclusive=upperInclusive)
					to numeratorMin (inclusive=lowerInclusive)
			]
			else
			[
				integer range
					from numeratorMin (inclusive=lowerInclusive)
					to numeratorMax (inclusive=upperInclusive)
			]
		]
	]
];

/**
 * Compute and answer the integer range type of the quotient.
 *
 * @method "_÷_"
 * @param "numeratorRange" "extended integer's type"
 * @param "denominator" "extended integer's type"
 * @returns "extended integer's type"
 *          The narrowest integer range type general enough to hold all possible
 *          quotients of `numeratorRange`'s instances and `denominator`.
 * @category "Mathematics" "Integers" "Types"
 */
Method "_÷_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	denominatorSet ::= {⌊b⌋, ⌈b⌉};
	If denominatorSet = {0} then
	[
		Reject parse, expected: cannotDivideByZeroMessage
	];
	numeratorSet ::= {⌊a⌋, ⌈a⌉};
	infinities ::= {{∞}, {-∞}};
	If numeratorSet ∈ infinities ∧ denominatorSet ∈ infinities then
	[
		Reject parse, expected: cannotDivideTwoInfinitiesMessage
	];
	union : extended integer's type := ⊥;
	negativeDenominators ::= b ∩ [-∞..-1];
	If negativeDenominators ≠ ⊥ then
	[
		union :=
			eject union ∪ (a ÷ negativeDenominators' genuine lower bound);
		union :=
			eject union ∪ (a ÷ negativeDenominators' genuine upper bound);
	];
	positiveDenominators ::= b ∩ [1..∞];
	If positiveDenominators ≠ ⊥ then
	[
		union :=
			eject union ∪ (a ÷ positiveDenominators' genuine lower bound);
		union :=
			eject union ∪ (a ÷ positiveDenominators' genuine upper bound);
	];
	union
];

/**
 * Compute and answer the integer range type of the quotient of the argument
 * types.
 *
 * @method "_÷_"
 * @restricts "extended integer's type"
 * @restricts "extended integer's type"
 */
Semantic restriction "_÷_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	a ÷ b
];

/**
 * Compute and answer the integer range type of the moduli of the argument
 * types.
 *
 * @method "_mod_"
 * @param "a" "extended integer's type"
 * @param "b" "extended integer's type"
 * @returns "extended integer's type"
 *          The narrowest integer range type general enough to hold all possible
 *          moduli of the argument's instances.
 * @category "Mathematics" "Integers" "Types"
 */
Method "_mod_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	denominatorSet ::= {⌊b⌋, ⌈b⌉};
	If denominatorSet = {0} then
	[
		Reject parse, expected: cannotDivideByZeroMessage
	];
	numeratorSet ::= {⌊a⌋, ⌈a⌉};
	infinities ::= {{∞}, {-∞}};
	If numeratorSet ∈ infinities ∧ denominatorSet ∈ infinities then
	[
		Reject parse, expected: cannotDivideTwoInfinitiesMessage
	];
	if ⌊b⌋ = ⌈b⌉
		∧ ⌊a⌋ is finite
		∧ ⌈a⌉ is finite
		∧ ⌊a⌋ ÷ ⌊b⌋ = ⌈a⌉ ÷ ⌊b⌋
	then
	[
		[⌊a⌋ mod ⌊b⌋ .. ⌈a⌉ mod ⌊b⌋]
	]
	else
	[
		[0..⌈b⌉)
	]
];

/**
 * Compute and answer the integer range type of the moduli of the argument
 * types.
 *
 * @method "_mod_"
 * @restricts "extended integer's type"
 * @restricts "extended integer's type"
 */
Semantic restriction "_mod_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	a mod b
];

/**
 * Disambiguate {@method "_→_"} and several conversion operations.
 *
 * @method "_→_"
 * @forbids "1" "double" "extended integer" "float"
 */
Grammatical restriction "_→_" is <∅, {"double", "extended integer", "float"}>;

/**
 * Compute and answer the absolute value of the argument.
 *
 * @method "`|_`|"
 * @param "a" "number"
 * @returns "number"
 *          The absolute value of the argument.
 * @category "Mathematics" "Numbers"
 */
Stable method "`|_`|" is
[
	a : number
|
	if a < 0 then [ -a ] else [ a ]
] : number;

/**
 * Preserve the numeric type of the argument.
 *
 * @method "`|_`|"
 * @restricts "double's type"
 */
Semantic restriction "`|_`|" is
[
	a : double's type
|
	double
];

/**
 * Preserve the numeric type of the argument.
 *
 * @method "`|_`|"
 * @restricts "float's type"
 */
Semantic restriction "`|_`|" is
[
	a : float's type
|
	float
];

/**
 * Strengthen the absolute value operation for integral types.
 *
 * @method "`|_`|"
 * @restricts "extended integer's type"
 */
Semantic restriction "`|_`|" is
[
	a : extended integer's type
|
	([0..∞] ∩ a) ∪ ([0..∞] ∩ -a)
];

/**
 * Deal with enumeration types.
 *
 * @method "`|_`|"
 * @restricts "number's type"
 */
Semantic restriction "`|_`|" is
[
	a : number's type
|
	if |a| = ∞ then
	[
		⊤
	]
	else
	[
		instances ::= a's instances → tuple;
		s : {any|} := ∅;
		From 1 to |instances| do
		[
			i : natural number
		|
			num ::= cast instances[i] into [n : number | n];
			s := s + |num|;
			true
		];
		s's type's element type
	]
];

/**
 * Catch accidental use of absolute value on expressions that are strictly
 * non-negative.
 *
 * @method "`|_`|"
 * @restricts "extended integer's type"
 */
Semantic restriction "`|_`|" is
[
	a : extended integer's type
|
	If a ∩ [0..∞] = a then
	[
		Reject parse, expected:
			"argument of absolute value (\"`|_`|\") to be potentially negative."
	];
	⊤
];

/* This table of functions is used by the inequality operations. */
predicates ::=
<
	[ a : number, b : number | a < b ],
	[ a : number, b : number | a ≤ b ],
	[ a : number, b : number | a = b ],
	[ a : number, b : number | a ≥ b ],
	[ a : number, b : number | a > b ]
>;

/**
 * Compute and answer the boolean value of the sequence of equals, less than or
 * equal, and less than operators.
 *
 * @method "«_‡«=|≤|<»!»"
 * @param "args" "<<number, [1..3]…|1..2>…|3..∞>"
 *        A tuple whose elements are a sequence of 2-tuples followed by an
 *        ending 1-tuple. The first element of these 1,2-tuples is a number.
 *        If present, the second element will be an integer in the range {@code
 *        "[1..3]"} to indicate {@code "="}, {@code "≤"}, or {@code "<"},
 *        respectively, as the comparison to be checked with the next number.
 * @returns "boolean"
 *          {@method "true"} if the entire chain of comparisons is true,
 *          {@method "false"} otherwise.
 * @category "Mathematics" "Relations" "Numbers"
 */
Public stable method "«_‡«=|≤|<»!»" is
[
	args : <<number, [1..3]…|1..2>…|3..∞>
|
	result : boolean := true;
	From 1 to |args| - 1 do
	[
		index : natural number
	|
		arg ::= args[index];
		Assert: |arg| = 2 ("args ≠ <aNumber, comparisonOperatorSubscript>");
		/* Determine which predicate to apply. */
		predicate ::= predicates[4 - arg[2]];
		if predicate(arg[1], args[index + 1][1]) then
		[
			true
		]
		else
		[
			result := false;
			false
		]
	];
	result
];

/**
 * Note that this accepts a very broad type of argument (so it's applicable for
 * non-numeric uses of this selector), but a very specific numbered choice of
 * operator (i.e., only {@code "="}).  It always rejects the parse if it's just
 * a chain of equalities, since there's a separate operator for that which can
 * deal with non-numerics.
 *
 * @method "comparison chain semantic restriction function"
 * @param "args" "<<any, [1..1]…|1..2>…|3..∞>'s type"
 * @returns "[<<any, [1..1]…|1..2>…|3..∞>'s type]→⊤"
 * @category "Semantic Restrictions"
 */
Public method "comparison chain semantic restriction function" is
[
	[
		args : <<any, [1..1]…|1..2>…|3..∞>'s type
	|
		Reject parse, expected:
			"inequality chain to include at least one inequality"
	]
];

/**
 * @method "«_‡«=|≤|<»!»"
 * @restricts "<<any, [1..1]…|1..2>…|3..∞>'s type"
 */
Semantic restriction "«_‡«=|≤|<»!»" is
	comparison chain semantic restriction function;

/**
 * Compute and answer the boolean value of the sequence of equals, greater than
 * or equal, and greater than operators.
 *
 * @method "«_‡«=|≥|>»!»"
 * @param "args" "<<number, [1..3]…|1..2>…|3..∞>"
 *        A tuple whose elements are a sequence of 2-tuples followed by an
 *        ending 1-tuple. The first element of these 1,2-tuples is a number.
 *        If present, the second element will be an integer in the range {@code
 *        "[1..3]"} to indicate {@code "="}, {@code "≥"}, or {@code ">"},
 *        respectively, as the comparison to be checked with the next number.
 * @returns "boolean"
 *          {@method "true"} if the entire chain of comparisons is true,
 *          {@method "false"} otherwise.
 * @category "Mathematics" "Relations" "Numbers"
 */
Public stable method "«_‡«=|≥|>»!»" is
[
	args : <<number, [1..3]…|1..2>…|3..∞>
|
	result : boolean := true;
	From 1 to |args| - 1 do
	[
		index : natural number
	|
		arg ::= args[index];
		Assert: |arg| = 2 ("args ≠ <aNumber, comparisonOperatorSubscript>");
		/* Determine which predicate to apply. */
		predicate ::= predicates[2 + arg[2]];
		if predicate(arg[1], args[index + 1][1]) then
		[
			true
		]
		else
		[
			result := false;
			false
		]
	];
	result
];

/**
 * @method "«_‡«=|≥|>»!»"
 * @restricts "<<any, [1..1]…|1..2>…|3..∞>'s type"
 */
Semantic restriction "«_‡«=|≥|>»!»" is
	comparison chain semantic restriction function;

/**
 * Helper for strengthening the result type of bit shifts.
 *
 * @method "_<<_"
 * @restricts "baseIntegerType" "integer's type"
 * @restricts "shiftFactorType" "integer's type"
 * @returns "integerType" a stronger integer subtype
 */
Stable method "_<<_" is
[
	baseIntegerType : integer's type,
	shiftFactorType : integer's type
|
	low : extended integer := ∞;
	high : extended integer := -∞;
	innerBlock ::= [base : extended integer, shift : extended integer |
		shifted ::= cast base into
			[
				baseInteger : integer
			|
				cast shift into
				[
					shiftInteger : integer
				|
					/* Finite case. */
					baseInteger << shiftInteger
				]
				else
				[
					/* Arbitrarily large shift. */
					if shift = ∞ then
					[
						/* Arbitrarily large left shift. */
						if baseInteger > 0 then [∞]
						else
						[
							if baseInteger < 0 then [-∞] else [0]
						]
					]
					else
					[
						/* Arbitrarily large right shift. */
						if baseInteger ≥ 0 then [0] else [-1]
					]
				]
			]
			else
			[
				/* Arbitrarily large (±) number to shift. */
				cast shift into
				[
					shiftInteger : integer
				|
					/* Arbitrarily large number shifted finitely. */
					base
				]
				else
				[
					/* Both the base and the shift are arbitrarily large. */
					if shift = ∞ then
					[
						base
					]
					else
					[
						if base = ∞ then [0] else [-1]
					]
				]
			];
		low := low min shifted;
		high := high max shifted;
	];
	/* Feed the block some characteristic values to compute the extrema. */
	outerBlock ::= [
		base : extended integer
	|
		If 0 ∈ shiftFactorType then [innerBlock(base, 0);];
		If -1 ∈ shiftFactorType then [innerBlock(base, -1);];
		If 1 ∈ shiftFactorType then [innerBlock(base, 1);];
		innerBlock(base, ⌊shiftFactorType⌋);
		innerBlock(base, ⌈shiftFactorType⌉);
	];

	If 0 ∈ baseIntegerType then [outerBlock(0);];
	If -1 ∈ baseIntegerType then [outerBlock(-1);];
	If 1 ∈ baseIntegerType then [outerBlock(1);];
	outerBlock(⌊baseIntegerType⌋);
	outerBlock(⌈baseIntegerType⌉);
	(low - 1 .. high + 1)
] : integer's type;

/**
 * Strengthen the result type of left-bitshift.
 *
 * @method "_<<_"
 * @restricts "baseIntegerType" "integer's type"
 * @restricts "shiftFactorType" "integer's type"
 */
Semantic restriction "_<<_" is
[
	baseIntegerType : integer's type,
	shiftFactorType : integer's type
|
	baseIntegerType << shiftFactorType
];

/**
 * Strengthen the result type of right-bitshift.
 *
 * @method "_>>_"
 * @restricts "baseIntegerType" "integer's type"
 * @restricts "shiftFactorType" "integer's type"
 */
Semantic restriction "_>>_" is
[
	baseIntegerType : integer's type,
	shiftFactorType : integer's type
|
	baseIntegerType << -shiftFactorType
];

Private forward method "_positive range pairs"
	is [whole number's type] → (whole number's type*);

/**
 * Compute the ranges as for "_range pairs" (below), but with the knowledge that
 * the range is whole number or a subtype.
 *
 * @method "_positive range pairs"
 * @param "range" "whole number's type"
 * @returns "whole number's type*"
 */
Private method "_positive range pairs" is
[
	range : whole number's type
|
	$outer : whole number's type*;
	Exit outer with <> if range = ⊥;
	/* Find the biggest string of rightmost one-bits that can be added to
	 * low without causing any internal carry and without exceeding the
	 * range.
	 */
	lowBits : integer;
	low ::= ⌊range⌋;
	Cast ⌈range⌉ into
	[
		high : [1..∞)
	|
		If low = 0 then
		[
			/* Range is [0..n]. */
			lowBits := high;
			[
				$here : ⊤;
				Exit here if lowBits bit∧ (lowBits + 1) = 0;
				lowBits := lowBits bit∨ (lowBits << -1);
				Restart here
			]();
		]
		else
		[
			lowBits := (-1 - low) bit∧ (low - 1);
		];
	]
	else
	[
		Exit outer with <range> if ⌈range⌉ = 0;
		Assert: ⌈range⌉ = ∞;
		Exit outer with <range> if low = 0;
		/* Find the next higher power of two. */
		boundary : integer := low;
		[
			$here : ⊤;
			Exit here if boundary bit∧ (boundary + 1) = 0;
			boundary := boundary bit∨ (boundary << -1);
			Restart here
		]();
		last ::= Cast [boundary + 1..∞)
			into [t : whole number's type | t];
		Exit outer with
			[low .. boundary] positive range pairs ++ <last>
	];
	strongLowBits : whole number :=
		cast lowBits into [x : whole number | x];
	[
		$loop : whole number's type*;
		subrangeEnd ::= low + strongLowBits;
		If subrangeEnd ∈ range then
		[
			Exit outer with
				<[low .. low + strongLowBits]>
				++ (low + strongLowBits .. ⌈range⌉ + 1) positive range pairs
		];
		Assert: strongLowBits ≠ 0;
		strongLowBits := strongLowBits << -1;
		Restart loop
	] : whole number's type* ()
] : whole number's type*;

/**
 * Decompose an integer type into a tuple of contiguous smaller integer types.
 * When the lower and upper bounds of a subrange are each finite, they must have
 * the form a*2^b and a*2^b + 2^b-1.  The lower bound ensures the bottom b bits
 * are zero, and the upper bound is the same but with the bottom b bits all one.
 * The low and high values may be the same, indicating a range consisting of a
 * single value.
 *
 * In the special case that the upper end of the subrange is {@code "∞"}, the
 * lower end must be a non-negative power of two.  In the case that the lower
 * end is {@code "-∞"}, the upper end must be one less than the negation of a
 * power of two.
 *
 * Produce the minimum number of such ranges.
 *
 * @method "_range pairs"
 * @param "range" "integer's type"
 * @returns "extended integer's type*"
 */
Private method "_range pairs" is
[
	range : integer's type
|
	rangeKind ::= (⌊range⌋ - 1 .. ⌈range⌉ + 1);
	pairs : <integer's type…|> := <>;
	complementOfNegative ::= ((-1)'s type - rangeKind) ∩ [0..∞);
	subranges ::= complementOfNegative positive range pairs;
	From 1 to |subranges| do
	[
		n : natural number
	|
		subcomplement ::= cast (-1)'s type - subranges[n]
			into [x : integer's type | x];
		pairs := <subcomplement> ++ pairs;
		true
	];
	positiveRegion ::= rangeKind ∩ [0..∞);
	pairs ++= positiveRegion positive range pairs;
	pairs
] : extended integer's type*;

/**
 * Strengthen bitwise-and operation.
 *
 * @method "_bit∧_"
 * @restricts "integer's type"
 * @restricts "integer's type"
 */
Semantic restriction "_bit∧_" is
[
	arg1 : integer's type,
	arg2 : integer's type
|
	values : {extended integer|0..∞} := ∅;
	include ::=
	[
		x : extended integer,
		y : extended integer
	|
		$includeLabel : ⊤;
		exit ::= [
			moreValues : {extended integer|0..∞}
		|
			values := eject values ∪ moreValues;
			Exit includeLabel
		];
		If x = ∞ then
		[
			If y ≥ 0 then
			[
				/* For some finite positive y, there exists a large positive
				 * number (implied by x) that has enough low zero bits to
				 * produce zero.  Similarly, there is a large positive number
				 * which is able to preserve all of y's bits.  Finally, when
				 * y is also arbitrarily large it can conspire with x to
				 * produce any whole number.
				 */
				exit({0, y})
			];
			/* Arbitrarily large positive integers can mask a negative
			 * number to ensure arbitrarily large positive integers are
			 * possible.  Other limits will determine how low a (positive)
			 * value can be produced.
			 */
			exit({x})
		];
		If x = -∞ then
		[
			If y ≥ 0 then
			[
				/* An arbitrarily large magnitude negative x can preserve any
				 * positive y.  It could also knock it down to zero.
				 */
				exit({0, y})
			];
			/* An arbitrarily large magnitude negative x can preserve any
			 * bits of y, but it can also zero any finite combination of
			 * bits, keeping it negative.
			 */
			exit({x, y})
		];
		If x ≥ 0 then
		[
			/* A particular finite positive x. */
			If y ∈ {∞, -∞} then
			[
				exit({0, x})
			];
			Cast x into
			[
				xi : integer
			|
				Cast y into
				[
					yi : integer
				|
					exit({xi bit∧ yi})
				]
			]
		];
		/* A particular finite negative x. */
		If y = ∞ then
		[
			exit({y})
		];
		If y = -∞ then
		[
			exit({x, y})
		];
		Cast x into
		[
			xi : integer
		|
			Cast y into
			[
				yi : integer
			|
				exit({xi bit∧ yi})
			]
		]
	] : ⊤;
	arg1Ranges ::= arg1 range pairs;
	arg2Ranges ::= arg2 range pairs;
	From 1 to |arg1Ranges| do
	[
		i1 : natural number
	|
		subrange1 ::= arg1Ranges[i1];
		From 1 to |arg2Ranges| do
		[
			i2 : natural number
		|
			subrange2 ::= arg2Ranges[i2];
			include(⌊subrange1⌋, ⌊subrange2⌋);
			include(⌊subrange1⌋, ⌈subrange2⌉);
			include(⌈subrange1⌉, ⌊subrange2⌋);
			include(⌈subrange1⌉, ⌈subrange2⌉);
			true
		];
		true
	];
	contentType ::= values' type's element type;
	(⌊contentType⌋ - 1 .. ⌈contentType⌉ + 1)
] : integer's type;

/**
 * Strengthen the result type of bounded bitshift, primarily based on the
 * truncation bit count.

 * Given a positive integer B, a shift factor S, and a truncation bit count T,
 * shift B to the left by S bits (treating a negative factor as a right shift),
 * then truncate the result to the bottom T bits by zeroing the rest.
 *
 * @method "_<<_keeping_bits"
 * @restricts "whole number's type"
 * @restricts "integer's type"
 * @restricts "whole number's type"
 */
Semantic restriction "_<<_keeping_bits" is
[
	baseInteger : whole number's type,
	shiftFactor : integer's type,
	truncationBits : whole number's type
|
	high : [0..∞] := ∞;
	If ⌈baseInteger⌉ ≠ ∞ ∧ ⌈shiftFactor⌉ ≠ ∞ then
	[
		finiteBaseMax : whole number;
		finiteBaseMax ?= ⌈baseInteger⌉;
		finiteShiftMax : integer;
		finiteShiftMax ?= ⌈shiftFactor⌉;
		high := finiteBaseMax << finiteShiftMax;
	];
	finiteBaseMin : whole number;
	finiteBaseMin ?= ⌊baseInteger⌋;
	finiteShiftMin : integer;
	finiteShiftMin ?= ⌊shiftFactor⌋;
	low : whole number := finiteBaseMin << finiteShiftMin;
	If ⌈truncationBits⌉ ≠ ∞ then
	[
		finiteTruncationMax : whole number;
		finiteTruncationMax ?= ⌈truncationBits⌉;
		high := high min ((1 << finiteTruncationMax) - 1);
	];
	finiteTruncationMin : whole number;
	finiteTruncationMin ?= ⌊truncationBits⌋;
	mask : whole number := (1 << finiteTruncationMin) - 1;
	low := low bit∧ mask;
	[low..high+1)
] : whole number's type;

/**
 * {@code "negative integer"} includes every finite {@method "integer"} strictly
 * less than {@code "0"}.
 *
 * @type "negative integer"
 * @supertype "(-∞..-1]"
 * @category "Mathematics" "Integers" "Types" "Constants"
 */
Public stable method "negative integer" is [(-∞..-1]];

/**
 * {@code "nonpositive integer"} includes every finite {@method "integer"}
 * strictly less than {@code "1"}.
 *
 * @type "nonpositive integer"
 * @category "Math"
 * @supertype "(-∞..0]"
 * @category "Mathematics" "Integers" "Types" "Constants"
 */
Public stable method "nonpositive integer" is [(-∞..0]];

/**
 * Find the greatest common denominator of two numbers using Euclid's theorem.
 *
 * @method "greatest common denominator of_and_"
 * @category "Mathematics" "Integers"
 * @param "input1" "integer"
 *        The first number of the pair to check.
 * @param "input2" "integer"
 *        The second number of the pair to check.
 * @returns "integer"
 *          The greatest common denominator of the numbers.
 */

Stable forward method "greatest common denominator of_and_" is
	[natural number, natural number] → natural number;

Method "greatest common denominator of_and_" is
[
	input1 : natural number,
	input2 : natural number
|
	greater : natural number := input1 max input2;
	lesser : natural number := input1 min input2;

	quotient ::= greater ÷ lesser;
	remainder ::= greater mod lesser;

	if remainder = 0 then [lesser]
	else
	[
		greatest common denominator of lesser and
			cast remainder into [n : natural number | n]
	]
] : natural number;

/**
 * Find the least common multiple of two numbers using Euclid's theorem.
 *
 * @category "Mathematics" "Integers"
 * @method "least common multiple of_and_"
 * @param "input1" "integer" the first number of the pair to check.
 * @param "input2" "integer" the second number of the pair to check.
 * @returns "integer" least common multiple of the numbers.
 */
Public stable method "least common multiple of_and_" is
[
	input1 : natural number,
	input2 : natural number
|
	cast input1 × input2 ÷ greatest common denominator of input1 and input2
		into [n : natural number | n]
] : natural number;

/**
* Respecting the sign of the result when enough type information is available
* to prove the signs of the arguments.
*
* @method "_bit⊕_"
* @restricts "integer's type"
* @restricts "integer's type"
*/
Semantic restriction "_bit⊕_" is
[
	a : integer's type,
	b : integer's type
|
	if (⌊a⌋≥0 ∧ ⌊b⌋≥0) ∨ (⌈a⌉<0 ∧ ⌈b⌉<0) then [whole number]
	else
	[
		if (⌈a⌉<0 ∧ ⌊b⌋≥0) ∨ (⌊a⌋≥0 ∧ ⌈b⌉<0) then [negative integer] else [⊤]
	]
];

/*
 * Strengthen some stable primitive methods.
 */

Method "_^_" is stable at [number, number]→number;
Method "_→float" is stable at [number]→float;
Method "_→double" is stable at [number]→double;
Method "_<_" is stable at [number, number]→boolean;
Method "_≤_" is stable at [number, number]→boolean;
Method "«_‡max»" is stable at [<number…|3..>]→number;
Method "«_‡min»" is stable at [<number…|3..>]→number;
Method "_+_" is stable at [number, number]→number;
Method "_-_" is stable at [number, number]→number;
Method "_×_" is stable at [number, number]→number;
Method "_÷_" is stable at [number, number]→number;
Method "_<<_" is stable at [integer, integer]→integer;
Method "_<<_keeping_bits"
	is stable at [whole number, integer, whole number]→whole number;
Method "_>>_" is stable at [integer, integer]→integer;
Method "_bit∧_" is stable at [integer, integer]→integer;
Method "_bit∨_" is stable at [integer, integer]→integer;
Method "_bit⊕_" is stable at [integer, integer]→integer;
