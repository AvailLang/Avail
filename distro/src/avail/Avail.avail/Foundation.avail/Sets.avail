/*
 * Sets.avail
 * Copyright © 1993-2020, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Sets"
Versions
	"1.4.0"
Extends
	"Collections",
	"Early Sets"
Uses
	"Bootstrap",
	"Control Structures",
	"Definers",
	"Early Conditionals",
	"Early Functions",
	"Early Maps",
	"Early Tuples",
	"Enumeration Support",
	"Literals",
	"Logic",
	"Macro Support",
	"Math",
	"Phrases",
	"Types",
	"Variables"
Names
	"_Δ_",
	"_∋_",
	"_⊂_",
	"_⊇_",
	"_⊉_",
	"_⊃_",
	"_∌_",
	"_⊄_",
	"_⊅_",
	"any_",
	"any_else_",
	"set body function(_,_)",
	"a set iteration prefix function"
Body

/**
 * Print set types neatly.
 *
 * @method "“_”"
 * @param "t" "set meta"
 * @returns "string"
 *          A nice-looking string representing the set type.
 */
Method "“_”" is
[
	t : set meta
|
	s : nonempty string := "{" ++ “t's element type” ++ "|";
	lower ::= ⌊t⌋;
	upper ::= ⌈t⌉;
	s := eject s ++ “||t||” (cardinality restriction);
	s := eject s ++ "}";
	s
] : string;

Method "_+_" is stable at [set, any]→set;

/**
 * @method "_+_"
 * @restricts "set meta"
 * @restricts "any meta"
 */
Semantic restriction "_+_" is
[
	setType : set meta,
	valueType : any meta
|
	elementType ::= setType's element type;
	/* If the element type is an instance type and equal to `valueType`,
	 * then the value is already present; the set type does not change.
	 */
	if |elementType| = 1 ∧ elementType ∈ nontype ∧ elementType = valueType then
	[
		setType
	]
	else
	[
		union ::= elementType ∪ valueType;
		sizes ::= ||setType||;
		/* If the type intersection of the element type and the new type is
		 * ⊥, then the new element cannot be present in the set. Adjust the
		 * cardinality accordingly.
		 */
		newSizes ::=
			if elementType ∩ valueType = ⊥ then
			[
				cast sizes + 1's type into [ t : whole number's type | t ]
			]
			/* Otherwise the element *may* be present, but there's no way to
			 * know for sure. Adjust the cardinality accordingly.
			 */
			else
			[
				cast sizes + [0..1] into [ t : whole number's type | t ]
			];
		{union | newSizes}
	]
];

/**
 * @method "_-_"
 * @restricts "set meta"
 * @restricts "any meta"
 */
Semantic restriction "_-_" is
[
	setType : set meta,
	value : any meta
|
	elementType ::= setType's element type;
	if elementType ∩ value = ⊥ then
	[
		setType
	]
	else if |value| = 1 ∧ |elementType| ≠ ∞ then
	[
		instances ::= elementType's instances \ value's instances;
		newElementType ::= enumeration of instances;
		{newElementType | 0 max (⌊setType⌋-1) .. ⌈setType⌉}
	]
	else
	[
		{elementType | 0 max (⌊setType⌋-1) .. ⌈setType⌉}
	]
];

Method "_→tuple" is stable at [set]→tuple;

/**
 * @method "_→tuple"
 * @restricts "set meta"
 */
Semantic restriction "_→tuple" is
[
	setType : set meta
|
	/* Note that we can't exploit instance types here, because conversion of a
	 * set to a tuple is an unstable operation.
	 */
	<<>, setType's element type… | ||setType||>
];

/**
 * Is the specified set empty?
 *
 * @method "_is empty"
 * @param "aSet" "set"
 * @returns "boolean"
 *          {@method "true"} if the argument is empty, {@method "false"}
 *          otherwise.
 * @category "Sets" "Queries"
 */
Stable method "_is empty" is
[
	aSet : set
|
	|aSet| = 0
];

/**
 * Iteratively apply {@param "action"} to each element of {@param "aSet"}, but
 * in no particular order.
 *
 * @method "For each of⁇_do_"
 * @param "aSet" "set"
 * @param "action" "[⊥]→⊤"
 *        A function that accepts the elements of the set.
 * @returns "⊤"
 * @category "Collections" "Sets" "Control Structures"
 */
Method "For each of⁇_do_" is
[
	aSet : set,
	action : [⊥]→⊤
|
	[
		index : natural number,
		end : whole number,
		aTuple : tuple
	|
		$loop : ⊤;
		Exit loop if index > end;
		action(aTuple[index]);
		Restart loop with <index + 1, end, aTuple>
	](1, |aSet|, aSet→tuple);
] : ⊤;

/**
 * Helper method for semantic restrictions: If {@param "action"} does not accept
 * the element types of {@param "setType"}, then reject the current parse.
 *
 * @method "Require:_accepts_"
 * @param "action" "function meta"
 *        A function type whose first argument must correspond to the element
 *        type of {@param "setType"}.
 * @param "setType" "set meta"
 * @returns "⊤"
 * @category "Assertions" "Sets" "Types"
 */
Method "Require:_accepts_" is
[
	action : function meta,
	setType : set meta
|
	If ⌊action's parameters' type⌋ < 1 then
	[
		Immediately reject parse, expected:
			"repeatedly applied function to accept at least one argument"
	];
	If action[1] ≠ ⊥ ∧ ¬setType's element type ⊆ action[1] then
	[
		Immediately reject parse, expected:
			"repeatedly applied function to accept all elements of the set ∈ "
			++ “setType”
			++ " (but it only accepts "
			++ “action[1]”
			++ ")"
	];
] : ⊤;

/**
 * Ensure that the function will accept all elements of the set. If the set is
 * certainly nonempty and the function certainly does not complete if applied,
 * then answer ⊥.
 *
 * @method "For each of⁇_do_"
 * @restricts "set meta"
 * @restricts "[⊥]→⊤'s type"
 */
Semantic restriction "For each of⁇_do_" is
[
	setType : set meta,
	action : [⊥]→⊤'s type
|
	Require: action accepts setType;
	if ⌊setType⌋ > 0 ∧ action's return type = ⊥ then [⊥] else [⊤]
];

/**
 * Answer a function that computes a prefix function.
 *
 * @method "a set iteration prefix function"
 * @returns "[literal phrase ⇒ token, expression phrase ⇒ set]→⊤"
 *          The requested function.
 */
Public method "a set iteration prefix function" is
[
	[
		elementPhrase : literal phrase ⇒ token,
		aSet : expression phrase ⇒ set
	|
		Declare loop variable elementPhrase as
		[
			aSetType ::= aSet's semantic type;
			aSetType's element type
		];
	]
]: [literal phrase ⇒ token, expression phrase ⇒ set]→⊤;

/**
 * Answer a function that computes a body function.
 *
 * @method "set body function(_,_)"
 * @param "anAtom" "atom" the atom that represents the function that the
 * 		macro builds
 * @param "baseReturnType" "type" the base return type of the method
 * @returns "[literal phrase ⇒ token, expression phrase ⇒ set,
 *   block phrase ⇒ []→ boolean]→send phrase ⇒ ⊤"
 *          The requested function.
 */
Public method "set body function(_,_)" is
[
	anAtom : atom,
	baseReturnType : type
|
	[
		elementPhrase : literal phrase ⇒ token,
		aSet : expression phrase ⇒ set,
		action : block phrase ⇒ []→ ⊤
	|
		name ::= elementPhrase's token's lexeme;
		aSetType ::= aSet's semantic type;
		elementType ::= aSetType's element type;
		blockType ::=
			[elementType]→(action's semantic type's return type);

		returnType ::= strengthen baseReturnType for call of anAtom
			using <aSetType, blockType>;

		statements ::= action's statements;
		blockReturnType ::= cast statements
			into [t : phrase+ | t[|t|]'s semantic type]
			else [⊤];
		declaration ::= scope map[name];
		Undeclare name;
		bootstrap restricted send anAtom with
			«<
				aSet,
				«[
				  	<cast declaration into [d : argument phrase | d]>
				 |
					statements
				 ] : blockReturnType»
			>» : returnType
	] : send phrase ⇒ ⊤
] : [literal phrase ⇒ token, expression phrase ⇒ set,
     block phrase ⇒ []→ ⊤]→send phrase ⇒ ⊤;

/**
 * Set iterating-loop that invokes {@param "action"} once for every
 * {@param "elementPhrase"} in {@param "aSet"}
 *
 * @macro "For each…in|of_§do_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aSet"}.
 * @param "aSet" "expression phrase ⇒ set"
 *        An {@type "expression phrase"} that yields the set to iterate over
 * @param "action" "block phrase ⇒ []→⊤"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        loop.
 * @returns "send phrase ⇒ ⊤"
 * @category "Control Structures" "Loops" "Collections" "Sets"
 */
Macro "For each…in|of_§do_" is a set iteration prefix function,
	set body function($"For each of⁇_do_", ⊤);

/**
 * Iteratively apply {@param "transformer"} to each element of {@param "aSet"},
 * collecting the results into a new tuple. The set is traversed in no
 * particular order. Answer the resultant set.
 *
 * @method "map_through_"
 * @param "aSet" "set"
 * @param "transformer" "[⊥]→any"
 *        A function that accepts the elements of the set.
 * @returns "set"
 *          A set of results of applications of {@param "transformer"} to the
 *          elements of {@param "aSet"}.
 * @category "Collections" "Sets" "Control Structures"
 */
Method "map_through_" is
[
	aSet : set,
	transformer : [⊥]→any
|
	aTuple ::= aSet→tuple;
	[
		index : natural number,
		end : whole number,
		outputSet : set
	|
		$loop : set;
		Exit loop with outputSet if index > end;
		transformed ::= transformer(aTuple[index]);
		Restart loop with <index + 1, end, outputSet + transformed>
	](1, |aSet|, ∅)
] : set;

/**
 * Ensure that the function will accept all elements of the set. If the set is
 * certainly nonempty, then the function cannot answer ⊥.
 *
 * @method "map_through_"
 * @restricts "set meta"
 * @restricts "[⊥]→any's type"
 */
Semantic restriction "map_through_" is
[
	setType : set meta,
	transformer : [⊥]→any's type
|
	Require: transformer accepts setType;
	lower ::=
		if ⌊setType⌋ > 0 then
		[
			If transformer's return type = ⊥ then
			[
				Immediately reject parse, expected:
					"repeatedly applied function to have a return type other than\
					\| ⊥"
			];
			1
		]
		else [0];
	{transformer's return type | [lower..⌈setType⌉ + 1)}
];

/**
 * Iteratively apply {@param "transformer"} to each element of {@param "aSet"},
 * collecting the results into a new tuple. The set is traversed in no
 * particular order. Answer the resultant set.
 *
 * @macro "map each…in|of_§through_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aSet"}.
 * @param "aSet" "expression phrase ⇒ set"
 *        An {@type "expression phrase"} that yields the set to iterate over
 * @param "action" "block phrase ⇒ []→⊤"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        loop.
 * @returns "send phrase ⇒ ⊤"
 * @category "Control Structures" "Loops" "Collections" "Sets"
 */
Macro "map each…in|of_§through_" is a set iteration prefix function,
	set body function($"map_through_",set);

/**
 * Iteratively apply {@param "predicate"} to each element of {@param "aSet"}, in
 * no particular order, collecting those elements for which {@param "predicate"}
 * answers {@param "true"} into a new set. Answer the new set.
 *
 * @method "filter_by_"
 * @param "aSet" "set"
 * @param "predicate" "[⊥]→boolean"
 *        A function that accepts the elements of the set and answers {@param
 *        "true"} iff they should be accumulated into the output set.
 * @returns "set"
 *          A set containing exactly those elements of {@param "aSet"} for which
 *          {@param "predicate"} answered {@method "true"}.
 * @category "Collections" "Sets" "Control Structures"
 */
Method "filter_by_" is
[
	aSet : set,
	predicate : [⊥]→boolean
|
	aTuple ::= aSet→tuple;
	index : natural number := 1;
	end ::= |aTuple|;
	result : set := ∅;
	[
		$loop : ⊤;
		Exit loop if end < index;
		element ::= aTuple[index];
		If predicate(element) then
		[
			result := eject result + element;
		];
		index++;
		Restart loop
	]();
	result
] : set;

/**
 * Ensure that the function will accept all elements of the set.
 *
 * @method "filter_by_"
 * @restricts "set meta"
 * @restricts "[⊥]→boolean's type"
 */
Semantic restriction "filter_by_" is
[
	setType : set meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts setType;
	if predicate's return type = true's type then [setType]
	else if predicate's return type = false's type then [∅'s type]
	else [{setType's element type|[0..⌈setType⌉ + 1)}]
];

/**
 * Iteratively apply {@param "predicate"} to each consecutive element of
 * {@param "aSet"}, collecting those elements for which {@param "predicate"}
 * answers {@method "true"} into a new set. Answer
 * the new set.
 *
 * @macro "select each…from_§where_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aSet"}.
 * @param "aSet" "expression phrase ⇒ any"
 *        An {@type "expression phrase"} that yields the set to iterate over
 * @param "action" "block phrase ⇒ []→⊤"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        loop.
 * @returns "send phrase ⇒ ⊤"
 * @category "Control Structures" "Loops" "Collections" "Sets"
 */
Macro "select each…from_§where_" is a set iteration prefix function,
	set body function($"filter_by_",set);

/**
 * Iteratively apply {@param "predicate"} to each consecutive element of
 * {@param "aSet"}, rejecting those elements for which {@param "predicate"}
 * answers {@method "true"} into a new set (and preserving ordering). Answer
 * the new set.
 *
 * @macro "reject each…from_§where_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aSet"}.
 * @param "aSet" "expression phrase ⇒ any"
 *        An {@type "expression phrase"} that yields the set to iterate over
 * @param "predicate" "block phrase ⇒ []→⊤"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        loop.
 * @returns "send phrase ⇒ ⊤"
 * @category "Control Structures" "Loops" "Collections" "Sets"
 */
Macro "reject each…from_§where_" is a set iteration prefix function,
[
	elementPhrase : literal phrase ⇒ token,
	aSet : expression phrase ⇒ set,
	predicate : block phrase ⇒ []→⊤
|
	anAtom ::= $"filter_by_";
	name ::= elementPhrase's token's lexeme;
	aSetType ::= aSet's semantic type;
	elementType ::= aSetType's element type;
	blockType ::=
		[elementType]→(predicate's semantic type's return type);

	returnType ::= strengthen set for call of anAtom
			using <aSetType, blockType>;

	statements ::= predicate's statements;
	size ::= |statements|;
	newStatements ::= if size = 0 then [<>] else
	[
		end : whole number := cast size-1 into [w : whole number | w];
		i : natural number := cast size into [n : natural number | n];
		c : expression phrase⇒any := cast statements[i] into
			[e : expression phrase⇒any | e];
		statements[..end] ++
			<bootstrap restricted send $"¬_" with «<c>» : boolean>
	];
	blockReturnType ::= cast newStatements
		into [t : phrase+ | t[|t|]'s semantic type]
		else [⊤];

	declaration ::= scope map[name];
	Undeclare name;

	bootstrap restricted send anAtom with
		«<
			aSet,
			«[
				<cast declaration into [d : argument phrase | d]>
			 |
				newStatements
			] : blockReturnType»
		>» : returnType
] : send phrase ⇒ ⊤;

/**
 * Iteratively apply {@param "accumulator"} to the elements of {@param "aSet"},
 * in no particular order, in order to transform and filter its elements into a
 * new set. When {@param "accumulator"} is invoked, it is passed a "keeper"
 * function. The keeper function may be invoked to "save" a particular value,
 * i.e., a value that will be copied into the output set. The keeper function
 * will save at most one value per element of {@param "aSet"}, i.e., each time
 * that {@param "accumulator"} is invoked, it may invoke the keeper function at
 * most one time. Answer the new set.
 *
 * @method "map and filter_by_"
 * @param "aSet" "set"
 * @param "accumulator" "[⊥, ⊥]→⊤"
 *        A function that accepts 1) an element from {@param "aSet"} and 2) a
 *        keeper function. The keeper function accepts an argument of the type
 *        that should be saved.
 * @returns "set"
 *          A set whose elements are those saved by the {@param "accumulator"}.
 * @category "Collections" "Sets" "Control Structures"
 */
Method "map and filter_by_" is
[
	aSet : set,
	accumulator : [⊥, ⊥]→⊤
|
	aTuple ::= aSet→tuple;
	index : natural number := 1;
	end ::= |aTuple|;
	result : set := ∅;
	[
		$loop : ⊤;
		Exit loop if end < index;
		hasAlreadyKept : boolean := false;
		accumulator(
			aTuple[index],
			[
				transformed : any
			|
				If ¬hasAlreadyKept then
				[
					result := eject result + transformed;
					hasAlreadyKept := true;
				];
			]);
		index++;
		Restart loop
	]();
	result
] : set;

/**
 * Ensure that the function will accept all arguments of the set and also an
 * appropriately typed keeper function.
 *
 * @method "map and filter_by_"
 * @restricts "set meta"
 * @restricts "[⊥, ⊥]→⊤'s type"
 */
Semantic restriction "map and filter_by_" is
[
	setType : set meta,
	accumulator : [⊥, ⊥]→⊤'s type
|
	Require: accumulator accepts setType;
	Require: accumulator's keeper is valid;
	If accumulator's return type ≠ ⊤ then
	[
		Immediately reject parse, expected:
			"repeatedly applied function to have return type ⊤"
	];
	{
		cast accumulator[2] into [ t : function meta | t[1] ]
		| [0..⌈setType⌉ + 1)
	}
];

/**
 * Compute and answer whether any of the elements of {@param "aSet"} satisfies
 * the specified function. Do not examine more elements than necessary.
 *
 * @method "any of_satisfies_"
 * @param "aSet" "set"
 * @param "predicate" "[⊥]→boolean"
 *        A function that accepts the elements of the set and answers a boolean.
 * @returns "boolean"
 *          {@method "true"} if {@param "predicate"} answers {@method "true"}
 *          for any element of {@param "aSet"}, {@method "false"} otherwise.
 * @category "Collections" "Sets" "Queries"
 */
Method "any of_satisfies_" is
[
	aSet : set,
	predicate : [⊥]→boolean
|
	[
		index : natural number,
		end : whole number,
		aTuple : tuple
	|
		$loop : boolean;
		Exit loop with false if index > end;
		test ::= predicate(aTuple[index]);
		Exit loop with true if test;
		Restart loop with <index + 1, end, aTuple>
	](1, |aSet|, aSet→tuple)
] : boolean;

/**
 * Ensure that the function will accept all elements of the set.
 *
 * @method "any of_satisfies_"
 * @restricts "set meta"
 * @restricts "[⊥]→boolean's type"
 */
Semantic restriction "any of_satisfies_" is
[
	setType : set meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts setType;
	predicate's return type
];

/**
 * Compute and answer whether each of the elements of {@param "aSet"} satisfies
 * the specified function. Do not examine more elements than necessary.
 *
 * @method "each of_satisfies_"
 * @param "aSet" "set"
 * @param "predicate" "[⊥]→boolean"
 *        A function that accepts the elements of the set and answers a boolean.
 * @returns "boolean"
 *          {@method "true"} if {@param "predicate"} answers {@method "true"}
 *          for each element of {@param "aSet"}, {@method "false"} otherwise.
 * @category "Collections" "Sets" "Queries"
 */
Method "each of_satisfies_" is
[
	aSet : set,
	predicate : [⊥]→boolean
|
	aTuple ::= aSet→tuple;
	[
		index : natural number,
		end : whole number
	|
		$loop : boolean;
		Exit loop with true if index > end;
		test ::= predicate(aTuple[index]);
		Exit loop with false if test = false;
		Restart loop with <index + 1, end>
	](1, |aTuple|)
] : boolean;

/**
 * Ensure that the function will accept all elements of the set.
 *
 * @method "each of_satisfies_"
 * @restricts "set meta"
 * @restricts "[⊥]→boolean's type"
 */
Semantic restriction "each of_satisfies_" is
[
	setType : set meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts setType;
	predicate's return type
];

/**
 * Compute and answer whether any of the elements of {@param "aSet"} satisfies
 * the specified function. Do not examine more elements than necessary.
 *
 * @macro "any…in|of_§satisfies_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aSet"}.
 * @param "aSet" "expression phrase ⇒ set"
 *        An {@type "expression phrase"} that yields the tuple to iterate over
 * @param "predicateBlock" "block phrase ⇒ []→boolean"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        predicate function.
 * @returns "send phrase ⇒ ⊤"
 * @category "Collections" "Sets" "Queries"
 */
Macro "any…in|of_§satisfies_" is a set iteration prefix function,
	set body function($"any of_satisfies_", boolean);

/**
 * Compute and answer whether all of the elements of {@param "aSet"} satisfies
 * the specified function. Do not examine more elements than necessary.
 *
 * @macro "each…in|of_§satisfies_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aSet"}.
 * @param "aTuple" "expression phrase ⇒ set"
 *        An {@type "expression phrase"} that yields the tuple to iterate over
 * @param "predicateBlock" "block phrase ⇒ []→boolean"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        predicate function.
 * @returns "send phrase ⇒ ⊤"
 * @category "Collections" "Sets" "Queries"
 */
Macro "each…in|of_§satisfies_" is a set iteration prefix function,
	set body function($"each of_satisfies_", boolean);

/**
 * Compute and answer the count of elements of {@param "aSet"} that satisfy the
 * given predicate.
 *
 * @method "count of_where_"
 * @param "aSet" "set"
 * @param "predicate" "[⊥]→boolean"
 *        A function that accepts the elements of the set and answers {@method
 *        "true"} if the element should be represented in the resulting count.
 * @returns "whole number"
 *          The number of elements of {@param "aSet"} for which {@param
 *          "predicate"} answers {@method "true"}.
 * @category "Collections" "Sets" "Queries"
 */
Method "count of_where_" is
[
	aSet : set,
	predicate : [⊥]→boolean
|
	aTuple ::= aSet→tuple;
	[
		index : natural number,
		end : whole number,
		count : whole number
	|
		$loop : whole number;
		Exit loop with count if index > end;
		test ::= predicate(aTuple[index]);
		Restart loop
			with <index + 1, end, if test then [count + 1] else [count]>
	](1, |aTuple|, 0)
] : whole number;

/**
 * Ensure that the function will accept all elements of the set.
 *
 * @method "count of_where_"
 * @restricts "set meta"
 * @restricts "[⊥]→boolean's type"
 */
Semantic restriction "count of_where_" is
[
	setType : set meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts setType;
	[0..⌈setType⌉ + 1)
];

/**
 * Compute and answer the count of elements of {@param "aSet"} that satisfy
 * the given predicate.
 *
 * @macro "count of…from|in|of_§where_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aSet"}.
 * @param "aSet" "expression phrase ⇒ set"
 *        An {@type "expression phrase"} that yields the tuple to iterate over
 * @param "predicateBlock" "block phrase ⇒ []→boolean"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        predicate function.
 * @returns "send phrase ⇒ ⊤"
 * @category "Queries" "Collections" "Sets"
 */
Macro "count of…from|in|of_§where_" is a set iteration prefix function,
	set body function($"count of_where_", whole number);

/**
 * Compute and answer the symmetric difference between the two sets, being the
 * set containing all elements in each set but no elements in both. This
 * amounts to the set union absent each element of the set intersection.
 *
 * @method "_Δ_"
 * @param "a" "set"
 * @param "b" "set"
 * @returns "set"
 *          The symmetric difference of {@param "a"} and {@param "b"}.
 * @author Leslie Schultz
 * @category "Sets" "Transformers"
 */
Public stable method "_Δ_" is
[
	a : set,
	b : set
|
	(a ∪ b) \ (a ∩ b)
];

/**
 * Strengthen `_Δ_`.
 *
 * @method "_Δ_"
 * @restricts "set meta"
 * @restricts "set meta"
 * @author Leslie Schultz
 */
Semantic restriction "_Δ_" is
[
	aType : set meta,
	bType : set meta
|
	aElementType ::= aType's element type;
	bElementType ::= bType's element type;
	lowerBound ::=
		if (aElementType ∩ bElementType) = ⊥
		then [ ⌊aType⌋ + ⌊bType⌋ ]
		else [ 0 ];
	upperBound ::= (⌈aType⌉ + ⌈bType⌉);
	{aElementType ∪ bElementType | lowerBound..upperBound}
];

/**
 * Does {@param "aSet"} contain {@param "value"}?
 *
 * @method "_∋_"
 * @param "aSet" "set"
 * @param "value" "any"
 *        An arbitrary value.
 * @returns "boolean"
 *          {@method "true"} if {@param "aSet"} contains {@param "value"} as a
 *          member, {@method "false"} otherwise.
 * @category "Sets" "Queries"
 */
Public stable method "_∋_" is
[
	aSet : set,
	value : any
|
	value ∈ aSet
];

/**
 * @method "_∋_"
 * @restricts "set meta"
 * @restricts "any meta"
 */
Semantic restriction "_∋_" is
[
	setType : set meta,
	valueType : any meta
|
	if (setType's element type) ∩ valueType = ⊥ then
	[
		false's type
	]
	else
	[
		/* Can't strengthen. */
		⊤
	]
];

/**
 * Is {@method "a"} a proper subset of {@method "b"}?
 *
 * @method "_⊂_"
 * @param "a" "set"
 * @param "b" "set"
 * @returns "boolean"
 *          {@method "true"} if {@param "a"} is a proper subset of {@param "b"},
 *          {@method "false"} otherwise.
 * @category "Sets" "Queries"
 */
Public stable method "_⊂_" is
[
	a : set,
	b : set
|
	|a| ≠ |b| ∧ a ⊆ b
] : boolean;

/**
 * @method "_⊂_"
 * @restricts "set meta"
 * @restricts "set meta"
 */
Semantic restriction "_⊂_" is
[
	typeA : set meta,
	typeB : set meta
|
	elementA ::= typeA's element type;
	elementB ::= typeB's element type;
	/* The basic rule is this: If the type intersection of the element type
	 * of `typeA` and the element type of `typeB` is ⊥, then the result must
	 * be false. Otherwise all bets are off.
	 */
	basicRule ::=
		[ if elementA ∩ elementB = ⊥ then [ false's type ] else [ ⊤ ] ];
	sizesB ::= ||typeB||;
	/* This is finesse. If `typeB` is definitely the set of all possible
	 * instances of its (enumeration) element type, then `typeA`'s instances
	 * must be subsets of `typeB`'s instance if `typeA`'s element type is a
	 * subtype of `typeB`'s element type.
	 */
	if |elementB| ≠ ∞ ∧ ⌊sizesB⌋ = ⌈sizesB⌉ ∧ |elementB| = ⌊sizesB⌋ then
	[
		if ⌈typeA⌉ < |elementB| ∧ elementA ⊆ elementB then [ true's type ]
		else basicRule
	]
	else basicRule
];

/**
 * Is {@param "a"} a superset of or equal to {@param "b"}?
 *
 * @method "_⊇_"
 * @param "a" "set"
 * @param "b" "set"
 * @returns "boolean"
 *           {@method "true"} if {@param "a"} is a superset of or equal to
 *           {@param "b"}, {@method "false"} otherwise.
 * @category "Sets" "Queries"
 */
Public stable method "_⊇_" is
[
	a : set,
	b : set
|
	b ⊆ a
];

/**
 * @method "_⊇_"
 * @restricts "set's type"
 * @restricts "set's type"
 */
Semantic restriction "_⊇_" is
[
	typeB : set's type,
	typeA : set's type
|
	elementA ::= typeA's element type;
	elementB ::= typeB's element type;
	/* The basic rule is this: If the type intersection of the element type
	 * of `typeA` and the element type of `typeB` is ⊥, then the result must
	 * be false. Otherwise all bets are off.
	 */
	basicRule ::=
		[ if elementA ∩ elementB = ⊥ then [ false's type ] else [ boolean ] ];
	sizesB ::= ||typeB||;
	/* This is finesse. If `typeB` is definitely the set of all possible
	 * instances of its (enumeration) element type, then `typeA`'s instances
	 * must be subsets of `typeB`'s instance if `typeA`'s element type is a
	 * subtype of `typeB`'s element type.
	 */
	if |elementB| ≠ ∞ ∧ ⌊sizesB⌋ = ⌈sizesB⌉ ∧ |elementB| = ⌊sizesB⌋ then
	[
		if elementA ⊆ elementB then [true's type]
		else basicRule
	]
	else basicRule
];

/**
 * Is {@param "a"} neither a superset nor equal to {@param "b"}?
 *
 * @method "_⊉_"
 * @param "a" "set"
 * @param "b" "set"
 * @returns "boolean"
 *          {@method "true"} if {@param "a"} is neither a superset of nor equal
 *          to {@param "b"}, {@method "false"} otherwise.
 * @category "Sets" "Queries"
 */
Public stable method "_⊉_" is
[
	a : set,
	b : set
|
	¬b ⊆ a
];

/**
 * @method "_⊉_"
 * @restricts "set's type"
 * @restricts "set's type"
 */
Semantic restriction "_⊉_" is
[
	typeA : set's type,
	typeB : set's type
|
	elementA ::= typeA's element type;
	elementB ::= typeB's element type;
	/* The basic rule is this: If the type intersection of the element type
	 * of `typeA` and the element type of `typeB` is ⊥, then the result must
	 * be false. Otherwise all bets are off.
	 */
	basicRule ::=
		[ if elementA ∩ elementB = ⊥ then [ true's type ] else [ boolean ] ];
	sizesA ::= ||typeA||;
	/* This is finesse. If `typeA` is definitely the set of all possible
	 * instances of its (enumeration) element type, then `typeB`'s instances
	 * must be subsets of `typeA`'s instance if `typeB`'s element type is a
	 * subtype of `typeA`'s element type.
	 */
	if |elementA| ≠ ∞ ∧ ⌊sizesA⌋ = ⌈sizesA⌉ ∧ |elementA| = ⌊sizesA⌋ then
	[
		if elementB ⊆ elementA then [false's type]
		else basicRule
	]
	else basicRule
];

/**
 * Is {@param "a"} neither a superset nor equal to {@param "b"}?
 *
 * @method "_⊈_"
 * @param "a" "set"
 * @param "b" "set"
 * @returns "boolean"
 *          {@method "true"} if {@param "a"} is neither a superset of nor equal
 *          to {@param "b"}, {@method "false"} otherwise.
 * @category "Sets" "Queries"
 */
Stable method "_⊈_" is
[
	a : set,
	b : set
|
	b ⊉ a
];

/**
 * @method "_⊈_"
 * @restricts "set's type"
 * @restricts "set's type"
 */
Semantic restriction "_⊈_" is
[
	typeA : set's type,
	typeB : set's type
|
	elementA ::= typeA's element type;
	elementB ::= typeB's element type;
	/* The basic rule is this: If the type intersection of the element type
	 * of `typeA` and the element type of `typeB` is ⊥, then the result must
	 * be false. Otherwise all bets are off.
	 */
	basicRule ::=
		[ if elementA ∩ elementB = ⊥ then [ true's type ] else [ boolean ] ];
	sizesB ::= ||typeB||;
	/* This is finesse. If `typeB` is definitely the set of all possible
	 * instances of its (enumeration) element type, then `typeA`'s instances
	 * must be subsets of `typeB`'s instance if `typeA`'s element type is a
	 * subtype of `typeB`'s element type.
	 */
	if |elementB| ≠ ∞ ∧ ⌊sizesB⌋ = ⌈sizesB⌉ ∧ |elementB| = ⌊sizesB⌋ then
	[
		if elementA ⊆ elementB then [false's type]
		else basicRule
	]
	else basicRule
];

/**
 * Is {@param "a"} a proper superset of {@param "b"}?
 *
 * @method "_⊃_"
 * @param "a" "set"
 * @param "b" "set"
 * @returns "boolean"
 *          {@method "true"} if {@param "a"} is a proper superset of {@param
 *          "b"}, {@method "false"} otherwise.
 * @category "Sets" "Queries"
 */
Public stable method "_⊃_" is
[
	a : set,
	b : set
|
	b ⊂ a
];

/**
 * @method "_⊃_"
 * @restricts "set meta"
 * @restricts "set meta"
 */
Semantic restriction "_⊃_" is
[
	typeB : set meta,
	typeA : set meta
|
	elementA ::= typeA's element type;
	elementB ::= typeB's element type;
	/* The basic rule is this: If the type intersection of the element type
	 * of `typeA` and the element type of `typeB` is ⊥, then the result must
	 * be false. Otherwise all bets are off.
	 */
	basicRule ::=
		[ if elementA ∩ elementB = ⊥ then [ false's type ] else [ ⊤ ] ];
	sizesB ::= ||typeB||;
	/* This is finesse. If `typeB` is definitely the set of all possible
	 * instances of its (enumeration) element type, then `typeA`'s instances
	 * must be subsets of `typeB`'s instance if `typeA`'s element type is a
	 * subtype of `typeB`'s element type.
	 */
	if |elementB| ≠ ∞ ∧ ⌊sizesB⌋ = ⌈sizesB⌉ ∧ |elementB| = ⌊sizesB⌋
	then
	[
		if ⌈typeA⌉ < |elementB| ∧ elementA ⊆ elementB then [true's type]
		else basicRule
	]
	else basicRule
];

/**
 * Is {@param "element"} not an element of {@param "aSet"}?
 *
 * @method "_∉_"
 * @param "element" "any"
 *        An arbitrary value.
 * @param "aSet" "set"
 * @returns "boolean"
 *          {@method "true"} if {@param "element"} is not an element of {@param
 *          "aSet"}, {@method "false"} otherwise.
 * @category "Sets" "Queries"
 */
Stable method "_∉_" is
[
	element : any,
	aSet : set
|
	¬ element ∈ aSet
] : boolean;

/**
 * @method "_∉_"
 * @restricts "any meta"
 * @restricts "set meta"
 */
Semantic restriction "_∉_" is
[
	valueType : any meta,
	setType : set meta
|
	if valueType ∩ (setType's element type) = ⊥ then
	[
		true's type
	]
	else
	[
		/* Can't strengthen. */
		⊤
	]
];

/**
 * Is {@param "a"} not a proper subset of {@param "b"}?
 *
 * @method "_⊄_"
 * @param "a" "set"
 * @param "b" "set"
 * @returns "boolean"
 *          {@method "true"} if {@param "a"} is not a proper subset of {@param
 *          "b"}, {@method "false"} otherwise.
 * @category "Sets" "Queries"
 */
Public stable method "_⊄_" is
[
	a : set,
	b : set
|
	¬ a ⊂ b
] : boolean;

/**
 * @method "_⊄_"
 * @restricts "set meta"
 * @restricts "set meta"
 */
Semantic restriction "_⊄_" is
[
	typeA : set meta,
	typeB : set meta
|
	elementA ::= typeA's element type;
	elementB ::= typeB's element type;
	/* The basic rule is this: If the type intersection of the element type
	 * of `typeA` and the element type of `typeB` is ⊥, then the result must
	 * be false. Otherwise all bets are off.
	 */
	basicRule ::=
		[ if elementA ∩ elementB = ⊥ then [ true's type ] else [ ⊤ ] ];
	sizesB ::= ||typeB||;
	/* This is finesse. If `typeB` is definitely the set of all possible
	 * instances of its (enumeration) element type, then `typeA`'s instances
	 * must be subsets of `typeB`'s instance if `typeA`'s element type is a
	 * subtype of `typeB`'s element type.
	 */
	if |elementB| ≠ ∞ ∧ ⌊sizesB⌋ = ⌈sizesB⌉ ∧ |elementB| = ⌊sizesB⌋
	then
	[
		if ⌈typeA⌉ < |elementB| ∧ elementA ⊆ elementB then [false's type]
		else basicRule
	]
	else basicRule
];

/**
 * Does {@param "aSet"} contain {@param "element"}?
 *
 * @method "_∌_"
 * @param "aSet" "set"
 * @param "element" "any"
 * @returns "boolean"
 *          {@method "true"} if {@param "aSet"} contains {@param "element"},
 *          {@method "false"} otherwise.
 * @category "Sets" "Queries"
 */
Public method "_∌_" is
[
	aSet : set,
	element : any
|
	¬ element ∈ aSet
] : boolean;

/**
 * @method "_∌_"
 * @restricts "set meta"
 * @restricts "any meta"
 */
Semantic restriction "_∌_" is
[
	setType : set meta,
	valueType : any meta
|
	if |valueType| = 1 ∧ |setType| = 1 then
	[
		(valueType's instance ∉ setType's instance)'s type
	]
	else if valueType ∩ (setType's element type) = ⊥ then
	[
		true's type
	]
	else
	[
		/* Can't strengthen. */
		⊤
	]
];

/**
 * Is {@param "a"} not a proper subset of {@param "b"}?
 *
 * @method "_⊅_"
 * @param "a" "set"
 * @param "b" "set"
 * @returns "boolean"
 *          {@method "true"} if {@param "a"} is not a proper subset of {@param
 *          "b"}, {@method "false"} otherwise.
 * @category "Sets" "Queries"
 */
Public method "_⊅_" is
[
	a : set,
	b : set
|
	b ⊄ a
] : boolean;

/**
 * @method "_⊅_"
 * @restricts "set meta"
 * @restricts "set meta"
 */
Semantic restriction "_⊅_" is
[
	typeA : set meta,
	typeB : set meta
|
	elementA ::= typeA's element type;
	elementB ::= typeB's element type;
	/* The basic rule is this: If the type intersection of the element type
	 * of `typeA` and the element type of `typeB` is ⊥, then the result must
	 * be false. Otherwise all bets are off.
	 */
	basicRule ::=
		[ if elementA ∩ elementB = ⊥ then [ true's type ] else [ ⊤ ] ];
	sizesA ::= ||typeA||;
	/* This is finesse. If `typeB` is definitely the set of all possible
	 * instances of its (enumeration) element type, then `typeA`'s instances
	 * must be subsets of `typeB`'s instance if `typeA`'s element type is a
	 * subtype of `typeB`'s element type.
	 */
	if |elementA| ≠ ∞ ∧ ⌊sizesA⌋ = ⌈sizesA⌉ ∧ |elementA| = ⌊sizesA⌋
	then
	[
		if ⌈typeB⌉ < |elementA| ∧ elementB ⊆ elementA then [false's type]
		else basicRule
	]
	else basicRule
];

Grammatical restriction {"_∋_", "_⊂_", "_⊇_", "_⊃_", "_∉_", "_∌_", "_⊄_", "_⊅_"}
	is <{"¬_"}, ∅>;

/**
 * @method "_∋_"
 * @forbids "1" "¬_"
 */

/**
 * @method "_⊂_"
 * @forbids "1" "¬_"
 */

/**
 * @method "_⊇_"
 * @forbids "1" "¬_"
 */

/**
 * @method "_⊃_"
 * @forbids "1" "¬_"
 */

/**
 * @method "_∉_"
 * @forbids "1" "¬_"
 */

/**
 * @method "_∌_"
 * @forbids "1" "¬_"
 */

/**
 * @method "_⊄_"
 * @forbids "1" "¬_"
 */

/**
 * @method "_⊅_"
 * @forbids "1" "¬_"
 */

/**
 * Answer an arbitrary element of the supplied {@type "set"}.
 *
 * @method "any_"
 * @param "s" "set"
 * @returns "any"
 * @category "Sets" "Queries"
 */
Public stable method "any_" is
[
	s : set
|
	/* Converting a set to a tuple is unstable, but since the whole point of the
	 * operation is to select an arbitrary element, it is safe and desirable to
	 * mark the method as stable.
	 */
	s→tuple[1]
];

/**
 * @method "any_"
 * @restricts "set meta"
 */
Semantic restriction "any_" is
[
	sType : set meta
|
	sType's element type
];

/**
 * Answer an arbitrary element of the supplied {@type "set"}. If the {@type
 * "set"} is empty, then answer the result of applying the specified {@type
 * "function"}.
 *
 * @method "any_"
 * @param "s" "set"
 * @param "f" "[]→any"
 *        The {@type "function"} to apply if {@param "s"} is empty.
 * @returns "any"
 *          An arbitrary element of {@param "s"}, or the result of applying
 *          {@type "function"} if {@param "s"} is empty.
 * @category "Sets" "Queries"
 */
Public method "any_else_" is
[
	s : set,
	f : []→any
|
	t ::= s→tuple;
	if t ≠ <> then [t[1]] else f
];

/**
 * @method "any_else_"
 * @restricts "set meta"
 * @restricts "[]→any's type"
 */
Semantic restriction "any_else_" is
[
	sType : set meta,
	fType : []→any's type
|
	if ⌊sType⌋ > 0 then [sType's element type]
	else if ⌈sType⌉ = 0 then [fType's return type]
	else [sType's element type ∪ fType's return type]
];

/**
 * Answer the only element of the supplied {@type "set"}.
 *
 * @method "only_"
 * @param "s" "set"
 * @returns "any"
 * @category "Sets" "Queries"
 */
Stable method "only_" is
[
	s : set
|
	t ::= s→tuple;
	Assert: |t|=1 ("set is not a singleton");
	t[1]
];

/**
 * @method "any_"
 * @restricts "set meta"
 */
Semantic restriction "only_" is
[
	sType : set meta
|
	sType's element type
];
