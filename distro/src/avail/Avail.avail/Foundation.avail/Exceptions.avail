/*
 * Exceptions.avail
 * Copyright © 1993-2015, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Exceptions"
Versions
	"1.0.0 DEV 2014-04-28"
Uses
	"Atoms",
	"Bootstrap",
	"Control Structures",
	"Definers",
	"Early Assertions",
	"Early Conditionals",
	"Enumeration Support",
	"Error Codes",
	"Functions",
	"Literals",
	"Logic",
	"Maps",
	"Math",
	"Objects",
	"Phrases",
	"Sets",
	"Strings",
	"Tuples",
	"Types",
	"Variables"
Names
	"Current fiber's unhandled exception handler is_",
	"Guard|guard_«intercept_»«ensure_»",
	"Raise_",
	"an exception for_",
	"cascade_",
	"current fiber's unhandled exception handler",
	"causal exception",
	"descriptive_",
	"error message",
	"try_else_",
	"_caused by_",
	"_'s⁇causal exception",
	"_'s⁇error code",
	"_'s⁇error message",
	"_'s⁇error name",
	"_'s⁇stack summary",
	"“_”(stack summary)",
	"“_”(frames_of stack summary«,⁇renumbered starting at_»)",
	"“_”(frames_of stack summary«,⁇renumbered starting at_»,⁇cascaded)",

	/* System exception categories. */
	"arithmetic exception",
	"bad-argument exception",
	"bad-format exception",
	"bad-message exception",
	"bad-phrase exception",
	"bad-primitive exception",
	"cascade exception",
	"code-generation exception",
	"definition exception",
	"descriptive exception",
	"element-access exception",
	"I/O exception",
	"instantiation exception",
	"invocation exception",
	"security exception",
	"system exception",
	"trace exception",
	"unsupported-operation exception",
	"variable-use exception",

	/* Voluntary termination. */
	"Honor a termination request",
	"termination-requested exception",

	/* Java exceptions. */
	"Java exception",
	"a Java exception caused by_",
	"_'s⁇throwable"

	/* Quite a few names are introduced, but all dynamically by the
	 * "Public exception_(_)extends_" defining method.
	 */
Body

/**
 * Answer a summary of the continuation stack associated with the specified
 * {@type "exception"}.
 *
 * @method "_'s⁇stack summary"
 * @param "e" "exception"
 *        An {@type "exception"}.
 * @returns "string*"
 *          A tuple of strings, each of which describes a continuation.
 * @category "Exceptions" "Queries"
 */
Public method "_'s⁇stack summary" is
[
	e : exception
|
	Primitive ExceptionStackDump
		(failureCode : incorrect-argument-type code's type);
	early failure function(failureCode)
] : string*;

/* Private field definitions. */
"error code" is a new atom;
"error name" is a new atom;

/**
 * Answer the field atom that represents an exception's cause.
 *
 * @method "causal exception"
 * @returns "atom"
 * @category "Exception Handling"
 */
"causal exception" is a new atom;

/**
 * Answer the field atom that represents an error message.
 *
 * @method "error message"
 * @returns "atom"
 * @category "Exception Handling"
 */
"error message" is a new atom;

/**
 * Answer the heritable fiber-local atom that represents a fiber's unhandled
 * exception handler.
 *
 * @method "unhandled exception handler"
 * @returns "atom"
 * @category "Exception Handling"
 */
"unhandled exception handler" is a new heritable fiber-local atom;

/**
 * Answer the unhandled exception handler for the current fiber.
 *
 * @method "current fiber's unhandled exception handler"
 * @returns "[exception]→⊥"
 * @category "Exception Handling"
 */
Public method "current fiber's unhandled exception handler" is
[
	cast current fiber[unhandled exception handler] into [t : [exception]→⊥ | t]
] : [exception]→⊥;

/**
 * Establish {@param "handler"} as the function that the current fiber will
 * apply in the event of an unhandled exception.
 *
 * @method "Current fiber's unhandled exception handler is_"
 * @param "handler" "[exception]→⊥"
 *    The unhandled exception handler. When an unhandled exception is trapped by
 *    the VM, the exception machinery will arrange to apply this function with
 *    the unhandled exception.
 * @returns "⊤"
 * @category "Exception Handling"
 */
Public method "Current fiber's unhandled exception handler is_" is
[
	handler : [exception]→⊥
|
	current fiber[unhandled exception handler] := handler;
] : ⊤;

/* This function that "Raise_" should invoke if the current fiber does not have
 * an unhandled exception handler. This will be updated after all other
 * exception machinery has been built.
 */
noUnhandledExceptionHandler : [exception]→⊥ :=
	[
		anException : exception
	|
		Crash: "unhandled exception: " ++ “anException”
	];

/**
 * Raise the specified {@type "exception"}. The virtual machine scans the
 * {@method "current fiber"}'s chain of {@type "continuation"}s to identify an
 * invocation of {@method "Guard|guard_«intercept_»«ensure_»"} (primitive 200).
 * Extract the second argument from that continuation. This is a {@type "tuple"}
 * of arity-one exception handling {@type "function"}. If any of these handlers,
 * from left to right, accepts {@param "anException"}, then discard all
 * continuations after this one and then invoke the handler with {@param
 * "anException"}. If none of these handlers accept the argument, then the
 * virtual machine continues scanning the chain of continuations for correctly
 * typed exception handling functions. If no suitable exception handling
 * function is found, then invoke the current fiber's {@method
 * "_'s⁇unhandled exception handler is_" unhandled exception handler}. {@method
 * "Crash:_" Crash} the current fiber if no such handler exists.
 *
 * @method "Raise_"
 * @param "anException" "exception"
 * @returns "⊥"
 * @category "Exception Handling" "Control Structures"
 */
Public method "Raise_" is
[
	anException : exception
|
	Primitive RaiseException (unhandledException : exception);
	If unhandled exception handler ∈ current fiber then
	[
		handler ::= current fiber's unhandled exception handler;
		handler(unhandledException)
	]
	else
	[
		noUnhandledExceptionHandler(anException)
	]
] : ⊥;

/**
 * Mark the nearest {@method "Guard|guard_«intercept_»«ensure_»" guard frame}
 * with the current exception handling state.
 *
 * @method "Mark nearest guard frame with_"
 * @param "marker" "{handler-sentinel code, unwind-sentinel code}ᵀ"
 * @returns "ᵀ"
 * @category "Bootstrap" "Primitives" "Exception Handling"
 */
Private method "Mark nearest guard frame with_" is
[
	marker : {handler-sentinel code, unwind-sentinel code}ᵀ
|
	Primitive MarkNearestCatch (failureCode :
		{cannot-mark-handler-frame code, no-handler-frame code}ᵀ);
	early failure function(failureCode)
] : ⊤;

Private method "private-do-and-also-function" is
[
	_argDecl1 ::= arg «this token: arg1 : []→⊤»;
	_argUse1 ::= «↓_argDecl1»(this token: arg1);
	_statement1 ::= send $"_(«_‡,»)" with «<_argUse1, «<>»>» : ⊤;

	_argDecl2 ::= arg «this token: arg2 : []→⊤»;
	_argUse2 ::= «↓_argDecl2»(this token: arg2);
	_statement2 ::= send $"_(«_‡,»)" with «<_argUse2, «<>»>» : ⊤;

	_first_of_sequence ::= first-of-seq «<_statement1, _statement2>»;
	_block ::=
		«[
			<_argDecl1, _argDecl2>
		|
			Primitive ""
			<_first_of_sequence>
		] : ⊤ ^ ∅»;
	_block → function
] : function;

/*
 * Execute the first block then the second block, but answer the result, if any,
 * of executing the first block.  It must operate this way even if the first
 * block actually passed in is of type ⊤ but secretly returns something more
 * specific.
 */

Private method "Do_and also_" is private-do-and-also-function;

/**
 * This is a helper for {@method "Private guard_intercept_ensure_"}. Run
 * {@param "body"} and then {@param "unwind"}. If {@param "body"} produces a
 * value then return it.
 *
 * @method "Run_and_"
 * @param "body" "[]→⊤"
 * @param "unwind" "[]→⊤"
 * @returns "⊤"
 * @category "Bootstrap" "Exception Handling"
 */
Private method "Run_and_" is
[
	body : []→⊤,
	unwind : []→⊤
|
	Do body and also
	[
		Mark nearest guard frame with handler-sentinel code;
		unwind();
		Mark nearest guard frame with unwind-sentinel code;
	];
] : ⊤;

/**
 * Though this is the primitive guard method, it is merely a helper for
 * {@method "Guard|guard_«intercept_»«ensure_»"}, the public exception
 * protection control structure.
 *
 * Execute {@param "body"}. If an {@type "exception"} is {@method "Raise_"
 * raised}, the virtual machine will scan the {@method "current fiber"}'s chain
 * of {@type "continuation"}s to identify invocations of this primitive. The
 * continuation nearest to the end of the continuation chain, i.e., closest to
 * the raise of the exception, that defines a handler that accepts an argument
 * of the correct type is invoked with the exception. So an exception handler
 * will potentially run if code run (directly or indirectly) by {@param "body"}
 * raises an exception of the accepted type.
 *
 * Whether {@param "body"} succeeds or is curtailed by an exception, always
 * apply {@param "unwind"}. This is a safe place to clean up an algorithm after
 * it runs or fails. If one of the handlers is invoked, then it will run after
 * the handler runs, even if the handler raises its own exception. This happens
 * because the public control structure, {@method
 * "Guard|guard_«intercept_»«ensure_»"}, embeds {@param "unwind"} into each of
 * the (modified) exception handlers.
 *
 * @method "Private guard_intercept_ensure_"
 * @param "body" "[]→⊤"
 *    The protected function.
 * @param "handlers" "<[⊥]→⊤…|>"
 *    A tuple of exception handlers.
 * @param "optionalUnwind" "([]→⊤)?"
 *    If specified, then a function to apply after either the successful
 *    completion of {@param "body"} or an unwind through this continuation.
 * @returns "⊤"
 * @category "Bootstrap" "Primitives" "Exception Handling" "Control Structures"
 */
Private method "Private guard_intercept_ensure_" is
[
	body : []→⊤,
	handlers : <[⊥]→⊤…|>,
	optionalUnwind : ([]→⊤)?
|
	Primitive CatchException (failureCode :
		{
			0,
			incorrect-argument-type code,
			handler-sentinel code,
			unwind-sentinel code
		}ᵀ);
	If failureCode = 0 then
	[
		Run body and optionalUnwind[1] else [[]];
	]
	else
	[
		early failure function(incorrect-argument-type code)
	];
] : ⊤;

/**
 * A cascade exception retains the exception that originally caused it.
 *
 * @type "cascade exception"
 * @supertype "exception"
 * @field "causal exception" "exception"
 * 		The original exception that lead to the current exception
 * @category "Exceptions"
 */
Public class "cascade exception" extends exception
	with fields
		public causal exception : exception;

/**
 * Construct and answer the type intersection of the argument and {@type
 * "cascade exception"}.
 *
 * @method "cascade_"
 * @param "exceptionType" "exception's type"
 *        An exception type.
 * @returns "cascade exception"
 *          An exception type that is a subtype of both {@type "cascade
 *          exception"} and {@param "exceptionType"}.
 * @category "Exceptions" "Types" "Constructors"
 */
Public method "cascade_" is
[
	exceptionType : exception's type
|
	cascade exception ∩ exceptionType
] : cascade exception's type;

/**
 * @method "cascade_"
 * @forbids 1 "exception"
 */
Grammatical restriction "cascade_" is <{"exception"}>;

/**
 * @method "cascade_"
 * @restricts "exception's type's type"
 */
Semantic restriction "cascade_" is
[
	exceptionMeta : exception's type's type
|
	((cascade exception) ∩ (exceptionMeta's instance))'s type
];

/**
 * Answer a {@type "cascade exception"} based on {@param "newException"} and
 * caused by {@param "originalException"}.
 *
 * @method "_caused by_"
 * @param "newException" "exception"
 * @param "originalException" "exception"
 * @returns "cascade exception"
 * @category "Exceptions" "Constructors"
 */
Public method "_caused by_" is
[
	newException : exception,
	originalException : exception
|
	fields ::= newException→map + causal exception→originalException;
	cast fields→object into [t : cascade exception | t]
] : cascade exception;

/**
 * This is a helper for {@method "Guard|guard_«intercept_»«ensure_»"}. Having
 * intercepted {@param "originalException"}, invoke {@param "handler"}. If it
 * raises an {@type "exception", then intercept it and store it locally. Run
 * {@param "unwind"}. If it raises an exception, then intercept it and store it
 * locally, overwriting any exception intercepted by a failure of {@param
 * "handler"}. If a new exception has been stored locally, then convert it into
 * a {@type "cascade exception"} and reraise it. Otherwise answer the result
 * produced by {@param "handler"}.
 *
 * @method "Handle_with_and_"
 * @param "originalException" "exception"
 *        The exception originally caught by the handler that {@method
 *        "Guard|guard_«intercept_»«ensure_»"} wrapped around {@param
 *        "handler"}.
 * @param "handler" "[⊥]→⊤"
 *        An exception handler lexically specified in the send of {@method
 *        "Guard|guard_«intercept_»«ensure_»"}.
 * @param "unwind" "[]→⊤"
 *        The unwind handler lexically specified in the send of {@method
 *        "Guard|guard_«intercept_»«ensure_»"}.
 * @returns "any"
 *          The value, if any, produced by {@param "handler"}.
 * @raises "cascade exception"
 *         If either {@param "handler"} or {@param "unwind"} raises an
 *         {@type "exception"}.
 * @category "Bootstrap" "Exception Handling"
 */
Private method "Handle_with_and_" is
[
	originalException : exception,
	handler : [⊥]→⊤,
	unwind : []→⊤
|
	preemptiveException : exception;
	/* Guard the handler, because we need to try the unwind no matter what
	 * happens.
	 */
	Private guard [handler(originalException);]
	intercept <[e : exception | preemptiveException := e;]>
	ensure <>;
	/* Guard the unwind, because if it blows up, then we want to build a cascade
	 * exception from it instead of from the handler.
	 */
	Private guard [unwind();]
	intercept <[e : exception | preemptiveException := e;]>
	ensure <>;
	/* Forbid a subsequent unwind. */
	Mark nearest guard frame with unwind-sentinel code;
	/* If either the handler or the unwind raised an exception, then convert it
	 * to a cascade exception (with the original exception attached) and reraise
	 * it.
	 */
	If preemptiveException is assigned then
	[
		Raise preemptiveException caused by originalException
	];
] : ⊤;

Private method "Handle_with_and_" is
[
	originalException : exception,
	handler : [⊥]→any,
	unwind : []→⊤
|
	result : any;
	preemptiveException : exception;
	/* Guard the handler, because we need to try the unwind no matter what
	 * happens.
	 */
	Private guard [result := handler(originalException);]
	intercept <[e : exception | preemptiveException := e;]>
	ensure <>;
	/* Guard the unwind, because if it blows up, then we want to build a cascade
	 * exception from it instead of from the handler.
	 */
	Private guard [unwind();]
	intercept <[e : exception | preemptiveException := e;]>
	ensure <>;
	/* Forbid a subsequent unwind. */
	Mark nearest guard frame with unwind-sentinel code;
	/* If either the handler or the unwind raised an exception, then convert it
	 * to a cascade exception (with the original exception attached) and reraise
	 * it.
	 */
	If preemptiveException is assigned then
	[
		Raise preemptiveException caused by originalException
	];
	/* The result must be assigned, or control would have left because of a
	 * raised exception.
	 */
	Assert: result is assigned;
	result
] : any;

/**
 * Reject the current parse if 1) any of the exception handlers aren't or 2) any
 * earlier handlers hide later handlers (by having a more general type).
 *
 * @method "Guard|guard_«intercept_»«ensure_»"
 * @restricts "[]→⊤'s type"
 * @restricts "<[⊥]→⊤…|>'s type"
 * @restricts "([]→⊤)?'s type"
 */
Semantic restriction "Guard|guard_«intercept_»«ensure_»" is
[
	bodyType : []→⊤'s type,
	handlersType : <[⊥]→⊤…|>'s type,
	unwindType : ([]→⊤)?'s type
|
	returnType : type := bodyType's return type;
	handlerCount ::= ⎣handlersType⎦;
	unwindCount ::= ⎣unwindType⎦;
	If handlerCount = 0 ∧ unwindCount = 0 then
	[
		Reject parse, expected:
			"at least one exception handler or an unwind handler"
	];
	For each index from 1 to handlerCount do
	[
		handlerType ::= handlersType[index];
		argType ::= handlerType[1];
		If argType = ⊥ then
		[
			Reject parse, expected: format
				"exception handler #“①”'s parameter type to be \
				\|statically known"
				with index
		];
		If ¬argType ⊆ exception then
		[
			Reject parse, expected: format
				"exception handler to accept only exceptions (not “①”)"
				with argType
		];
		hidingArgTypes : type* := <>;
		For each inner from 1 to index - 1 do
		[
			previousArgType ::= handlersType[inner][1];
			If argType ⊆ previousArgType then
			[
				hidingArgTypes := eject hidingArgTypes ++ <previousArgType>;
			];
		];
		If ¬hidingArgTypes is empty then
		[
			Reject parse, expected: format
			"exception handler for “①” to be reachable \
			\|(but it is hidden by each of: “②”)"
			with argType, hidingArgTypes
		];
		returnType := eject returnType ∪ handlerType's return type;
	];
	returnType
];

/**
 * Execute {@param "body"}. If an {@type "exception"} is {@method "Raise_"
 * raised}, the virtual machine will scan the {@method "current fiber"}'s chain
 * of {@type "continuation"}s to identify invocations of this primitive. The
 * continuation nearest to the end of the continuation chain, i.e., closest to
 * the raise of the exception, that defines a handler that accepts an argument
 * of the correct type is invoked with the exception. So an exception handler
 * will potentially run if code run (directly or indirectly) by {@param "body"}
 * raises an exception of the accepted type.
 *
 * Whether {@param "body"} succeeds or is curtailed by an exception, always
 * apply {@param "unwind"}. This is a safe place to clean up an algorithm after
 * it runs or fails. If one of the handlers is invoked, then it will run after
 * the handler runs, even if the handler raises its own exception.
 *
 * @method "Guard|guard_«intercept_»«ensure_»"
 * @param "bodyPhrase" "expression phrase ⇒ []→⊤"
 *        The protected function.
 * @param "handlersPhrase" "list phrase ⇒ (([⊥]→⊤)*)"
 *        A {@type "list phrase" list} of exception handlers.
 * @param "optionalUnwindPhrase" "list phrase ⇒ (([]→⊤)?)"
 *        If specified, then a function to apply after either the successful
 *        completion of {@param "body"} or an unwind through this continuation.
 * @returns "send phrase ⇒ ⊤"
 * @category "Exception Handling" "Control Structures"
 */
Public macro "Guard|guard_«intercept_»«ensure_»" is
[
	bodyPhrase : expression phrase ⇒ []→⊤,
	handlersPhrase : list phrase ⇒ (([⊥]→⊤)*),
	optionalUnwindPhrase : list phrase ⇒ (([]→⊤)?)
|
	handlers ::= handlersPhrase's expressions;
	optionalUnwind ::= optionalUnwindPhrase's expressions;
	unwind ::= optionalUnwind[1] else [«[<>] : ⊤»];
	catchAll ::=
		[
			outerArg ::= arg «`"e"` : exception»;
			innerArg ::= arg «`"ex"` : exception»;
			«[
				<outerArg>
			|
				<
					send $"Handle_with_and_" with
						«<
							«↓outerArg»,
							«[
								<innerArg>
							|
								<send $"Raise_" with «<«↓innerArg»>» : ⊥>
							] : ⊥»,
							unwind
						>» : ⊥
				>
			] : ⊥»
		];
	/* Wrap each of the handlers. The wrapper will call the user-supplied
	 * exception handler and then the unwind handler. If the user did not supply
	 * a catch-all, then we need to synthesize one to make sure that the ensure
	 * mechanism always works.
	 */
	needCatchAll : boolean := true;
	wrappedHandlers ::=
		map each handler in handlers through
		[
			handlerType ::= handler's semantic type;
			argType ::= handlerType[1];
			If argType = exception then [needCatchAll := false;];
			arg ::= arg «`"originalException"` : argType»;
			«[
				<arg>
			|
				<
					send $"Handle_with_and_" with
						«<
							«↓arg»,
							handler,
							unwind
						>» : handlerType's return type
				>
			] : handlerType's return type»
		];
	realHandlers ::=
		(wrappedHandlers ++ if needCatchAll then [<catchAll()>] else [<>])
			→ list phrase;
	restricted send $"Private guard_intercept_ensure_" with
		«<
			bodyPhrase,
			realHandlers,
			optionalUnwindPhrase
		>» : ⊤
];

/**
 * Attempt {@param "protected"}. If it does not raise an {@type "exception"},
 * then answer its result. Otherwise, answer the result of applying {@param
 * "else"}.
 *
 * @method "try_else_"
 * @param "protected" "[]→any"
 *    The function whose answer is preferred.
 * @param "else" "[]→any"
 *    The function whose answer will be returned if {@param "protected"} raises
 *    an {@type "exception"}.
 * @returns "any"
 *    If possible, then the answer obtained by applying {@param "protected"}.
 *    Otherwise, the answer obtained by applying {@param "else"}.
 * @category "Exception Handling" "Control Structures"
 */
Public method "try_else_" is
[
	protected : []→any,
	else : []→any
|
	guard protected intercept [e : exception | else()]
] : any;

/**
 * @method "try_else_"
 * @restricts "[]→any's type"
 * @restricts "[]→any's type"
 */
Semantic restriction "try_else_" is
[
	protected : []→any's type,
	else : []→any's type
|
	if protected's return type = ⊥ then [else's return type]
	else [protected's return type ∪ else's return type]
];

/**
 * A system exception privately contains a system error code.
 *
 * @type "system exception"
 * @field "error code" "natural number"
 * 		The vm error code.
 * @field "error name" "string"
 * 		The full name of the system exception including the word "exception"
 * 		at the end.
 * @supertype "exception"
 * @category "Exceptions"
 */
Public class "system exception" extends exception
	with fields
		error code : natural number,
		error name : string;

/**
 * @method "“_”"
 * @param "anException" "system exception"
 * @returns "string"
 */
Stable method "“_”" is
[
	anException : system exception
|
	(a|an) “anException's error name”
] : string;

/* A map from error codes to system exceptions. */
exceptionsByCode : {natural number→system exception's type|} := {};

/**
 * Define a new system exception class. Publish the name of the class.
 *
 * @method "System exception_(_)extends_"
 * @param "exceptionBaseName" "nonempty string"
 *    The base name of the exception class (without the trailing " exception").
 * @param "code" "natural number"
 *    The error code that uniquely identifies the system exception.
 * @param "supertype" "exception's type"
 *    The nearest supertype of the new exception class.
 * @returns "⊤"
 * @category "Bootstrap" "Declarations" "Exceptions"
 */
Private method "System exception_(_)extends_" is
[
	exceptionBaseName : nonempty string,
	code : natural number,
	supertype : exception's type
|
	Assert: ¬code ∈ ↑exceptionsByCode ("code " ++ “code” ++ " already in use");
	Assert: ¬exceptionBaseName ends with " exception"
		(format "\"‘①’\" ends with \" exception\"" with exceptionBaseName);
	exceptionName ::= exceptionBaseName ++ " exception";
	Class exceptionName extends supertype ∩ system exception
		with fields
			error code : code's type,
			error name : exceptionName's type;
	Export exceptionName as a new name;
	site ::= cast method definition of atom for exceptionName for <>
		into [t : method definition | t];
	implementation ::= cast site's function into [t : []→object meta | t];
	exceptionType ::= cast implementation()
		into  [t : system exception's type | t];
	↑exceptionsByCode [code] := exceptionType;
];

/**
 * An arithmetic exception describes error conditions related to arithmetic and
 * manipulation of numbers.
 *
 * @type "arithmetic exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "arithmetic exception" extends exception;

/**
 * A bad-argument exception describes error conditions related to invoking a
 * method, function, or similar entity with arguments that are correctly typed
 * but not semantically valid.
 *
 * @type "bad-argument exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "bad-argument exception" extends exception;

/**
 * A bad-format exception describes error conditions related to invalid formats
 * and/or format applications.
 *
 * @type "bad-format exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "bad-format exception" extends bad-argument exception;

/**
 * A message exception describes error conditions related to messages, i.e.,
 * method names.
 *
 * @type "bad-message exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "bad-message exception" extends exception;

/**
 * A bad phrase exception describes error conditions related to phrase
 * construction.
 *
 * @type "bad-phrase exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "bad-phrase exception" extends exception;

/**
 * A bad-primitive exception describes error conditions related to invocations
 * of nonexistent or not meaningfully implemented primitives.
 *
 * @type "bad=primitive exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "bad-primitive exception" extends exception;

/**
 * A code-generation exception describes error conditions related to runtime
 * generation of code.
 *
 * @type "code-generation exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "code-generation exception" extends exception;

/**
 * A definition exception describes error conditions related to defining Avail
 * methods, restrictions, types, and other entities.
 *
 * @type "definition exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "definition exception" extends exception;

/**
 * An element-access exception describes error conditions related to failed
 * retrieval of an object from a larger structure (including the runtime
 * system).
 *
 * @type "element-access exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "element-access exception" extends exception;

/**
 * An I/O exception describes error conditions related to program input or
 * output.
 *
 * @type "I/O exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "I/O exception" extends exception;

/**
 * An invocation exception describes error conditions related to invoking
 * functions, methods, or similar objects with the wrong number or types of
 * arguments.
 *
 * @type "invocation exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "invocation exception" extends exception;

/**
 * An instantiation exception describes error conditions related to
 * instantiating types (particularly user-defined object types).
 *
 * @type "instantiation exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "instantiation exception" extends exception;

/**
 * A security exception describes error conditions related to program
 * permissions.
 *
 * @type "security exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "security exception" extends exception;

/**
 * A trace exception describes error conditions related to system tracing.
 *
 * @type "trace exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "trace exception" extends exception;

/**
 * An unsupported-operation exception describes error conditions related to
 * performing operations that are not supported by the underlying platform.
 *
 * @type "unsupported-operation exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "unsupported-operation exception" extends exception;

/**
 * A variable use exception describes error conditions related to usage of
 * variables.
 *
 * @type "variable-use exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "variable-use exception" extends exception;

/* Define specific exception classes for each of the VM and Foundation error
 * codes.
 */

/**
 * Raised when adding {@method "∞"} and {@method "-∞"}.
 *
 * @type "cannot-add-unlike-infinities exception"
 * @supertype "arithmetic exception"
 * @field "error code" "1's type"
 * 		The vm error code.
 * @field "error name" "string"
 * 		The full name of the system exception including the word "exception"
 * 		at the end.
 * @category "Exceptions" "Mathematics"
 */
System exception "cannot-add-unlike-infinities" (1)
	extends arithmetic exception;

/**
 * Raised when subtracting {@type "extended integer" infinities} with the same
 * sign.
 *
 * @type "cannot-subtract-like-infinities exception"
 * @supertype "arithmetic exception"
 * @field "error code" "2's type"
 * 		The vm error code.
 * @field "error name" "string"
 * 		The full name of the system exception including the word "exception"
 * 		at the end.
 * @category "Exceptions" "Mathematics"
 */
System exception "cannot-subtract-like-infinities" (2)
	extends arithmetic exception;

/**
 * Raised when multiplying {@code 0} and {@method "∞"}.
 *
 * @type "cannot-multiply-zero-and-infinity exception"
 * @supertype "arithmetic exception"
 * @field "error code" "3's type"
 * 		The vm error code.
 * @field "error name" "string"
 * 		The full name of the system exception including the word "exception"
 * 		at the end.
 * @category "Exceptions" "Mathematics"
 */
System exception "cannot-multiply-zero-and-infinity" (3)
	extends arithmetic exception;

/**
 * Raised when dividing any dividend by {@code 0}.
 *
 * @type "cannot-divide-by-zero exception"
 * @supertype "arithmetic exception"
 * @field "error code" "4's type"
 * 		The vm error code.
 * @field "error name" "string"
 * 		The full name of the system exception including the word "exception"
 * 		at the end.
 * @category "Exceptions" "Mathematics"
 */
System exception "cannot-divide-by-zero" (4)
	extends arithmetic exception;

/**
 * Raised when dividing an {@type "extended integer" infinity} by another one.
 *
 * @type "cannot-divide-infinities exception"
 * @supertype "arithmetic exception"
 * @field "error code" "5's type"
 * 		The vm error code.
 * @field "error name" "string"
 * 		The full name of the system exception including the word "exception"
 * 		at the end.
 * @category "Exceptions" "Mathematics"
 */
System exception "cannot-divide-infinities" (5)
	extends arithmetic exception;

/**
 * Raised when reading from an {@method "↑_is unassigned" unassigned} {@type
 * "variable"}.
 *
 * @type "cannot-read-unassigned-variable exception"
 * @supertype "variable-use exception"
 * @field "error code" "6's type"
 * 		The vm error code.
 * @field "error name" "string"
 * 		The full name of the system exception including the word "exception"
 * 		at the end.
 * @category "Exceptions" "Variables"
 */
System exception "cannot-read-unassigned-variable" (6)
	extends variable-use exception;

/**
 * Raised when storing an inappropriately typed value into a {@type "variable"}
 * (using {@method "_`?=_"} or the like).
 *
 * @type "cannot-store-incorrectly-typed-value exception"
 * @supertype "variable-use exception"
 * @field "error code" "7's type"
 * 		The vm error code.
 * @field "error name" "string"
 * 		The full name of the system exception including the word "exception"
 * 		at the end.
 * @category "Exceptions" "Variables"
 */
System exception "cannot-store-incorrectly-typed-value" (7)
	extends variable-use exception;

/**
 * Raised when {@method "Swap_↑and_↑" exchanging} the contents of two
 * incompatibly typed variables.
 *
 * @type "cannot-swap-contents-of-differently-typed-variables exception"
 * @supertype "variable-use exception"
 * @field "error code" "8's type"
 * 		The vm error code.
 * @field "error name" "string"
 * 		The full name of the system exception including the word "exception"
 * 		at the end.
 * @category "Exceptions" "Variables"
 */
System exception "cannot-swap-contents-of-differently-typed-variables" (8)
	extends variable-use exception;

/**
 * Raised when reading or removing a nonexistent {@type "fiber"}-local variable.
 *
 * @type "no-such-fiber-variable exception"
 * @supertype "element-access exception"
 * @field "error code" "9's type"
 * 		The vm error code.
 * @field "error name" "string"
 * 		The full name of the system exception including the word "exception"
 * 		at the end.
 * @category "Exceptions" "Concurrency"
 */
System exception "no-such-fiber-variable" (9)
	extends element-access exception;

/**
 * Raised when accessing a {@type "tuple"} or {@type "pojo array"} with an index
 * that is out of bounds, i.e., less than {@code 1} or greater than the
 * {@method "`|_`|" size} of the target.
 *
 * @type "subscript-out-of-bounds exception"
 * @supertype "element-access exception"
 * @field "error code" "10's type"
 * 		The vm error code.
 * @field "error name" "string"
 * 		The full name of the system exception including the word "exception"
 * 		at the end.
 * @category "Exceptions" "Tuples" "Pojos"
 */
System exception "subscript-out-of-bounds" (10)
	extends element-access exception;

/**
 * Raised when performing an operation with the wrong number of arguments.
 *
 * @type "incorrect-number-of-arguments exception"
 * @supertype "invocation exception"
 * @field "error code" "11's type"
 * 		The vm error code.
 * @field "error name" "string"
 * 		The full name of the system exception including the word "exception"
 * 		at the end.
 * @category "Exceptions"
 */
System exception "incorrect-number-of-arguments" (11)
	extends invocation exception;

/**
 * Raised when performing an operation with one or more incorrectly typed
 * arguments.
 *
 * @type "incorrect-argument-type exception"
 * @supertype "invocation exception"
 * @field "error code" "12's type"
 * 		The vm error code.
 * @field "error name" "string"
 * 		The full name of the system exception including the word "exception"
 * 		at the end.
 * @category "Exceptions"
 */
System exception "incorrect-argument-type" (12)
	extends invocation exception;

/**
 * Raised when the return type declared or inferred for a particular {@type
 * "method definition"} does not agree with the return type declared by that
 * {@type "method definition"}'s {@method "Forward method_is_" forward
 * declaration}.
 *
 * @type "method-return-type-not-as-forward-declared exception"
 * @supertype "definition exception"
 * @field "error code" "13's type"
 * 		The vm error code.
 * @field "error name" "string"
 * 		The full name of the system exception including the word "exception"
 * 		at the end.
 * @category "Exceptions"
 */
System exception "method-return-type-not-as-forward-declared" (13)
	extends definition exception;

/**
 * Raised when attempting to {@method "Exit_" exit} a {@type "continuation"}
 * with a value insufficiently strong to satisfy the {@type "continuation"}'s
 * return type.
 *
 * @type "continuation-expected-stronger-type exception"
 * @supertype "invocation exception"
 * @field "error code" "14's type"
 * 		The vm error code.
 * @field "error name" "string"
 * 		The full name of the system exception including the word "exception"
 * 		at the end.
 * @category "Exceptions" "Continuations"
 */
System exception "continuation-expected-stronger-type" (14)
	extends invocation exception;

/**
 * Raised when invoking a primitive {@type "method"} that is not supported by
 * the underlying platform.
 *
 * @type "operation-not-supported exception"
 * @supertype "unsupported-operation"
 * @field "error code" "15's type"
 * 		The vm error code.
 * @field "error name" "string"
 * 		The full name of the system exception including the word "exception"
 * 		at the end.
 * @category "Exceptions" "Primitives"
 */
System exception "operation-not-supported" (15)
	extends unsupported-operation exception;

/**
 * Raised when invoking an operation that expects an enumeration type with an
 * argument that is not an enumeration type.
 *
 * @type "not-an-enumeration exception"
 * @supertype "invocation exception"
 * @field "error code" "17's type"
 * 		The vm error code.
 * @field "error name" "string"
 * 		The full name of the system exception including the word "exception"
 * 		at the end.
 * @category "Exceptions" "Types" "Enumerations"
 */
System exception "not-an-enumeration" (17)
	extends invocation exception;

/**
 * Raised by {@method "_<<_keeping_bits"} when the truncation size is negative.
 *
 * @type "shift-and-truncate-requires-non-negative exception"
 * @supertype "arithmetic exception"
 * @field "error code" "18's type"
 * 		The vm error code.
 * @field "error name" "string"
 * 		The full name of the system exception including the word "exception"
 * 		at the end.
 * @category "Exceptions" "Mathematics"
 */
System exception "shift-and-truncate-requires-non-negative" (18)
	extends arithmetic exception;

/**
 * Raised when attempting to look up a nonexistent {@type "method"}.
 *
 * @type "no-method exception"
 * @supertype "element-access exception"
 * @field "error code" "19's type"
 * 		The vm error code.
 * @field "error name" "string"
 * 		The full name of the system exception including the word "exception"
 * 		at the end.
 * @category "Exceptions" "Methods"
 */
System exception "no-method" (19)
	extends element-access exception;

/**
 * Raised by {@method "function from_and_"} when attempting to create a {@type
 * "function"} with the wrong number of captured values.
 *
 * @type "wrong-outers exception"
 * @supertype "code-generation"
 * @field "error code" "20's type"
 * 		The vm error code.
 * @field "error name" "string"
 * 		The full name of the system exception including the word "exception"
 * 		at the end.
 * @category "Exceptions" "Functions"
 */
System exception "wrong-outers" (20)
	extends code-generation exception;

System exception "key-not-found" (21)
	extends element-access exception;
System exception "negative-size" (22)
	extends bad-argument exception;
System exception "general-I/O" (23)
	extends I/O exception;
System exception "permission-denied" (24)
	extends security exception;
System exception "invalid-handle" (25)
	extends bad-argument exception;
System exception "invalid-primitive-number" (26)
	extends code-generation exception;
System exception "function-disagrees-with-primitive-restriction" (27)
	extends code-generation exception;
System exception "local-type-literal-is-not-a-type" (28)
	extends code-generation exception;
System exception "outer-type-literal-is-not-a-type" (29)
	extends code-generation exception;
System exception "too-large-to-represent" (30)
	extends system exception;
System exception "type-restriction-must-accept-only-types" (31)
	extends definition exception;
System exception "incorrect-type-for-group" (32)
	extends bad-message exception;
System exception "no-special-object" (33)
	extends element-access exception;
System exception "macro-argument-must-be-a-parse-node" (34)
	extends definition exception;
System exception "ambiguous-name" (35)
	extends bad-message exception;
System exception "declaration-kind-does-not-support-assignment" (36)
	extends bad-phrase exception;
System exception "declaration-kind-does-not-support-reference" (37)
	extends bad-phrase exception;
System exception "exclamation-mark-must-follow-an-alternation-group" (38)
	extends bad-message exception;
System exception "redefined-with-same-argument-types" (39)
	extends definition exception;
System exception "result-type-should-covary-with-arguments" (40)
	extends definition exception;
System exception "special-atom" (41)
	extends bad-argument exception;
System exception "incorrect-type-for-complex-group" (42)
	extends bad-message exception;
System exception "incorrect-use-of-double-dagger" (43)
	extends bad-message exception;
System exception "unbalanced-guillemets" (44)
	extends bad-message exception;
System exception "method-name-is-not-canonical" (45)
	extends bad-message exception;
System exception "expected-operator-after-backquote" (46)
	extends bad-message exception;
System exception "incorrect-type-for-boolean-group" (47)
	extends bad-message exception;
System exception "incorrect-type-for-counting-group" (48)
	extends bad-message exception;
System exception "octothorp-must-follow-a-simple-group" (49)
	extends bad-message exception;
System exception "question-mark-must-follow-a-simple-group" (50)
	extends bad-message exception;
System exception "case-insensitive-expression-canonization" (51)
	extends bad-message exception;
System exception "tilde-must-not-follow-argument" (52)
	extends bad-message exception;
System exception "double-question-mark-must-follow-a-token-or-simple-group" (53)
	extends bad-message exception;
System exception "alternative-must-not-contain-arguments" (54)
	extends bad-message exception;
System exception "vertical-bar-must-separate-tokens-or-simple-groups" (55)
	extends bad-message exception;
System exception "cannot-convert-not-a-number-to-integer" (56)
	extends bad-argument exception;
System exception "incorrect-type-for-numbered-choice" (57)
	extends bad-message exception;
System exception "infallible-primitive-must-not-have-statements" (58)
	extends bad-phrase exception;
System exception "macro-prefix-functions-must-return-top" (59)
	extends definition exception;
System exception "primitive-fallibility-disagrees-with-failure-variable" (60)
	extends definition exception;
System exception "final-expression-should-agree-with-declared-return-type" (61)
	extends definition exception;
System exception "primitive-should-agree-with-declared-return-type" (62)
	extends definition exception;
System exception "label-type-should-agree-with-declared-return-type" (63)
	extends definition exception;
System exception "return-type-is-mandatory-with-primitives-or-labels" (64)
	extends definition exception;
System exception "not-evaluating-macro" (65)
	extends definition exception;
System exception "bad-yield-type" (66)
	extends bad-phrase exception;
System exception "macro-prefix-function-argument-must-be-a-parse-node" (67)
	extends definition exception;
System exception "macro-must-return-a-parse-node" (68)
	extends definition exception;
System exception "no-such-field" (69)
	extends element-access exception;
System exception "loading-is-over" (70)
	extends system exception;
System exception "untimely-parse-rejection" (71)
	extends system exception;
System exception "method-is-sealed" (72)
	extends definition exception;
System exception "cannot-overwrite-write-once-variable" (73)
	extends variable-use exception;
System exception "atom-already-exists" (74)
	extends definition exception;
System exception "cannot-mix-method-and-macro-definitions" (75)
	extends definition exception;
System exception "cannot-create-continuation-for-infallible-primitive-function" (76)
	extends invocation exception;
System exception "illegal-trace-mode" (77)
	extends trace exception;
System exception "up-arrow-must-follow-argument" (78)
	extends bad-message exception;
System exception "result-disagreed-with-expected-type" (79)
	extends definition exception;
System exception "handler-sentinel" (80)
	extends system exception;
System exception "cannot-mark-handler-frame" (81)
	extends system exception;
System exception "no-handler-frame" (82)
	extends system exception;
System exception "unwind-sentinel" (83)
	extends system exception;
System exception "no-method-definition" (84)
	extends definition exception;
System exception "ambiguous-method-definition" (85)
	extends definition exception;
System exception "forward-method-definition" (86)
	extends definition exception;
System exception "abstract-method-definition" (87)
	extends definition exception;
System exception "observed-variable-written-while-untraced" (88)
	extends variable-use exception;
System exception "fiber-is-terminated" (89)
	extends system exception;
System exception "fiber-result-unavailable" (90)
	extends system exception;
System exception "fiber-cannot-join-itself" (91)
	extends system exception;
System exception "fiber-produced-incorrectly-typed-result" (92)
	extends element-access exception;
System exception "not-open-for-read" (93)
	extends bad-argument exception;
System exception "not-open-for-write" (94)
	extends bad-argument exception;
System exception "exceeds-vm-limit" (95)
	extends bad-argument exception;
System exception "serialization-failed" (96)
	extends bad-argument exception;
System exception "deserialization-failed" (97)
	extends bad-argument exception;
System exception "inconsistent-argument-reordering" (98)
	extends bad-message exception;
System exception "block-contains-invalid-statements" (100)
	extends bad-phrase exception;
System exception "block-is-invalid" (101)
	extends bad-phrase exception;
System exception "block-must-not-contain-outers" (102)
	extends bad-phrase exception;
System exception "block-compilation-failed" (103)
	extends code-generation exception;
System exception "sequence-contains-invalid-statements" (105)
	extends bad-phrase exception;
System exception "supercast-expression-type-must-not-be-top-or-bottom" (106)
	extends bad-phrase exception;
System exception "supercast-expression-must-not-also-be-a-supercast" (107)
	extends bad-phrase exception;
System exception "supercast-must-be-strict-supertype-of-expression-type" (108)
	extends bad-phrase exception;
System exception "no-external-process" (150)
	extends I/O exception;
System exception "no-file" (200)
	extends I/O exception;
System exception "file-exists" (201)
	extends I/O exception;
System exception "directory-not-empty" (202)
	extends I/O exception;
System exception "partial-success" (203)
	extends system exception;
System exception "illegal-option" (204)
	extends bad-argument exception;
System exception "invalid-path" (205)
	extends bad-argument exception;
System exception "Java-class-not-available" (500)
	extends element-access exception;
System exception "pojo-type-is-abstract" (501)
	extends bad-argument exception;
System exception "Java-method-not-available" (502)
	extends element-access exception;
System exception "Java-marshaling-failed" (504)
	extends invocation exception;
System exception "Java-field-not-available" (505)
	extends element-access exception;
System exception "Java-field-reference-is-ambiguous" (506)
	extends bad-message exception;
System exception "cannot-modify-final-Java-field" (507)
	extends variable-use exception;
System exception "Java-method-reference-is-ambiguous" (508)
	extends bad-message exception;
System exception "object-type-extension-contains-duplicates" (1000)
	extends definition exception;
System exception "object-type-extension-did-not-produce-subtype" (1001)
	extends definition exception;
System exception "object-type-extension-changed-field-accessor-name"(1002)
	extends definition exception;
System exception "object-type-extension-changed-field-referrer-name"(1003)
	extends definition exception;
System exception "object-type-extension-changed-field-mutator-name"(1004)
	extends definition exception;
System exception "object-instantiation-contains-duplicates" (1010)
	extends instantiation exception;
System exception "object-instantiation-did-not-produce-instance" (1011)
	extends instantiation exception;
System exception "invalid-argument" (1020)
	extends bad-format exception;
System exception "runaway-format-variable" (1021)
	extends bad-format exception;
System exception "empty-format-variable" (1022)
	extends bad-format exception;
System exception "invalid-format-metacharacter-escape" (1023)
	extends bad-format exception;
System exception "invalid-format-metacharacter-use" (1024)
	extends bad-format exception;
System exception "format-variable-interpolation-failed" (1025)
	extends bad-format exception;
System exception "invalid-format-variable" (1026)
	extends bad-format exception;
System exception "missing-format-variable-binding" (1027)
	extends bad-format exception;
System exception "cannot-compute-logarithm-for-nonpositive-base" (1040)
	extends bad-argument exception;
System exception "cannot-compute-logarithm-of-nonpositive-number" (1041)
	extends bad-argument exception;

/**
 * Ensure that all error codes have corresponding exceptions.
 *
 * @method "Ensure:all error codes have corresponding exceptions"
 * @returns "⊤"
 * @category "Bootstrap" "Assertions"
 */
Private method "Ensure:all error codes have corresponding exceptions" is [];
Semantic restriction "Ensure:all error codes have corresponding exceptions" is
[
	missingSystemExceptions ::= reject each errorCode from VM error codes
		where [errorCode ∈ exceptionsByCode];
	missingExceptionClasses ::=
		reject each errorCode → errorName from error codes
			where [errorCode ∈ exceptionsByCode];
	problem : string := "exception classes to be defined for the following";
	If |missingSystemExceptions| ≠ 0 then
	[
		problem ++= " VM exceptions: " ++ “missingSystemExceptions”;
		If |missingExceptionClasses| ≠ 0 then [problem ++= " and";];
	];
	If |missingExceptionClasses| ≠ 0 then
	[
		problem ++= " error codes: " ++ “missingExceptionClasses”;
	];
	If |missingSystemExceptions| ≠ 0 ∨ |missingExceptionClasses| ≠ 0 then
	[
		Reject parse, expected: problem
	];
	⊤
];

Ensure: all error codes have corresponding exceptions;

/**
 * A descriptive exception holds an error message.
 *
 * @type "descriptive exception"
 * @supertype "exception"
 * @field "error message" "string"
 * 		A descriptive message associated with the exception.
 * @category "Exceptions"
 */
Public class "descriptive exception" extends exception
	with fields
		public error message : string;

/**
 * Construct and answer the type intersection of the argument and {@type
 * "descriptive exception"}.
 *
 * @method "descriptive_"
 * @param "exceptionType" "exception's type"
 *        An exception type.
 * @returns "descriptive exception"
 *          An exception type that is a subtype of both {@type "descriptive
 *          exception"} and {@param "exceptionType"}.
 * @category "Exceptions" "Types" "Constructors"
 */
Public method "descriptive_" is
[
	exceptionType : exception's type
|
	descriptive exception ∩ exceptionType
] : descriptive exception's type;

/**
 * @method "descriptive_"
 * @forbids 1 "exception"
 */
Grammatical restriction "descriptive_" is <{"exception"}>;

/**
 * @method "descriptive_"
 * @restricts "exception's type's type"
 */
Semantic restriction "descriptive_" is
[
	exceptionMeta : exception's type's type
|
	((descriptive exception) ∩ (exceptionMeta's instance))'s type
];

/**
 * @method "“_”"
 * @param "e" "descriptive exception"
 * @returns "string"
 * 		The stringified {@type "descriptive exception"}
 * @category "Stringification"
 */
Stable method "“_”" is
[
	e : descriptive exception
|
	format
		"‘①’
		\|(
		\|\t‘②’
		\|)"
	with
		(a|an) “e's type”,
		e's error message
];

/**
 * Answer the right exception for the specified system error code.
 *
 * @method "an exception for_"
 * @param "errorCode" "natural number"
 *        A system error code.
 * @returns "exception"
 *          The appropriate exception for the specified error code.
 * @category "Exceptions" "Constructors"
 */
Public method "an exception for_" is
[
	errorCode : natural number
|
	exceptionType ::= exceptionsByCode[errorCode];
	an exceptionType with
		error code ::= errorCode,
		error name ::= exceptionType's error name's instance
] : exception;

"throwable" is a new field atom;

/**
 * A Java exception wraps a pojo representing a Java-style {@code Throwable}.
 *
 * @type "Java exception"
 * @supertype "exception"
 * @field "throwable" "pojo exception"
 * @category "Exceptions" "POJO"
 */
Public class "Java exception" extends exception
	with field
		public throwable : pojo exception;

/**
 * Construct and answer a {@type "Java exception"} that was conceptually caused
 * by the {@type "pojo exception" argument}.
 *
 * @method "a Java exception caused by_"
 * @param "e" "pojo exception"
 *        A Java-style {@code Throwable}.
 * @returns "Java exception"
 * @category "Exceptions" "POJO" "Constructors"
 */
Method "a Java exception caused by_" is
[
	e : pojo exception
|
	a Java exception with throwable ::= e
] : Java exception;

/**
 * Obtain a printed representation of the specified {@type "exception"}'s stack
 * summary, suitable for printing.
 *
 * @method "“_”(stack summary)"
 * @param "e" "exception"
 * @returns "string"
 * @category "Exceptions" "Stringification"
 */
Public method "“_”(stack summary)" is
[
	e : exception
|
	dump ::= e's stack summary;
	text : string := "";
	For each index from |dump| to 1 by -1 do
	[
		frame ::= dump[index];
		text := eject text ++ (format "\t‘①’\n" with frame);
	];
	text
];

Method "“_”(stack summary)" is
[
	e : descriptive exception
|
	"(\n\t"
	++ e's error message
	++ "\n)\n"
	++ “(e :: exception)” (stack summary)
];

/**
 * Obtain a printed representation of the specified {@type "exception"}'s stack
 * summary, suitable for printing. Only summarize frames in the given range.
 *
 * @method "“_”(frames_of stack summary«,⁇renumbered starting at_»)"
 * @param "e" "exception"
 * @param "range" "natural number's type"
 *        The range of the stack to summarize. The ordinal of the base frame is
 *        {@code 1}. If the ceiling of the range is out of bounds for the stack,
 *        then substitute the actual size of the stack.
 * @param "start" "natural number"
 *        If specified, then the ordinal to present for the {@code ⎣range⎦}-th
 *        frame of the stack.
 * @returns "string"
 * @category "Exceptions" "Stringification"
 */
Public method "“_”(frames_of stack summary«,⁇renumbered starting at_»)" is
[
	e : exception,
	range : [1..∞)'s type,
	start : natural number?
|
	dump ::= e's stack summary;
	text : string := "";
	ordinal : natural number := start[1] else [1];
	For each index from ⎣range⎦ to ⎡range⎤ min |dump| do
	[
		frame ::= dump[index];
		colon ::= first index of ":" in frame;
		Assert: colon ≠ 0;
		withoutOrdinal ::= frame[colon + 1..];
		newFrame ::= format "\t#“①”:‘②’\n" with ordinal, withoutOrdinal;
		text := newFrame ++ eject text;
		ordinal++;
	];
	text
];

Method "“_”(frames_of stack summary«,⁇renumbered starting at_»)" is
[
	e : descriptive exception,
	range : [1..∞)'s type,
	start : natural number?
|
	"(\n\t"
	++ e's error message
	++ "\n)\n"
	++ “(e :: exception)” (frames range of stack summary,
		renumbered starting at start[1] else [1])
];

/**
 * Obtain a printed representation of the specified {@type "exception"}'s
 * cascaded stack summary, suitable for printing. Only summarize frames of the
 * outmost {@type "exception"} in the given range; all originating {@type
 * "exception"}s are fully summarized.
 *
 * @method "“_”(frames_of stack summary«,⁇renumbered starting at_»,⁇cascaded)"
 * @param "ex" "exception"
 *        An {@type "exception"} raised by the {@method "current fiber"}.
 * @param "range" "natural number's type"
 *        The range of {@param "ex"}'s stack to summarize. The ordinal of the
 *        base frame is {@code 1}. If the ceiling of the range is out of bounds
 *        for the stack, then substitute the actual size of the stack.
 * @param "start" "natural number"
 *        If specified, then the ordinal to present for the {@code ⎣range⎦}-th
 *        frame of {@param "e"}'s stack.
 * @returns "string"
 * @category "Exceptions" "Stringification"
 */
Public method
	"“_”(frames_of stack summary«,⁇renumbered starting at_»,⁇cascaded)"
is
[
	ex : exception,
	range : [1..∞)'s type,
	start : natural number?
|
	e : exception := ex;
	msg : string := "";
	firstTime : boolean := true;
	While e is assigned do
	[
		name ::= “e's type's names” (as list partitioned by " ∩ ");
		msg := eject msg ++ (a|an) “name” ++ "\n";
		msg := eject msg ++
			if firstTime then
			[
				firstTime := false;
				“e” (frames range of stack summary,
					renumbered starting at start[1] else [1])
			]
			else
			[
				“e” (stack summary)
			];
		Cast e into
		[
			cascade : cascade exception
		|
			msg := eject msg ++ "\ncaused by…\n";
			e := cascade's causal exception;
		]
		else
		[
			Clear e;
		];
	];
	msg
] : string;

/**
 * A termination-requested exception indicates that termination has been
 * requested for the current fiber.
 *
 * @type "termination-requested exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "termination-requested exception" extends exception;

/**
 * Raise a {@type "termination-requested exception"} iff {@method
 * "termination requested" termination has been requested}.
 *
 * @method "Honor a termination request"
 * @returns "⊤"
 * @raises "termination-requested exception"
 *         If {@method "termination requested" termination has been requested}.
 * @category "Exceptions" "Control Structures"
 */
Public method "Honor a termination request" is
[
	If termination requested then
	[
		Raise a termination-requested exception
	];
] : ⊤;

/**
 * Set the function that should be invoked whenever an unassigned variable is
 * read.
 *
 * @method "unassigned variable read function:=_"
 * @param "aFunction" "[]→⊥"
 * @returns "⊤"
 * @category "Bootstrap" "Primitives" "Exceptions" "Variables"
 */
Private method "unassigned variable read function:=_" is
[
	aFunction : []→⊥
|
	Primitive SetUnassignedVariableAccessFunction;
] : ⊤;

/* Raise a cannot-read-unassigned-variable exception whenever an unassigned
 * variable is read.
 */
unassigned variable read function :=
	[Raise a cannot-read-unassigned-variable exception];

"bad message" is a new field atom;
"expected type" is a new field atom;
"actual value" is a new field atom;

/**
 * Set the function that should be invoked whenever a method send produces a
 * result whose type disagrees with the expected type as determined at compile
 * time by applicable semantic restrictions.
 *
 * @method "unexpected result function:=_"
 * @param "aFunction" "[function, type, any]→⊥"
 *        A {@type "function"} that accepts the errant {@type "function"},
 *        the {@type "type" expected type}, and a {@type "variable"} containing
 *        the {@type "any" actual value}, respectively.
 * @returns "⊤"
 * @category "Bootstrap" "Primitives" "Exceptions" "Methods"
 */
Private method "unexpected result function:=_" is
[
	aFunction : [function, type, ↑any]→⊥
|
	Primitive SetResultDisagreedWithExpectedTypeFunction;
] : ⊤;

/* Raise a result-disagreed-with-expected-type whenever a method send produces
 * a result whose type disagrees with the expected type as determined at
 * comile time by applicable semantic restrictions.
 */
unexpected result function :=
	[
		badMessage : function,
		expectedType : type,
		actualValue : ↑any
	|
		exceptionType ::=
			descriptive result-disagreed-with-expected-type exception;
		message ::= badMessage's message;
		reportedValue ::=
			if actualValue is assigned then [↓actualValue]
			else ["«nil»"];
		e ::= an exceptionType with
			error message ::=
				format
					"message:  ‘①’
					\|\texpected value:  “②”
					\|\tactual value:  “③”"
				with
					message,
					expectedType,
					reportedValue,
			bad message ::= message,
			expected type ::= expectedType,
			actual value ::= reportedValue;
		Raise e
	];

/**
 * Set the function that should be invoked whenever a message send encounters
 * a definitional error, such as ambiguous or failed method definition lookup,
 * or invocation of a forward or abstract method.
 *
 * @method "invalid method send function:=_"
 * @param "aFunction" "<natural number, method, tuple>"
 *        The first function argument is actually restricted to lookup related
 *        issues only.
 * @returns "⊤"
 * @category "Bootstrap" "Primitives" "Exceptions" "Methods"
 */
Private method "invalid method send function:=_" is
[
	aFunction : [
		{
			no-method code,
			no-method-definition code,
			ambiguous-method-definition code,
			forward-method-definition code,
			abstract-method-definition code}ᵀ,
		method,
		tuple
	]→⊥
|
	Primitive SetInvalidMessageSendFunction;
] : ⊤;

"looked up method" is a new atom;
"looked up arguments" is a new atom;

/* Raise the appropriate exception whenever a message send fails dynamically. */
invalid method send function :=
	[
		code : {
			no-method code,
			no-method-definition code,
			ambiguous-method-definition code,
			forward-method-definition code,
			abstract-method-definition code}ᵀ,
		theMethod : method,
		arguments : tuple
	|
		exceptionType ::= exceptionsByCode[code];
		name ::= exceptionType's error name's instance;
		e ::= an exceptionType with
			error code ::= code,
			error name ::= name,
			error message ::=
				format
					"method:  “①”
					\|\targuments:  “②”"
				with
					theMethod,
					arguments,
			looked up method ::= theMethod,
			looked up arguments ::= arguments;
		Raise e
	] : ⊥;

/*
 * Even though we can in general allow unintended "subexpressions" like <⊥>[2]
 * to fail, we're not <em>quite</em> far enough along in exception support to be
 * able to log it sensibly.  See down a few lines for this phantom misparse.
 */
Grammatical restriction "`$_@pc=_stack=_[_]caller=_" is <∅, ∅, {"_[_]"}, ∅, ∅>;

/* If the unhandled exception handler catches a termination-requested exception,
 * we want the fiber to exit cleanly, so use an uninitialized variable. This is
 * because we don't want the synthetic base continuation to have a calling
 * continuation. When a base continuation returns, the fiber exits cleanly, in
 * this case without a final result.
 *
 * Note that the stack tuple must include a value for each stack slot required
 * by the continuation. The stack grows downward, and predecrements before
 * pushing, so the stack pointer should begin at the first invalid index.
 */
syntheticBase ::=
	[
		caller : continuation;
		$[Ignore: 0;]@pc=1 stack=<⊥>[2] caller=↑caller
	]();

/* This completes the behavior of "Raise_" in the event that no unhandled
 * exception handler has been specified for the current fiber.
 */
noUnhandledExceptionHandler :=
	[
		unhandled : exception
	|
		msg : string := "";
		/* If the error was encountered during compilation, then indicate which
		 * module was being compiled.
		 */
		Guard
		[
			m ::= current module;
			msg :=
				format "Unhandled exception during compilation of “①”:\n"
				with m's name;
		]
		intercept [e : loading-is-over exception |];
		msg := eject msg ++ "Unhandled exception: ";
		msg := eject msg ++ any unhandled's type's names;
		msg := eject msg ++ "\n\nCausal trace follows:\n";
		msg := eject msg
			++ “unhandled” (frames [1..∞) of stack summary, cascaded)
			++ "\nThe current fiber will be terminated.\n";
		/* If the current fiber was launched in order to apply a semantic
		 * restriction, run a macro, or run a macro prefix function, then reject
		 * the current parse. Otherwise, emit the error message to the stardard
		 * error stream and terminate the current fiber.
		 */
		If current fiber can reject a parse then
		[
			Reject parse, expected: msg
		];
		/* If the unhandled exception is a termination-requested exception, then
		 * arrange to exit the current fiber cleanly. Note that this will only
		 * work correctly if the current fiber isn't expected to produce a
		 * result.
		 */
		Cast unhandled into
		[
			unused : termination-requested exception
		|
			Exit syntheticBase
		]
		else
		[
			Error: msg;
			Terminate current fiber
		]
	];

originalEarlyFailureFunction ::= early failure function;

After the current module is unloaded,
	do [Set early failure function to originalEarlyFailureFunction;];

/* Exceptions are going live! Failures of bootstrap linked primitives will now
 * raise appropriate exceptions.
 */
Set early failure function to
[
	errorCode : natural number
|
	Assert: errorCode ∈ exceptionsByCode
		("no exception class for " ++ “errorCode”);
	exceptionType ::= exceptionsByCode[errorCode];
	Raise an exceptionType with
		error code ::= errorCode,
		error name ::= exceptionType's error name's instance
] : ⊥;

originalStabilityFailureFunction ::= stability failure function;

After the current module is unloaded,
	do [Set stability failure function to originalStabilityFailureFunction;];

/* Henceforth, when a macro generated by "Method_is stable at_" raises an
 * exception, the exception will be suppressed. recover() will be invoked to
 * produce an appropriate send of the original message.
 */
Set stability failure function to
[
	op : []→literal phrase,
	recover : []→(send phrase ⇒ any)
|
	guard op
	intercept
	[
		e : exception
	|
		Reject parse, expected:
			"stable method not to fail during macro evaluation:\n"
			++ “e” (stack summary)
	]
] : expression phrase ⇒ any;
