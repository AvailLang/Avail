/*
 * Infallible Primitives.avail
 * Copyright © 1993-2021, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * GENERATED FILE
 * * Generator: avail.tools.bootstrap.BootstrapGenerator
 * * Last Generated: 11/30/21, 12:34 PM
 *
 * DO NOT MODIFY MANUALLY. ALL MANUAL CHANGES WILL BE LOST.
 */

Module "Infallible Primitives"
Versions
	"Avail-1.6.0"
Extends
Uses
	"Origin",
	"Special Objects",
	"Primitives" =
	(
		"$_",
		"<_,_`…`|_>",
		"Assert:_(_)",
		"Breakpoint",
		"Cast|cast_into_else_",
		"Crash:_",
		"Exit_if_",
		"Park current fiber",
		"Request termination of_",
		"Restart_",
		"Set name of function implementation_to_",
		"Sleep for_millisecond|milliseconds",
		"Terminate current fiber",
		"Unname_from_",
		"Unpark_",
		"Yield current fiber",
		"[`…]→_",
		"_'s⁇arguments",
		"_'s⁇arity",
		"_'s⁇atom",
		"_'s⁇bindings",
		"_'s⁇bundle",
		"_'s⁇caller",
		"_'s⁇character type number",
		"_'s⁇code point",
		"_'s⁇declaration",
		"_'s⁇declared exceptions",
		"_'s⁇declared type",
		"_'s⁇default type",
		"_'s⁇definitions",
		"_'s⁇element type",
		"_'s⁇element|member type",
		"_'s⁇entry points",
		"_'s⁇expression",
		"_'s⁇expressions",
		"_'s⁇function",
		"_'s⁇function type",
		"_'s⁇genuine lower bound",
		"_'s⁇genuine upper bound",
		"_'s⁇hash",
		"_'s⁇implementation",
		"_'s⁇key type",
		"_'s⁇keys",
		"_'s⁇leading types",
		"_'s⁇lexeme",
		"_'s⁇line number",
		"_'s⁇list",
		"_'s⁇literals",
		"_'s⁇lookup type",
		"_'s⁇maximum stack depth",
		"_'s⁇message",
		"_'s⁇method",
		"_'s⁇name",
		"_'s⁇name:=_",
		"_'s⁇names",
		"_'s⁇nybblecodes",
		"_'s⁇outer variables",
		"_'s⁇parameters'type",
		"_'s⁇permutation",
		"_'s⁇primitive name",
		"_'s⁇priority",
		"_'s⁇priority:=_",
		"_'s⁇program counter",
		"_'s⁇public names",
		"_'s⁇read type",
		"_'s⁇result type",
		"_'s⁇return type",
		"_'s⁇seals",
		"_'s⁇semantic type",
		"_'s⁇stack",
		"_'s⁇stack pointer",
		"_'s⁇starting position",
		"_'s⁇statements",
		"_'s⁇target",
		"_'s⁇token",
		"_'s⁇tokens",
		"_'s⁇type",
		"_'s⁇value",
		"_'s⁇value type",
		"_'s⁇values",
		"_'s⁇write type",
		"_++_",
		"_+_",
		"_+_→_",
		"_-_",
		"_<_",
		"_=_",
		"_[_]",
		"_\\_",
		"_^_",
		"_bit∧_",
		"_bit∨_",
		"_bit⊕_",
		"_has initializing expression",
		"_has public name_",
		"_has result",
		"_has terminated",
		"_is a primitive",
		"_is a valid message",
		"_is open for side effects",
		"_is special",
		"_mod_",
		"_reinterpreted as bits",
		"_reinterpreted as double",
		"_reinterpreted as float",
		"_reversed",
		"_↑is unassigned",
		"_→JSON",
		"_→block phrase",
		"_→character",
		"_→double",
		"_→float",
		"_→list phrase",
		"_→literal phrase",
		"_→map",
		"_→object",
		"_→object type",
		"_→set",
		"_→statement phrase",
		"_→tuple",
		"_∈_",
		"_∩_",
		"_∪_",
		"_≤_",
		"_⊆_",
		"_⨉_^_",
		"`|_'s⁇local variables`|",
		"`|_'s⁇outer variables`|",
		"`|_'s⁇parameters`|",
		"`|_`|",
		"`|`|_`|`|",
		"`«$_:_`»",
		"`«_::=_`»",
		"`«_:_:=_`»",
		"`«_:_`»",
		"`«marker phrase_⇒_`»",
		"`«module variable_(_)`»",
		"`«↓_`»",
		"`«↓_`»(_)",
		"`↑_",
		"arg`«_:_`»",
		"concatenate_",
		"current fiber",
		"current fiber can reject a parse",
		"current fiber[_]:=_",
		"enumeration of_",
		"fiber→_",
		"function accepting_and returning_",
		"high-precision timer value",
		"integer range from_(inclusive=_)to_(inclusive=_)",
		"literal token⇒_",
		"ln_",
		"method exists named_",
		"milliseconds since the Epoch",
		"new anonymous module importing_",
		"new_[_]",
		"new_applying_",
		"new`↑_",
		"non-canonical problem with_",
		"primfail`«_:_`»",
		"primitive description of_",
		"read_/write_",
		"termination requested",
		"{_`|_}",
		"{_→_`|_}",
		"∪_",
		"∪_[_.._]",
		"⌈_⌉",
		"⌊_⌋"
	)
Names
Body

/**
 * Is the specified {@type "atom"} special, i.e., well-known to the Avail
 * implementation?
 *
 * @category "Primitives"
 * @method "_is special"
 * @param "anAtom" "atom"
 *        An arbitrary {@type "atom"}.
 * @returns "boolean"
 *    {@method "true"} if {@param "anAtom"} is special, {@method "false"}
 *    otherwise.
 */
Primitive "_is special" is
[
	anAtom : atom
|
	Primitive AtomIsSpecial;
] : boolean;

/**
 * Answer the debug name of the specified atom.
 *
 * @category "Primitives" "Atoms" "Queries"
 * @method "_'s⁇name"
 * @param "anAtom" "atom"
 *        An atom.
 * @returns "string"
 *    The argument's debug name.
 */
Primitive "_'s⁇name" is
[
	anAtom : atom
|
	Primitive AtomName;
] : string;

/**
 * Is {@param "name"} a valid message? Do not attempt to look up a method
 * associated with this name. Simply verify that {@param "name"} is a viable
 * name of a method.
 *
 * @category "Primitives" "Methods" "Queries"
 * @method "_is a valid message"
 * @param "name" "atom"
 *        The name in question.
 * @returns "boolean"
 *    {@method "true"} if the argument is a valid message, {@method "false"}
 *    otherwise.
 */
Primitive "_is a valid message" is
[
	name : atom
|
	Primitive IsCanonicalMessage;
] : boolean;

/**
 * Answer the argument's Unicode code point.
 *
 * @category "Primitives" "Integers" "Unicode" "Conversions"
 * @method "_'s⁇code point"
 * @param "aCharacter" "character"
 *        A character.
 * @returns "[0..1114111]"
 *    The Unicode code point that encodes the argument.
 */
Primitive "_'s⁇code point" is
[
	aCharacter : character
|
	Primitive CharacterCodePoint;
] : code point;

/**
 * Answer the argument as a character.
 *
 * @category "Primitives" "Integers" "Unicode" "Conversions"
 * @method "_→character"
 * @param "codePoint" "[0..1114111]"
 *        A Unicode code point.
 * @returns "character"
 *    The character encoded by the argument.
 */
Primitive "_→character" is
[
	codePoint : code point
|
	Primitive CharacterFromCodePoint;
] : character;

/**
 * Answer the character type of the given character.  The character type is an
 * integer in the range [0..31], corresponding to
 * {@code "java.lang.Character.getType(int)"}.
 *
 * @category "Primitives"
 * @method "_'s⁇character type number"
 * @param "aCharacter" "character"
 *        The character to categorize.
 * @returns "[0..31]"
 *    The type of character that was provided, encoded as a value in [0..31].
 */
Primitive "_'s⁇character type number" is
[
	aCharacter : character
|
	Primitive CharacterType;
] : character type number;

/**
 * Construct and answer a variable that holds the caller of the specified
 * continuation. This variable will be unassigned if the continuation has no
 * caller.
 *
 * @category "Primitives" "Continuations" "Variables" "Constructors"
 * @method "_'s⁇caller"
 * @param "aContinuation" "$[…]→⊥"
 *        A continuation.
 * @returns "↑$[…]→⊥"
 *    A variable that, if assigned, holds the argument's caller. If unassigned,
 *    then the argument has no caller.
 */
Primitive "_'s⁇caller" is
[
	aContinuation : continuation
|
	Primitive ContinuationCaller;
] : continuation variable;

/**
 * Answer the current function of the specified continuation.
 *
 * @category "Primitives" "Continuations" "Queries"
 * @method "_'s⁇function"
 * @param "aContinuation" "$[…]→⊥"
 *        A continuation.
 * @returns "[…]→⊤"
 *    The argument's current function. This is the function whose execution
 *    will be resumed if the continuation is resumed.
 */
Primitive "_'s⁇function" is
[
	aContinuation : continuation
|
	Primitive ContinuationFunction;
] : function;

/**
 * Answer the program counter of the specified continuation. Using the current
 * function's tuple of Level One nybblecodes, this is the index of the next
 * instruction to be performed (if the continuation is resumed).
 *
 * @category "Primitives" "Continuations" "Queries"
 * @method "_'s⁇program counter"
 * @param "aContinuation" "$[…]→⊥"
 *        A continuation.
 * @returns "[1..∞)"
 *    The argument's Level One program counter.
 */
Primitive "_'s⁇program counter" is
[
	aContinuation : continuation
|
	Primitive ContinuationPC;
] : natural number;

/**
 * Answer the stack of the specified continuation. This tuple contains the
 * arguments, local variables, and temporaries. Any null values, forbidden to
 * leak through into observable Avail macro-state, are replaced with an
 * unassigned variable whose containment type is ⊥. Note that such a variable
 * cannot be constructed either syntactically nor through a variable
 * construction primitive.
 *
 * @category "Primitives" "Continuations" "Queries"
 * @method "_'s⁇stack"
 * @param "aContinuation" "$[…]→⊥"
 *        A continuation.
 * @returns "tuple"
 *    The argument's stack.
 */
Primitive "_'s⁇stack" is
[
	aContinuation : continuation
|
	Primitive ContinuationStackData;
] : tuple;

/**
 * Answer the stack pointer of the specified continuation. This is the index of
 * the top of the local stack. For an empty stack, this value equals the size of
 * the stack plus one. The stack grows downward.
 *
 * @category "Primitives" "Continuations" "Queries"
 * @method "_'s⁇stack pointer"
 * @param "aContinuation" "$[…]→⊥"
 *        A continuation.
 * @returns "[1..∞)"
 *    The argument's stack pointer.
 */
Primitive "_'s⁇stack pointer" is
[
	aContinuation : continuation
|
	Primitive ContinuationStackPointer;
] : natural number;

/**
 * Answer the type of the function represented by the specified continuation.
 *
 * @category "Primitives" "Types" "Continuations" "Queries"
 * @method "_'s⁇function type"
 * @param "continuationType" "($[…]→⊥)'s type"
 *        A continuation type.
 * @returns "([…]→⊤)'s type"
 *    The argument's current function's type.
 */
Primitive "_'s⁇function type" is
[
	continuationType : continuation meta
|
	Primitive ContinuationTypeToFunctionType;
] : function meta;

/**
 * Compute and answer a continuation type capable of representing a current
 * function of the specified type.
 *
 * @category "Primitives" "Types" "Continuations" "Constructors"
 * @method "$_"
 * @param "functionType" "([…]→⊤)'s type"
 *        A function type.
 * @returns "($[…]→⊥)'s type"
 *    The requested continuation type.
 */
Primitive "$_" is
[
	functionType : function meta
|
	Primitive FunctionTypeToContinuationType;
] : continuation meta;

/**
 * If the provided boolean is true, exit the ⊤-producing continuation. Execution
 * proceeds as though the continuation had just returned normally. The current
 * continuation (in which this primitive was invoked) is completely replaced by
 * the specified continuation's resumed caller.  If the provided boolean is
 * false, do nothing.
 *
 * @category "Primitives" "Continuations" "Control Structures"
 * @method "Exit_if_"
 * @param "aContinuation" "$[…]→⊤"
 *        The continuation to exit.
 * @param "condition" "boolean"
 *        Whether to exit.
 * @raises "⊤"
 */
Primitive "Exit_if_" is
[
	aContinuation : continuation returning top,
	condition : boolean
|
	Primitive ExitContinuationIf;
] : ⊤;

/**
 * Restart the continuation with its original arguments. Execution proceeds as
 * though the continuation's caller had just invoked the continuation's current
 * function with its original arguments. The current continuation (in which
 * this primitive was invoked) is completely replaced by the restarted
 * continuation.
 *
 * @category "Primitives" "Continuations" "Control Structures"
 * @method "Restart_"
 * @param "aContinuation" "$[…]→⊥"
 *        The continuation to restart.
 * @returns "⊥"
 */
Primitive "Restart_" is
[
	aContinuation : continuation
|
	Primitive RestartContinuation;
] : ⊥;

/**
 * Compute and answer the numeric argument as a double-precision floating point
 * number.
 *
 * @category "Primitives" "Numbers" "Conversions"
 * @method "_→double"
 * @param "aNumeric" "number"
 *        A number.
 * @returns "double"
 *    A {@type "double"} whose value approximates the argument.
 */
Primitive "_→double" is
[
	aNumeric : number
|
	Primitive AsDouble;
] : double;

/**
 * Compute and answer the smallest integral double-precision floating point
 * number greater than or equal to the argument, i.e., the ceiling of {@param "x"}.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "⌈_⌉"
 * @param "x" "double"
 *        A double-precision floating point number.
 * @returns "double"
 *    If the `0` is ±∞ or not-a-number, then {@param "x"}, otherwise the ceiling of
 *    {@param "x"}.
 */
Primitive "⌈_⌉" is
[
	x : double
|
	Primitive DoubleCeiling;
] : double;

/**
 * Compute and answer an approximation of the natural exponential function for
 * the given exponent, i.e., e^{@param "x"}.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "_^_"
 * @param "eulerNumber" "(2.718281828459045)'s type"
 *        Euler's number.
 * @param "x" "double"
 *        The exponent.
 * @returns "double"
 *    An approximation of e^{@param "x"}.
 */
Primitive "_^_" is
[
	eulerNumber : type of Euler number,
	x : double
|
	Primitive DoubleExp;
] : double;

/**
 * Compute and answer the largest integral double-precision floating point
 * number less than or equal to the argument, i.e., the floor of {@param
 * "x"}.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "⌊_⌋"
 * @param "x" "double"
 *        A double-precision floating point number.
 * @returns "double"
 *    If the `0` is ±∞ or not-a-number, then {@param "x"}, otherwise the
 *    floor of {@param "x"}.
 */
Primitive "⌊_⌋" is
[
	x : double
|
	Primitive DoubleFloor;
] : double;

/**
 * Reinterpret the 64-bit signed integer as the bit pattern of an IEEE-754
 * double-precision floating point number.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "_reinterpreted as double"
 * @param "anInt64" "[-9223372036854775808..9223372036854775807]"
 *        A 64-bit signed integer.
 * @returns "double"
 *    The double having the specified bit representation.
 */
Primitive "_reinterpreted as double" is
[
	anInt64 : int64
|
	Primitive DoubleFromLongBits;
] : double;

/**
 * Compute and answer an approximation of the natural logarithm of the argument,
 * i.e., ln {@param "x"}.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "ln_"
 * @param "x" "double"
 *        A double-precision floating point number.
 * @returns "double"
 *    An approximation of ln {@param "x"}.
 */
Primitive "ln_" is
[
	x : double
|
	Primitive DoubleLn;
] : double;

/**
 * Compute and answer an approximation of {@param "dividend"} modulo {@param "divisor"}, i.e. the
 * remainder produced by dividing the arguments.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "_mod_"
 * @param "dividend" "double"
 *        The dividend.
 * @param "divisor" "double"
 *        The divisor.
 * @returns "double"
 *    An approximation of `0` mod {@param "divisor"}.
 */
Primitive "_mod_" is
[
	dividend : double,
	divisor : double
|
	Primitive DoubleModulus;
] : double;

/**
 * Compute and answer {@param "a"}⨉(2^{@param "two"}) without loss of
 * precision or intermediate overflow. This scales {@param "a"} by a power
 * of two (`2`).
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "_⨉_^_"
 * @param "a" "double"
 *        A single-precision floating point number.
 * @param "two" "(2)'s type"
 *        The number two (`2`).
 * @param "b" "(-∞..∞)"
 *        The scaling factor.
 * @returns "double"
 *    The requested value.
 */
Primitive "_⨉_^_" is
[
	a : double,
	two : type of two,
	b : integer
|
	Primitive DoubleTimesTwoPower;
] : double;

/**
 * Treat the IEEE-754 double-precision floating point number's representation as
 * a 64 bit sequence, and answer the (signed) integer having those bits.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "_reinterpreted as bits"
 * @param "aDouble" "double"
 *        The double to reinterpret.
 * @returns "[-9223372036854775808..9223372036854775807]"
 *    The double's bit representation as a signed 64-bit integer.
 */
Primitive "_reinterpreted as bits" is
[
	aDouble : double
|
	Primitive DoubleToLongBits;
] : int64;

/**
 * Ascertain whether the current fiber can reject an ongoing parse.
 *
 * @category "Primitives" "Concurrency"
 * @method "current fiber can reject a parse"
 * @returns "boolean"
 *    `true` if the current fiber can reject a parse, `false`
 *    otherwise.
 */
Primitive "current fiber can reject a parse" is
[
	Primitive CanRejectParse;
] : boolean;

/**
 * Construct and answer a fiber type whose result type is {@param "resultType"}.
 *
 * @category "Primitives" "Types" "Concurrency"
 * @method "fiber→_"
 * @param "resultType" "(⊤)'s type"
 *        A type.
 * @returns "(fiber→⊤)'s type"
 *    The requested fiber type.
 */
Primitive "fiber→_" is
[
	resultType : type
|
	Primitive CreateFiberType;
] : fiber meta;

/**
 * Answer the current fiber.
 *
 * @category "Primitives" "Concurrency" "Queries"
 * @method "current fiber"
 * @returns "fiber→⊤"
 *    The current fiber.
 */
Primitive "current fiber" is
[
	Primitive CurrentFiber;
] : fiber;

/**
 * Answer the name of the specified fiber.
 *
 * @category "Primitives" "Concurrency" "Queries"
 * @method "_'s⁇name"
 * @param "aFiber" "fiber→⊤"
 *        A fiber.
 * @returns "string"
 *    The fiber's name.
 */
Primitive "_'s⁇name" is
[
	aFiber : fiber
|
	Primitive FiberName;
] : string;

/**
 * Answer the result type of the specified fiber type.
 *
 * @category "Primitives" "Types" "Concurrency" "Queries"
 * @method "_'s⁇result type"
 * @param "fiberType" "(fiber→⊤)'s type"
 *        A fiber type.
 * @returns "(⊤)'s type"
 *    The argument's result type.
 */
Primitive "_'s⁇result type" is
[
	fiberType : fiber meta
|
	Primitive FiberTypeResultType;
] : type;

/**
 * Extract the priority of a fiber. A fiber with higher priority may receive a
 * larger share of the available CPU time than one with a low priority.
 *
 * @category "Primitives" "Concurrency" "Queries"
 * @method "_'s⁇priority"
 * @param "aFiber" "fiber→⊤"
 *        The fiber from which to extract the priority.
 * @returns "[0..255]"
 *    A whole number representing the priority of the fiber.
 */
Primitive "_'s⁇priority" is
[
	aFiber : fiber
|
	Primitive GetFiberPriority;
] : byte;

/**
 * Does the specified fiber have a result ready?
 *
 * @category "Primitives" "Concurrency" "Queries"
 * @method "_has result"
 * @param "aFiber" "fiber→⊤"
 *        A fiber.
 * @returns "boolean"
 *    `true` if the fiber has terminated and produced a result, `false`
 *    otherwise.
 */
Primitive "_has result" is
[
	aFiber : fiber
|
	Primitive HasResult;
] : boolean;

/**
 * Has the specified fiber terminated?
 *
 * @category "Primitives" "Concurrency" "Queries"
 * @method "_has terminated"
 * @param "aFiber" "fiber→⊤"
 *        A fiber.
 * @returns "boolean"
 *    `true` if the fiber has terminated, `false` otherwise.
 */
Primitive "_has terminated" is
[
	aFiber : fiber
|
	Primitive HasTerminated;
] : boolean;

/**
 * Has termination of the current fiber been requested? Answer the current value
 * of the appropriate interrupt request flag and simultaneously clear it.
 *
 * @category "Primitives" "Concurrency" "Queries"
 * @method "termination requested"
 * @returns "boolean"
 *    `true` if termination of the current fiber has been requested, `false`
 *    otherwise.
 */
Primitive "termination requested" is
[
	Primitive IsTerminationRequested;
] : boolean;

/**
 * Attempt to acquire the permit associated with the current fiber. If the
 * permit is available, then consume it and return immediately. If the permit is
 * not available, then park the current fiber. A fiber suspended in this fashion
 * may be resumed only by calling `Unpark_`. A newly unparked fiber should
 * always recheck the basis for its having parked, to see if it should park
 * again. Low-level synchronization mechanisms may require the ability to
 * spuriously unpark in order to ensure correctness.
 *
 * @category "Primitives" "Concurrency" "Synchronization" "Control Structures"
 * @method "Park current fiber"
 * @returns "⊤"
 */
Primitive "Park current fiber" is
[
	Primitive ParkCurrentFiber;
] : ⊤;

/**
 * Request termination of the specified fiber, unparking the fiber at the same
 * time. Termination is consensual only; cooperation of the fiber is required to
 * affect actual termination.
 *
 * @category "Primitives" "Concurrency" "Mutators"
 * @method "Request termination of_"
 * @param "victim" "fiber→⊤"
 *        A fiber.
 * @returns "⊤"
 */
Primitive "Request termination of_" is
[
	victim : fiber
|
	Primitive RequestTermination;
] : ⊤;

/**
 * Set the name of the specified fiber.
 *
 * @category "Primitives" "Concurrency" "Mutators"
 * @method "_'s⁇name:=_"
 * @param "aFiber" "fiber→⊤"
 *        A fiber.
 * @param "name" "string"
 *        The fiber's new name.
 * @returns "⊤"
 */
Primitive "_'s⁇name:=_" is
[
	aFiber : fiber,
	name : string
|
	Primitive SetFiberName;
] : ⊤;

/**
 * Modify the priority of a fiber. A fiber with higher priority may receive a
 * larger share of the available CPU time than one with a low priority.
 *
 * @category "Primitives" "Concurrency" "Mutators"
 * @method "_'s⁇priority:=_"
 * @param "aFiber" "fiber→⊤"
 *        The fiber to prioritize.
 * @param "priority" "[0..255]"
 *        The new priority.
 * @returns "⊤"
 */
Primitive "_'s⁇priority:=_" is
[
	aFiber : fiber,
	priority : byte
|
	Primitive SetFiberPriority;
] : ⊤;

/**
 * Set the value bound to {@param "key"} in the current fiber's environment,
 * overwriting any previous value. Since the fiber's environment essentially
 * contains fiber-local variables (i.e. bindings from atoms to arbitrary
 * values), this operation effectively writes a fiber-local variable.
 *
 * @category "Primitives" "Concurrency" "Mutators"
 * @method "current fiber[_]:=_"
 * @param "key" "atom"
 *        The key whose value should be (over)written.
 * @param "value" "any"
 *        The new value.
 * @returns "⊤"
 */
Primitive "current fiber[_]:=_" is
[
	key : atom,
	value : any
|
	Primitive SetFiberVariable;
] : ⊤;

/**
 * Cause the current fiber to sleep for the specified number of milliseconds.
 * The fiber will sleep for at least the specified amount of time, and a best
 * effort will be made to awaken the fiber as soon as the delay has expired.
 * No real-time guarantees are made.
 *
 * @category "Primitives" "Concurrency" "Time" "Control Structures"
 * @method "Sleep for_millisecond|milliseconds"
 * @param "delayMillis" "[0..∞]"
 *        The minimum number of milliseconds to sleep.
 * @returns "⊤"
 */
Primitive "Sleep for_millisecond|milliseconds" is
[
	delayMillis : nonnegative extended integer
|
	Primitive Sleep;
] : ⊤;

/**
 * Terminate the current fiber.
 *
 * @category "Primitives" "Bootstrap" "Concurrency"
 * @method "Terminate current fiber"
 * @returns "⊥"
 */
Primitive "Terminate current fiber" is
[
	Primitive TerminateCurrentFiber;
] : ⊥;

/**
 * Unpark the specified fiber. If the permit associated with the fiber is
 * available, then simply continue. If the permit is not available, then restore
 * the permit and schedule resumption of the fiber. A newly unparked fiber
 * should always recheck the basis for its having parked, to see if it should
 * park again. Low-level synchronization mechanisms may require the ability to
 * spuriously unpark in order to ensure correctness.
 *
 * @category "Primitives" "Concurrency" "Synchronization" "Control Structures"
 * @method "Unpark_"
 * @param "aFiber" "fiber→⊤"
 *        A fiber.
 * @returns "⊤"
 */
Primitive "Unpark_" is
[
	aFiber : fiber
|
	Primitive UnparkFiber;
] : ⊤;

/**
 * Yield the current fiber. That is, give up the fiber's time slice so that
 * other processes of higher or equal priority may run.
 *
 * @category "Primitives" "Concurrency"
 * @method "Yield current fiber"
 * @returns "⊤"
 */
Primitive "Yield current fiber" is
[
	Primitive Yield;
] : ⊤;

/**
 * Compute and answer the numeric argument as a single-precision floating point
 * number.
 *
 * @category "Primitives" "Numbers" "Conversions"
 * @method "_→float"
 * @param "aNumber" "number"
 *        A number.
 * @returns "float"
 *    A {@type "float"} whose value approximates the argument.
 */
Primitive "_→float" is
[
	aNumber : number
|
	Primitive AsFloat;
] : float;

/**
 * Compute and answer the smallest integral single-precision floating point
 * number greater than or equal to the argument, i.e., the ceiling of {@param "x"}.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "⌈_⌉"
 * @param "x" "float"
 *        A single-precision floating point number.
 * @returns "float"
 *    If the `0` is ±∞ or not-a-number, then {@param "x"}, otherwise the
 *    ceiling of {@param "x"}.
 */
Primitive "⌈_⌉" is
[
	x : float
|
	Primitive FloatCeiling;
] : float;

/**
 * Compute and answer an approximation of the natural exponential function for
 * the given exponent, i.e., e^{@param "x"}.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "_^_"
 * @param "eulerNumber" "(2.718281828459045)'s type"
 *        Euler's number.
 * @param "x" "float"
 *        The exponent.
 * @returns "float"
 *    An approximation of e^{@param "x"}.
 */
Primitive "_^_" is
[
	eulerNumber : type of Euler number,
	x : float
|
	Primitive FloatExp;
] : float;

/**
 * Compute and answer the largest integral single-precision floating point
 * number less than or equal to the argument, i.e., the floor of {@param "x"}.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "⌊_⌋"
 * @param "x" "float"
 *        A single-precision floating point number.
 * @returns "float"
 *    If the `0` is ±∞ or not-a-number, then {@param "x"}, otherwise the
 *    floor of {@param "x"}.
 */
Primitive "⌊_⌋" is
[
	x : float
|
	Primitive FloatFloor;
] : float;

/**
 * Reinterpret the 32-bit signed integer as the bit pattern of an IEEE-754
 * floating point number.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "_reinterpreted as float"
 * @param "anInt32" "[-2147483648..2147483647]"
 *        A 32-bit signed integer.
 * @returns "float"
 *    The single-precision float having the specified bit representation.
 */
Primitive "_reinterpreted as float" is
[
	anInt32 : int32
|
	Primitive FloatFromIntBits;
] : float;

/**
 * Compute and answer an approximation of the natural logarithm of the argument,
 * i.e., ln {@param "x"}.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "ln_"
 * @param "x" "float"
 *        A single-precision floating point number.
 * @returns "float"
 *    An approximation of ln {@param "x"}.
 */
Primitive "ln_" is
[
	x : float
|
	Primitive FloatLn;
] : float;

/**
 * Compute and answer an approximation of {@param "dividend"} modulo {@param "divisor"}, i.e. the
 * remainder produced by dividing the arguments.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "_mod_"
 * @param "dividend" "float"
 *        The dividend.
 * @param "divisor" "float"
 *        The divisor.
 * @returns "float"
 *    An approximation of {@param "dividend"} mod {@param "divisor"}.
 */
Primitive "_mod_" is
[
	dividend : float,
	divisor : float
|
	Primitive FloatModulus;
] : float;

/**
 * Compute and answer {@param "a"}⨉(2^{@param "b"}) without loss of precision or
 * intermediate overflow. This scales {@param "a"} by a power of two (`2`).
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "_⨉_^_"
 * @param "a" "float"
 *        A single-precision floating point number.
 * @param "two" "(2)'s type"
 *        The number two (`2`).
 * @param "b" "(-∞..∞)"
 *        The scaling factor.
 * @returns "float"
 *    The requested value.
 */
Primitive "_⨉_^_" is
[
	a : float,
	two : type of two,
	b : integer
|
	Primitive FloatTimesTwoPower;
] : float;

/**
 * Treat the IEEE-754 single-precision float's representation as a 32 bit
 * sequence, and answer the (signed) integer having those bits.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "_reinterpreted as bits"
 * @param "aFloat" "float"
 *        The float to reinterpret.
 * @returns "[-2147483648..2147483647]"
 *    The float's bit representation as a signed 32-bit integer.
 */
Primitive "_reinterpreted as bits" is
[
	aFloat : float
|
	Primitive FloatToIntBits;
] : int32;

/**
 * Construct and answer a function type with the specified parameter types and
 * return type.
 *
 * @category "Primitives" "Types" "Functions" "Constructors"
 * @method "function accepting_and returning_"
 * @param "parameterTypes" "<(any)'s type…|>"
 *        The parameter types.
 * @param "returnType" "(⊤)'s type"
 *        The return type.
 * @returns "([…]→⊤)'s type"
 *    The requested function type. Instances of this type accept arguments
 *    whose types conform to the parameter types and whose return value
 *    conforms to the return type.
 */
Primitive "function accepting_and returning_" is
[
	parameterTypes : tuple of any meta,
	returnType : type
|
	Primitive CreateFunctionType;
] : function meta;

/**
 * Construct and answer a function type with the specified return type.
 * Instances of this type include any function that returns a value of the
 * specified return type, irrespective of the number or types of its parameters.
 *
 * @category "Primitives" "Types" "Functions" "Constructors"
 * @method "[`…]→_"
 * @param "returnType" "(⊤)'s type"
 *        A type.
 * @returns "([…]→⊤)'s type"
 *    The requested function type. Instances of this type answer values of the
 *    specified return type.
 */
Primitive "[`…]→_" is
[
	returnType : type
|
	Primitive CreateGeneralFunctionType;
] : function meta;

/**
 * Construct and answer a function that is an instance of {@param "aFunctionType"}
 * and applies {@param "functionToApply"} when itself applied with the appropriate
 * number and types of arguments. The new function answers whatever
 * {@param "functionToApply"} answers.
 *
 * @category "Primitives" "Functions" "Constructors"
 * @method "new_applying_"
 * @param "aFunctionType" "([…]→⊤)'s type"
 *        The desired function type.
 * @param "functionToApply" "[…]→⊤"
 *        The function that the new function will apply when itself applied with
 *        the correct number and types of arguments.
 * @returns "[…]→⊤"
 *    The requested function.
 */
Primitive "new_applying_" is
[
	aFunctionType : function meta,
	functionToApply : function
|
	Primitive CreateStubFunction;
] : function;

/**
 * Compute and answer a block phrase that represents the decompilation of the
 * specified function. Outer variables are treated as literals.
 *
 * @category "Primitives" "Phrases" "Functions" "Conversions"
 * @method "_→block phrase"
 * @param "aFunction" "[…]→⊤"
 *        A function.
 * @returns "block phrase⇒[…]→⊤"
 *    A block phrase.
 */
Primitive "_→block phrase" is
[
	aFunction : function
|
	Primitive DecompileFunction;
] : block phrase;

/**
 * Answer the message associated with the {@type "function"}.
 *
 * @category "Primitives"
 * @method "_'s⁇message"
 * @param "aFunction" "[…]→⊤"
 *        A {@type "function"}.
 * @returns "string"
 *    The name of the message associated with {@param "_'s⁇message"}.
 */
Primitive "_'s⁇message" is
[
	aFunction : function
|
	Primitive FunctionMessage;
] : string;

/**
 * Answer all variables captured by the specified function. For functions
 * compiled directly from source code (i.e. the vast majority of them), these
 * variables are lexically captured.
 *
 * @category "Primitives" "Functions" "Queries"
 * @method "_'s⁇outer variables"
 * @param "aFunction" "[…]→⊤"
 *        A function.
 * @returns "tuple"
 *    The argument's outer variables.
 */
Primitive "_'s⁇outer variables" is
[
	aFunction : function
|
	Primitive OuterVariables;
] : tuple;

/**
 * Answer a tuple type that describes the parameter types of the specified
 * function type.
 *
 * @category "Primitives" "Types" "Functions" "Queries"
 * @method "_'s⁇parameters'type"
 * @param "functionType" "([…]→⊤)'s type"
 *        A function type.
 * @returns "(tuple)'s type"
 *    A fixed-size tuple type whose element types correspond to the parameter
 *    types of the argument.
 */
Primitive "_'s⁇parameters'type" is
[
	functionType : function meta
|
	Primitive ParamsType;
] : tuple meta;

/**
 * Answer the return type of the specified function type.
 *
 * @category "Primitives" "Types" "Functions" "Queries"
 * @method "_'s⁇return type"
 * @param "functionType" "([…]→⊤)'s type"
 *        A function type.
 * @returns "(⊤)'s type"
 *    The return type of the argument.
 */
Primitive "_'s⁇return type" is
[
	functionType : function meta
|
	Primitive ReturnType;
] : type;

/**
 * Early assertion mechanism. This is obsolete once exceptions are available.
 * Raise a special exception in the virtual machine that may be trapped to
 * facilitate debugging. This exception will provided access to {@param "message"}.
 *
 * @category "Primitives" "Bootstrap" "Assertions"
 * @method "Assert:_(_)"
 * @param "predicate" "boolean"
 *        A boolean, usually derived from a more complex predicate expression.
 * @param "message" "string"
 *        Text describing the assertion failure, ignored unless {@param
 *        "predicate"} is `false`.
 * @returns "⊤"
 */
Primitive "Assert:_(_)" is
[
	predicate : boolean,
	message : string
|
	Primitive Assert;
] : ⊤;

/**
 * Cause the Avail virtual machine to raise an
 * `org.availlang.exceptions.AvailBreakpointException` that a Java debugger
 * can trap upon raise.
 *
 * This method exists to facilitate debugging of the Avail virtual machine, and
 * will be withdrawn once the implementation is considered sufficiently stable.
 *
 * @category "Primitives" "Bootstrap"
 * @method "Breakpoint"
 * @returns "⊤"
 */
Primitive "Breakpoint" is
[
	Primitive BreakPoint;
] : ⊤;

/**
 * Answer the number of milliseconds which have elapsed since midnight
 * Coordinated Universal Time (UTC) of Thursday, January 1, 1970 (i.e. the Unix
 * Epoch).
 *
 * @category "Primitives" "Time" "Queries"
 * @method "milliseconds since the Epoch"
 * @returns "[0..∞)"
 *    The current time as the number of milliseconds which have elapsed since
 *    the Unix Epoch.
 */
Primitive "milliseconds since the Epoch" is
[
	Primitive CurrentTimeMilliseconds;
] : whole number;

/**
 * Answer the current value of the high-precision timer. The answer has
 * nanosecond precision, but not necessarily nanosecond resolution; the actual
 * resolution is implementation-dependent. The high-precision timer does not
 * have a fixed reference frame, so it should generally only be used to measure
 * the time elapsed between two invocations.
 *
 * @category "Primitives" "Time" "Queries"
 * @method "high-precision timer value"
 * @returns "[0..∞)"
 *    The current value of the high-precision timer, in nanoseconds.
 */
Primitive "high-precision timer value" is
[
	Primitive CurrentTimeNanoseconds;
] : whole number;

/**
 * Crash the current fiber. Use the specified value to provide contextual
 * debugging information.
 *
 * This method must not leak beyond the bootstrap package. Termination of
 * fibers is dangerous because it avoids cleaning up active continuations and
 * ergo promotes deadlock (by failing to relinquish held locks). Only
 * cooperative termination, e.g. interrupt queues, is supported in ordinary
 * system or application code. This method is provided only for early detection
 * of serious failures in bootstrap code. Real failures in system code outside
 * of the bootstrap package use Avail's usual exception handling machinery.
 *
 * @category "Primitives" "Bootstrap" "Exceptions"
 * @method "Crash:_"
 * @param "value" "any"
 *        A value, provided to establish context for debugging.
 * @returns "⊥"
 */
Primitive "Crash:_" is
[
	value : any
|
	Primitive EmergencyExit;
] : ⊥;

/**
 * Are the arguments equal?
 *
 * @category "Primitives" "Mathematics" "Relations"
 * @method "_=_"
 * @param "arg1" "any"
 *        A value.
 * @param "arg2" "any"
 *        A value.
 * @returns "boolean"
 *    `true` if the arguments are equal, `false` otherwise.
 */
Primitive "_=_" is
[
	arg1 : any,
	arg2 : any
|
	Primitive Equality;
] : boolean;

/**
 * Answer the hash value of {@param "value"}. The hash values of equal values
 * are always themselves equal. The hash values of differing values will tend
 * to differ, but the pigeonhole principle means that hashing a larger key space
 * into a smaller hash space will lead to occasional collisions.
 *
 * The actual hash value is currently an instance of {@type "[-2^31..2^31)"},
 * but the weaker type is used to facilitate forward migration to larger hash
 * spaces.
 *
 * @category "Primitives"
 * @method "_'s⁇hash"
 * @param "value" "any"
 *        An arbitrary value.
 * @returns "[-2147483648..2147483647]"
 *    The hash value of the argument.
 */
Primitive "_'s⁇hash" is
[
	value : any
|
	Primitive Hash;
] : int32;

/**
 * Does the argument denote a valid primitive?
 *
 * @category "Primitives" "Methods" "Queries"
 * @method "_is a primitive"
 * @param "primitiveName" "string"
 *        A potential primitive name.
 * @returns "boolean"
 *    `true` if the argument denotes a valid primitive, `false` otherwise.
 */
Primitive "_is a primitive" is
[
	primitiveName : string
|
	Primitive IsPrimitiveDefined;
] : boolean;

/**
 * Render the argument into JSON.
 *
 * @category "Primitives"
 * @method "_→JSON"
 * @param "value" "any"
 *        An arbitrary value.
 * @returns "string"
 *    A string containing the JSON representation of {@param "value"}.
 */
Primitive "_→JSON" is
[
	value : any
|
	Primitive ToJSON;
] : string;

/**
 * Produce a primitive description of the argument. This description is
 * mechanically constructed by the Avail virtual machine. It may not contain
 * appropriately localized text, and is intended to provide
 * implementation-specific information that serves only to assist the
 * Avail virtual machine developers in debugging the implementation.
 *
 * @category "Primitives" "Stringification"
 * @method "primitive description of_"
 * @param "value" "any"
 *        A value.
 * @returns "string"
 *    A mechanically constructed, possibly non-localized,
 *    implementation-specific description of the argument.
 */
Primitive "primitive description of_" is
[
	value : any
|
	Primitive ToString;
] : string;

/**
 * Compute and answer the bitwise {@code "AND"} of the arguments.
 *
 * @category "Primitives" "Numbers" "Integers" "Mathematics" "Bits"
 * @method "_bit∧_"
 * @param "arg1" "(-∞..∞)"
 *        An integer.
 * @param "arg2" "(-∞..∞)"
 *        An integer.
 * @returns "(-∞..∞)"
 *    The bitwise AND of {@param "arg1"} and {@param "arg2"}.
 */
Primitive "_bit∧_" is
[
	arg1 : integer,
	arg2 : integer
|
	Primitive BitwiseAnd;
] : integer;

/**
 * Compute and answer the bitwise {@code "OR"} of the arguments.
 *
 * @category "Primitives" "Numbers" "Integers" "Mathematics" "Bits"
 * @method "_bit∨_"
 * @param "arg1" "(-∞..∞)"
 *        An integer.
 * @param "arg2" "(-∞..∞)"
 *        An integer.
 * @returns "(-∞..∞)"
 *    The bitwise OR of {@param "arg1"} and {@param "arg2"}.
 */
Primitive "_bit∨_" is
[
	arg1 : integer,
	arg2 : integer
|
	Primitive BitwiseOr;
] : integer;

/**
 * Compute and answer the bitwise {@code "XOR"} of the arguments.
 *
 * @category "Primitives" "Numbers" "Integers" "Mathematics" "Bits"
 * @method "_bit⊕_"
 * @param "arg1" "(-∞..∞)"
 *        An integer.
 * @param "arg2" "(-∞..∞)"
 *        An integer.
 * @returns "(-∞..∞)"
 *    The bitwise XOR of {@param "arg1"} and {@param "arg2"}.
 */
Primitive "_bit⊕_" is
[
	arg1 : integer,
	arg2 : integer
|
	Primitive BitwiseXor;
] : integer;

/**
 * Construct and answer an integral range type whose lower bound is {@param "lowerBound"}
 * and whose upper bound is {@param "upperBound"}.
 *
 * @category "Primitives" "Numbers" "Types" "Constructors"
 * @method "integer range from_(inclusive=_)to_(inclusive=_)"
 * @param "lowerBound" "[-∞..∞]"
 *        The lower bound.
 * @param "lowerBoundInclusive" "boolean"
 *        `true` if the lower bound should be adjudged inclusive, `false`
 *        otherwise.
 * @param "upperBound" "[-∞..∞]"
 *        The upper bound.
 * @param "upperBoundInclusive" "boolean"
 *        `true` if the upper bound should be adjudged inclusive, `false`
 *        otherwise.
 * @returns "([-∞..∞])'s type"
 *    The requested integral range type.
 */
Primitive "integer range from_(inclusive=_)to_(inclusive=_)" is
[
	lowerBound : extended integer,
	lowerBoundInclusive : boolean,
	upperBound : extended integer,
	upperBoundInclusive : boolean
|
	Primitive CreateIntegerRange;
] : extended integer meta;

/**
 * Answer the lower bound of the specified integral range type.
 *
 * @category "Primitives" "Numbers" "Types" "Queries"
 * @method "_'s⁇genuine lower bound"
 * @param "range" "([-∞..∞])'s type"
 *        An integral range type.
 * @returns "[-∞..∞]"
 *    The lower bound of the argument.
 */
Primitive "_'s⁇genuine lower bound" is
[
	range : extended integer meta
|
	Primitive LowerBound;
] : extended integer;

/**
 * Answer the upper bound of the specified integral range type.
 *
 * @category "Primitives" "Numbers" "Types" "Queries"
 * @method "_'s⁇genuine upper bound"
 * @param "range" "([-∞..∞])'s type"
 *        An integral range type.
 * @returns "[-∞..∞]"
 *    The upper bound of the argument.
 */
Primitive "_'s⁇genuine upper bound" is
[
	range : extended integer meta
|
	Primitive UpperBound;
] : extended integer;

/**
 * Construct and answer a map from the supplied tuple of bindings.
 *
 * @category "Primitives" "Maps" "Constructors"
 * @method "_→map"
 * @param "bindings" "<<any…|2>…|>"
 *        A tuple of bindings. Each element of the argument is a
 *       2-tuple that represents a binding. The first element of each 2-tuple is
 *       a key, the second element is the value that should be bound to that key
 *       in the resultant map.
 * @returns "map"
 *    The requested map.
 */
Primitive "_→map" is
[
	bindings : key-value tuple
|
	Primitive CreateMap;
] : map;

/**
 * Construct and answer a map type with the specified key type, value type, and
 * range of cardinalities.
 *
 * @category "Primitives" "Types" "Maps" "Constructors"
 * @method "{_→_`|_}"
 * @param "keyType" "(any)'s type"
 *        A type to which all keys of instances must conform.
 * @param "valueType" "(any)'s type"
 *        A type to which all values of instances must conform.
 * @param "cardinalityType" "([0..∞))'s type"
 *        The range of cardinalities to which all instances must
 *       conform.
 * @returns "(map)'s type"
 *    The requested map type.
 */
Primitive "{_→_`|_}" is
[
	keyType : any meta,
	valueType : any meta,
	cardinalityType : whole number meta
|
	Primitive CreateMapType;
] : map meta;

/**
 * Is {@param "key"} a member of the set of keys of {@param "aMap"}?
 *
 * @category "Primitives" "Maps" "Queries"
 * @method "_∈_"
 * @param "key" "any"
 *        The key whose membership should be queried.
 * @param "aMap" "map"
 *        A map.
 * @returns "boolean"
 *    `true` if {@param "key"} if a key of {@param "aMap"}, `false`
 *    otherwise.
 */
Primitive "_∈_" is
[
	key : any,
	aMap : map
|
	Primitive KeyInMap;
] : boolean;

/**
 * Answer a tuple containing the bindings of the specified map. A binding is a
 * 2-tuple of key and value.
 *
 * @category "Primitives" "Maps" "Queries"
 * @method "_'s⁇bindings"
 * @param "aMapType" "map"
 *        A map.
 * @returns "<<any…|2>…|>"
 *    The argument's bindings.
 */
Primitive "_'s⁇bindings" is
[
	aMapType : map
|
	Primitive MapBindings;
] : key-value tuple;

/**
 * Answer the set of keys of the specified map.
 *
 * @category "Primitives" "Maps" "Queries"
 * @method "_'s⁇keys"
 * @param "aMap" "map"
 *        A map.
 * @returns "set"
 *    The argument's keys.
 */
Primitive "_'s⁇keys" is
[
	aMap : map
|
	Primitive MapKeysAsSet;
] : set;

/**
 * Construct and answer a map that is based on the supplied map. The answer
 * (potentially) differs from the argument in that it contains a binding from
 * {@param "key"} to {@param "value"}; any value previously bound to
 * {@param "key"} is "forgotten" in the new map.
 *
 * @category "Primitives" "Maps" "Transformers"
 * @method "_+_→_"
 * @param "aMap" "map"
 *        A map.
 * @param "key" "any"
 *        A key.
 * @param "value" "any"
 *        The new value for the key.
 * @returns "{any→any|1..∞}"
 *    The requested map.
 */
Primitive "_+_→_" is
[
	aMap : map,
	key : any,
	value : any
|
	Primitive MapReplacingKey;
] : non-empty map;

/**
 * Answer the cardinality of the specified map.
 *
 * @category "Primitives" "Maps" "Queries"
 * @method "`|_`|"
 * @param "aMap" "map"
 *        A map.
 * @returns "[0..∞)"
 *    The argument's cardinality.
 */
Primitive "`|_`|" is
[
	aMap : map
|
	Primitive MapSize;
] : whole number;

/**
 * Answer the most specific type to which the keys of all instances must
 * conform.
 *
 * @category "Primitives" "Types" "Maps" "Queries"
 * @method "_'s⁇key type"
 * @param "aMapType" "(map)'s type"
 *        A map type.
 * @returns "(any)'s type"
 *    The argument's key type.
 */
Primitive "_'s⁇key type" is
[
	aMapType : map meta
|
	Primitive MapTypeKeyType;
] : any meta;

/**
 * Answer the acceptable range of cardinalities for instances of the specified
 * map type.
 *
 * @category "Primitives" "Types" "Maps" "Queries"
 * @method "`|`|_`|`|"
 * @param "aMapType" "(map)'s type"
 *        A map type.
 * @returns "([0..∞))'s type"
 *    The argument's cardinality requirement.
 */
Primitive "`|`|_`|`|" is
[
	aMapType : map meta
|
	Primitive MapTypeSizes;
] : whole number meta;

/**
 * Answer the most specific type to which the values of all instances must
 * conform.
 *
 * @category "Primitives" "Types" "Maps" "Queries"
 * @method "_'s⁇value type"
 * @param "aMapType" "(map)'s type"
 *        A map type.
 * @returns "(any)'s type"
 *    The argument's value type.
 */
Primitive "_'s⁇value type" is
[
	aMapType : map meta
|
	Primitive MapTypeValueType;
] : any meta;

/**
 * Answer a tuple containing the values of the specified map. The values are
 * arranged in no particular order.
 *
 * @category "Primitives" "Maps" "Queries"
 * @method "_'s⁇values"
 * @param "aMapType" "map"
 *        A map.
 * @returns "tuple"
 *    The argument's values.
 */
Primitive "_'s⁇values" is
[
	aMapType : map
|
	Primitive MapValuesAsTuple;
] : tuple;

/**
 * Construct and answer a map that is based on the supplied map. The answer
 * (potentially) differs from the argument in that it does not contain a
 * binding for {@param "key"}; any such previous binding is "forgotten" in the new map.
 *
 * @category "Primitives" "Maps" "Transformers"
 * @method "_-_"
 * @param "aMap" "map"
 *        A map.
 * @param "key" "any"
 *        A key whose binding should be omitted.
 * @returns "map"
 *    The requested map.
 */
Primitive "_-_" is
[
	aMap : map,
	key : any
|
	Primitive MapWithoutKey;
] : map;

/**
 * Answer the number of parameters required by the specified method.
 *
 * @category "Primitives" "Methods" "Queries"
 * @method "`|_'s⁇parameters`|"
 * @param "aMessageBundle" "message bundle"
 *        A method.
 * @returns "[0..∞)"
 *    The number of parameters required by the specified method.
 */
Primitive "`|_'s⁇parameters`|" is
[
	aMessageBundle : message bundle
|
	Primitive BundleParametersCount;
] : whole number;

/**
 * Answer the specified definition's function type.
 *
 * @category "Primitives" "Definitions" "Queries"
 * @method "_'s⁇function type"
 * @param "aDefinition" "definition"
 *        Any definition (method, macro, abstract, forward).
 * @returns "([…]→⊤)'s type"
 *    The requested function type.
 */
Primitive "_'s⁇function type" is
[
	aDefinition : definition
|
	Primitive DefinitionBodySignature;
] : function meta;

/**
 * Describe why the given proposed message name is invalid.
 *
 * @category "Primitives"
 * @method "non-canonical problem with_"
 * @param "messageName" "string"
 *        The proposed message name.
 * @returns "string"
 *    A string describing the malformation of the proposed message name, or the
 *    empty string if it is well-formed.
 */
Primitive "non-canonical problem with_" is
[
	messageName : string
|
	Primitive DescribeNoncanonicalMessage;
] : string;

/**
 * Is there a method bound to the specified name?
 *
 * @category "Primitives" "Atoms" "Methods" "Queries"
 * @method "method exists named_"
 * @param "trueName" "atom"
 *        An atom.
 * @returns "boolean"
 *    `true` if {@param "trueName"} names a method, `false` otherwise.
 */
Primitive "method exists named_" is
[
	trueName : atom
|
	Primitive ExistsMethodWithName;
] : boolean;

/**
 * Answer the atom that uniquely identifies the specified message bundle.
 *
 * @category "Primitives" "Atoms" "Queries"
 * @method "_'s⁇atom"
 * @param "aMessageBundle" "message bundle"
 *        A message bundle for some method.
 * @returns "atom"
 *    The requested atom.
 */
Primitive "_'s⁇atom" is
[
	aMessageBundle : message bundle
|
	Primitive MessageBundleName;
] : atom;

/**
 * Answer the specified method definition's function.
 *
 * @category "Primitives" "Definitions" "Queries"
 * @method "_'s⁇function"
 * @param "aDefinition" "method definition"
 *        A method definition.
 * @returns "[…]→⊤"
 *    The requested function.
 */
Primitive "_'s⁇function" is
[
	aDefinition : method definition
|
	Primitive MethodDefinitionBody;
] : function;

/**
 * Answer the {@type "definition"}s of the specified {@type "method"}.
 *
 * @category "Primitives"
 * @method "_'s⁇definitions"
 * @param "aMethod" "method"
 *        An arbitrary {@type "method"}.
 * @returns "<definition…|>"
 *    A {@type "tuple"} of {@type "definition"}s.
 */
Primitive "_'s⁇definitions" is
[
	aMethod : method
|
	Primitive MethodDefinitions;
] : tuple of definition;

/**
 * Answer all seals applied to the specified method.
 *
 * @category "Primitives" "Methods" "Queries"
 * @method "_'s⁇seals"
 * @param "aMethod" "method"
 *        A method.
 * @returns "<<(any)'s type…|>…|>"
 *    A tuple comprising the seals applied to {@param "aMethod"}.
 */
Primitive "_'s⁇seals" is
[
	aMethod : method
|
	Primitive Seals;
] : tuple of tuple of any meta;

/**
 * Create an anonymous {@type "module"} that privately imports only and exactly
 * the supplied {@type "set"} of {@type "atom" atoms}.
 *
 * @category "Primitives" "Modules"
 * @method "new anonymous module importing_"
 * @param "allImports" "{atom|}"
 *        Every atom to be imported privately by the new module.
 * @returns "module"
 *    The new module.
 */
Primitive "new anonymous module importing_" is
[
	allImports : set of atom
|
	Primitive CreateAnonymousModule;
] : module;

/**
 * Answer the entry points introduced by the specified module.
 *
 * @category "Primitives"
 * @method "_'s⁇entry points"
 * @param "aModule" "module"
 *        A module.
 * @returns "{string|}"
 *    A set containing the entry point names introduced by {@param "aModule"}
 */
Primitive "_'s⁇entry points" is
[
	aModule : module
|
	Primitive Entries;
] : set of string;

/**
 * Determine whether the provided module defines an atom with the given name.
 *
 * @category "Primitives"
 * @method "_has public name_"
 * @param "aModule" "module"
 *        The module to examine.
 * @param "aString" "string"
 *        The name to look for in the module's new names.
 * @returns "boolean"
 *    Whether the name was defined in the module.
 */
Primitive "_has public name_" is
[
	aModule : module,
	aString : string
|
	Primitive HasNewName;
] : boolean;

/**
 * Determine whether the {@type "module"} is still open to the performance of
 * further side effects upon it.
 *
 * @category "Primitives" "Modules"
 * @method "_is open for side effects"
 * @param "aModule" "module"
 *        The module to query for openness.
 * @returns "boolean"
 *    {@method "true"} if {@param "aModule"} is open, {@method "false"} otherwise.
 */
Primitive "_is open for side effects" is
[
	aModule : module
|
	Primitive IsModuleOpen;
] : boolean;

/**
 * Answer the fully qualified name of the specified module.
 *
 * @category "Primitives" "Modules" "Queries"
 * @method "_'s⁇name"
 * @param "aModule" "module"
 *        A module.
 * @returns "string"
 *    The fully qualified name of {@param "aModule"}.
 */
Primitive "_'s⁇name" is
[
	aModule : module
|
	Primitive ModuleName;
] : string;

/**
 * Answer the public names introduced by the specified module.  This is a map
 * from string to atom.
 *
 * @category "Primitives" "Modules" "Queries"
 * @method "_'s⁇public names"
 * @param "aModule" "module"
 *        A module.
 * @returns "{string→atom|}"
 *    A map containing the public names introduced by {@param "aModule"}.
 */
Primitive "_'s⁇public names" is
[
	aModule : module
|
	Primitive NewNames;
] : map from string to atom;

/**
 * Is the first argument less than or equal to the second argument?
 *
 * @category "Primitives" "Numbers" "Mathematics" "Relations"
 * @method "_≤_"
 * @param "arg1" "number"
 *        A number.
 * @param "arg2" "number"
 *        A number.
 * @returns "boolean"
 *    `true` if the first argument is less than or equal to the second
 *    argument, `false` otherwise.
 */
Primitive "_≤_" is
[
	arg1 : number,
	arg2 : number
|
	Primitive LessOrEqual;
] : boolean;

/**
 * Is the first argument strictly less than the second argument?
 *
 * @category "Primitives" "Numbers" "Mathematics" "Relations"
 * @method "_<_"
 * @param "arg1" "number"
 *        A number.
 * @param "arg2" "number"
 *        A number.
 * @returns "boolean"
 *    `true` if the first argument is strictly less than the second argument,
 *    `false` otherwise.
 */
Primitive "_<_" is
[
	arg1 : number,
	arg2 : number
|
	Primitive LessThan;
] : boolean;

/**
 * Construct and answer an object based on the supplied map.
 *
 * @category "Primitives" "Objects" "Constructors"
 * @method "_→object"
 * @param "fieldsToValues" "{atom→any|}"
 *        A map whose keys are the fields of the new object and whose values are
 *        the corresponding field values.
 * @returns "object"
 *    The requested object.
 */
Primitive "_→object" is
[
	fieldsToValues : field map
|
	Primitive MapToObject;
] : object;

/**
 * Construct and answer an object type based on the supplied map.
 *
 * @category "Primitives" "Types" "Objects" "Maps" "Conversions"
 * @method "_→object type"
 * @param "fieldsToTypes" "{atom→(any)'s type|}"
 *        A map whose keys are the fields of the new object and whose values are
 *        the corresponding field types.
 * @returns "(object)'s type"
 *    The requested object type.
 */
Primitive "_→object type" is
[
	fieldsToTypes : field type map
|
	Primitive MapToObjectType;
] : object meta;

/**
 * Construct and answer a map based on the supplied object.
 *
 * @category "Primitives" "Objects" "Maps" "Conversions"
 * @method "_→map"
 * @param "anObject" "object"
 *        An object whose fields should be the keys of the new map and whose
 *        values are the corresponding values.
 * @returns "{atom→any|}"
 *    The requested map.
 */
Primitive "_→map" is
[
	anObject : object
|
	Primitive ObjectToMap;
] : field map;

/**
 * Construct and answer a tuple based on the supplied object.
 *
 * @category "Primitives" "Tuples" "Objects" "Conversions"
 * @method "_→tuple"
 * @param "anObject" "object"
 *        An object.
 * @returns "<<atom, any…|2>…|>"
 *    A tuple that represents the composition of the object. Its elements are
 *    2-tuples. Each 2-tuple's first element is an atom (i.e., the field
 *    identifier) and its second element is associated value.
 */
Primitive "_→tuple" is
[
	anObject : object
|
	Primitive ObjectToTuple;
] : field tuple;

/**
 * For the purpose of debugging, bind a name to an object type. This name will
 * be used for subtypes that do not bind a more specific name to describe their
 * own subtypes.
 *
 * @category "Primitives" "Types" "Objects" "Mutators"
 * @method "_'s⁇name:=_"
 * @param "anObjectType" "(object)'s type"
 *        An object type.
 * @param "name" "string"
 *        The name that should be bound to the object type. This will replace
 *        a previously bound name.
 * @returns "⊤"
 */
Primitive "_'s⁇name:=_" is
[
	anObjectType : object meta,
	name : string
|
	Primitive RecordNewTypeName;
] : ⊤;

/**
 * Unbind the specified name from the specified object type.  This undoes the
 * action of {@method "_'s⁇name:=_"}, generally as an unloading action for a
 * {@type "module"}.
 *
 * @category "Primitives" "Types" "Objects" "Mutators"
 * @method "Unname_from_"
 * @param "name" "string"
 *        The name that should no longer be bound to the object type.
 * @param "anObjectType" "(object)'s type"
 *        An object type.
 * @returns "⊤"
 */
Primitive "Unname_from_" is
[
	name : string,
	anObjectType : object meta
|
	Primitive RemoveTypeName;
] : ⊤;

/**
 * Construct and answer an object based on the supplied tuple.
 *
 * @category "Primitives" "Tuples" "Objects" "Conversions"
 * @method "_→object"
 * @param "fieldAssignments" "<<atom, any…|2>…|>"
 *        A tuple whose elements are 2-tuples. Each 2-tuple's first element is
 *        an atom (i.e., the field identifier) and its second element is
 *        associated value.
 * @returns "object"
 *    The requested object.
 */
Primitive "_→object" is
[
	fieldAssignments : field tuple
|
	Primitive TupleToObject;
] : object;

/**
 * Construct and answer an object type based on the supplied tuple.
 *
 * @category "Primitives" "Types" "Tuples" "Objects" "Conversions"
 * @method "_→object type"
 * @param "fieldDefinitions" "<<atom, (any)'s type…|2>…|>"
 *        A tuple whose elements are 2-tuples. Each 2-tuple's first element is
 *        an atom (i.e., the field identifier) and its second element is the
 *        value type permitted by the field.
 * @returns "(object)'s type"
 *    The requested object type.
 */
Primitive "_→object type" is
[
	fieldDefinitions : field type tuple
|
	Primitive TupleToObjectType;
] : object meta;

/**
 * Answer the set of locally most-specific names bound to the specified object
 * type.
 *
 * @category "Primitives" "Types" "Objects" "Queries"
 * @method "_'s⁇names"
 * @param "anObjectType" "(object)'s type"
 *        An object type.
 * @returns "{string|}"
 *    The set of locally most-specific names bound to the specified object
 *    type.
 */
Primitive "_'s⁇names" is
[
	anObjectType : object meta
|
	Primitive TypeNames;
] : set of string;

/**
 * Answer the specified assignment's target variable.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s⁇target"
 * @param "anAssignment" "assignment phrase⇒⊤"
 *        An assignment.
 * @returns "variable use phrase⇒any"
 *    The assignment's target variable.
 */
Primitive "_'s⁇target" is
[
	anAssignment : assignment phrase
|
	Primitive AssignmentTarget;
] : variable use phrase;

/**
 * Answer the specified assignment's value expression.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s⁇value"
 * @param "anAssignment" "assignment phrase⇒⊤"
 *        An assignment.
 * @returns "expression phrase⇒any"
 *    The assignment's value expression.
 */
Primitive "_'s⁇value" is
[
	anAssignment : assignment phrase
|
	Primitive AssignmentValue;
] : expression yielding any;

/**
 * Answer the arguments of the specified block.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s⁇arguments"
 * @param "aBlock" "block phrase⇒[…]→⊤"
 *        A block.
 * @returns "<argument phrase⇒⊤…|>"
 *    A tuple of argument declarations.
 */
Primitive "_'s⁇arguments" is
[
	aBlock : block phrase
|
	Primitive BlockArguments;
] : argument tuple;

/**
 * Answer the declared exceptions of the specified block.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s⁇declared exceptions"
 * @param "aBlock" "block phrase⇒[…]→⊤"
 *        A block.
 * @returns "{exception|}"
 *    The block's set of declared exceptions.
 */
Primitive "_'s⁇declared exceptions" is
[
	aBlock : block phrase
|
	Primitive BlockDeclaredExceptions;
] : set of exception;

/**
 * Answer the specified block's outer variables.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s⁇outer variables"
 * @param "aBlock" "block phrase⇒[…]→⊤"
 *        A block.
 * @returns "<declaration phrase⇒⊤…|>"
 *    A tuple of declarations of outer variables required to complete the
 *    meaning of the block.
 */
Primitive "_'s⁇outer variables" is
[
	aBlock : block phrase
|
	Primitive BlockNeededVariables;
] : declaration tuple;

/**
 * Extract the name of the primitive used by this block phrase, or the empty
 * string if the block does not specify a primitive.
 *
 * @category "Primitives"
 * @method "_'s⁇primitive name"
 * @param "aBlock" "block phrase⇒[…]→⊤"
 *        The block phrase to examine.
 * @returns "string"
 *    Either the name of this block phrase's primitive or the empty string.
 */
Primitive "_'s⁇primitive name" is
[
	aBlock : block phrase
|
	Primitive BlockPrimitiveName;
] : string;

/**
 * Answer the return type of the specified block.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s⁇return type"
 * @param "aBlock" "block phrase⇒[…]→⊤"
 *        A block.
 * @returns "(⊤)'s type"
 *    The block's return type.
 */
Primitive "_'s⁇return type" is
[
	aBlock : block phrase
|
	Primitive BlockReturnType;
] : type;

/**
 * Answer the statements of the specified block.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s⁇statements"
 * @param "aBlock" "block phrase⇒[…]→⊤"
 *        A block.
 * @returns "<phrase⇒⊤…|>"
 *    A tuple of statements. These are either assignments, declarations, labels,
 *    sequences, or ⊤-valued sends.
 */
Primitive "_'s⁇statements" is
[
	aBlock : block phrase
|
	Primitive BlockStatements;
] : phrase tuple;

/**
 * Construct and answer an argument declaration.
 *
 * @category "Primitives" "Phrases" "Constructors"
 * @method "arg`«_:_`»"
 * @param "name" "token"
 *        The name of the new constant.
 * @param "declaredType" "(any)'s type"
 *        The declared type of the named constant.
 * @returns "argument phrase⇒⊤"
 *    The requested argument declaration.
 */
Primitive "arg`«_:_`»" is
[
	name : token,
	declaredType : any meta
|
	Primitive CreateArgumentDeclaration;
] : argument phrase;

/**
 * Convert the {@type "expression phrase⇒⊤"} into a
 * {@type "expression as statement phrase⇒⊤"}.
 *
 * @category "Primitives"
 * @method "_→statement phrase"
 * @param "expr" "expression phrase⇒⊤"
 *        An {@type "expression phrase⇒⊤"}.
 * @returns "expression as statement phrase⇒⊤"
 *    The wrapping {@type "expression as statement phrase⇒⊤"}.
 */
Primitive "_→statement phrase" is
[
	expr : expression phrase
|
	Primitive CreateExpressionAsStatementPhrase;
] : expression as statement phrase;

/**
 * Construct and answer an initialized local variable declaration.
 *
 * @category "Primitives" "Phrases" "Constructors"
 * @method "`«_:_:=_`»"
 * @param "name" "token"
 *        The name of the new variable.
 * @param "declaredType" "(any)'s type"
 *        The declared type of the named variable.
 * @param "initializer" "expression phrase⇒any"
 *        The initialization expression.
 * @returns "local variable phrase⇒⊤"
 *    The requested initialized local variable declaration.
 */
Primitive "`«_:_:=_`»" is
[
	name : token,
	declaredType : any meta,
	initializer : expression yielding any
|
	Primitive CreateInitializingVariableDeclaration;
] : local variable phrase;

/**
 * Construct and answer a label declaration.
 *
 * @category "Primitives" "Phrases" "Constructors"
 * @method "`«$_:_`»"
 * @param "name" "token"
 *        The name of the new constant.
 * @param "declaredType" "$[…]→⊥"
 *        The declared type of the named constant.
 * @returns "label phrase⇒⊤"
 *    The requested label declaration.
 */
Primitive "`«$_:_`»" is
[
	name : token,
	declaredType : continuation
|
	Primitive CreateLabelDeclaration;
] : label phrase;

/**
 * Construct and answer a list from the specified tuple of expressions.
 *
 * @category "Primitives" "Phrases" "Constructors"
 * @method "_→list phrase"
 * @param "aTuple" "<expression phrase⇒any…|>"
 *        A tuple of expressions.
 * @returns "list phrase⇒tuple (subexpressions tuple type=<phrase⇒any…|>)"
 *    The requested list.
 */
Primitive "_→list phrase" is
[
	aTuple : tuple of expressions yielding any
|
	Primitive CreateListExpression;
] : list phrase;

/**
 * Construct and answer a literal expression.
 *
 * @category "Primitives" "Phrases" "Constructors"
 * @method "_→literal phrase"
 * @param "aLiteralToken" "literal token⇒any"
 *        A literal token.
 * @returns "literal phrase⇒any"
 *    The requested literal expression.
 */
Primitive "_→literal phrase" is
[
	aLiteralToken : literal token
|
	Primitive CreateLiteralExpression;
] : literal phrase;

/**
 * Construct a suitably parameterized literal token type.
 *
 * @category "Primitives" "Types" "Phrases" "Constructors"
 * @method "literal token⇒_"
 * @param "literalValue" "(any)'s type"
 *        The literal value's type
 * @returns "(literal token⇒any)'s type"
 *    A literal token type.
 */
Primitive "literal token⇒_" is
[
	literalValue : any meta
|
	Primitive CreateLiteralTokenType;
] : literal token meta;

/**
 * Construct and answer a local constant declaration.
 *
 * @category "Primitives" "Phrases" "Constructors"
 * @method "`«_::=_`»"
 * @param "name" "token"
 *        The name of the new constant.
 * @param "expression" "expression phrase⇒any"
 *        The initialization expression for the new constant.
 * @returns "local constant phrase⇒⊤"
 *    The requested local constant declaration.
 */
Primitive "`«_::=_`»" is
[
	name : token,
	expression : expression yielding any
|
	Primitive CreateLocalConstantDeclaration;
] : local constant phrase;

/**
 * Create a marker phrase with the given value and yield type.
 *
 * @category "Primitives"
 * @method "`«marker phrase_⇒_`»"
 * @param "value" "any"
 *        The marker phrase's value.
 * @param "expressionType" "(⊤)'s type"
 *        The marker phrase's yield type.
 * @returns "marker phrase⇒⊤"
 *    A marker phrase.
 */
Primitive "`«marker phrase_⇒_`»" is
[
	value : any,
	expressionType : type
|
	Primitive CreateMarkerPhrase;
] : marker phrase;

/**
 * Answer a module variable declaration based on the given variable and token.
 *
 * @category "Primitives"
 * @method "`«module variable_(_)`»"
 * @param "aVariable" "read ⊤/write ⊥"
 *        TODO
 * @param "aToken" "token"
 *        TODO
 * @returns "module variable phrase⇒⊤"
 *    A module variable declaration phrase.
 */
Primitive "`«module variable_(_)`»" is
[
	aVariable : write-only variable,
	aToken : token
|
	Primitive CreateModuleVariableDeclaration;
] : module variable phrase;

/**
 * Construct and answer a primitive failure local constant declaration.
 *
 * @category "Primitives" "Phrases" "Constructors"
 * @method "primfail`«_:_`»"
 * @param "name" "token"
 *        The name of the new constant.
 * @param "declaredType" "(any)'s type"
 *        The declared type of the named constant.
 * @returns "primitive failure reason phrase⇒⊤"
 *    The requested primitive failure local constant declaration.
 */
Primitive "primfail`«_:_`»" is
[
	name : token,
	declaredType : any meta
|
	Primitive CreatePrimitiveFailureVariableDeclaration;
] : primitive failure reason phrase;

/**
 * Construct and answer a local variable declaration.
 *
 * @category "Primitives" "Phrases" "Constructors"
 * @method "`«_:_`»"
 * @param "name" "token"
 *        The name of the new variable.
 * @param "declaredType" "(any)'s type"
 *        The declared type of the named variable.
 * @returns "local variable phrase⇒⊤"
 *    The requested local variable declaration.
 */
Primitive "`«_:_`»" is
[
	name : token,
	declaredType : any meta
|
	Primitive CreateVariableExpression;
] : local variable phrase;

/**
 * Create a variable use expression from the specified token and declaration.
 *
 * @category "Primitives" "Phrases" "Constructors"
 * @method "`«↓_`»(_)"
 * @param "aDeclaration" "declaration phrase⇒⊤"
 *        The declaration that created the referenced entity.
 * @param "aToken" "token"
 *        A token that names the entity at the point of use.
 * @returns "variable use phrase⇒any"
 *    The requested variable use expression.
 */
Primitive "`«↓_`»(_)" is
[
	aDeclaration : declaration phrase,
	aToken : token
|
	Primitive CreateVariableUse;
] : variable use phrase;

/**
 * Answer whether this declaration has an initializing expression.
 *
 * @category "Primitives"
 * @method "_has initializing expression"
 * @param "decl" "declaration phrase⇒⊤"
 *        The declaration.
 * @returns "boolean"
 *    True if the declaration has an initializing expression, false otherwise.
 */
Primitive "_has initializing expression" is
[
	decl : declaration phrase
|
	Primitive DeclarationHasInitializingExpression;
] : boolean;

/**
 * Answer the token that names the entity introduced by the specified
 * declaration.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s⁇token"
 * @param "aDeclaration" "declaration phrase⇒⊤"
 *        A declaration.
 * @returns "token"
 *    The requested token.
 */
Primitive "_'s⁇token" is
[
	aDeclaration : declaration phrase
|
	Primitive DeclarationToken;
] : token;

/**
 * Answer the declared type of the entity introduced by the specified
 * declaration.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s⁇declared type"
 * @param "aDeclaration" "declaration phrase⇒⊤"
 *        A declaration.
 * @returns "(any)'s type"
 *    The requested type.
 */
Primitive "_'s⁇declared type" is
[
	aDeclaration : declaration phrase
|
	Primitive DeclarationType;
] : any meta;

/**
 * Answer the {@type "expression phrase⇒⊤"} wrapped by the {@type
 * "expression as statement phrase⇒⊤"}.
 *
 * @category "Primitives"
 * @method "_'s⁇expression"
 * @param "stmt" "expression as statement phrase⇒⊤"
 *        An {@type "expression as statement phrase⇒⊤"}.
 * @returns "expression phrase⇒⊤"
 *    The wrapped {@type "expression phrase⇒⊤"}.
 */
Primitive "_'s⁇expression" is
[
	stmt : expression as statement phrase
|
	Primitive ExpressionAsStatementExpression;
] : expression phrase;

/**
 * Answer the tuple of statements that constitute the specified
 * first-of-sequence.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s⁇statements"
 * @param "aFirstOfSequence" "first of sequence phrase⇒⊤"
 *        A first-of-sequence.
 * @returns "<phrase⇒⊤…|>"
 *    The requested tuple of statements.
 */
Primitive "_'s⁇statements" is
[
	aFirstOfSequence : first of sequence phrase
|
	Primitive FirstOfSequenceStatements;
] : phrase tuple;

/**
 * Answer the tuple of expressions that constitute the specified list.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s⁇expressions"
 * @param "aList" "list phrase⇒tuple (subexpressions tuple type=<phrase⇒any…|>)"
 *        A list.
 * @returns "<expression phrase⇒any…|>"
 *    The requested tuple of expressions.
 */
Primitive "_'s⁇expressions" is
[
	aList : list phrase
|
	Primitive ListExpressions;
] : tuple of expressions yielding any;

/**
 * Answer the specified literal expression's defining token.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s⁇token"
 * @param "aLiteral" "literal phrase⇒any"
 *        A literal expression.
 * @returns "literal token⇒any"
 *    The requested literal token.
 */
Primitive "_'s⁇token" is
[
	aLiteral : literal phrase
|
	Primitive LiteralExpressionToken;
] : literal token;

/**
 * Extract this literal token type's value type. That's the type of value
 * that a conforming literal token can produce.
 *
 * @category "Primitives" "Types" "Phrases" "Queries"
 * @method "_'s⁇value type"
 * @param "literalTokenType" "(literal token⇒any)'s type"
 *        The literal token type.
 * @returns "(any)'s type"
 *    The type of value that such a literal token can produce.
 */
Primitive "_'s⁇value type" is
[
	literalTokenType : literal token meta
|
	Primitive LiteralTokenTypeValueType;
] : any meta;

/**
 * Answer the literal value associated with the specified token.
 *
 * @category "Primitives" "Tokens" "Queries"
 * @method "_'s⁇value"
 * @param "aLiteralToken" "literal token⇒any"
 *        A literal token.
 * @returns "any"
 *    The literal value produced by {@param "aLiteralToken"}.
 */
Primitive "_'s⁇value" is
[
	aLiteralToken : literal token
|
	Primitive LiteralTokenValue;
] : any;

/**
 * Extract a marker phrase's value.
 *
 * @category "Primitives"
 * @method "_'s⁇value"
 * @param "markerPhrase" "marker phrase⇒⊤"
 *        A marker phrase.
 * @returns "any"
 *    The marker phrase's value.
 */
Primitive "_'s⁇value" is
[
	markerPhrase : marker phrase
|
	Primitive MarkerPhraseValue;
] : any;

/**
 * Answer the {@type "list phrase"} wrapped by the specified {@type
 * "permuted list phrase"}.
 *
 * @category "Primitives"
 * @method "_'s⁇list"
 * @param "permuted" "permuted list phrase⇒tuple (subexpressions tuple type=<phrase⇒any…|>)"
 *        A {@type "permuted list phrase"}.
 * @returns "list phrase⇒tuple (subexpressions tuple type=<phrase⇒any…|>)"
 *    The {@type "list phrase"} permuted by {@param "permuted"}.
 */
Primitive "_'s⁇list" is
[
	permuted : permuted list phrase
|
	Primitive PermutedListList;
] : list phrase;

/**
 * Answer the permutation {@type "tuple"} for the specified {@type
 * "permuted list phrase"}.
 *
 * @category "Primitives"
 * @method "_'s⁇permutation"
 * @param "permuted" "permuted list phrase⇒tuple (subexpressions tuple type=<phrase⇒any…|>)"
 *        A {@type "permuted list phrase"}.
 * @returns "<[1..∞)…|1..∞>"
 *    The permutation {@type "tuple"}. This comprises the target indices,
 *    indexed by source index.
 */
Primitive "_'s⁇permutation" is
[
	permuted : permuted list phrase
|
	Primitive PermutedListPermutation;
] : permutation tuple;

/**
 * Answer the semantic type of the specified phrase. This is the type of value
 * produced when the content of the phrase is evaluated (by the compiler and/or
 * runtime).
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s⁇semantic type"
 * @param "phrase" "phrase⇒⊤"
 *        A phrase.
 * @returns "(⊤)'s type"
 *    A type that describes all values producible by evaluations of the
 *    argument.
 */
Primitive "_'s⁇semantic type" is
[
	phrase : phrase
|
	Primitive PhraseExpressionType;
] : type;

/**
 * Answer the supplied phrase's tuple of {@code tokens}.  These are generally
 * the tokens that are part of the phrase but not part of any subphrase.
 *
 * @category "Primitives"
 * @method "_'s⁇tokens"
 * @param "phrase" "phrase⇒⊤"
 *        The phrase to examine.
 * @returns "<token…|>"
 *          The supplied phrase's tuple of tokens.
 */
Primitive "_'s⁇tokens" is
[
	phrase : phrase
|
	Primitive PhraseTokens;
] : token tuple;

/**
 * Answer the semantic type of the specified phrase type.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s⁇semantic type"
 * @param "phraseType" "(phrase⇒⊤)'s type"
 *        A phrase type.
 * @returns "(⊤)'s type"
 *    The requested semantic type.
 */
Primitive "_'s⁇semantic type" is
[
	phraseType : phrase meta
|
	Primitive PhraseTypeExpressionType;
] : type;

/**
 * Answer the specified variable reference's referent.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "`«↓_`»"
 * @param "aReference" "reference phrase⇒read ⊤/write ⊥"
 *        A variable reference.
 * @returns "variable use phrase⇒any"
 *    The variable use referenced by the argument.
 */
Primitive "`«↓_`»" is
[
	aReference : variable reference phrase
|
	Primitive ReferenceTarget;
] : variable use phrase;

/**
 * Answer the specified message send's list of argument expressions.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s⁇arguments"
 * @param "aSend" "send phrase⇒⊤"
 *        A message send.
 * @returns "list phrase⇒tuple (subexpressions tuple type=<phrase⇒any…|>)"
 *    The requested list of argument expressions.
 */
Primitive "_'s⁇arguments" is
[
	aSend : send phrase
|
	Primitive SendArgumentsList;
] : list phrase;

/**
 * Extract the message bundle from a send phrase.
 *
 * @category "Primitives"
 * @method "_'s⁇bundle"
 * @param "sendPhrase" "send phrase⇒⊤"
 *        A send phrase.
 * @returns "message bundle"
 *    The message bundle sent by this send phrase.
 */
Primitive "_'s⁇bundle" is
[
	sendPhrase : send phrase
|
	Primitive SendBundle;
] : message bundle;

/**
 * Answer the target method of the specified message send.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s⁇method"
 * @param "aSend" "send phrase⇒⊤"
 *        A message send.
 * @returns "method"
 *    The requested method.
 */
Primitive "_'s⁇method" is
[
	aSend : send phrase
|
	Primitive SendMethod;
] : method;

/**
 * Answer the specified message send's expected return type.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s⁇return type"
 * @param "aSend" "send phrase⇒⊤"
 *        A message send.
 * @returns "(⊤)'s type"
 *    The requested type.
 */
Primitive "_'s⁇return type" is
[
	aSend : send phrase
|
	Primitive SendReturnType;
] : type;

/**
 * Answer the tuple of statements that constitute the specified sequence.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s⁇statements"
 * @param "aSequence" "sequence phrase⇒⊤"
 *        A sequence.
 * @returns "<phrase⇒⊤…|>"
 *    The requested tuple of statements.
 */
Primitive "_'s⁇statements" is
[
	aSequence : sequence phrase
|
	Primitive SequenceStatements;
] : phrase tuple;

/**
 * Answer a supercast's base expression.
 *
 * @category "Primitives"
 * @method "_'s⁇expression"
 * @param "aSupercast" "super cast phrase⇒any"
 *        The supercast from which to extract the base expression
 * @returns "expression phrase⇒any"
 *    The supercast's base expression, which provides the actual argument value
 *    to a message send.
 */
Primitive "_'s⁇expression" is
[
	aSupercast : super cast phrase
|
	Primitive SuperCastExpression;
] : expression yielding any;

/**
 * Answer a supercast's lookup type, the type to be used for method lookup.
 *
 * @category "Primitives"
 * @method "_'s⁇lookup type"
 * @param "aSupercast" "super cast phrase⇒any"
 *        The supercast from which to extract the lookup type.
 * @returns "(any)'s type"
 *    The type that the supercast uses during method lookup.
 */
Primitive "_'s⁇lookup type" is
[
	aSupercast : super cast phrase
|
	Primitive SuperCastLookupType;
] : any meta;

/**
 * Answer the lexeme of the specified token. This is the source text that
 * produced the token.
 *
 * @category "Primitives" "Tokens" "Queries"
 * @method "_'s⁇lexeme"
 * @param "aToken" "token"
 *        A token.
 * @returns "<character…|1..∞>"
 *    The source text of {@param "aToken"}.
 */
Primitive "_'s⁇lexeme" is
[
	aToken : token
|
	Primitive TokenLexeme;
] : nonempty string;

/**
 * Answer the one-based line number of the specified token within the module
 * that supplied it.
 *
 * @category "Primitives" "Tokens" "Queries"
 * @method "_'s⁇line number"
 * @param "aToken" "token"
 *        A token.
 * @returns "[0..∞)"
 *    The one-based line number of {@param "aToken"}.
 */
Primitive "_'s⁇line number" is
[
	aToken : token
|
	Primitive TokenLineNumber;
] : whole number;

/**
 * Answer the zero-based starting position of the specified token within the
 * module that supplied it.
 *
 * @category "Primitives" "Tokens" "Queries"
 * @method "_'s⁇starting position"
 * @param "aToken" "token"
 *        A token.
 * @returns "[0..∞)"
 *    The zero-based starting position of {@param "aToken"}.
 */
Primitive "_'s⁇starting position" is
[
	aToken : token
|
	Primitive TokenStart;
] : whole number;

/**
 * Answer the declaration that introduced the entity referenced by the specified
 * variable use expression.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s⁇declaration"
 * @param "use" "variable use phrase⇒any"
 *        A variable use expression.
 * @returns "declaration phrase⇒⊤"
 *    The requested declaration.
 */
Primitive "_'s⁇declaration" is
[
	use : variable use phrase
|
	Primitive VariableUseDeclaration;
] : declaration phrase;

/**
 * Answer the specified variable use expression's token.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s⁇token"
 * @param "use" "variable use phrase⇒any"
 *        A variable use expression.
 * @returns "token"
 *    The token that names the referenced entity at the point of use.
 */
Primitive "_'s⁇token" is
[
	use : variable use phrase
|
	Primitive VariableUseToken;
] : token;

/**
 * Compute and answer a pojo array with the specified element type and length.
 *
 * @category "Primitives" "POJO" "Constructors"
 * @method "new_[_]"
 * @param "elementType" "(any)'s type"
 *        The element type.
 * @param "length" "[0..∞)"
 *        The number of elements.
 * @returns "any[]"
 *    A new pojo array that can store and answer {@param "length"} elements conforming
 *    to {@param "elementType"}.
 */
Primitive "new_[_]" is
[
	elementType : any meta,
	length : whole number
|
	Primitive CreatePojoArray;
] : pojo array;

/**
 * Construct and answer a pojo array type whose element type is {@param "elementType"}
 * and whose cardinality requirement is {@param "cardinalityRequirement"}.
 *
 * @category "Primitives" "Types" "POJO" "Constructors"
 * @method "_[_]"
 * @param "elementType" "(any)'s type"
 *        The type of the elements of instances.
 * @param "cardinalityRequirement" "([0..∞))'s type"
 *        The range of sizes of instances.
 * @returns "(any[])'s type"
 *    The requested pojo array type.
 */
Primitive "_[_]" is
[
	elementType : any meta,
	cardinalityRequirement : whole number meta
|
	Primitive CreatePojoArrayType;
] : pojo array meta;

/**
 * Construct and answer a tuple whose elements are sourced from the specified
 * pojo array.
 *
 * @category "Primitives" "Tuples" "POJO" "Conversions"
 * @method "_→tuple"
 * @param "aPojoArray" "any[]"
 *        A pojo array.
 * @returns "tuple"
 *    The requested tuple.
 */
Primitive "_→tuple" is
[
	aPojoArray : pojo array
|
	Primitive CreateTupleFromPojoArray;
] : tuple;

/**
 * Answer the number of elements contained by the specified pojo array.
 *
 * @category "Primitives" "POJO" "Queries"
 * @method "`|_`|"
 * @param "anArray" "any[]"
 *        A pojo array.
 * @returns "[0..∞)"
 *    The size of the argument.
 */
Primitive "`|_`|" is
[
	anArray : pojo array
|
	Primitive PojoArrayLength;
] : whole number;

/**
 * Answer the element type of the specified pojo array type.
 *
 * @category "Primitives" "Types" "POJO" "Queries"
 * @method "_'s⁇element type"
 * @param "pojoArrayType" "(any[])'s type"
 *        A pojo array type.
 * @returns "(any)'s type"
 *    The element type of {@param "pojoArrayType"}.
 */
Primitive "_'s⁇element type" is
[
	pojoArrayType : pojo array meta
|
	Primitive PojoArrayTypeContentType;
] : any meta;

/**
 * Answer the cardinality restriction of the specified pojo array type.
 *
 * @category "Primitives" "Types" "POJO" "Queries"
 * @method "`|`|_`|`|"
 * @param "pojoArrayType" "(any[])'s type"
 *        A pojo array type.
 * @returns "([0..∞))'s type"
 *    The cardinality restriction of {@param "pojoArrayType"}.
 */
Primitive "`|`|_`|`|" is
[
	pojoArrayType : pojo array meta
|
	Primitive PojoArrayTypeSizes;
] : whole number meta;

/**
 * Answer the function type of any function that could close the specified
 * function implementation.
 *
 * @category "Primitives" "Function Implementations" "Queries"
 * @method "_'s⁇function type"
 * @param "aFunctionImplementation" "¢[…]→⊤"
 *        A function implementation.
 * @returns "([…]→⊤)'s type"
 *    The argument's function type.
 */
Primitive "_'s⁇function type" is
[
	aFunctionImplementation : function implementation
|
	Primitive CompiledCodeFunctionType;
] : function meta;

/**
 * Answer the literals that support a function implementation's algorithm.
 *
 * @category "Primitives" "Function Implementations" "Queries"
 * @method "_'s⁇literals"
 * @param "aFunctionImplementation" "¢[…]→⊤"
 *        A function implementation.
 * @returns "tuple"
 *    A tuple containing the argument's supporting literals.
 */
Primitive "_'s⁇literals" is
[
	aFunctionImplementation : function implementation
|
	Primitive CompiledCodeLiterals;
] : tuple;

/**
 * Answer the arity of a function implementation. This is the number of
 * parameters accepted by the function implementation.
 *
 * @category "Primitives" "Function Implementations" "Queries"
 * @method "_'s⁇arity"
 * @param "aFunctionImplementation" "¢[…]→⊤"
 *        A function implementation.
 * @returns "[0..∞)"
 *    The argument's arity.
 */
Primitive "_'s⁇arity" is
[
	aFunctionImplementation : function implementation
|
	Primitive CompiledCodeNumArgs;
] : whole number;

/**
 * Answer the number of local variables used by a function implementation.
 *
 * @category "Primitives" "Function Implementations" "Queries"
 * @method "`|_'s⁇local variables`|"
 * @param "aFunctionImplementation" "¢[…]→⊤"
 *        A function implementation.
 * @returns "[0..∞)"
 *    The number of locals used by the argument.
 */
Primitive "`|_'s⁇local variables`|" is
[
	aFunctionImplementation : function implementation
|
	Primitive CompiledCodeNumLocals;
] : whole number;

/**
 * Answer the number of outer variables used by a function implementation.
 *
 * @category "Primitives" "Function Implementations" "Queries"
 * @method "`|_'s⁇outer variables`|"
 * @param "aFunctionImplementation" "¢[…]→⊤"
 *        A function implementation.
 * @returns "[0..∞)"
 *    The number of outers used by the argument.
 */
Primitive "`|_'s⁇outer variables`|" is
[
	aFunctionImplementation : function implementation
|
	Primitive CompiledCodeNumOuters;
] : whole number;

/**
 * Answer the maximum stack depth of a function implementation. This does not
 * account for arguments and local variables (which occupy the "bottom" stack
 * slots).
 *
 * @category "Primitives" "Function Implementations" "Queries"
 * @method "_'s⁇maximum stack depth"
 * @param "aFunctionImplementation" "¢[…]→⊤"
 *        A function implementation.
 * @returns "[0..∞)"
 *    The argument's maximum stack depth.
 */
Primitive "_'s⁇maximum stack depth" is
[
	aFunctionImplementation : function implementation
|
	Primitive CompiledCodeNumStackSlots;
] : whole number;

/**
 * Answer the Level One instructions that describe a function implementation's
 * algorithm as a tuple of nybblecodes.
 *
 * @category "Primitives" "Function Implementations" "Queries"
 * @method "_'s⁇nybblecodes"
 * @param "aFunctionImplementation" "¢[…]→⊤"
 *        A function implementation.
 * @returns "<[0..15]…|>"
 *    The argument's nybblecodes.
 */
Primitive "_'s⁇nybblecodes" is
[
	aFunctionImplementation : function implementation
|
	Primitive CompiledCodeNybbles;
] : tuple of nybble;

/**
 * Answer the implementation of the specified function. A function's
 * implementation comprises its nybblecodes, its literals, its primitive
 * linkage (if any), its function type, and various statistics.
 *
 * @category "Primitives" "Functions" "Queries"
 * @method "_'s⁇implementation"
 * @param "aFunction" "[…]→⊤"
 *        A function.
 * @returns "¢[…]→⊤"
 *    The argument's implementation.
 */
Primitive "_'s⁇implementation" is
[
	aFunction : function
|
	Primitive CompiledCodeOfFunction;
] : function implementation;

/**
 * Answer the name of the primitive linked to the specified function
 * implementation. If the function implementation does not have
 * primitive linkage, then answer the empty string.
 *
 * @category "Primitives" "Function Implementations" "Queries"
 * @method "_'s⁇primitive name"
 * @param "aFunctionImplementation" "¢[…]→⊤"
 *        A function implementation.
 * @returns "string"
 *    The argument's primitive name, or the empty string if the argument does
 *    not have primitive linkage.
 */
Primitive "_'s⁇primitive name" is
[
	aFunctionImplementation : function implementation
|
	Primitive CompiledCodePrimitiveName;
] : string;

/**
 * Set the descriptive name of the given function implementation.  This value is
 * presented in stack traces and other symbolic circumstances.  This
 * automatically sets the names of the sub-functions in a systematic way.
 *
 * @category "Primitives"
 * @method "Set name of function implementation_to_"
 * @param "rawFunction" "¢[…]→⊤"
 *        The function implementation to name.
 * @param "name" "<character…|1..∞>"
 *        A string used to name the function implementation.
 * @returns "⊤"
 */
Primitive "Set name of function implementation_to_" is
[
	rawFunction : function implementation,
	name : nonempty string
|
	Primitive SetCompiledCodeName;
] : ⊤;

/**
 * Construct and answer a set type with the specified element type and range of
 * cardinalities.
 *
 * @category "Primitives" "Types" "Sets" "Constructors"
 * @method "{_`|_}"
 * @param "elementType" "(any)'s type"
 *        The element type.
 * @param "cardinalityType" "([0..∞))'s type"
 *        The range of allowed cardinalities.
 * @returns "(set)'s type"
 *    The requested set type. Instances have elements that conform to
 *    {@param "elementType"} and cardinalities that conform to {@param
 *    "cardinalityType"}.
 */
Primitive "{_`|_}" is
[
	elementType : any meta,
	cardinalityType : whole number meta
|
	Primitive CreateSetType;
] : set meta;

/**
 * Is {@param "element"} an element of {@param "aSet"}?
 *
 * @category "Primitives" "Sets" "Queries"
 * @method "_∈_"
 * @param "element" "any"
 *        An arbitrary value.
 * @param "aSet" "set"
 *        A set.
 * @returns "boolean"
 *    `true` if {@param "element"} is an element of {@param "aSet"}, `false`
 *    otherwise.
 */
Primitive "_∈_" is
[
	element : any,
	aSet : set
|
	Primitive ElementInSet;
] : boolean;

/**
 * Compute and answer the asymmetric set difference of {@param "minuend"} and
 * {@param "subtrahend"} (also the relative complement of {@param "subtrahend"} in {@param "minuend"}).
 * This is a set that contains only those elements present in {@param "minuend"}
 * but not in {@param "subtrahend"}.
 *
 * @category "Primitives" "Sets" "Mathematics"
 * @method "_\\_"
 * @param "minuend" "set"
 *        The minuend.
 * @param "subtrahend" "set"
 *        The subtrahend.
 * @returns "set"
 *    The asymmetric set difference of {@param "minuend"} and {@param "subtrahend"}.
 */
Primitive "_\\_" is
[
	minuend : set,
	subtrahend : set
|
	Primitive SetDifference;
] : set;

/**
 * Compute and answer the set intersection of the arguments. This is a set that
 * contains only those elements present in each set.
 *
 * @category "Primitives" "Sets" "Mathematics"
 * @method "_∩_"
 * @param "arg1" "set"
 *        A set.
 * @param "arg2" "set"
 *        A set.
 * @returns "set"
 *    The set intersection of the arguments.
 */
Primitive "_∩_" is
[
	arg1 : set,
	arg2 : set
|
	Primitive SetIntersection;
] : set;

/**
 * Is {@param "arg1"} a subset of or equal to {@param "arg2"}?
 *
 * @category "Primitives" "Sets" "Mathematics" "Relations"
 * @method "_⊆_"
 * @param "arg1" "set"
 *        A set.
 * @param "arg2" "set"
 *        A set.
 * @returns "boolean"
 *    `true` if {@param "arg1"} is a subset of or equal to {@param "arg2"},
 *    `false` otherwise.
 */
Primitive "_⊆_" is
[
	arg1 : set,
	arg2 : set
|
	Primitive SetIsSubset;
] : boolean;

/**
 * Answer the cardinality of the specified set.
 *
 * @category "Primitives" "Sets" "Queries"
 * @method "`|_`|"
 * @param "aSet" "set"
 *        A set.
 * @returns "[0..∞)"
 *    The argument's cardinality.
 */
Primitive "`|_`|" is
[
	aSet : set
|
	Primitive SetSize;
] : whole number;

/**
 * Construct and answer a tuple that arbitrarily orders the elements of the
 * specified set. The conversion is unstable, and thus different calls given
 * the same argument may produce different orderings.
 *
 * @category "Primitives" "Sets" "Tuples" "Conversions"
 * @method "_→tuple"
 * @param "aSet" "set"
 *        A set.
 * @returns "tuple"
 *    The requested tuple.
 */
Primitive "_→tuple" is
[
	aSet : set
|
	Primitive SetToTuple;
] : tuple;

/**
 * Answer the element type of the specified set type. This is the most specific
 * type to which all elements of instances must conform.
 *
 * @category "Primitives" "Types" "Sets" "Queries"
 * @method "_'s⁇element|member type"
 * @param "aSetType" "(set)'s type"
 *        A set type.
 * @returns "(any)'s type"
 *    The argument's element type.
 */
Primitive "_'s⁇element|member type" is
[
	aSetType : set meta
|
	Primitive SetTypeElementType;
] : any meta;

/**
 * Answer the acceptable range of cardinalities for instances of the specified
 * set type.
 *
 * @category "Primitives" "Types" "Sets" "Queries"
 * @method "`|`|_`|`|"
 * @param "aSetType" "(set)'s type"
 *        A set type.
 * @returns "([0..∞))'s type"
 *    The argument's cardinality requirement.
 */
Primitive "`|`|_`|`|" is
[
	aSetType : set meta
|
	Primitive SetTypeSizes;
] : whole number meta;

/**
 * Compute and answer the set union of the arguments. This is a set that
 * contains the elements of both sets.
 *
 * @category "Primitives" "Sets" "Mathematics"
 * @method "_∪_"
 * @param "arg1" "set"
 *        A set.
 * @param "arg2" "set"
 *        A set.
 * @returns "set"
 *    The set union of the arguments.
 */
Primitive "_∪_" is
[
	arg1 : set,
	arg2 : set
|
	Primitive SetUnion;
] : set;

/**
 * Compute and answer the set union of the specified set and a set containing
 * the supplied element.
 *
 * @category "Primitives" "Sets" "Mathematics"
 * @method "_+_"
 * @param "aSet" "set"
 *        A set.
 * @param "newElement" "any"
 *        The element that must be present in the resultant set.
 * @returns "{any|1..∞}"
 *    A set that contains the same elements as {@param "aSet"} but also
 *    contains {@param "newElement"}.
 */
Primitive "_+_" is
[
	aSet : set,
	newElement : any
|
	Primitive SetWith;
] : non-empty set;

/**
 * Compute and answer the asymmetric set difference of the specified set and a
 * set containing the supplied element.
 *
 * @category "Primitives" "Sets" "Mathematics"
 * @method "_-_"
 * @param "aSet" "set"
 *        A set.
 * @param "oldElement" "any"
 *        The element that must not be present in the resultant set.
 * @returns "set"
 *    A set that contains the same elements as {@param "aSet"} except that
 *    it does not contain {@param "oldElement"}.
 */
Primitive "_-_" is
[
	aSet : set,
	oldElement : any
|
	Primitive SetWithout;
] : set;

/**
 * Construct and answer a set that uniquely (by definition) contains the same
 * elements as the specified tuple.
 *
 * @category "Primitives" "Sets" "Tuples" "Conversions"
 * @method "_→set"
 * @param "aTuple" "tuple"
 *        A tuple.
 * @returns "set"
 *    The requested set.
 */
Primitive "_→set" is
[
	aTuple : tuple
|
	Primitive TupleToSet;
] : set;

/**
 * Construct and answer a tuple that is the left-to-right concatenation of all
 * elements (i.e. tuples) of the specified tuple.
 *
 * @category "Primitives" "Tuples" "Transformers"
 * @method "concatenate_"
 * @param "tupleOfTuples" "<tuple…|>"
 *        A tuple of tuples.
 * @returns "tuple"
 *    The requested tuple.
 */
Primitive "concatenate_" is
[
	tupleOfTuples : tuple of tuple
|
	Primitive ConcatenateTuples;
] : tuple;

/**
 * Construct and answer a tuple type with the specified leading element types,
 * default element type, and range of cardinalities.
 *
 * @category "Primitives" "Types" "Tuples" "Constructors"
 * @method "<_,_`…`|_>"
 * @param "leadingTypes" "<(any)'s type…|>"
 *        The leading types.
 * @param "defaultType" "(any)'s type"
 *        The default type.
 * @param "cardinalityType" "([0..∞))'s type"
 *        The range of allowed cardinalities.
 * @returns "(tuple)'s type"
 *    The requested tuple type.
 */
Primitive "<_,_`…`|_>" is
[
	leadingTypes : tuple of any meta,
	defaultType : any meta,
	cardinalityType : whole number meta
|
	Primitive CreateTupleType;
] : tuple meta;

/**
 * Reverses the order of the given tuple.
 *
 * @category "Primitives" "Tuples" "Transformers"
 * @method "_reversed"
 * @param "aTuple" "tuple"
 *        A tuple.
 * @returns "tuple"
 *    A tuple that is the reverse of the original tuple
 */
Primitive "_reversed" is
[
	aTuple : tuple
|
	Primitive ReverseTuple;
] : tuple;

/**
 * Answer the cardinality of the specified tuple.
 *
 * @category "Primitives" "Tuples" "Queries"
 * @method "`|_`|"
 * @param "aTuple" "tuple"
 *        A tuple.
 * @returns "[0..∞)"
 *    The argument's cardinality.
 */
Primitive "`|_`|" is
[
	aTuple : tuple
|
	Primitive TupleSize;
] : whole number;

/**
 * Answer the element type of the {@param "index"}-th element of instances of the
 * specified type. If {@param "index"} is out of bounds, then answer
 * {@type "⊥"}.
 *
 * @category "Primitives" "Types" "Tuples" "Queries"
 * @method "_[_]"
 * @param "aTupleType" "(tuple)'s type"
 *        A tuple type.
 * @param "index" "[1..∞)"
 *        The index of the desired element type.
 * @returns "(any)'s type"
 *    The requested element type, or ⊥ if {@param "index"} is out of bounds.
 */
Primitive "_[_]" is
[
	aTupleType : tuple meta,
	index : natural number
|
	Primitive TupleTypeAt;
] : any meta;

/**
 * Compute and answer the type union of the indicated range of element types.
 *
 * @category "Primitives" "Types" "Tuples" "Queries"
 * @method "∪_[_.._]"
 * @param "aTupleType" "(tuple)'s type"
 *        A tuple type.
 * @param "startIndex" "[1..∞)"
 *        The one-based index (inclusive) of the start of the range.
 * @param "endIndex" "[0..∞]"
 *        The one-based index (inclusive) of the end of the range.
 * @returns "(any)'s type"
 *    The type union of all element types in the specified range.
 */
Primitive "∪_[_.._]" is
[
	aTupleType : tuple meta,
	startIndex : natural number,
	endIndex : nonnegative extended integer
|
	Primitive TupleTypeAtThrough;
] : any meta;

/**
 * Compute and answer the concatenation of the specified tuple types. This is
 * the most specific type that encompasses all possible concatenations of the
 * instances of the two types.
 *
 * @category "Primitives" "Types" "Tuples" "Transformers"
 * @method "_++_"
 * @param "arg1" "(tuple)'s type"
 *        A tuple type.
 * @param "arg2" "(tuple)'s type"
 *        A tuple type.
 * @returns "(tuple)'s type"
 *    The requested tuple type.
 */
Primitive "_++_" is
[
	arg1 : tuple meta,
	arg2 : tuple meta
|
	Primitive TupleTypeConcatenate;
] : tuple meta;

/**
 * Answer the default element type of instances of the specified type.
 *
 * @category "Primitives" "Types" "Tuples" "Queries"
 * @method "_'s⁇default type"
 * @param "aTupleType" "(tuple)'s type"
 *        A tuple type.
 * @returns "(any)'s type"
 *    The argument's default element type.
 */
Primitive "_'s⁇default type" is
[
	aTupleType : tuple meta
|
	Primitive TupleTypeDefaultType;
] : any meta;

/**
 * Answer a tuple containing the leading element types of instances of the
 * specified type.
 *
 * @category "Primitives" "Types" "Tuples" "Queries"
 * @method "_'s⁇leading types"
 * @param "aTupleType" "(tuple)'s type"
 *        A tuple type.
 * @returns "<(any)'s type…|>"
 *    The argument's leading element types.
 */
Primitive "_'s⁇leading types" is
[
	aTupleType : tuple meta
|
	Primitive TupleTypeLeadingTypes;
] : tuple of any meta;

/**
 * Answer the range of allowed cardinalities of instances of the specified type.
 *
 * @category "Primitives" "Types" "Tuples" "Queries"
 * @method "`|`|_`|`|"
 * @param "aTupleType" "(tuple)'s type"
 *        A tuple type.
 * @returns "([0..∞))'s type"
 *    The argument's cardinality requirement.
 */
Primitive "`|`|_`|`|" is
[
	aTupleType : tuple meta
|
	Primitive TupleTypeSizes;
] : whole number meta;

/**
 * Compute and answer the type union of the elements of the given tuple of
 * types.
 *
 * @category "Primitives" "Types" "Tuples" "Queries"
 * @method "∪_"
 * @param "tupleOfTypes" "<(⊤)'s type…|>"
 *        A tuple of types.
 * @returns "(⊤)'s type"
 *    The type union of the elements of the argument.
 */
Primitive "∪_" is
[
	tupleOfTypes : tuple of type
|
	Primitive UnionOfTupleOfTypes;
] : type;

/**
 * If {@param "value"} is type-compatible with the parameter expected by the
 * function {@param "intoBlock"}, then invoke it with that argument, otherwise
 * invoke {@param "elseBlock"} with no arguments.  Answer the result of
 * whichever function was evaluated (they may be ⊤-valued).
 *
 * @category "Primitives"
 * @method "Cast|cast_into_else_"
 * @param "value" "any"
 *        A value to type-test.
 * @param "intoBlock" "[⊥]→⊤"
 *        A function to invoke with the provided value if its type is
 *        compatible with the parameter type.
 * @param "elseBlock" "[]→⊤"
 *        A zero-argument function to invoke if the value was not compatible
 *        with the first function's parameter.
 * @returns "⊤"
 *    The value produced by whichever function ran.  May be ⊤-valued.
 */
Primitive "Cast|cast_into_else_" is
[
	value : any,
	intoBlock : unary procedure,
	elseBlock : nullary procedure
|
	Primitive CastIntoElse;
] : ⊤;

/**
 * Construct and answer an enumeration whose instances are fully determined by
 * the membership of the specified set.
 *
 * @category "Primitives" "Types" "Constructors"
 * @method "enumeration of_"
 * @param "instances" "set"
 *        The complete set of instances of the enumeration.
 * @returns "(any)'s type"
 *    The requested enumeration.
 */
Primitive "enumeration of_" is
[
	instances : set
|
	Primitive CreateEnumeration;
] : any meta;

/**
 * Answer the number of instances of the specified type. This is `∞` for all
 * types except for enumerations.
 *
 * @category "Primitives" "Types" "Queries"
 * @method "`|_`|"
 * @param "aType" "(⊤)'s type"
 *        A type.
 * @returns "[0..∞]"
 *    The cardinality of the membership of the type.
 */
Primitive "`|_`|" is
[
	aType : type
|
	Primitive InstanceCount;
] : nonnegative extended integer;

/**
 * Is {@param "value"} an instance of {@param "aType"}?
 *
 * @category "Primitives"
 * @method "_∈_"
 * @param "value" "any"
 *        The value to test for membership in {@param "aType"}.
 * @param "aType" "(⊤)'s type"
 *        The target type for the membership check.
 * @returns "boolean"
 *    {@method "true"} if {@param "value"} is an instance of {@param
 *    "aType"}, {@method "false"} otherwise.
 */
Primitive "_∈_" is
[
	value : any,
	aType : type
|
	Primitive IsInstanceOf;
] : boolean;

/**
 * Is the first argument a subtype of the second argument? This does not
 * implement the proper subtype relation, so the first argument is considered
 * a subtype of the second argument also if it is equal to the second argument.
 *
 * @category "Primitives" "Types" "Mathematics" "Relations"
 * @method "_⊆_"
 * @param "arg1" "(⊤)'s type"
 *        A type.
 * @param "arg2" "(⊤)'s type"
 *        A type.
 * @returns "boolean"
 *    `true` if the first argument is a subtype of, or the same type as, the
 *    second argument, `false` otherwise.
 */
Primitive "_⊆_" is
[
	arg1 : type,
	arg2 : type
|
	Primitive IsSubtypeOf;
] : boolean;

/**
 * Answer the precise instance type of the supplied value. This is the most
 * specific possible type that describes the value.
 *
 * @category "Primitives" "Types" "Constructors"
 * @method "_'s⁇type"
 * @param "value" "any"
 *        An arbitrary value.
 * @returns "(any)'s type"
 *    The precise instance type of the supplied value.
 */
Primitive "_'s⁇type" is
[
	value : any
|
	Primitive Type;
] : any meta;

/**
 * Compute and answer the type intersection of the two types. This is the most
 * general type that is a subtype of both types.
 *
 * @category "Primitives" "Types" "Mathematics"
 * @method "_∩_"
 * @param "arg1" "(⊤)'s type"
 *        A type.
 * @param "arg2" "(⊤)'s type"
 *        A type.
 * @returns "(⊤)'s type"
 *    The type intersection of the arguments.
 */
Primitive "_∩_" is
[
	arg1 : type,
	arg2 : type
|
	Primitive TypeIntersection;
] : type;

/**
 * Compute and answer the type union of the two types. This is the most
 * specific type that is a supertype of both types.
 *
 * @category "Primitives" "Types" "Mathematics"
 * @method "_∪_"
 * @param "arg1" "(⊤)'s type"
 *        A type.
 * @param "arg2" "(⊤)'s type"
 *        A type.
 * @returns "(⊤)'s type"
 *    The type union of the arguments.
 */
Primitive "_∪_" is
[
	arg1 : type,
	arg2 : type
|
	Primitive TypeUnion;
] : type;

/**
 * Construct and answer a variable type from the specified read and write types.
 *
 * @category "Primitives" "Variables" "Types" "Constructors"
 * @method "read_/write_"
 * @param "readType" "(⊤)'s type"
 *        The read type of the variable type.
 * @param "writeType" "(⊤)'s type"
 *        The write type of the variable type.
 * @returns "(read ⊤/write ⊥)'s type"
 *    The requested variable type.
 */
Primitive "read_/write_" is
[
	readType : type,
	writeType : type
|
	Primitive CreateReadWriteVariableType;
] : variable meta;

/**
 * Construct and answer a new variable with the specified containment type.
 *
 * @category "Primitives" "Variables" "Constructors"
 * @method "new`↑_"
 * @param "containmentType" "(any)'s type"
 *        The containment type.
 * @returns "read ⊤/write ⊥"
 *    A new variable capable of retrieving and storing values of the specified
 *    containment type.
 */
Primitive "new`↑_" is
[
	containmentType : any meta
|
	Primitive CreateVariable;
] : write-only variable;

/**
 * Construct and answer a variable type with the specified containment type.
 *
 * @category "Primitives" "Variables" "Types" "Constructors"
 * @method "`↑_"
 * @param "containmentType" "(any)'s type"
 *        The containment type.
 * @returns "(read ⊤/write ⊥)'s type"
 *    The requested variable type.
 */
Primitive "`↑_" is
[
	containmentType : any meta
|
	Primitive CreateVariableType;
] : variable meta;

/**
 * Is the specified variable unassigned?
 *
 * @category "Primitives" "Variables" "Queries"
 * @method "_↑is unassigned"
 * @param "var" "read ⊤/write ⊥"
 *        A variable.
 * @returns "boolean"
 *    {@method "true"} if the variable does not contain a value, {@method
 *    "false"} otherwise.
 */
Primitive "_↑is unassigned" is
[
	var : write-only variable
|
	Primitive HasNoValue;
] : boolean;

/**
 * Answer the read type of the specified variable type. All values read from
 * instances of the variable type are at least as specific as the answer.
 *
 * @category "Primitives" "Variables" "Types" "Queries"
 * @method "_'s⁇read type"
 * @param "varType" "(read ⊤/write ⊥)'s type"
 *        A variable type.
 * @returns "(⊤)'s type"
 *    The most general type that describes values that can be read from
 *    instances of {@param "varType"}.
 */
Primitive "_'s⁇read type" is
[
	varType : variable meta
|
	Primitive VariableReadType;
] : type;

/**
 * Answer the write type of the specified variable type. All values written to
 * instances of the variable type are at least as specific as the answer.
 *
 * @category "Primitives" "Variables" "Types" "Queries"
 * @method "_'s⁇write type"
 * @param "varType" "(read ⊤/write ⊥)'s type"
 *        A variable type.
 * @returns "(⊤)'s type"
 *    The most general type that describes values that can be written to
 *    instances of {@param "varType"}.
 */
Primitive "_'s⁇write type" is
[
	varType : variable meta
|
	Primitive VariableWriteType;
] : type;

