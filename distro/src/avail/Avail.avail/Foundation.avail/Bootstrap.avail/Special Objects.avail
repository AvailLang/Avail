/*
 * Special Objects.avail
 * Copyright © 1993-2022, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * GENERATED FILE
 * * Generator: avail.tools.bootstrap.BootstrapGenerator
 * * Last Generated: 1/28/22, 2:22 PM
 *
 * DO NOT MODIFY MANUALLY. ALL MANUAL CHANGES WILL BE LOST.
 */

Module "Special Objects"
Versions
	"Avail-1.6.0"
Extends
	"Origin"
Uses
Names
	/*  78 */ "-∞",
	/* 111 */ "Euler's number",
	/*  82 */ "Java null",
	/*  21 */ "VM error codes",
	/*  44 */ "abstract definition",
	/* 145 */ "all tokens key",
	/*   1 */ "any",
	/*  69 */ "any meta",
	/*  62 */ "argument phrase",
	/* 122 */ "argument tuple",
	/*  53 */ "assignment phrase",
	/*  11 */ "atom",
	/*  54 */ "block phrase",
	/*   2 */ "boolean",
	/* 129 */ "byte",
	/*   3 */ "character",
	/* 167 */ "character type number",
	/*  38 */ "code point",
	/* 164 */ "comment",
	/*   9 */ "continuation",
	/*  10 */ "continuation meta",
	/* 168 */ "continuation returning top",
	/*  92 */ "continuation variable",
	/*  61 */ "declaration phrase",
	/* 123 */ "declaration tuple",
	/*  43 */ "definition",
	/*  12 */ "double",
	/*  96 */ "empty map",
	/* 104 */ "empty tuple",
	/* 160 */ "end of file",
	/*  24 */ "exception",
	/* 155 */ "explicit subclassing key",
	/* 150 */ "expression as statement phrase",
	/*  52 */ "expression phrase",
	/* 126 */ "expression yielding any",
	/*  13 */ "extended integer",
	/*  18 */ "extended integer meta",
	/*  71 */ "false",
	/*  25 */ "fiber",
	/* 132 */ "fiber meta",
	/*  93 */ "field map",
	/* 120 */ "field tuple",
	/*  94 */ "field type map",
	/* 119 */ "field type tuple",
	/* 140 */ "first of sequence phrase",
	/*  15 */ "float",
	/*  45 */ "forward definition",
	/*   4 */ "function",
	/*   6 */ "function implementation",
	/*   5 */ "function meta",
	/*  86 */ "function returning any",
	/* 146 */ "int32",
	/* 147 */ "int64",
	/*  17 */ "integer",
	/*  95 */ "key-value tuple",
	/* 161 */ "keyword",
	/*  63 */ "label phrase",
	/* 158 */ "lexer body function",
	/* 157 */ "lexer filter function",
	/*  59 */ "list phrase",
	/* 162 */ "literal",
	/*  55 */ "literal phrase",
	/* 116 */ "literal token",
	/*  58 */ "literal token meta",
	/*  65 */ "local constant phrase",
	/*  64 */ "local variable phrase",
	/* 154 */ "macro bundle key",
	/*  47 */ "macro definition",
	/* 109 */ "macro function",
	/*  39 */ "map",
	/* 153 */ "map from string to atom",
	/*  19 */ "map meta",
	/* 156 */ "map variable",
	/* 174 */ "marker phrase",
	/*  40 */ "message bundle",
	/*  41 */ "message bundle tree",
	/*  42 */ "method",
	/*  46 */ "method definition",
	/*  20 */ "module",
	/*  67 */ "module constant phrase",
	/* 175 */ "module imports tuple",
	/*  66 */ "module variable phrase",
	/*  37 */ "natural number",
	/*  97 */ "non-empty map",
	/*  99 */ "non-empty set",
	/* 169 */ "non-empty string of digits",
	/* 136 */ "nonempty set of atom",
	/* 135 */ "nonempty set of string",
	/* 133 */ "nonempty string",
	/* 137 */ "nonempty tuple",
	/* 118 */ "nonnegative extended integer",
	/*  31 */ "nontype",
	/*  90 */ "nullary procedure",
	/*  16 */ "number",
	/* 101 */ "nybble",
	/*  22 */ "object",
	/*  23 */ "object meta",
	/* 163 */ "operator",
	/* 170 */ "optional send phrase and report string",
	/* 143 */ "parse map key",
	/* 166 */ "parse rejection level",
	/* 151 */ "permutation tuple",
	/* 141 */ "permuted list phrase",
	/*  50 */ "phrase",
	/* 113 */ "phrase meta",
	/* 121 */ "phrase tuple",
	/*  80 */ "pojo",
	/*  87 */ "pojo array",
	/*  85 */ "pojo array meta",
	/*  89 */ "pojo exception",
	/* 127 */ "pojo failure function",
	/*  84 */ "pojo meta",
	/*  88 */ "pojo self",
	/*  83 */ "pojo self type",
	/*  81 */ "pojo⊥",
	/*  91 */ "predicate function",
	/*  76 */ "primitive failure function",
	/*  68 */ "primitive failure reason phrase",
	/* 131 */ "readable extended integer variable",
	/* 144 */ "scope map key",
	/* 149 */ "scope stack key",
	/* 107 */ "semantic restriction function",
	/*  57 */ "send phrase",
	/*  51 */ "sequence phrase",
	/*  26 */ "set",
	/*  27 */ "set meta",
	/* 114 */ "set of atom",
	/* 134 */ "set of exception",
	/*  75 */ "set of string",
	/*  49 */ "stack dump key",
	/* 148 */ "statement phrase",
	/* 159 */ "static tokens key",
	/*  28 */ "string",
	/* 171 */ "styler function",
	/* 142 */ "super cast phrase",
	/* 115 */ "token",
	/* 172 */ "token classifiers",
	/* 173 */ "token tuple",
	/*  70 */ "true",
	/*  32 */ "tuple",
	/*  33 */ "tuple meta",
	/* 117 */ "tuple of any meta",
	/* 152 */ "tuple of definition",
	/* 125 */ "tuple of expressions yielding any",
	/*  48 */ "tuple of function",
	/* 138 */ "tuple of integer",
	/* 102 */ "tuple of nybble",
	/* 108 */ "tuple of semantic restriction function",
	/* 128 */ "tuple of set of atom",
	/*  74 */ "tuple of set of string",
	/*  72 */ "tuple of string",
	/* 100 */ "tuple of tuple",
	/* 130 */ "tuple of tuple of any meta",
	/*  73 */ "tuple of type",
	/* 139 */ "two or more tuple",
	/*  34 */ "type",
	/* 112 */ "type of Euler number",
	/*  14 */ "type of tuple of type of any",
	/* 110 */ "type of two",
	/* 106 */ "type of zero",
	/* 105 */ "unary procedure",
	/* 103 */ "unsigned short",
	/* 124 */ "variable",
	/*   8 */ "variable meta",
	/*  56 */ "variable reference phrase",
	/*  60 */ "variable use phrase",
	/* 165 */ "whitespace",
	/*  36 */ "whole number",
	/*  98 */ "whole number meta",
	/* 124 */ "write-only variable",
	/*  77 */ "∅",
	/*  79 */ "∞",
	/*  35 */ "⊤",
	/*  29 */ "⊥",
	/*  30 */ "⊥meta"
Body

/**
 * The practical abstract root of the Avail type lattice. {@code "any"} is the
 * second most senior type, inferior only to {@method "⊤"}. It includes every
 * value available to an Avail program, i.e., every Avail value except for the
 * unexposed special value nil.
 *
 * {@code "any"} is made extremely useful by the interaction of polymorphism
 * and semantic restrictions. Many algorithms can be codified once in terms of
 * {@code "any"} and then strengthened via a semantic restriction that
 * extrapolates a stronger result subtype from the static input types.
 *
 * {@code "any"} is the most general type that may appear in the following
 * contexts:
 *
 * <ul>
 * <li>As a parameter type of a function type.</li>
 * <li>As the read type of a variable type.</li>
 * <li>As a leading type or the default type of a tuple type.</li>
 * <li>As the element type of a set type.</li>
 * <li>As the key type or value type of a map type.</li>
 * <li>As the field type of an object type.</li>
 * <li>As the type parameter of a pojo type.</li>
 * </ul>
 *
 * @category "Primitives" "Types"
 * @type "any"
 * @supertype "⊤"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-any.html"
 */
Special object "any" is special object 1;

/**
 * The enumeration of the special atoms {@method "true"} and {@method "false"}.
 * All primitive interrogatives use classical (Boolean) bivalence and all stable
 * primitive interrogatives obey the three classical (Aristotelian) laws of
 * thought.
 *
 * Bivalent logic assigns either {@method "true"} or {@method "false"} as the
 * unique truth value of every proposition. A primitive interrogative, i.e.
 * {@method "boolean" "boolean-valued"} primitive, is stable iff it reliably answers
 * either {@method "true"} or {@method "false"} for a given set of arguments.
 *
 * The three classical laws of thought are:
 *
 * <ul>
 * <li><strong>The law of identity: P → P.</strong> For every stable primitive
 * interrogative {@code "prim_,_,_"}, then {@code "prim A, B, C = prim A, B, C"}.
 * </li>
 * <li><strong>The law of noncontradiction: ¬(P ∧ ¬P).</strong> For every
 * stable primitive interrogative {@code "prim_,_,_"}, then {@method
 * "(prim A, B, C ∧ ¬prim A, B, C) = false"}.</li>
 * <li><strong>The law of excluded middle: P ∨ ¬P.</strong> For every primitive
 * interrogative {@code "prim_,_,_"}, then {@code
 * "((prim A, B, C = true) ∨ (prim A, B, C = false)) = true"}.</li></ul>
 *
 * Note that values may be instances of many enumerations. This means that Avail
 * directly supports other logical systems, such as Kleene's three-valued logic
 * of indeterminacy, whose truth values are {@code "true"}, {@code "false"},
 * and {@code "unknown"}. Implementation of this system would proceed directly
 * from creation of an atom to represent {@code "unknown"} and the formation of
 * a new enumeration that contained the standard {@method "true"} and {@method
 * "false"} atoms and also the {@code "unknown"} atom. New logical operations
 * could then be written in terms of this new enumeration.
 *
 * @category "Primitives" "Types"
 * @type "boolean"
 * @supertype "atom"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-boolean.html"
 */
Special object "boolean" is special object 2;

/**
 * A character is a sign or symbol in the semiotic sense: an entity with
 * distinct identity that is nonetheless generally intended and understood to
 * represent something other than itself. The visual representation of a
 * character is a glyph. A character is necessarily distinct from how it is
 * written or printed. The same character will differ in any two handwritten
 * occurrences, even when the same person is responsible for the production of
 * both. Likewise the printed representation of a character will differ by font
 * or style. So a character has identity independent of any and all glyphs that
 * transcribe it.
 *
 * Avail is only concerned with character value, not meaning or transcription. A
 * character is always equal to itself and always unequal to another character.
 * Characters are immutable and possess but a single intrinsic property:
 * {@method "_'s⁇code point" Unicode code point}. Unicode is an international
 * standard for the codification of all widely used characters. A code point is
 * a numeric value that is uniquely associated with a character relative to some
 * system of codification. Thus a character's Unicode code point singularly
 * identifies it within the Unicode scheme.
 *
 * A character literal is expressed as a cent sign {@code "¢"} (U+00A2) followed
 * by a single-character lexeme or length-one string literal. Avail character
 * literal notation is provided by the method {@method "¢…!"}. The
 * single-character form is sufficient for nearly every character, but the
 * string literal form must be employed when the desired character is a
 * quotation mark {@code "\""} (U+0022), semicolon {@code ";"} (U+003B), or
 * nonprintable character.
 *
 * @category "Primitives" "Types"
 * @type "character"
 * @supertype "nontype"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-boolean.html"
 * @see "http://www.unicode.org/"
 * @see "http://www.unicode.org/standard/standard.html"
 */
Special object "character" is special object 3;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "function"
 * @alias "[…]→⊤"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-function.html"
 */
Special object "function" is special object 4;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "function meta"
 * @alias "[…]→⊤'s type"
 * @sticky
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-function.html"
 */
Special object "function meta" is special object 5;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "function implementation"
 * @alias "¢[…]→⊤"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-function-implementation.html"
 */
Special object "function implementation" is special object 6;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "variable"
 * @alias "read ⊤/write ⊥"
 * @supertype "nontype"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-variable.html"
 */
Special object "variable" is special object 7;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "variable meta"
 * @alias "(read ⊤/write ⊥)'s type"
 * @supertype "nontypes type"
 * @sticky
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-variable.html"
 */
Special object "variable meta" is special object 8;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "continuation"
 * @alias "$[…]→⊥"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-continuation.html"
 */
Special object "continuation" is special object 9;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "continuation meta"
 * @alias "($[…]→⊥)'s type"
 * @sticky
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-continuation.html"
 */
Special object "continuation meta" is special object 10;

/**
 * An {@code "atom"} is a mutable value associated with a module-allocated
 * name. For each name that appears in the {@code "Names"} section of a module's
 * header, the compiler associates that name with a new atom. For each name that
 * appears in the {@code "Uses"} or {@code "Extends"} section of a module's
 * header, the compiler associates that name with the atom introduced by the
 * module that named it. During compilation of a module, an atom may be
 * retrieved by presenting its name, a string, to the primitive method {@method
 * "atom for_"}. If the atom was neither introduced by the current module nor
 * imported from another module, then {@method "atom for_"} privately
 * introduces a new atom into the {@method "current module"}; a subsequent send
 * with the same argument within the context of the same module will produce the
 * same atom.
 *
 * In ordinary use, the primary asset of an atom is its distinction from every
 * other value, including an equivalently named atom that originated in a
 * different module. Consider the values {@method "true"} and {@method "false"}
 * from classical logic. The principal characteristic of each is its distinction
 * from the other. In other words, {@method "true"} and {@method "false"}
 * differ by identity rather than by some measurable quantity. In Avail, the
 * values {@method "true"} and {@method "false"} are special atoms; they are
 * issued by the virtual machine rather than some module. The type {@type
 * "boolean"} is simply the finite enumeration of these two atoms.
 *
 * In addition to a {@method "_'s⁇name" name} and an {@method "_'s⁇issuing
 * module" issuing module}, an atom also comprises a collection of bindings,
 * called properties. Since an atom has identity, it can {@method "_[_]:=_"
 * acquire new properties}, {@method "_[_]:=_" update existing properties}, and
 * {@method "Remove_[_]" lose properties altogether}. A property is an
 * association between another atom — the property key — and an arbitrary value
 * — the property value. The properties of an atom are not enumerable, thus
 * ensuring modular usage; an algorithm can only query or alter a property for
 * which it possesses the key.
 *
 * The type {@code "atom"} has every atom as an instance. atom is a complete
 * type. Though its properties are analogous to the bindings of a map or the
 * attributes of an object, {@code "atom"} does not require (or permit) type
 * parameters for the property key type or the property value type. These
 * limitations are a direct consequence of mutability.
 *
 * Note that special atoms cannot participate in the property mechanism. For
 * instance, the special atom true cannot be either the target or the property
 * key of a property interrogation. It can be a property value, however.
 *
 * @category "Primitives" "Types" "Atoms"
 * @type "atom"
 * @supertype "nontype"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-atom.html"
 */
Special object "atom" is special object 11;

/**
 * A double — that is, an IEEE 754 double-precision floating point number — is
 * an approximation of a real number. The representation uses 64 binary digits,
 * hereinafter bits, organized as 1 sign bit, 52 bits of mantissa, and 11 bits
 * of exponent. The sign bit distinguishes positive (sign bit = 0) and negative
 * (sign bit = 1) values. The mantissa encodes the significant binary digits of
 * the number. The exponent scales the mantissa by a particular power of 2.
 * Finite double values range from {@code "-1.79769313486231570e+308"} to
 * {@code "1.79769313486231570e+308"}. The closest to zero nonzero double values
 * are {@code "±4.94065645841246544e-324"}. Positive zero ({@code "0.0"}) and
 * negative zero ({@code "-0.0"}) are considered distinct. Infinities are
 * supported, but indicate an overflow of representational limits (rather than
 * {@code "±∞"}). Some encodings do not represent real values; such a value is a
 * not-a-number ({@code "NaN"}). No two differing {@code "NaN"} encodings are
 * considered equal. This is a departure from a strict interpretation of IEEE
 * 754.
 *
 * In Avail, a literal double begins with one or more decimal digits, contains a
 * full stop {@code "."} (U+002E) and fractional part, and optionally ends with
 * exponential notation — an {@code "E"} (U+0045) or {@code "e"} (U+0065)
 * followed by one or more decimal digits.
 *
 * Though {@code "double"} numerically subsumes {@type "float"}, they are
 * considered siblings because their values differ by internal representation.
 * {@code "double"} is not a supertype of {@type "float"}. No float value is
 * also a double value, and no double value is also a float value.
 *
 * @category "Primitives" "Types" "Numbers"
 * @type "double"
 * @supertype "number"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-double.html"
 */
Special object "double" is special object 12;

/**
 * An integer is a discrete number, i.e., it has no fractional part. As such,
 * integers are excellent for counting and labeling.
 *
 * The literal representation of an integer is a sequence of one or more decimal
 * digits. Negative integer literals are created using the method {@method
 * "-_"}, which defines a semantic restriction that strengthens the answer's
 * type to an instance type whenever the argument's value is precisely known.
 * {@method "∞"} and {@method "-∞"} are positive and negative infinity,
 * respectively.
 *
 * @category "Primitives" "Types" "Numbers"
 * @type "extended integer"
 * @alias "[-∞..∞]"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-extended-integer.html"
 */
Special object "extended integer" is special object 13;

/**
 * A tuple type whose default type is {@type "any meta" any's type}.
 *
 * @category "Primitives" "Types"
 * @type "type of tuple of type of any"
 * @alias "<any's type…|>'s type"
 */
Special object "type of tuple of type of any" is special object 14;

/**
 * A float — that is, an IEEE 754 single-precision floating point number — is an
 * approximation of a real number. The representation uses 32 bits, organized as
 * 1 sign bit, 23 bits of mantissa, and 8 bits of exponent. Finite float values
 * range from {@code "-3.40282347e+38"} to {@code "3.40282347e+38"}. The
 * closest to zero nonzero float values are {@code "±1.40239846e-45"}. Positive
 * zero ({@code "0.0"}) and negative zero ({@code "-0.0"}) are considered
 * distinct. Infinities are supported, but indicate an overflow of
 * representational limits (rather than {@code "±∞"}). Some encodings do not
 * represent real values; such a value is a not-a-number ({@code "NaN"}). No
 * two differing {@code "NaN"} encodings are considered equal. This is a
 * departure from a strict interpretation of IEEE 754.
 *
 * The float type is provided only for interoperation with the Java programming
 * language. Use of float values is generally discouraged; prefer double values
 * whenever possible. There is no syntax for specifying a literal float.
 * Instead, use the method {@method "_→float"} to convert a double value to a
 * float value.
 *
 * @category "Primitives" "Types" "Numbers"
 * @type "float"
 * @supertype "number"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-float.html"
 */
Special object "float" is special object 15;

/**
 * A number is an immutable mathematical object. Uses of numbers include
 * counting, annotating entities to distinguish them, and measuring the
 * magnitudes of quantities. Avail natively supports integers and two distinct
 * precisions of floating-point approximations of real numbers. {@type
 * "extended integer" Integers} are discrete, and thus excel at counting and
 * labeling. Real numbers form a continuum, and are therefore suitable for
 * taking measurements.
 *
 * @category "Primitives" "Types" "Numbers"
 * @type "number"
 * @supertype "nontype"
 * @see {@type "double"}
 * @see {@type "extended integer"}
 * @see {@type "float"}
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-number.html"
 */
Special object "number" is special object 16;

/**
 * The type of all finite integers.
 *
 * @category "Primitives" "Types"
 * @type "integer"
 * @alias "(-∞..∞)"
 * @supertype "extended integer"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-extended-integer.html"
 */
Special object "integer" is special object 17;

/**
 * Avail's integral type specifies four parameters for completion:
 *
 * <ul>
 * <li>The lower bound is an integer which specifies the smallest allowed value.
 * The floor operation, {@method "⌊_⌋"}, answers the lower bound of an integral
 * type.</li>
 * <li>The lower bound inclusion indicator is a {@type "boolean"} value that
 * establishes whether the lower bound is a member of the integral type. When
 * this value is {@method "true"}, then the lower bound is included in the
 * type's membership. When this value is {@method "false"}, then it is not so
 * included. The method {@method "⌊_⌋is inclusive"} answers the lower bound
 * inclusion indicator of an integral type.</li>
 * <li>The upper bound is an integer which specifies the largest allowed value.
 * The ceiling operation, {@method "⌈_⌉"}, answers the upper bound of an
 * integral type.</li>
 * <li>The upper bound inclusion indicator is a {@type "boolean"} value that
 * establishes whether the upper bound is a member of the integral type. When
 * this value is {@method "true"}, then the upper bound is included in the
 * type's membership. When this value is {@method "false"}, then it is not so
 * included. The method {@method "⌈_⌉is inclusive"} answers the upper bound
 * inclusion indicator of an integral type.</li>
 * </ul>
 *
 * @category "Primitives" "Types"
 * @type "extended integer meta"
 * @alias "[-∞..∞]'s type"
 * @sticky
 * @see {@method "integer range from_(inclusive=_)to_(inclusive=_)"}
 * @see {@method "[_.._]"}
 * @see {@method "[_.._)"}
 * @see {@method "(_.._]"}
 * @see {@method "(_.._)"}
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-extended-integer.html"
 */
Special object "extended integer meta" is special object 18;

/**
 * The map type specifies three parameters for completion:
 * <ul>
 * <li>The key type specifies a type that includes every key of the domain. The
 * method {@method "_'s⁇key type"} answers the key type of a map type.</li>
 * <li>The value type specifies a type that includes every value of the
 * codomain. The method {@method "_'s⁇value type"} answers the value type of a
 * map type.</li>
 * <li>The cardinality restriction is an {@method "extended integer meta"
 * integral type} that specifies the range of sizes that describe instances. The
 * method {@method "`|`|_`|`|"} answers the cardinality restriction of a map
 * type. The floor operation, {@method "⌊_⌋"}, answers the lower bound of a
 * map type's cardinality restriction. The ceiling operation, {@method "⌈_⌉"},
 * answers the upper bound of a map type's cardinality restriction.</li>
 * </ul>
 *
 * @category "Primitives" "Types"
 * @type "map meta"
 * @alias "{any→any|}'s type"
 * @sticky
 * @see {@method "{_→_`|_}"}
 * @see {@method "{_→_`|_.._}"}
 * @see {@method "{_→_`|_..}"}
 * @see {@method "{_→_`|.._}"}
 * @see {@method "{_→_`|}"}
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-map.html"
 */
Special object "map meta" is special object 19;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "module"
 * @supertype "nontype"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-module.html"
 */
Special object "module" is special object 20;

/**
 * Answer a {@type "tuple"} containing all of the error codes well-known to
 * the Avail virtual machine.
 *
 * @category "Primitives" "Constants"
 * @method "VM error codes"
 * @alias "<natural number…|>"
 * @returns "VM error codes's type"
 */
Special object "VM error codes" is special object 21;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "object"
 * @supertype "nontype"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-object.html"
 */
Special object "object" is special object 22;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "object meta"
 * @alias "object's type"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-object.html"
 */
Special object "object meta" is special object 23;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "exception"
 * @supertype "object"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-exception.html"
 */
Special object "exception" is special object 24;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "fiber"
 * @alias "fiber→⊤"
 * @supertype "nontype"
 */
Special object "fiber" is special object 25;

/**
 * A set is an immutable, finite, unordered collection of distinct, homogeneous
 * values, called members or elements. The number of elements is the cardinality
 * of the set. Breaking this down:
 *
 * <ul>
 * <li>Immutable means that the composition of a set is not subject to change.
 * No operations are, or can be, defined to modify a set in any way; only
 * operations that derive new sets from existing sets are expressible.</li>
 * <li>Finite means that the cardinality of a set is never the value {@method
 * "∞"}. To store a set in memory requires space proportional to its
 * cardinality, and memory is clearly always finite. Additional limits to the
 * practical cardinality of sets may be imposed by the implementation.</li>
 * <li>Unordered means that the members of a set do not occur in any particular
 * order. Any two sets with the same membership are therefore equal.</li>
 * <li>Distinct means that a member occurs only once in the membership of a set.
 * Thus a value is either a member of a set or it is not.</li>
 * <li>Homogeneous means that the members of a set universally conform to a
 * single most general type.</li>
 * </ul>
 *
 * A literal set is expressed as a left curly bracket {@code "{"} (U+007B),
 * then a list of members separated by commas {@code ","} (U+002C), and finally
 * a right curly bracket {@code "}"} (U+007D). The empty set is written as
 * {@method "∅"} (U+2205).
 *
 * The elements of a set need not be known statically. Sets are constructed with
 * the method {@method "{«_‡,»}"}; there is no special built-in syntax for
 * constructing sets. When the compiler can infer an instance type for each
 * argument expression of a particular send of this message, then the semantic
 * restriction is able to strengthen the result to an instance type, thereby
 * according it the same force as a literal understood primitively by the
 * compiler.
 *
 * @category "Primitives" "Types"
 * @type "set"
 * @alias "{any|}"
 * @supertype "nontype"
 * @see {@method "{«_‡,»}"}
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-set.html"
 */
Special object "set" is special object 26;

/**
 * The set type specifies two parameters for completion:
 *
 * <ul>
 * <li>The member type (or element type) specifies a type that includes every
 * member. The method {@method "_'s⁇element|member type"} answers the member
 * type of a set type.</li>
 * <li>The cardinality restriction is an {@method "extended integer meta"
 * integral type} that specifies the range of sizes that describe instances. The
 * method {@method "`|`|_`|`|"} answers the cardinality restriction of a set
 * type. The floor operation, {@method "⌊_⌋"}, answers the lower bound of a set
 * type's cardinality restriction. The ceiling operation, {@method "⌈_⌉"},
 * answers the upper bound of a set type's cardinality restriction.</li>
 * </ul>
 *
 * @category "Primitives" "Types"
 * @type "set meta"
 * @alias "{any|}'s type"
 * @sticky
 * @see {@method "{_|_}"}
 * @see {@method "{_|_.._}"}
 * @see {@method "{_|_..}"}
 * @see {@method "{_|}"}
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-set.html"
 */
Special object "set meta" is special object 27;

/**
 * A string represents text without respect to style or encoding. Naturally, the
 * content of a string consists of {@type "character"}s arrayed in a fixed
 * order.
 *
 * Like integer and double literals, string literals are understood directly by
 * the Avail compiler. A string literal begins with a quotation mark {@code
 * "\""} (U+0022), continues with arbitrary Unicode characters optionally
 * interleaved with escape sequences, and ends with a quotation mark. The string
 * literal metacharacters are quotation mark and reverse solidus {@code "\\"}
 * (U+005C) — also called backslash. A reverse solidus alters the meaning of the
 * next character, called the escaped character:
 *
 * <ul>
 * <li>When the escaped character is reverse solidus or quotation mark, then its
 * special meaning as a metacharacter is disabled.</li>
 * <li>When the escaped character is {@code "t"} (U+0074), then the intended
 * character is character tabulation (U+0009), also called horizontal tab.</li>
 * </ul>
 * <li>When the escaped character is {@code "n"} (U+006E), then the intended
 * character is line feed (U+000A)</li>.
 * <li>When the escaped character is {@code "r"} (U+0072), then the intended
 * character is carriage return (U+000D).</li>
 * <li>When the escaped character is left parenthesis {@code "("} (U+0028),
 * then the compiler expects a sequence of hexadecimal numerals separated by
 * commas {@code ","} (U+002C) and finally a right parenthesis {@code ")"}
 * (U+0029). Each hexadecimal numeral must denote an integral value from
 * {@code "0"} to {@code "10FFFF"}<sub>16</sub> ({@code
 * "1114111"}<sub>10</sub>); the case of the hexadecimal digits {@code "A"}
 * through {@code "F"} does not matter. Each number represents the character
 * associated with the Unicode code point of the same value. The construct as a
 * whole then denotes a sequence of characters.</li>
 * <li>When the escaped character is line feed (U+000A), then the compiler
 * elides the line feed altogether. This permits a string literal to span
 * multiple lines without forcing its content to span multiple lines. Note that
 * an occurrence of carriage return (U+000D) after the reverse solidus, or even
 * the combination carriage return+line feed, is treated similarly; it is
 * stripped from the resulting string.</li>
 * <li>When the escaped character is vertical line {@code "|"} (U+007C), then
 * the compiler discards all whitespace from the beginning of the same line up
 * to the reverse solidus. This region is not permitted to contain characters
 * other than whitespace, in fact. This feature permits nice formatting of
 * multiline string literals within source code, and is particularly powerful in
 * conjunction with escaping of line feeds.</li>
 * </ul>
 *
 * The empty string is written as {@code "\"\""}. It is the same value as the
 * empty tuple, {@code "<>"}.
 *
 * @category "Primitives" "Types"
 * @type "string"
 * @alias "character*"
 * @supertype "tuple"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-string.html"
 */
Special object "string" is special object 28;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "⊥"
 * @alias "⊥"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-bottom.html"
 */
Special object "⊥" is special object 29;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "⊥meta"
 * @alias "⊥'s type"
 */
Special object "⊥meta" is special object 30;

/**
 * Every value that is not itself a type is an instance of the primitive type
 * {@code "nontype"}. The subtypes of {@code "nontype"} are therefore those
 * types whose instances are not themselves types. Except for {@method "⊤"},
 * {@method "any"}, and {@method "type"}, every primitive type is a subtype of
 * {@code "nontype"}. It is a sibling of {@method "type"}, and every value is
 * either an instance of {@code "nontype"} or {@method "type"}.
 *
 * @category "Primitives" "Types"
 * @type "nontype"
 * @supertype "any"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-nontype.html"
 */
Special object "nontype" is special object 31;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "tuple"
 * @alias "any*"
 * @supertype "nontype"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-tuple.html"
 */
Special object "tuple" is special object 32;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "tuple meta"
 * @alias "any*'s type"
 * @sticky
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-tuple.html"
 */
Special object "tuple meta" is special object 33;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "type"
 * @alias "⊤'s type"
 */
Special object "type" is special object 34;

/**
 * The true abstract root of the Avail type lattice. It is pronounced "top" and
 * written as the down tack (⊤) character. Every Avail value is an instance
 * of {@code "⊤"}, and every Avail type is a subtype of {@code "⊤"}.
 *
 * {@code "⊤"} is distinct from {@method "any"} in that it includes exactly one
 * additional value: the special value {@code "nil"}. This value does not
 * satisfy any public protocol and is not available to an Avail programmer. It
 * is, however, implicitly returned from every procedure, i.e., function whose
 * return type is {@code "⊤"}. Thus {@code "nil"} is the value produced iff no
 * value is produced. The virtual machine uses {@code "nil"} to simplify
 * several core algorithms, but exposure of nil to an Avail programmer would not
 * yield a net good.
 *
 * {@code "⊤"} typically appears in Avail code in only a few select contexts:
 *
 * <ul>
 * <li>As the {@method "_'s⁇return type" return type} of a function type. In
 * this context, it signifies that the function does not produce a value, i.e.,
 * it produces the unexposed value {@code "nil"}.</li>
 * <li>As the {@method "_'s⁇return type" return type} of a continuation type. In
 * this context, it signifies that the continuation will not produce a value,
 * i.e., it produces the unexposed value {@code "nil"}.</li>
 * <li>As the {@method "_'s⁇read type" read type} of a variable type. In this
 * context, it signifies that no value may be read from the variable, i.e., the
 * variable is write-only.</li>
 * <li>As the idempotent initial value of an accumulator variable whose
 * intermediate and final results represent a chain of type intersections. (Note
 * that the type intersection of {@code "⊤"} with some type {@code "X"} is
 * always {@code "X"}.)</li>
 * <li>As the result of a semantic restriction on a procedure that serves only
 * to reject parses based on the static types of the arguments (but does not
 * strengthen the return type).</li>
 * <li>As the {@method "_'s⁇result type" result type} of a phrase. In this
 * context, it signifies that the phrase serves as a statement (and not merely
 * as an expression).</li>
 * </ul>
 *
 * A function whose declared return type is {@code "⊤"} is still permitted to
 * answer an actual (non-{@code "nil"}) value. This is consistent with the type
 * lattice, since every value is an instance of {@code "⊤"}. It is useful,
 * moreover, because a semantic restriction may strengthen the return type of a
 * {@code "⊤"}-valued function at a particular call site to a subtype of
 * {@code "⊤"}.
 *
 * {@code "⊤"} is expressly forbidden from occurring in most contexts, including
 * the following:
 *
 * <ul>
 * <li>As a parameter type of a function type.</li>
 * <li>As the write type of a variable type. This also implies that it cannot
 * be the type of an actual variable.</li>
 * <li>As a leading type or the default type of a tuple type.</li>
 * <li>As the element type of a set type.</li>
 * <li>As the key type or value type of a map type.</li>
 * <li>As the field type of an object type.</li>
 * <li>As the type parameter of a pojo type.</li>
 * </ul>
 *
 * Note that these prohibitions, when considered in aggregate, negate any
 * possible value that could be gleaned from exposing the special value {@code
 * "nil"} to an Avail program. They conspire together to ensure that nil could
 * never be retained by an Avail value. It may therefore only exist as a
 * temporary within a continuation, i.e., an item on the local stack of a
 * function call. A reflective query of a continuation's temporaries that would
 * answer {@code "nil"} will instead produce a variable whose read type is
 * {@method "⊥"}.
 *
 * @category "Primitives" "Types"
 * @type "⊤"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-top.html"
 */
Special object "⊤" is special object 35;

/**
 * The type of all counting numbers.
 *
 * @category "Primitives" "Types"
 * @type "whole number"
 * @alias "[0..∞)"
 * @supertype "extended integer"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-extended-integer.html"
 */
Special object "whole number" is special object 36;

/**
 * The type of all positive numbers. This is also the type of all subscripts.
 *
 * @category "Primitives" "Types"
 * @type "natural number"
 * @alias "[1..∞)"
 * @supertype "extended integer"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-extended-integer.html"
 */
Special object "natural number" is special object 37;

/**
 * The type of all reserved Unicode code points.
 *
 * @category "Primitives" "Types"
 * @type "code point"
 * @alias "[0..1114111]"
 * @supertype "whole number"
 */
Special object "code point" is special object 38;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "map"
 * @alias "{any→any|}"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-map.html"
 */
Special object "map" is special object 39;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "message bundle"
 * @supertype "nontype"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-message-bundle.html"
 */
Special object "message bundle" is special object 40;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "message bundle tree"
 * @supertype "nontype"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-message-bundle-tree.html"
 */
Special object "message bundle tree" is special object 41;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "method"
 * @supertype "nontype"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-method.html"
 */
Special object "method" is special object 42;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "definition"
 * @supertype "type"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-definition.html"
 */
Special object "definition" is special object 43;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "abstract definition"
 * @supertype "definition"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-abstract-definition.html"
 */
Special object "abstract definition" is special object 44;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "forward definition"
 * @supertype "definition"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-forward-definition.html"
 */
Special object "forward definition" is special object 45;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "method definition"
 * @supertype "definition"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-method-definition.html"
 */
Special object "method definition" is special object 46;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "macro definition"
 * @supertype "definition"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-macro-definition.html"
 */
Special object "macro definition" is special object 47;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "tuple of function"
 * @alias "<[…]→⊤…|>"
 */
Special object "tuple of function" is special object 48;

/**
 * The {@code atom} under which the stack is captured within an
 * {@code exception} when it is raised.
 *
 * @category "Primitives" "Constants"
 * @type "stack dump key"
 * @alias "atom"
 * @returns "stack dump key's type"
 */
Special object "stack dump key" is special object 49;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "phrase"
 * @alias "phrase⇒⊤"
 * @supertype "nontype"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-phrase.html"
 */
Special object "phrase" is special object 50;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "sequence phrase"
 * @alias "sequence phrase⇒⊤"
 * @supertype "phrase"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-sequence-phrase.html"
 */
Special object "sequence phrase" is special object 51;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "expression phrase"
 * @alias "expression phrase⇒⊤"
 * @supertype "phrase"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-expression-phrase.html"
 */
Special object "expression phrase" is special object 52;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "assignment phrase"
 * @alias "assignment phrase⇒⊤"
 * @supertype "expression phrase"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-assignment-phrase.html"
 */
Special object "assignment phrase" is special object 53;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "block phrase"
 * @alias "block phrase⇒[…]→⊤"
 * @supertype "expression phrase"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-block-phrase.html"
 */
Special object "block phrase" is special object 54;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "literal phrase"
 * @alias "literal phrase⇒any"
 * @supertype "expression phrase"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-literal-phrase.html"
 */
Special object "literal phrase" is special object 55;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "variable reference phrase"
 * @alias "reference phrase⇒variable"
 * @supertype "expression phrase"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-variable-reference-phrase.html"
 */
Special object "variable reference phrase" is special object 56;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "send phrase"
 * @alias "send phrase⇒⊤"
 * @supertype "expression phrase"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-send-phrase.html"
 */
Special object "send phrase" is special object 57;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "literal token meta"
 * @alias "(literal token⇒any)'s type"
 * @supertype "token's type"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-literal-token.html"
 */
Special object "literal token meta" is special object 58;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "list phrase"
 * @alias "list phrase⇒tuple"
 * @supertype "expression phrase"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-list-phrase.html"
 */
Special object "list phrase" is special object 59;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "variable use phrase"
 * @alias "variable use phrase⇒any"
 * @supertype "expression phrase"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-variable-use-phrase.html"
 */
Special object "variable use phrase" is special object 60;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "declaration phrase"
 * @alias "declaration phrase⇒⊤"
 * @supertype "phrase"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-declaration-phrase.html"
 */
Special object "declaration phrase" is special object 61;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "argument phrase"
 * @alias "argument phrase⇒⊤"
 * @supertype "declaration phrase"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-argument-phrase.html"
 */
Special object "argument phrase" is special object 62;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "label phrase"
 * @alias "label phrase⇒⊤"
 * @supertype "declaration phrase"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-label-phrase.html"
 */
Special object "label phrase" is special object 63;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "local variable phrase"
 * @alias "local variable phrase⇒⊤"
 * @supertype "declaration phrase"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-local-variable-phrase.html"
 */
Special object "local variable phrase" is special object 64;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "local constant phrase"
 * @alias "local constant phrase⇒⊤"
 * @supertype "declaration phrase"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-local-constant-phrase.html"
 */
Special object "local constant phrase" is special object 65;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "module variable phrase"
 * @alias "module variable phrase⇒⊤"
 * @supertype "declaration phrase"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-module-variable-phrase.html"
 */
Special object "module variable phrase" is special object 66;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "module constant phrase"
 * @alias "module constant phrase⇒⊤"
 * @supertype "declaration phrase"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-module-constant-phrase.html"
 */
Special object "module constant phrase" is special object 67;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "primitive failure reason phrase"
 * @alias "primitive failure reason phrase⇒⊤"
 * @supertype "declaration phrase"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-primitive-failure-reason-phrase.html"
 */
Special object "primitive failure reason phrase" is special object 68;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "any meta"
 * @alias "any's type"
 * @supertype "type"
 * @sticky
 */
Special object "any meta" is special object 69;

/**
 * The special atom that represents truth. {@method "true"} is an instance of
 * {@type "boolean"}.
 *
 * @category "Primitives" "Constants"
 * @method "true"
 * @returns "true's type"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-boolean.html"
 */
Special object "true" is special object 70;

/**
 * The special atom that represents falsehood. {@method "false"} is an instance
 * of {@type "boolean"}.
 *
 * @category "Primitives" "Constants"
 * @method "false"
 * @returns "false's type"
 * @see "http://www.availlang.org/about-avail/documentation/type-system/types-boolean.html"
 */
Special object "false" is special object 71;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "tuple of string"
 * @alias "string*"
 */
Special object "tuple of string" is special object 72;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "tuple of type"
 * @alias "<⊤'s type…|>"
 */
Special object "tuple of type" is special object 73;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "tuple of set of string"
 * @alias "<{string|}…|>"
 */
Special object "tuple of set of string" is special object 74;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "set of string"
 * @alias "{string|}"
 */
Special object "set of string" is special object 75;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "primitive failure function"
 * @alias "[[1..∞)]→⊥"
 */
Special object "primitive failure function" is special object 76;

/**
 * Answer the empty {@type "set"}.
 *
 * @category "Primitives" "Constants"
 * @method "∅"
 * @returns "∅'s type"
 */
Special object "∅" is special object 77;

/**
 * Answer negative infinity.
 *
 * @category "Primitives" "Constants"
 * @method "-∞"
 * @returns "-∞'s type"
 */
Special object "-∞" is special object 78;

/**
 * Answer positive infinity.
 *
 * @category "Primitives" "Constants"
 * @method "∞"
 * @returns "∞'s type"
 */
Special object "∞" is special object 79;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "pojo"
 * @alias "java.lang.Object"
 * @supertype "nontype"
 */
Special object "pojo" is special object 80;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "pojo⊥"
 * @alias "pojo ⊥"
 * @supertype "pojo"
 */
Special object "pojo⊥" is special object 81;

/**
 * Answer Java {@code "null"}.
 *
 * @category "Primitives" "Constants"
 * @method "Java null"
 * @type "⊥"
 * @returns "Java null's type"
 */
Special object "Java null" is special object 82;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "pojo self type"
 * @alias "pojo self type"
 * @supertype "atom"
 */
Special object "pojo self type" is special object 83;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "pojo meta"
 * @alias "java.lang.Object's type"
 */
Special object "pojo meta" is special object 84;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "pojo array meta"
 * @alias "any[]'s type"
 */
Special object "pojo array meta" is special object 85;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "function returning any"
 * @alias "[…]→any"
 */
Special object "function returning any" is special object 86;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "pojo array"
 * @alias "any[]"
 */
Special object "pojo array" is special object 87;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Constants"
 * @method "pojo self"
 * @returns "pojo self's type"
 */
Special object "pojo self" is special object 88;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "pojo exception"
 * @alias "java.lang.Throwable"
 */
Special object "pojo exception" is special object 89;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "nullary procedure"
 * @alias "[]→⊤"
 */
Special object "nullary procedure" is special object 90;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "predicate function"
 * @alias "[]→boolean"
 */
Special object "predicate function" is special object 91;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "continuation variable"
 * @alias "↑$[…]→⊥"
 */
Special object "continuation variable" is special object 92;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "field map"
 * @alias "{atom→any|}"
 */
Special object "field map" is special object 93;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "field type map"
 * @alias "{atom→any's type|}"
 */
Special object "field type map" is special object 94;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "key-value tuple"
 * @alias "<<any…|2>…|>"
 */
Special object "key-value tuple" is special object 95;

/**
 * Answer the empty {@type "map"}.
 *
 * @category "Primitives" "Constants"
 * @method "empty map"
 * @returns "{}'s type"
 */
Special object "empty map" is special object 96;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "non-empty map"
 * @alias "{any→any|1..∞}"
 */
Special object "non-empty map" is special object 97;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "whole number meta"
 * @alias "[0..∞)'s type"
 */
Special object "whole number meta" is special object 98;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "non-empty set"
 * @alias "{any|1..∞}"
 */
Special object "non-empty set" is special object 99;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "tuple of tuple"
 * @alias "tuple*"
 */
Special object "tuple of tuple" is special object 100;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "nybble"
 * @alias "[0..15]"
 */
Special object "nybble" is special object 101;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "tuple of nybble"
 * @alias "<[0..15]…|>"
 */
Special object "tuple of nybble" is special object 102;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "unsigned short"
 * @alias "[0..65535]"
 */
Special object "unsigned short" is special object 103;

/**
 * Answer the empty {@type "tuple"}.
 *
 * @category "Primitives" "Constants"
 * @method "empty tuple"
 * @returns "<>'s type"
 */
Special object "empty tuple" is special object 104;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "unary procedure"
 * @alias "[⊥]→⊤"
 */
Special object "unary procedure" is special object 105;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "type of zero"
 * @alias "0's type"
 */
Special object "type of zero" is special object 106;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "semantic restriction function"
 * @alias "[…]→⊤'s type"
 */
Special object "semantic restriction function" is special object 107;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "tuple of semantic restriction function"
 * @alias "<[…]→⊤'s type…|>"
 */
Special object "tuple of semantic restriction function" is special object 108;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "macro function"
 * @alias "[…]→phrase⇒⊤"
 */
Special object "macro function" is special object 109;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "type of two"
 * @alias "2's type"
 */
Special object "type of two" is special object 110;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Constants"
 * @method "Euler's number"
 * @returns "2.718281828459045d's type"
 */
Special object "Euler's number" is special object 111;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "type of Euler number"
 * @alias "2.718281828459045d's type"
 */
Special object "type of Euler number" is special object 112;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "phrase meta"
 * @alias "(phrase⇒⊤)'s type"
 */
Special object "phrase meta" is special object 113;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "set of atom"
 * @alias "{atom|}"
 */
Special object "set of atom" is special object 114;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "token"
 * @supertype "nontype"
 */
Special object "token" is special object 115;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "literal token"
 * @alias "literal token⇒any"
 * @supertype "token"
 */
Special object "literal token" is special object 116;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "tuple of any meta"
 * @alias "<any's type…|>"
 */
Special object "tuple of any meta" is special object 117;

/**
 * The type of all nonnegative integers.
 *
 * @category "Primitives" "Types"
 * @type "nonnegative extended integer"
 * @alias "[0..∞]"
 */
Special object "nonnegative extended integer" is special object 118;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "field type tuple"
 * @alias "<<atom, any's type…|2>…|>"
 */
Special object "field type tuple" is special object 119;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "field tuple"
 * @alias "<<atom, any…|2>…|>"
 */
Special object "field tuple" is special object 120;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "phrase tuple"
 * @alias "<phrase⇒⊤…|>"
 */
Special object "phrase tuple" is special object 121;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "argument tuple"
 * @alias "<argument phrase⇒⊤…|>"
 */
Special object "argument tuple" is special object 122;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "declaration tuple"
 * @alias "<declaration phrase⇒⊤…|>"
 */
Special object "declaration tuple" is special object 123;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "write-only variable"
 * @alias "read ⊤/write ⊥"
 * @supertype "variable"
 */
Special object "write-only variable" is special object 124;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "tuple of expressions yielding any"
 * @alias "<expression phrase⇒any…|>"
 */
Special object "tuple of expressions yielding any" is special object 125;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "expression yielding any"
 * @alias "expression phrase⇒any"
 */
Special object "expression yielding any" is special object 126;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "pojo failure function"
 * @alias "[java.lang.Throwable]→⊥"
 */
Special object "pojo failure function" is special object 127;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "tuple of set of atom"
 * @alias "<{atom|}…|>"
 */
Special object "tuple of set of atom" is special object 128;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "byte"
 * @alias "[0..255]"
 */
Special object "byte" is special object 129;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "tuple of tuple of any meta"
 * @alias "<<any's type…|>…|>"
 */
Special object "tuple of tuple of any meta" is special object 130;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "readable extended integer variable"
 * @alias "read [-∞..∞]/write ⊥"
 */
Special object "readable extended integer variable" is special object 131;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "fiber meta"
 * @alias "(fiber→⊤)'s type"
 */
Special object "fiber meta" is special object 132;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "nonempty string"
 * @alias "character+"
 */
Special object "nonempty string" is special object 133;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "set of exception"
 * @alias "{exception|}"
 */
Special object "set of exception" is special object 134;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "nonempty set of string"
 * @alias "{string|1..∞}"
 */
Special object "nonempty set of string" is special object 135;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "nonempty set of atom"
 * @alias "{atom|1..∞}"
 */
Special object "nonempty set of atom" is special object 136;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "nonempty tuple"
 * @alias "any+"
 */
Special object "nonempty tuple" is special object 137;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "tuple of integer"
 * @alias "<(-∞..∞)…|>"
 */
Special object "tuple of integer" is special object 138;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "two or more tuple"
 * @alias "<any…|2..∞>"
 */
Special object "two or more tuple" is special object 139;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "first of sequence phrase"
 * @alias "first of sequence phrase⇒⊤"
 */
Special object "first of sequence phrase" is special object 140;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "permuted list phrase⇒tuple"
 * @alias "permuted list phrase"
 */
Special object "permuted list phrase" is special object 141;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "super cast phrase⇒any"
 * @alias "super cast phrase"
 */
Special object "super cast phrase" is special object 142;

/**
 * The name of the fiber global through which parsing information is
 * communicated to and from the compiler.
 *
 * @category "Primitives" "Constants"
 * @method "parse map key"
 * @type "atom"
 * @returns "parse map key's type"
 */
Special object "parse map key" is special object 143;

/**
 * The key within the client data fiber global that holds a map of all
 * declarations that are currently in scope during compilation.
 *
 * @category "Primitives" "Constants"
 * @method "scope map key"
 * @type "atom"
 * @returns "scope map key's type"
 */
Special object "scope map key" is special object 144;

/**
 * The key within the client data fiber global that holds the tuple of tokens
 * that contributed to the current macro whose body is running.
 *
 * @category "Primitives" "Constants"
 * @method "all tokens key"
 * @type "atom"
 * @returns "all tokens key's type"
 */
Special object "all tokens key" is special object 145;

/**
 * Signed 32-bit integers.
 *
 * @category "Primitives" "Types"
 * @type "[-2147483648..2147483647]"
 * @alias "int32"
 */
Special object "int32" is special object 146;

/**
 * Signed 64-bit integers.
 *
 * @category "Primitives" "Types"
 * @type "[-9223372036854775808..9223372036854775807]"
 * @alias "int64"
 * @supertype "phrase"
 */
Special object "int64" is special object 147;

/**
 * The type of all statement phrases.
 *
 * @category "Primitives" "Types"
 * @type "statement phrase⇒⊤"
 * @alias "statement phrase"
 */
Special object "statement phrase" is special object 148;

/**
 * The key within the client data fiber global that holds a tuple of maps which
 * are previously pushed compilation scopes.
 *
 * @category "Primitives" "Constants"
 * @method "scope stack key"
 * @type "atom"
 * @returns "scope stack key's type"
 */
Special object "scope stack key" is special object 149;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "expression as statement phrase⇒⊤"
 * @alias "expression as statement phrase"
 * @supertype "statement phrase"
 */
Special object "expression as statement phrase" is special object 150;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "<[1..∞)…|1..∞>"
 * @alias "permutation tuple"
 */
Special object "permutation tuple" is special object 151;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "<definition…|>"
 * @alias "tuple of definition"
 */
Special object "tuple of definition" is special object 152;

/**
 * TODO: Special object description goes here.
 *
 * @category "Primitives" "Types"
 * @type "{string→atom|}"
 * @alias "map from string to atom"
 */
Special object "map from string to atom" is special object 153;

/**
 * The key within the client data fiber global that holds the bundle for which
 * a send is undergoing macro substitution.
 *
 * @category "Primitives" "Constants"
 * @method "macro bundle key"
 * @type "atom"
 * @returns "macro bundle key's type"
 */
Special object "macro bundle key" is special object 154;

/**
 * An atom property key that indicates the atom is for explicit subclassing of
 * object types.
 *
 * @category "Primitives" "Constants"
 * @method "explicit subclassing key"
 * @type "atom"
 * @returns "explicit subclassing key's type"
 */
Special object "explicit subclassing key" is special object 155;

/**
 * The type of variables that must contain a map.
 *
 * @category "Primitives" "Types"
 * @type "read map/write ⊥"
 * @alias "map variable"
 */
Special object "map variable" is special object 156;

/**
 * The function type for lexer filters.  If a lexer filter function is passed a
 * character and it returns true, that lexer body will be called whenever that
 * character is encountered during lexical scanning.
 *
 * @category "Primitives" "Types"
 * @type "[character]→boolean"
 * @alias "lexer filter function"
 */
Special object "lexer filter function" is special object 157;

/**
 * The function type for lexer bodies.  A lexer body has access to the source
 * code being scanned, the position at which to start, and the line number at
 * the initial position.
 *
 * @category "Primitives" "Types"
 * @type "[string, [1..∞), [1..∞)]→{<token…|1..∞>|}"
 * @alias "lexer body function"
 */
Special object "lexer body function" is special object 158;

/**
 * The key within the client data fiber global that holds a tuple of tokens,
 * corresponding to parts of the method name, that contributed to the current
 * macro whose prefix function or body is running.
 *
 * @category "Primitives" "Constants"
 * @method "static tokens key"
 * @type "atom"
 * @returns "static tokens key's type"
 */
Special object "static tokens key" is special object 159;

/**
 * An atom that designates the end-of-file token type.
 *
 * @category "Primitives" "Constants"
 * @method "end of file"
 * @type "atom"
 * @returns "end of file's type"
 */
Special object "end of file" is special object 160;

/**
 * An atom that designates the keyword token type.
 *
 * @category "Primitives" "Constants"
 * @method "keyword"
 * @type "atom"
 * @returns "keyword's type"
 */
Special object "keyword" is special object 161;

/**
 * An atom that designates the literal token type.
 *
 * @category "Primitives" "Constants"
 * @method "literal"
 * @type "atom"
 * @returns "literal's type"
 */
Special object "literal" is special object 162;

/**
 * An atom that designates the operator token type.
 *
 * @category "Primitives" "Constants"
 * @method "operator"
 * @type "atom"
 * @returns "operator's type"
 */
Special object "operator" is special object 163;

/**
 * An atom that designates the comment token type.
 *
 * @category "Primitives" "Constants"
 * @method "comment"
 * @type "atom"
 * @returns "comment's type"
 */
Special object "comment" is special object 164;

/**
 * An atom that designates the whitespace token type.
 *
 * @category "Primitives" "Constants"
 * @method "whitespace"
 * @type "atom"
 * @returns "whitespace's type"
 */
Special object "whitespace" is special object 165;

/**
 * The type for parse rejection levels, currently [1..4].
 *
 * @category "Primitives" "Types"
 * @type "[1..4]"
 * @alias "parse rejection level"
 */
Special object "parse rejection level" is special object 166;

/**
 * An integer indicating the nature of some Unicode code point.  For details,
 * see {@code "java.lang.Character.getType(int)"}.
 *
 * @category "Primitives" "Types"
 * @type "[0..31]"
 * @alias "character type number"
 */
Special object "character type number" is special object 167;

/**
 * The continuation type for continuations based on ⊤-valued functions.
 *
 * @category "Primitives" "Types"
 * @type "$[…]→⊤"
 * @alias "continuation returning top"
 */
Special object "continuation returning top" is special object 168;

/**
 * The type for non-empty strings composed entirely of digit characters.
 *
 * @category "Primitives" "Types"
 * @type "¢[0-9]ᵀ+"
 * @alias "non-empty string of digits"
 */
Special object "non-empty string of digits" is special object 169;

/**
 * The 2-element tuple type where the first element is itself a tuple of zero
 * or one occurrences of send phrase, and the second element is a (possibly
 * empty) string.
 *
 * @category "Primitives" "Types"
 * @type "<(send phrase→⊤)?, string…|2>"
 * @alias "optional send phrase and report string"
 */
Special object "optional send phrase and report string" is special object 170;

/**
 * The type for styler functions.  These are passed:
 *   1. a send phrase to be styled,
 *   2. a variable containing a map from send phrase to style, already populated
 *      with styles from the current send phrase's descendants.
 *   3. a variable containing a map from token to style, already populated with
 *      styles from the current send phrase's descendants.
 * When subsequently applying the final styles to the source text, the phrase
 * style map is visited.  Each static token of that phrase is added to the token
 * style map, if it's not already present.  Static tokens are those tokens which
 * literally occur in the message name.  After the token style map has been
 * updated, the tokens are extracted, sorted by file position, and captured in
 * separate records in the relevant repository file.  These can then be overlaid
 * efficiently onto the module text.
 *
 * @category "Primitives" "Types"
 * @type "[send phrase, ↑{send phrase→style|}, ↑{token→style|}]→⊤"
 * @alias "styler function"
 */
Special object "styler function" is special object 171;

/**
 * The enumeration of atoms that specify a token's type.
 *
 * @category "Primitives" "Types"
 * @type "token classifiers"
 */
Special object "token classifiers" is special object 172;

/**
 * The type of a tuple containing zero or more tokens.
 *
 * @category "Primitives" "Types"
 * @type "{1}"
 * @alias "token tuple"
 */
Special object "token tuple" is special object 173;

/**
 * The marker phrase type, instances of which are generally produced by an
 * explicit construction primitive.  A marker phrase type has a yield type.
 * An actual marker phrase contains both a value and a yield type, which do not
 * need to agree with each other.
 *
 * @category "Primitives" "Types"
 * @type "marker phrase⇒⊤"
 * @alias "marker phrase"
 */
Special object "marker phrase" is special object 174;

/**
 * The type for the module imports list for the CreateAnonymousModule
 * primitive.
 *
 * @category "Primitives" "Types"
 * @type "{1}"
 * @alias "module imports tuple"
 */
Special object "module imports tuple" is special object 175;

