/*
 * Fallible Primitives.avail
 * Copyright © 1993-2022, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * GENERATED FILE
 * * Generator: avail.tools.bootstrap.BootstrapGenerator
 * * Last Generated: 8/17/22, 4:23 PM
 *
 * DO NOT MODIFY MANUALLY. ALL MANUAL CHANGES WILL BE LOST.
 */

Module "Fallible Primitives"
Versions
	"Avail-1.6.1"
Extends
Uses
	"Origin",
	"Error Codes",
	"Special Objects",
	"Primitives" =
	(
		"$_@pc=_stack=_[_]caller=_",
		"Abstract method_is_",
		"After the current module is unloaded,⁇do_",
		"Alias_to_",
		"Attempt to join_",
		"Close module_",
		"Copy macros from_to_",
		"Error:_",
		"Exit_with_if_",
		"Export_as a new name",
		"Forward method_is_",
		"Grammatical restriction_is_",
		"Immediately accept parse",
		"In_millisecond|milliseconds,⁇invoke_with_,⁇forked at priority_",
		"Invoke_with_,⁇forked at priority_",
		"Invoke|invoke_with_",
		"Lexer_when_is_",
		"Macro_is«_,»_«styled by_»?",
		"Mark for_character|characters of read ahead",
		"Print:_",
		"Remove current fiber[_]",
		"Remove_[_]",
		"Reset to mark",
		"Restart_with_",
		"Seal method_at_",
		"Seal method|methods_at existing definitions",
		"Semantic restriction_is_",
		"Style method name_",
		"Style span of_with_«overwriting»?",
		"Style string literal_",
		"Style token_as_«overwriting»?",
		"Style_with_",
		"_'s⁇_field",
		"_'s⁇initializing expression",
		"_'s⁇instances",
		"_'s⁇issuing module",
		"_'s⁇result",
		"_(_)@_:_",
		"_+_",
		"_-=_",
		"_-_",
		"_<<_",
		"_<<_keeping_bits",
		"_>>_",
		"_[_.._]",
		"_[_.._]→_",
		"_[_]",
		"_[_]:=_",
		"_[_]→_",
		"_[_↔_]",
		"_has definition for_",
		"_is unambiguous",
		"_occurrences⁇of_",
		"_parameterized by_",
		"_permuted by_",
		"_to_by_",
		"_«[_]»[_.._]→_",
		"_«[_]»→_",
		"_×_",
		"_÷_",
		"_→extended integer",
		"_→function",
		"_→map",
		"_→tuple",
		"_∈_",
		"_∈current fiber",
		"``_``(_)@_:_«from phrase_»?",
		"`|message_'s⁇parameters`|",
		"`«(_:=_)`»",
		"`«[_`|Primitive__]:_^_`»",
		"`«_:=_`»",
		"`«`↑_`»",
		"`«supercast(_::_)`»",
		"all atoms for_",
		"atom for_",
		"constructor of_,⁇parameterized by_",
		"current fiber[_]",
		"current macro name",
		"current module",
		"current module's exported names",
		"current module's visible names",
		"first-of-seq`«_`»",
		"function from_and_",
		"in_millisecond|milliseconds,⁇invoke_with_,⁇forked at priority_",
		"invoke_with_,⁇forked at priority_",
		"lookup macro_with phrases_",
		"message_contains groups",
		"method definition of_for_",
		"method for_",
		"method_._,⁇parameterized by_",
		"new anonymous module importing_",
		"new atom named_",
		"new explicit subclass atom named_",
		"new`↑_initialized to_",
		"new⁇heritable«fiber-local»⁇atom named_",
		"next character",
		"restricted report and send_with_:_",
		"semantic restrictions for_given_",
		"send_with_:_",
		"seq`«_`»",
		"static method_._,⁇parameterized by_",
		"↓_"
	)
Names
	"early failure function",
	"Set early failure function to_"
Body

Primitive "{«_‡,»}" is
[
	aTuple : tuple
|
	Primitive TupleToSet;
] : set;

Primitive "_ᵀ" is
[
	instances : set
|
	Primitive CreateEnumeration;
] : any meta;

Primitive "Private fail primitive with_" is
[
	value : any
|
	Primitive EmergencyExit;
] : ⊥;

_fail_primitive : primitive failure function :=
	[
		arg1 : any
	|
		Private fail primitive with arg1
	] : ⊥;

Primitive "early failure function" is
[
	_fail_primitive
] : primitive failure function;

Primitive "Set early failure function to_" is
[
	arg1 : primitive failure function
|
	_fail_primitive := arg1;
] : ⊤;

Primitive "Private invoke_with«_‡,»" is
[
	aFunction : function,
	arguments : tuple
|
	Primitive InvokeWithTuple (failureCode : natural number);
	Private fail primitive with failureCode
] : ⊤;

Primitive "Private semantic restriction_is_" is
[
	methodName : string,
	restriction : semantic restriction function
|
	Primitive AddSemanticRestriction (failureCode : natural number);
	Private fail primitive with failureCode
] : ⊤;

Private semantic restriction "Private invoke_with«_‡,»" is
[
	aFunction : function meta,
	arguments : tuple meta
|
	⊥
];

/**
 * Assuming that {@param "anAtom"} has a property whose key is {@param
 * "key"}, then answer the property value associated with the {@param
 * "key"}.
 *
 * @category "Primitives" "Atoms" "Queries"
 * @method "_[_]"
 * @param "anAtom" "atom"
 *        An atom.
 * @param "key" "atom"
 *        The property key.
 * @returns "any"
 *    The property value bound to the key.
 * @raises "no-such-field exception"
 */
Primitive "_[_]" is
[
	anAtom : atom,
	key : atom
|
	Primitive AtomGetProperty (failureCode : {
		no-such-field code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : any;

/**
 * Does {@param "anAtom"} have a property whose key is {@param "key"}?
 *
 * @category "Primitives" "Atoms" "Queries"
 * @method "_∈_"
 * @param "key" "atom"
 *        The property key.
 * @param "anAtom" "atom"
 *        An atom.
 * @returns "boolean"
 *    `true` if {@param "anAtom"} has a property whose key is {@param
 *    "key"}, `false` otherwise.
 * @raises "special-atom exception"
 */
Primitive "_∈_" is
[
	key : atom,
	anAtom : atom
|
	Primitive AtomHasProperty (failureCode : {
		special-atom code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : boolean;

/**
 * Answer the module that issued the specified atom.
 *
 * @category "Primitives" "Atoms" "Queries"
 * @method "_'s⁇issuing module"
 * @param "anAtom" "atom"
 *        An atom.
 * @returns "module"
 *    The requested module.
 * @raises "special-atom exception"
 */
Primitive "_'s⁇issuing module" is
[
	anAtom : atom
|
	Primitive AtomIssuingModule (failureCode : {
		special-atom code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : module;

/**
 * Remove from {@param "anAtom"} the property whose key is {@param "key"}.
 *
 * @category "Primitives" "Atoms" "Mutators"
 * @method "Remove_[_]"
 * @param "anAtom" "atom"
 *        An atom.
 * @param "key" "atom"
 *        A property key.
 * @returns "⊤"
 * @raises "no-such-field exception"
 */
Primitive "Remove_[_]" is
[
	anAtom : atom,
	key : atom
|
	Primitive AtomRemoveProperty (failureCode : {
		no-such-field code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * For {@param "anAtom"}, establish a property binding from {@param
 * "key"} to {@param "value"}. Any previous property binding for {@param
 * "key"} is replaced.
 *
 * @category "Primitives" "Atoms" "Mutators"
 * @method "_[_]:=_"
 * @param "anAtom" "atom"
 *        An atom.
 * @param "key" "atom"
 *        The property key.
 * @param "value" "any"
 *        The property value.
 * @returns "⊤"
 * @raises "special-atom exception"
 */
Primitive "_[_]:=_" is
[
	anAtom : atom,
	key : atom,
	value : any
|
	Primitive AtomSetProperty (failureCode : {
		special-atom code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Construct and answer a new atom. Associate with the atom the supplied string,
 * which should be a name used for debugging purposes only. Atoms have identity
 * and all atoms are distinct, regardless of whether their debug names are
 * equal.
 *
 * @category "Primitives" "Atoms" "Constructors"
 * @method "new atom named_"
 * @param "debugName" "string"
 *        A name to associate with the atom for debugging purposes. This name
 *        does not participate in atom comparison.
 * @returns "atom"
 *    A new atom, distinct from every other atom answered by a different
 *    invocation of this primitive.
 * @raises "ambiguous-name exception"
 */
Primitive "new atom named_" is
[
	debugName : string
|
	Primitive CreateAtom (failureCode : {
		ambiguous-name code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : atom;

/**
 * Construct and answer a new atom for use as a field key in an object or
 * object type. This field key's sole purpose is to differentiate the object
 * type from any existing object types. Associate with the atom the supplied
 * string, which should be a name used for debugging purposes only. Atoms have
 * identity and all atoms are distinct, regardless of whether their debug names
 * are equal.
 *
 * @category "Primitives" "Atoms" "Constructors"
 * @method "new explicit subclass atom named_"
 * @param "debugName" "string"
 *        A name to associate with the atom for debugging purposes. This name
 *        does not participate in atom comparison.
 * @returns "atom"
 *    A new atom, distinct from every other atom answered by a different
 *    invocation of this primitive, and marked for use as an explicit subclass
 *    field key in a new object type.
 * @raises "ambiguous-name exception"
 */
Primitive "new explicit subclass atom named_" is
[
	debugName : string
|
	Primitive CreateExplicitSubclassAtom (failureCode : {
		ambiguous-name code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : atom;

/**
 * Is {@param "name"} unambiguous in the {@method "current module"}?
 *
 * @category "Primitives" "Name Resolution"
 * @method "_is unambiguous"
 * @param "name" "string"
 *        The name in question.
 * @returns "boolean"
 *    {@method "true"} if the argument is unambiguous, {@method "false"}
 *    otherwise.
 * @raises "loading-is-over exception"
 */
Primitive "_is unambiguous" is
[
	name : string
|
	Primitive IsUnambiguousName (failureCode : {
		loading-is-over code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : boolean;

/**
 * Answer all atoms referenced by the specified name in the module currently
 * undergoing compilation. If this name already refers to atoms in scope,
 * i.e., either ones 1) imported through the "Uses" or "Extends" sections of the
 * current module's header, 2) introduced by the "Names" section of the
 * current module's header, or 3) introduced by dynamic publication then, answer
 * these atoms. Otherwise, answer an empty set.
 *
 * @category "Primitives" "Atoms" "Name Resolution" "Constructors"
 * @method "all atoms for_"
 * @param "name" "string"
 *        The name which should be resolved locally.
 * @returns "{atom|}"
 *    The set of all locally visible atoms that match the argument.
 * @raises "loading-is-over exception"
 */
Primitive "all atoms for_" is
[
	name : string
|
	Primitive LookupAtomsForName (failureCode : {
		loading-is-over code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : set of atom;

/**
 * Accept the current attempt at parsing an expression.  This can be used by
 * semantic restrictions and macro prefix functions to allow early exits.  In
 * addition, it allows semantic restriction bodies to be bottom-typed,
 * indicating that it <em>cannot</em> strengthen the expression type, allowing
 * detection of methods that are always ⊤-valued, avoiding the search for
 * invocations of them as ordinary subexpressions.  This should improve both
 * parsing speed and the diagnostic quality of parse errors.
 *
 * This method may only be invoked from the body of a semantic restriction
 * function: it should only be invoked by the Avail compiler, never by a
 * semantically valid Avail program.
 *
 * @category "Primitives"
 * @method "Immediately accept parse"
 * @returns "⊥"
 *    Ends the current fiber immediately (or after safely unwinding to the base
 *    stack frame after exceptions are installed), and does not return.
 * @raises "untimely-parse-acceptance exception"
 */
Primitive "Immediately accept parse" is
[
	Primitive AcceptParsing (failureCode : {
		untimely-parse-acceptance code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊥;

/**
 * Answer the atom for the message bundle of the send phrase being evaluated as
 * a macro.  Fail if a macro is not being evaluated by the current fiber.
 *
 * @category "Primitives"
 * @method "current macro name"
 * @returns "atom"
 *    The atom of the send phrase undergoing macro expansion.
 * @raises "not-evaluating-macro exception"
 *    If a macro is not being evaluated by the current fiber.
 */
Primitive "current macro name" is
[
	Primitive CurrentMacroName (failureCode : {
		not-evaluating-macro}ᵀ);
	Private invoke _fail_primitive with failureCode
] : atom;

/**
 * Generate and answer a function from the specified block.
 *
 * @category "Primitives" "Phrases" "Functions" "Conversions"
 * @method "_→function"
 * @param "aBlock" "block phrase⇒[…]→⊤"
 *        A block. Note that the block is treated as a top-level construct, so
 *        it must not refer to any outer variable declarations.
 * @returns "[…]→⊤"
 *    The requested function.
 * @raises "block-is-invalid exception"
 * @raises "block-must-not-contain-outers exception"
 * @raises "block-compilation-failed exception"
 */
Primitive "_→function" is
[
	aBlock : block phrase
|
	Primitive GenerateFunctionForBlock (failureCode : {
		block-is-invalid code,
		block-must-not-contain-outers code,
		block-compilation-failed code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : function;

/**
 * Construct and answer a continuation whose current function, Level One
 * program counter, local stack, local stack pointer, and calling continuation
 * are specified by the arguments.
 *
 * @category "Primitives" "Continuations" "Constructors"
 * @method "$_@pc=_stack=_[_]caller=_"
 * @param "aFunction" "[…]→⊤"
 *        The new continuation's current function.
 * @param "programCounter" "[0..∞)"
 *        @param "aFunction"'s program counter. This is the index of the
 *        next Level One instruction to execute when the new continuation is
 *        resumed.
 * @param "stack" "tuple"
 *        @param "aFunction"'s stack. This tuple contains the arguments, local
 *        variables, and temporaries.
 * @param "stackPointer" "[1..∞)"
 *        @param "aFunction"'s stack pointer. This is the index of the
 *        top of the stack.
 * @param "caller" "↑$[…]→⊥"
 *        A variable holding the new continuation's calling continuation.
 *        If the variable is unassigned, then create a root continuation (i.e.
 *        one without a caller).
 * @returns "$[…]→⊥"
 *    The requested continuation.
 * @raises "incorrect-continuation-stack-size exception"
 * @raises "cannot-create-continuation-for-infallible-primitive-function exception"
 */
Primitive "$_@pc=_stack=_[_]caller=_" is
[
	aFunction : function,
	programCounter : whole number,
	stack : tuple,
	stackPointer : natural number,
	caller : continuation variable
|
	Primitive CreateContinuation (failureCode : {
		incorrect-continuation-stack-size code,
		cannot-create-continuation-for-infallible-primitive-function code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : continuation;

/**
 * If the provided boolean is true, exit the continuation and answer the
 * specified value to the continuation's caller. Execution proceeds as though
 * the continuation had just returned from its current function with the
 * supplied value. The current continuation (in which this primitive was
 * invoked) is completely replaced by the specified continuation's resumed
 * caller.  If the provided boolean is false, do nothing.
 *
 * @category "Primitives" "Continuations" "Control Structures"
 * @method "Exit_with_if_"
 * @param "aContinuation" "$[…]→⊥"
 *        The continuation to exit.
 * @param "value" "any"
 *         The value with which to exit {@param "aContinuation"}.
 * @param "condition" "boolean"
 *        Whether to exit.
 * @returns "⊤"
 * @raises "continuation-expected-stronger-type exception"
 *         If the value to return isn't strong enough for the continuation.
 */
Primitive "Exit_with_if_" is
[
	aContinuation : continuation,
	value : any,
	condition : boolean
|
	Primitive ExitContinuationWithResultIf (failureCode : {
		continuation-expected-stronger-type code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Invoke the function with the given arguments. Answer its result.
 *
 * @category "Primitives" "Functions" "Function Application"
 * @method "Invoke|invoke_with_"
 * @param "aFunction" "[…]→⊤"
 *        A function.
 * @param "arguments" "tuple"
 *        The tuple of arguments.
 * @returns "⊤"
 *    The value produced by applying the arguments to the function.
 * @raises "exception" ("natural number")
 *         Since the function's implementation is arbitrary, it can raise any
 *         exception.
 */
Primitive "Invoke|invoke_with_" is
[
	aFunction : function,
	arguments : tuple
|
	Primitive InvokeWithTuple (failureCode : natural number);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Restart the continuation with the specified arguments. Execution proceeds as
 * though the continuation's caller had just invoked the continuation's current
 * function with the given arguments instead of the original arguments. The
 * current continuation (in which this primitive was invoked) is completely
 * replaced by the restarted continuation.
 *
 * @category "Primitives" "Continuations" "Control Structures"
 * @method "Restart_with_"
 * @param "aContinuation" "$[…]→⊥"
 *        The continuation to restart.
 * @param "arguments" "tuple"
 *        The new arguments with which to restart {@param "aContinuation"}.
 * @returns "⊥"
 * @raises "incorrect-number-of-arguments exception"
 * @raises "incorrect-argument-type exception"
 */
Primitive "Restart_with_" is
[
	aContinuation : continuation,
	arguments : tuple
|
	Primitive RestartContinuationWithArguments (failureCode : {
		incorrect-number-of-arguments code,
		incorrect-argument-type code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊥;

/**
 * Compute and answer an `extended integer` by rounding the argument toward
 * zero (`0`).
 *
 * @category "Primitives" "Numbers" "Integers" "Conversions"
 * @method "_→extended integer"
 * @param "aDouble" "double"
 *        A double-precision floating point number.
 * @returns "[-∞..∞]"
 *    The requested value.
 * @raises "cannot-convert-not-a-number-to-integer exception"
 */
Primitive "_→extended integer" is
[
	aDouble : double
|
	Primitive DoubleTruncatedAsInteger (failureCode : {
		cannot-convert-not-a-number-to-integer code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : extended integer;

/**
 * Attempt to join the specified fiber. If the fiber has already terminated,
 * then return immediately; otherwise, arrange to unpark the current fiber when
 * the specified fiber terminates and park the current fiber.
 *
 * @category "Primitives" "Concurrency" "Synchronization" "Control Structures"
 * @method "Attempt to join_"
 * @param "aFiber" "fiber→⊤"
 *        A fiber.
 * @returns "⊤"
 * @raises "fiber-cannot-join-itself exception"
 */
Primitive "Attempt to join_" is
[
	aFiber : fiber
|
	Primitive AttemptJoinFiber (failureCode : {
		fiber-cannot-join-itself code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Construct and answer a new atom. Associate with the atom the supplied string,
 * which should be a name used for debugging purposes only. Atoms have identity
 * and all atoms are distinct, regardless of whether their debug names are
 * equal. When this atom occurs as a key within a fiber's environment, any new
 * fibers created by this fiber will also include this key and the associated
 * value at creation time.
 *
 * @category "Primitives" "Atoms" "Concurrency" "Constructors"
 * @method "new⁇heritable«fiber-local»⁇atom named_"
 * @param "debugName" "string"
 *        A name to associate with the atom for debugging purposes.
 *       This name does not participate in atom comparison.
 * @returns "atom"
 *    A new atom, distinct from every other atom answered by a different
 *    invocation of this primitive, that represents a heritable fiber-local
 *    variable.
 * @raises "ambiguous-name exception"
 * @raises "atom-already-exists exception"
 */
Primitive "new⁇heritable«fiber-local»⁇atom named_" is
[
	debugName : string
|
	Primitive CreateFiberHeritableAtom (failureCode : {
		ambiguous-name code,
		atom-already-exists code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : atom;

/**
 * When at least the specified number of milliseconds have elapsed, fork a new
 * fiber at the specified priority. The new fiber will invoke the given function
 * with the supplied arguments. A best effort will be made to start the fiber as
 * soon as the delay has expired, but no real-time guarantees are made.
 *
 * @category "Primitives" "Concurrency" "Time" "Control Structures"
 * @method "in_millisecond|milliseconds,⁇invoke_with_,⁇forked at priority_"
 * @param "delayMillis" "[0..∞]"
 *        The minimum number of milliseconds to delay the start of the new
 *       fiber.
 * @param "aFunction" "[…]→⊤"
 *        A function.
 * @param "arguments" "tuple"
 *        The arguments to the function.
 * @param "priority" "[0..255]"
 *        The priority of the new fiber.
 * @returns "fiber→⊤"
 *    The new fiber.
 * @raises "incorrect-number-of-arguments exception"
 * @raises "incorrect-argument-type exception"
 */
Primitive "in_millisecond|milliseconds,⁇invoke_with_,⁇forked at priority_" is
[
	delayMillis : nonnegative extended integer,
	aFunction : function,
	arguments : tuple,
	priority : byte
|
	Primitive DelayedFork (failureCode : {
		incorrect-number-of-arguments code,
		incorrect-argument-type code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : fiber;

/**
 * When at least the specified number of milliseconds have elapsed, fork a new
 * fiber at the specified priority. The new fiber will invoke the given function
 * with the supplied arguments. A best effort will be made to start the fiber as
 * soon as the delay has expired, but no real-time guarantees are made.
 *
 * @category "Primitives" "Concurrency" "Time" "Control Structures"
 * @method "In_millisecond|milliseconds,⁇invoke_with_,⁇forked at priority_"
 * @param "delayMillis" "[0..∞]"
 *        The minimum number of milliseconds to delay the start of the new
 *       fiber.
 * @param "aFunction" "[…]→⊤"
 *        A function.
 * @param "arguments" "tuple"
 *        The arguments to the function.
 * @param "priority" "[0..255]"
 *        The priority of the new fiber.
 * @returns "⊤"
 * @raises "incorrect-number-of-arguments exception"
 * @raises "incorrect-argument-type exception"
 */
Primitive "In_millisecond|milliseconds,⁇invoke_with_,⁇forked at priority_" is
[
	delayMillis : nonnegative extended integer,
	aFunction : function,
	arguments : tuple,
	priority : byte
|
	Primitive DelayedForkOrphan (failureCode : {
		incorrect-number-of-arguments code,
		incorrect-argument-type code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Answer the result of running the specified fiber to successful completion.
 * This method may only be called safely after an affirmative answer from
 * `_has result`.
 *
 * @category "Primitives" "Concurrency" "Queries"
 * @method "_'s⁇result"
 * @param "aFiber" "fiber→⊤"
 *        A fiber.
 * @returns "any"
 *    The result yielded by the specified fiber. This is the value produced by
 *    the fiber's outermost continuation, i.e., its base function.
 * @raises "fiber-result-unavailable exception"
 * @raises "fiber-produced-incorrectly-typed-result exception"
 */
Primitive "_'s⁇result" is
[
	aFiber : fiber
|
	Primitive FiberResult (failureCode : {
		fiber-result-unavailable code,
		fiber-produced-incorrectly-typed-result code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : any;

/**
 * Fork a new fiber at the specified priority. The new fiber will invoke the
 * given function with the supplied arguments.
 *
 * @category "Primitives" "Concurrency" "Control Structures"
 * @method "invoke_with_,⁇forked at priority_"
 * @param "aFunction" "[…]→⊤"
 *        A function.
 * @param "arguments" "tuple"
 *        The arguments to the function.
 * @param "priority" "[0..255]"
 *        The priority of the new fiber.
 * @returns "fiber→⊤"
 *    The new fiber.
 * @raises "incorrect-number-of-arguments exception"
 * @raises "incorrect-argument-type exception"
 */
Primitive "invoke_with_,⁇forked at priority_" is
[
	aFunction : function,
	arguments : tuple,
	priority : byte
|
	Primitive Fork (failureCode : {
		incorrect-number-of-arguments code,
		incorrect-argument-type code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : fiber;

/**
 * Fork a new fiber at the specified priority. The new fiber will invoke the
 * given function with the supplied arguments.
 *
 * @category "Primitives" "Concurrency" "Control Structures"
 * @method "Invoke_with_,⁇forked at priority_"
 * @param "aFunction" "[…]→⊤"
 *        A function.
 * @param "arguments" "tuple"
 *        The arguments to the function.
 * @param "priority" "[0..255]"
 *        The priority of the new fiber.
 * @returns "⊤"
 * @raises "incorrect-number-of-arguments exception"
 * @raises "incorrect-argument-type exception"
 */
Primitive "Invoke_with_,⁇forked at priority_" is
[
	aFunction : function,
	arguments : tuple,
	priority : byte
|
	Primitive ForkOrphan (failureCode : {
		incorrect-number-of-arguments code,
		incorrect-argument-type code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Does the current fiber's environment have a value bound to {@param "key"}? This
 * effectively ascertains whether a fiber-local variable exists for the
 * specified fiber.
 *
 * @category "Primitives" "Concurrency" "Queries"
 * @method "_∈current fiber"
 * @param "key" "atom"
 *        The key whose existence should be queried.
 * @returns "boolean"
 *    `true` if the current fiber binds a value to {@param "key"}, `false`
 *    otherwise.
 * @raises "special-atom exception"
 */
Primitive "_∈current fiber" is
[
	key : atom
|
	Primitive IsFiberVariable (failureCode : {
		special-atom code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : boolean;

/**
 * Answer the value bound to {@param "key"} in the current fiber's environment.
 * Since the fiber's environment essentially contains fiber-local variables
 * (i.e. bindings from atoms to arbitrary values), this operation effectively
 * reads a fiber-local variable.
 *
 * @category "Primitives" "Concurrency" "Queries"
 * @method "current fiber[_]"
 * @param "key" "atom"
 *        The key whose value should be obtained.
 * @returns "any"
 *    The value bound to {@param "key"} within the current fiber's environment.
 * @raises "no-such-fiber-variable exception"
 */
Primitive "current fiber[_]" is
[
	key : atom
|
	Primitive LookupFiberVariable (failureCode : {
		no-such-fiber-variable code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : any;

/**
 * Remove the binding indicated by {@param "key"} from the current fiber's
 * environment.
 *
 * @category "Primitives" "Concurrency" "Mutators"
 * @method "Remove current fiber[_]"
 * @param "key" "atom"
 *        The key whose binding should be removed.
 * @returns "⊤"
 * @raises "no-such-fiber-variable exception"
 * @raises "special-atom exception"
 */
Primitive "Remove current fiber[_]" is
[
	key : atom
|
	Primitive RemoveFiberVariable (failureCode : {
		no-such-fiber-variable code,
		special-atom code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Compute and answer an `extended integer` by rounding the argument toward
 * zero (`0`).
 *
 * @category "Primitives" "Numbers" "Integers" "Conversions"
 * @method "_→extended integer"
 * @param "aFloat" "float"
 *        A single-precision floating point number.
 * @returns "[-∞..∞]"
 *    The requested value.
 * @raises "cannot-convert-not-a-number-to-integer exception"
 */
Primitive "_→extended integer" is
[
	aFloat : float
|
	Primitive FloatTruncatedAsInteger (failureCode : {
		cannot-convert-not-a-number-to-integer code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : extended integer;

/**
 * Construct and answer a function given the specified function implementation
 * and tuple of captured variables.
 *
 * @category "Primitives" "Functions" "Constructors"
 * @method "function from_and_"
 * @param "implementation" "¢[…]→⊤"
 *        The compiled code that describes the algorithm.
 * @param "outerVariables" "tuple"
 *        The tuple of outer variables.
 * @returns "[…]→⊤"
 *    The requested function.
 * @raises "wrong-outers exception"
 */
Primitive "function from_and_" is
[
	implementation : function implementation,
	outerVariables : tuple
|
	Primitive CreateFunction (failureCode : {
		wrong-outers code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : function;

/**
 * Answer the {@param "index"}-th parameter type of the specified function type.
 *
 * @category "Primitives" "Types" "Functions" "Queries"
 * @method "_[_]"
 * @param "functionType" "([…]→⊤)'s type"
 *        A function type.
 * @param "index" "[1..∞)"
 *        The one-based index of the desired parameter type.
 * @returns "(any)'s type"
 *    The {@param "index"}-th parameter type of the argument.
 * @raises "subscript-out-of-bounds exception"
 */
Primitive "_[_]" is
[
	functionType : function meta,
	index : natural number
|
	Primitive ParamTypeAt (failureCode : {
		subscript-out-of-bounds code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : any meta;

/**
 * Mark the standard input stream to allow at least {@param "count"}
 * characters of read ahead.
 *
 * @category "Primitives" "Standard IO"
 * @method "Mark for_character|characters of read ahead"
 * @param "count" "[0..∞)"
 *        The requested number of characters of read ahead.
 * @returns "⊤"
 * @raises "I/O exception"
 */
Primitive "Mark for_character|characters of read ahead" is
[
	count : whole number
|
	Primitive MarkStandardInputStream (failureCode : {
		I/O-error code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Print the argument to the application's standard output stream.
 *
 * @category "Primitives" "Standard IO" "Synchronous IO"
 * @method "Print:_"
 * @param "text" "string"
 *        A string.
 * @returns "⊤"
 * @raises "I/O exception"
 */
Primitive "Print:_" is
[
	text : string
|
	Primitive PrintToConsole (failureCode : {
		I/O-error code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Print the argument to the application's standard error stream.
 *
 * @category "Primitives" "Standard IO" "Synchronous IO"
 * @method "Error:_"
 * @param "text" "string"
 *        A string.
 * @returns "⊤"
 * @raises "I/O exception"
 */
Primitive "Error:_" is
[
	text : string
|
	Primitive PrintToErrorConsole (failureCode : {
		I/O-error code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Read the next character from the standard input stream.
 *
 * @category "Primitives" "Standard IO" "Synchronous IO"
 * @method "next character"
 * @returns "character"
 *    The next character from the standard input stream.
 * @raises "I/O exception"
 */
Primitive "next character" is
[
	Primitive ReadFromStandardInput (failureCode : {
		I/O-error code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : character;

/**
 * Reset the standard input stream to the previously set mark.
 *
 * @category "Primitives" "Standard IO"
 * @method "Reset to mark"
 * @returns "⊤"
 * @raises "I/O exception"
 */
Primitive "Reset to mark" is
[
	Primitive ResetStandardInputStream (failureCode : {
		I/O-error code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Shift {@param "baseInteger"} to the left by {@param "shiftFactor"} bits. If
 * {@param "baseInteger"} is negative then treat it as a right shift of the
 * corresponding positive amount.
 *
 * @category "Primitives" "Numbers" "Integers" "Mathematics" "Bits"
 * @method "_<<_"
 * @param "baseInteger" "(-∞..∞)"
 *        An integer to shift.
 * @param "shiftFactor" "(-∞..∞)"
 *        How many bits to shift left (or right if negative).
 * @returns "(-∞..∞)"
 *    ⌊_<<_ × 2<sup>baseInteger</sup>⌋
 * @raises "too-large-to-represent exception"
 */
Primitive "_<<_" is
[
	baseInteger : integer,
	shiftFactor : integer
|
	Primitive BitShiftLeft (failureCode : {
		too-large-to-represent code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : integer;

/**
 * Shift {@param "baseInteger"} to the right by {@param "shiftFactor"} bits. If
 * {@param "baseInteger"} is negative then treat it as a left shift of the
 * corresponding positive amount.
 *
 * @category "Primitives" "Numbers" "Integers" "Mathematics" "Bits"
 * @method "_>>_"
 * @param "baseInteger" "(-∞..∞)"
 *        An integer to shift.
 * @param "shiftFactor" "(-∞..∞)"
 *        How many bits to shift right (or left if negative).
 * @returns "(-∞..∞)"
 *    ⌊_>>_ ÷ 2<sup>baseInteger</sup>⌋
 * @raises "too-large-to-represent exception"
 */
Primitive "_>>_" is
[
	baseInteger : integer,
	shiftFactor : integer
|
	Primitive BitShiftRight (failureCode : {
		too-large-to-represent code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : integer;

/**
 * Shift {@param "baseInteger"} to the left by {@param "shiftFactor"} bits
 * (treating a negative factor as a right shift), then truncate the result to
 * the bottom {@param "truncationBits"} bits by zeroing the rest.
 *
 * @category "Primitives" "Numbers" "Integers" "Mathematics" "Bits"
 * @method "_<<_keeping_bits"
 * @param "baseInteger" "[0..∞)"
 *        A non-negative integer to shift and mask.
 * @param "shiftFactor" "(-∞..∞)"
 *        How many bit positions to shift left by (negative for a right shift).
 * @param "truncationBits" "[0..∞)"
 *        The number of low-order bits to preserve after the shift (must
 *        be ≥ 0).
 * @returns "[0..∞)"
 *    ⌊_<<_keeping_bits × 2<sup>baseInteger</sup>⌋ mod 2<sup>shiftFactor</sup>
 * @raises "too-large-to-represent exception"
 */
Primitive "_<<_keeping_bits" is
[
	baseInteger : whole number,
	shiftFactor : integer,
	truncationBits : whole number
|
	Primitive BitShiftWithTruncation (failureCode : {
		too-large-to-represent code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : whole number;

/**
 * Answer the value bound to {@param "aMap"} in {@param "key"}.
 *
 * @category "Primitives" "Maps" "Queries"
 * @method "_[_]"
 * @param "aMap" "map"
 *        A map.
 * @param "key" "any"
 *        The key whose bound value should be obtained.
 * @returns "any"
 *    The value bound to {@param "key"} in {@param "aMap"}.
 * @raises "key-not-found exception"
 */
Primitive "_[_]" is
[
	aMap : map,
	key : any
|
	Primitive MapAtKey (failureCode : {
		key-not-found code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : any;

/**
 * Given a multi-level data structure where the outermost later is a map, the
 * intervening layers are maps or tuples, and the innermost target reached by
 * the provided path is a tuple, answer a variant of the data structure such
 * that the indicated slice of the innermost target has been replaced with the
 * provided tuple. The replacement tuple can differ in size from the slice.
 *
 * @category "Primitives" "Tuples" "Maps" "Transformers"
 * @method "_«[_]»[_.._]→_"
 * @param "aMap" "map"
 *        The target map.
 * @param "pathTuple" "<any…|1..∞>"
 *        The tuple providing the path to follow to reach the location
 *        to be updated.
 * @param "sliceStartIndex" "[1..∞)"
 *        The start index of the tuple slice to be replaced.
 * @param "sliceEndIndex" "[0..∞)"
 *        The end index of the tuple slice to be replaced.
 * @param "newValues" "tuple"
 *        The tuple containing the replacement values.
 * @returns "map"
 *    a new map with the new values installed at the proposed locations.
 * @raises "subscript-out-of-bounds exception"
 * @raises "incorrect-argument-type exception"
 * @raises "key-not-found exception"
 * @raises "negative-size exception"
 */
Primitive "_«[_]»[_.._]→_" is
[
	aMap : map,
	pathTuple : nonempty tuple,
	sliceStartIndex : natural number,
	sliceEndIndex : whole number,
	newValues : tuple
|
	Primitive MapReplaceRangeNAryKey (failureCode : {
		subscript-out-of-bounds code,
		incorrect-argument-type code,
		key-not-found code,
		negative-size code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : map;

/**
 * Replace the value at the location indicated by the path tuple of the target
 * map with the new value. If the replacement value type differs from the
 * type of the value at the replacement location, the answered map will have a
 * different type than the original source map.
 *
 * @category "Primitives" "Tuples" "Maps" "Transformers"
 * @method "_«[_]»→_"
 * @param "aMap" "map"
 *        The target map.
 * @param "pathTuple" "<any…|1..∞>"
 *        The tuple providing the path to follow to reach the location
 *        to be updated.
 * @param "newValue" "any"
 *        The replacement value.
 * @returns "map"
 *    a new map with the new value installed at the proposed location
 * @raises "subscript-out-of-bounds exception"
 *    If an index in the pathTuple attempts to access an index that is greater
 *    than the size of the targeted tuple within aMap.
 * @raises "incorrect-argument-type exception"
 *    If an index in the pathTuple, that is not the final index where the
 *    replacement is made, attempts to access a value as if it were a
 *    map or a tuple but the value at that location is neither.
 * @raises "key-not-found exception"
 *    If an index in the pathTuple attempts to access a map in aMap with a key
 *    not in the map.
 */
Primitive "_«[_]»→_" is
[
	aMap : map,
	pathTuple : nonempty tuple,
	newValue : any
|
	Primitive MapReplacingNAryKey (failureCode : {
		subscript-out-of-bounds code,
		incorrect-argument-type code,
		key-not-found code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : map;

/**
 * Declare an abstract method with the specified name and signature. A concrete
 * definition is one whose parameter types and return type are strictly more
 * specific than the corresponding types of the abstract signature.
 *
 * @category "Primitives" "Name Resolution" "Methods" "Constructors" "Mutators"
 * @method "Abstract method_is_"
 * @param "methodName" "string"
 *        The name of the abstract method to declare.
 * @param "aFunctionType" "([…]→⊤)'s type"
 *        The signature.
 * @returns "⊤"
 * @raises "incorrect-argument-type exception"
 * @raises "incorrect-type-for-group exception"
 * @raises "ambiguous-name exception"
 * @raises "exclamation-mark-must-follow-an-alternation-group exception"
 * @raises "redefined-with-same-argument-types exception"
 * @raises "result-type-should-covary-with-arguments exception"
 * @raises "incorrect-type-for-complex-group exception"
 * @raises "incorrect-use-of-double-dagger exception"
 * @raises "unbalanced-guillemets exception"
 * @raises "method-name-is-not-canonical exception"
 * @raises "expected-operator-after-backquote exception"
 * @raises "incorrect-type-for-boolean-group exception"
 * @raises "incorrect-type-for-counting-group exception"
 * @raises "octothorp-must-follow-a-simple-group-or-ellipsis exception"
 * @raises "question-mark-must-follow-a-simple-group exception"
 * @raises "case-insensitive-expression-canonization exception"
 * @raises "double-question-mark-must-follow-a-token-or-simple-group exception"
 * @raises "alternative-must-not-contain-arguments exception"
 * @raises "vertical-bar-must-separate-tokens-or-simple-groups exception"
 * @raises "incorrect-type-for-numbered-choice exception"
 * @raises "cannot-define-during-compilation exception"
 * @raises "loading-is-over exception"
 * @raises "method-is-sealed exception"
 * @raises "up-arrow-must-follow-argument exception"
 * @raises "inconsistent-argument-reordering exception"
 */
Primitive "Abstract method_is_" is
[
	methodName : string,
	aFunctionType : function meta
|
	Primitive AbstractMethodDeclaration (failureCode : {
		incorrect-argument-type code,
		incorrect-type-for-group code,
		ambiguous-name code,
		exclamation-mark-must-follow-an-alternation-group code,
		redefined-with-same-argument-types code,
		result-type-should-covary-with-arguments code,
		incorrect-type-for-complex-group code,
		incorrect-use-of-double-dagger code,
		unbalanced-guillemets code,
		method-name-is-not-canonical code,
		expected-operator-after-backquote code,
		incorrect-type-for-boolean-group code,
		incorrect-type-for-counting-group code,
		octothorp-must-follow-a-simple-group-or-ellipsis code,
		question-mark-must-follow-a-simple-group code,
		case-insensitive-expression-canonization code,
		double-question-mark-must-follow-a-token-or-simple-group code,
		alternative-must-not-contain-arguments code,
		vertical-bar-must-separate-tokens-or-simple-groups code,
		incorrect-type-for-numbered-choice code,
		cannot-define-during-compilation code,
		loading-is-over code,
		method-is-sealed code,
		up-arrow-must-follow-argument code,
		inconsistent-argument-reordering code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Declare an abstract method with the specified name and signature. A concrete
 * definition is one whose parameter types and return type are strictly more
 * specific than the corresponding types of the abstract signature.
 *
 * Only extend the grammar of the current module if the atom was introduced by
 * the current module.
 *
 * @category "Primitives" "Methods" "Constructors" "Mutators"
 * @method "Abstract method_is_"
 * @param "methodName" "atom"
 *        The atom that uniquely names the abstract method to declare.
 * @param "signature" "([…]→⊤)'s type"
 *        The signature.
 * @returns "⊤"
 * @raises "incorrect-argument-type exception"
 * @raises "incorrect-type-for-group exception"
 * @raises "exclamation-mark-must-follow-an-alternation-group exception"
 * @raises "redefined-with-same-argument-types exception"
 * @raises "result-type-should-covary-with-arguments exception"
 * @raises "incorrect-type-for-complex-group exception"
 * @raises "incorrect-use-of-double-dagger exception"
 * @raises "unbalanced-guillemets exception"
 * @raises "method-name-is-not-canonical exception"
 * @raises "expected-operator-after-backquote exception"
 * @raises "incorrect-type-for-boolean-group exception"
 * @raises "incorrect-type-for-counting-group exception"
 * @raises "octothorp-must-follow-a-simple-group-or-ellipsis exception"
 * @raises "question-mark-must-follow-a-simple-group exception"
 * @raises "case-insensitive-expression-canonization exception"
 * @raises "double-question-mark-must-follow-a-token-or-simple-group exception"
 * @raises "alternative-must-not-contain-arguments exception"
 * @raises "vertical-bar-must-separate-tokens-or-simple-groups exception"
 * @raises "incorrect-type-for-numbered-choice exception"
 * @raises "cannot-define-during-compilation exception"
 * @raises "loading-is-over exception"
 * @raises "method-is-sealed exception"
 * @raises "up-arrow-must-follow-argument exception"
 * @raises "inconsistent-argument-reordering exception"
 */
Primitive "Abstract method_is_" is
[
	methodName : atom,
	signature : function meta
|
	Primitive AbstractMethodDeclarationForAtom (failureCode : {
		incorrect-argument-type code,
		incorrect-type-for-group code,
		exclamation-mark-must-follow-an-alternation-group code,
		redefined-with-same-argument-types code,
		result-type-should-covary-with-arguments code,
		incorrect-type-for-complex-group code,
		incorrect-use-of-double-dagger code,
		unbalanced-guillemets code,
		method-name-is-not-canonical code,
		expected-operator-after-backquote code,
		incorrect-type-for-boolean-group code,
		incorrect-type-for-counting-group code,
		octothorp-must-follow-a-simple-group-or-ellipsis code,
		question-mark-must-follow-a-simple-group code,
		case-insensitive-expression-canonization code,
		double-question-mark-must-follow-a-token-or-simple-group code,
		alternative-must-not-contain-arguments code,
		vertical-bar-must-separate-tokens-or-simple-groups code,
		incorrect-type-for-numbered-choice code,
		cannot-define-during-compilation code,
		loading-is-over code,
		method-is-sealed code,
		up-arrow-must-follow-argument code,
		inconsistent-argument-reordering code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Define the specified semantic restriction. Henceforth whenever the method
 * named by {@param "methodName"} is invoked with arguments accepted by
 * {@param "restriction"}, then apply {@param "restriction"} with the most
 * specific available types of the actual arguments. This is determined by the
 * compiler at the method's call site.
 *
 * A semantic restriction has two responsibilities. First, it may reject a
 * method invocation on any appropriate semantic grounds by calling
 * `Reject parse«silently|weakly|moderately|strongly⁇»!,expected:_`. Second,
 * it may strengthen the type of value produced at the call site by answering
 * a subtype of the method's declared return type.
 *
 * @category "Primitives" "Name Resolution" "Methods" "Constructors" "Mutators"
 * @category "Semantic Restrictions"
 * @method "Semantic restriction_is_"
 * @param "methodName" "string"
 *        The name of the method to which the semantic restriction applies.
 * @param "restriction" "[…]→(⊤)'s type"
 *        The restriction function.
 * @returns "⊤"
 * @raises "incorrect-number-of-arguments exception"
 * @raises "incorrect-argument-type exception"
 * @raises "type-restriction-must-accept-only-types exception"
 * @raises "incorrect-type-for-group exception"
 * @raises "ambiguous-name exception"
 * @raises "exclamation-mark-must-follow-an-alternation-group exception"
 * @raises "incorrect-type-for-complex-group exception"
 * @raises "incorrect-use-of-double-dagger exception"
 * @raises "unbalanced-guillemets exception"
 * @raises "method-name-is-not-canonical exception"
 * @raises "expected-operator-after-backquote exception"
 * @raises "incorrect-type-for-boolean-group exception"
 * @raises "incorrect-type-for-counting-group exception"
 * @raises "octothorp-must-follow-a-simple-group-or-ellipsis exception"
 * @raises "question-mark-must-follow-a-simple-group exception"
 * @raises "case-insensitive-expression-canonization exception"
 * @raises "double-question-mark-must-follow-a-token-or-simple-group exception"
 * @raises "alternative-must-not-contain-arguments exception"
 * @raises "vertical-bar-must-separate-tokens-or-simple-groups exception"
 * @raises "incorrect-type-for-numbered-choice exception"
 * @raises "cannot-define-during-compilation exception"
 * @raises "loading-is-over exception"
 * @raises "up-arrow-must-follow-argument exception"
 * @raises "inconsistent-argument-reordering exception"
 */
Primitive "Semantic restriction_is_" is
[
	methodName : string,
	restriction : semantic restriction function
|
	Primitive AddSemanticRestriction (failureCode : {
		incorrect-number-of-arguments code,
		incorrect-argument-type code,
		type-restriction-must-accept-only-types code,
		incorrect-type-for-group code,
		ambiguous-name code,
		exclamation-mark-must-follow-an-alternation-group code,
		incorrect-type-for-complex-group code,
		incorrect-use-of-double-dagger code,
		unbalanced-guillemets code,
		method-name-is-not-canonical code,
		expected-operator-after-backquote code,
		incorrect-type-for-boolean-group code,
		incorrect-type-for-counting-group code,
		octothorp-must-follow-a-simple-group-or-ellipsis code,
		question-mark-must-follow-a-simple-group code,
		case-insensitive-expression-canonization code,
		double-question-mark-must-follow-a-token-or-simple-group code,
		alternative-must-not-contain-arguments code,
		vertical-bar-must-separate-tokens-or-simple-groups code,
		incorrect-type-for-numbered-choice code,
		cannot-define-during-compilation code,
		loading-is-over code,
		up-arrow-must-follow-argument code,
		inconsistent-argument-reordering code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Define the specified semantic restriction. Henceforth whenever the method
 * named by {@param "methodName"} is invoked with arguments accepted by
 * {@param "restriction"}, then apply {@param "restriction"} with the most
 * specific available types of the actual arguments. This is determined by the
 * compiler at the method's call site.
 *
 * A semantic restriction has two responsibilities. First, it may reject a
 * method invocation on any appropriate semantic grounds by calling
 * `Reject parse«silently|weakly|moderately|strongly⁇»!,expected:_`. Second, it
 * may strengthen the type of value produced at the call site by answering a
 * subtype of the method's declared return type.
 *
 * @category "Primitives" "Methods" "Constructors" "Mutators"
 * @category "Semantic Restrictions"
 * @method "Semantic restriction_is_"
 * @param "methodName" "atom"
 *        The name of the method to which the semantic restriction applies.
 * @param "restriction" "[…]→(⊤)'s type"
 *        The restriction function.
 * @returns "⊤"
 * @raises "incorrect-number-of-arguments exception"
 * @raises "incorrect-argument-type exception"
 * @raises "type-restriction-must-accept-only-types exception"
 * @raises "incorrect-type-for-group exception"
 * @raises "exclamation-mark-must-follow-an-alternation-group exception"
 * @raises "incorrect-type-for-complex-group exception"
 * @raises "incorrect-use-of-double-dagger exception"
 * @raises "unbalanced-guillemets exception"
 * @raises "method-name-is-not-canonical exception"
 * @raises "expected-operator-after-backquote exception"
 * @raises "incorrect-type-for-boolean-group exception"
 * @raises "incorrect-type-for-counting-group exception"
 * @raises "octothorp-must-follow-a-simple-group-or-ellipsis exception"
 * @raises "question-mark-must-follow-a-simple-group exception"
 * @raises "case-insensitive-expression-canonization exception"
 * @raises "double-question-mark-must-follow-a-token-or-simple-group exception"
 * @raises "alternative-must-not-contain-arguments exception"
 * @raises "vertical-bar-must-separate-tokens-or-simple-groups exception"
 * @raises "incorrect-type-for-numbered-choice exception"
 * @raises "cannot-define-during-compilation exception"
 * @raises "loading-is-over exception"
 * @raises "up-arrow-must-follow-argument exception"
 * @raises "inconsistent-argument-reordering exception"
 */
Primitive "Semantic restriction_is_" is
[
	methodName : atom,
	restriction : semantic restriction function
|
	Primitive AddSemanticRestrictionForAtom (failureCode : {
		incorrect-number-of-arguments code,
		incorrect-argument-type code,
		type-restriction-must-accept-only-types code,
		incorrect-type-for-group code,
		exclamation-mark-must-follow-an-alternation-group code,
		incorrect-type-for-complex-group code,
		incorrect-use-of-double-dagger code,
		unbalanced-guillemets code,
		method-name-is-not-canonical code,
		expected-operator-after-backquote code,
		incorrect-type-for-boolean-group code,
		incorrect-type-for-counting-group code,
		octothorp-must-follow-a-simple-group-or-ellipsis code,
		question-mark-must-follow-a-simple-group code,
		case-insensitive-expression-canonization code,
		double-question-mark-must-follow-a-token-or-simple-group code,
		alternative-must-not-contain-arguments code,
		vertical-bar-must-separate-tokens-or-simple-groups code,
		incorrect-type-for-numbered-choice code,
		cannot-define-during-compilation code,
		loading-is-over code,
		up-arrow-must-follow-argument code,
		inconsistent-argument-reordering code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Alias {@param "newName"} to {@param "oldAtom"}. This has the same effect
 * as import renaming, but behaves dynamically.
 *
 * @category "Primitives"
 * @method "Alias_to_"
 * @param "newName" "string"
 *        A {@type "string"} that represents the alias.
 * @param "oldAtom" "atom"
 *        An {@type "atom"} that represents the original name.
 * @returns "⊤"
 * @raises "incorrect-argument-type exception"
 * @raises "incorrect-type-for-group exception"
 * @raises "ambiguous-name exception"
 * @raises "exclamation-mark-must-follow-an-alternation-group exception"
 * @raises "special-atom exception"
 * @raises "incorrect-type-for-complex-group exception"
 * @raises "incorrect-use-of-double-dagger exception"
 * @raises "unbalanced-guillemets exception"
 * @raises "method-name-is-not-canonical exception"
 * @raises "expected-operator-after-backquote exception"
 * @raises "incorrect-type-for-boolean-group exception"
 * @raises "incorrect-type-for-counting-group exception"
 * @raises "octothorp-must-follow-a-simple-group-or-ellipsis exception"
 * @raises "question-mark-must-follow-a-simple-group exception"
 * @raises "case-insensitive-expression-canonization exception"
 * @raises "double-question-mark-must-follow-a-token-or-simple-group exception"
 * @raises "alternative-must-not-contain-arguments exception"
 * @raises "vertical-bar-must-separate-tokens-or-simple-groups exception"
 * @raises "incorrect-type-for-numbered-choice exception"
 * @raises "cannot-define-during-compilation exception"
 * @raises "loading-is-over exception"
 * @raises "atom-already-exists exception"
 * @raises "up-arrow-must-follow-argument exception"
 * @raises "inconsistent-argument-reordering exception"
 */
Primitive "Alias_to_" is
[
	newName : string,
	oldAtom : atom
|
	Primitive Alias (failureCode : {
		incorrect-argument-type code,
		incorrect-type-for-group code,
		ambiguous-name code,
		exclamation-mark-must-follow-an-alternation-group code,
		special-atom code,
		incorrect-type-for-complex-group code,
		incorrect-use-of-double-dagger code,
		unbalanced-guillemets code,
		method-name-is-not-canonical code,
		expected-operator-after-backquote code,
		incorrect-type-for-boolean-group code,
		incorrect-type-for-counting-group code,
		octothorp-must-follow-a-simple-group-or-ellipsis code,
		question-mark-must-follow-a-simple-group code,
		case-insensitive-expression-canonization code,
		double-question-mark-must-follow-a-token-or-simple-group code,
		alternative-must-not-contain-arguments code,
		vertical-bar-must-separate-tokens-or-simple-groups code,
		incorrect-type-for-numbered-choice code,
		cannot-define-during-compilation code,
		loading-is-over code,
		atom-already-exists code,
		up-arrow-must-follow-argument code,
		inconsistent-argument-reordering code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Does the method whose bundle has the specified name have a unique definition
 * for the given tuple of parameter types?
 *
 * @category "Primitives" "Atoms" "Methods" "Queries"
 * @method "_has definition for_"
 * @param "methodName" "atom"
 *        A method name (an atom).
 * @param "parameterTypes" "<(any)'s type…|>"
 *        A tuple of parameter types. This must agree in length with the number
 *        of parameters expected by the method.
 * @returns "boolean"
 *    `true` if {@param "methodName"} has a unique definition for the specified
 *    parameter types, `false` otherwise.
 * @raises "incorrect-number-of-arguments exception"
 * @raises "no-method exception"
 * @raises "no-method-definition exception"
 * @raises "ambiguous-method-definition exception"
 */
Primitive "_has definition for_" is
[
	methodName : atom,
	parameterTypes : tuple of any meta
|
	Primitive BundleHasDefinitionForArgumentTypes (failureCode : {
		incorrect-number-of-arguments code,
		no-method code,
		no-method-definition code,
		ambiguous-method-definition code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : boolean;

/**
 * Copy all macros defined for the first {@type bundle} into the second
 * {@type bundle}.  Only copy macros visible in the current module.
 *
 * @category "Primitives"
 * @method "Copy macros from_to_"
 * @param "sourceAtom" "atom"
 *        The {@type bundle} already containing macros.
 * @param "targetAtom" "atom"
 *        The {type bundle} in which to add new macros.
 * @returns "⊤"
 * @raises "incorrect-argument-type exception"
 * @raises "incorrect-type-for-group exception"
 * @raises "ambiguous-name exception"
 * @raises "exclamation-mark-must-follow-an-alternation-group exception"
 * @raises "redefined-with-same-argument-types exception"
 * @raises "special-atom exception"
 * @raises "incorrect-type-for-complex-group exception"
 * @raises "incorrect-use-of-double-dagger exception"
 * @raises "unbalanced-guillemets exception"
 * @raises "method-name-is-not-canonical exception"
 * @raises "expected-operator-after-backquote exception"
 * @raises "incorrect-type-for-boolean-group exception"
 * @raises "incorrect-type-for-counting-group exception"
 * @raises "octothorp-must-follow-a-simple-group-or-ellipsis exception"
 * @raises "question-mark-must-follow-a-simple-group exception"
 * @raises "case-insensitive-expression-canonization exception"
 * @raises "double-question-mark-must-follow-a-token-or-simple-group exception"
 * @raises "alternative-must-not-contain-arguments exception"
 * @raises "vertical-bar-must-separate-tokens-or-simple-groups exception"
 * @raises "incorrect-type-for-numbered-choice exception"
 * @raises "cannot-define-during-compilation exception"
 * @raises "loading-is-over exception"
 * @raises "atom-already-exists exception"
 * @raises "up-arrow-must-follow-argument exception"
 * @raises "inconsistent-argument-reordering exception"
 */
Primitive "Copy macros from_to_" is
[
	sourceAtom : atom,
	targetAtom : atom
|
	Primitive CopyMacros (failureCode : {
		incorrect-argument-type code,
		incorrect-type-for-group code,
		ambiguous-name code,
		exclamation-mark-must-follow-an-alternation-group code,
		redefined-with-same-argument-types code,
		special-atom code,
		incorrect-type-for-complex-group code,
		incorrect-use-of-double-dagger code,
		unbalanced-guillemets code,
		method-name-is-not-canonical code,
		expected-operator-after-backquote code,
		incorrect-type-for-boolean-group code,
		incorrect-type-for-counting-group code,
		octothorp-must-follow-a-simple-group-or-ellipsis code,
		question-mark-must-follow-a-simple-group code,
		case-insensitive-expression-canonization code,
		double-question-mark-must-follow-a-token-or-simple-group code,
		alternative-must-not-contain-arguments code,
		vertical-bar-must-separate-tokens-or-simple-groups code,
		incorrect-type-for-numbered-choice code,
		cannot-define-during-compilation code,
		loading-is-over code,
		atom-already-exists code,
		up-arrow-must-follow-argument code,
		inconsistent-argument-reordering code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Lookup a definition of the method with the given name, given the
 * tuple of parameter types.
 *
 * @category "Primitives" "Methods" "Name Resolution"
 * @method "method definition of_for_"
 * @param "methodName" "atom"
 *        The name of the method.
 * @param "parameterTypes" "<(any)'s type…|>"
 *        A tuple of parameter types. This must agree in length with the number
 *        of parameters expected by the method.
 * @returns "definition"
 *    The unique definition of {@param "methodName"} that best accords with the
 *    specified parameter types.
 * @raises "incorrect-number-of-arguments exception"
 * @raises "no-method exception"
 * @raises "no-method-definition exception"
 * @raises "ambiguous-method-definition exception"
 */
Primitive "method definition of_for_" is
[
	methodName : atom,
	parameterTypes : tuple of any meta
|
	Primitive DefinitionForArgumentTypes (failureCode : {
		incorrect-number-of-arguments code,
		no-method code,
		no-method-definition code,
		ambiguous-method-definition code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : definition;

/**
 * Declare the intention to locally define a method with the specified name and
 * signature. If no such method is defined before compilation of the containing
 * module completes, then the compiler will emit an appropriate error message.
 *
 * Recursive methods must be forward declared. Mutually recursive methods must
 * forward declare all but the lexically first participant in the recursion.
 *
 * @category "Primitives" "Name Resolution" "Methods" "Constructors" "Mutators"
 * @method "Forward method_is_"
 * @param "methodName" "string"
 *        The name of the method to forward declare.
 * @param "aFunctionType" "([…]→⊤)'s type"
 *        The signature.
 * @returns "⊤"
 * @raises "incorrect-argument-type exception"
 * @raises "incorrect-type-for-group exception"
 * @raises "ambiguous-name exception"
 * @raises "exclamation-mark-must-follow-an-alternation-group exception"
 * @raises "redefined-with-same-argument-types exception"
 * @raises "result-type-should-covary-with-arguments exception"
 * @raises "incorrect-type-for-complex-group exception"
 * @raises "incorrect-use-of-double-dagger exception"
 * @raises "unbalanced-guillemets exception"
 * @raises "method-name-is-not-canonical exception"
 * @raises "expected-operator-after-backquote exception"
 * @raises "incorrect-type-for-boolean-group exception"
 * @raises "incorrect-type-for-counting-group exception"
 * @raises "octothorp-must-follow-a-simple-group-or-ellipsis exception"
 * @raises "question-mark-must-follow-a-simple-group exception"
 * @raises "case-insensitive-expression-canonization exception"
 * @raises "double-question-mark-must-follow-a-token-or-simple-group exception"
 * @raises "alternative-must-not-contain-arguments exception"
 * @raises "vertical-bar-must-separate-tokens-or-simple-groups exception"
 * @raises "incorrect-type-for-numbered-choice exception"
 * @raises "cannot-define-during-compilation exception"
 * @raises "loading-is-over exception"
 * @raises "method-is-sealed exception"
 * @raises "up-arrow-must-follow-argument exception"
 * @raises "inconsistent-argument-reordering exception"
 */
Primitive "Forward method_is_" is
[
	methodName : string,
	aFunctionType : function meta
|
	Primitive ForwardMethodDeclaration (failureCode : {
		incorrect-argument-type code,
		incorrect-type-for-group code,
		ambiguous-name code,
		exclamation-mark-must-follow-an-alternation-group code,
		redefined-with-same-argument-types code,
		result-type-should-covary-with-arguments code,
		incorrect-type-for-complex-group code,
		incorrect-use-of-double-dagger code,
		unbalanced-guillemets code,
		method-name-is-not-canonical code,
		expected-operator-after-backquote code,
		incorrect-type-for-boolean-group code,
		incorrect-type-for-counting-group code,
		octothorp-must-follow-a-simple-group-or-ellipsis code,
		question-mark-must-follow-a-simple-group code,
		case-insensitive-expression-canonization code,
		double-question-mark-must-follow-a-token-or-simple-group code,
		alternative-must-not-contain-arguments code,
		vertical-bar-must-separate-tokens-or-simple-groups code,
		incorrect-type-for-numbered-choice code,
		cannot-define-during-compilation code,
		loading-is-over code,
		method-is-sealed code,
		up-arrow-must-follow-argument code,
		inconsistent-argument-reordering code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Define the indicated grammatical restrictions. Each method name in
 * {@param "methodsToRestrict"} must accept the same number of arguments, though
 * not necessarily the same types (or the same order of types). Each element `e`
 * of {@param "exclusions"}, itself a set of method names, corresponds to an
 * argument position `n` of any method name in {@param "methodsToRestrict"}. The
 * compiler rejects parses of source text that invoke methods named in `e` when
 * they occur grammatically at argument position `n` of an invocation of any
 * method named in {@param "methodsToRestrict"}.
 *
 * Note that "argument position" corresponds to a blank, not to a top-level
 * repeating sequence (indicated by guillemet notation).
 *
 * @category "Primitives" "Name Resolution" "Methods" "Constructors" "Mutators"
 * @method "Grammatical restriction_is_"
 * @param "methodsToRestrict" "{string|1..∞}"
 *        A set of method names, each of which should be restricted.
 * @param "exclusions" "<{string|}…|>"
 *        A tuple of sets of method names. The method names in the `n`-th set
 *        are restricted from occurring grammatically at the `n`-th argument
 *        position of any invocation of a method named in
 *        {@param "methodsToRestrict"}.
 * @returns "⊤"
 * @raises "incorrect-number-of-arguments exception"
 * @raises "incorrect-argument-type exception"
 * @raises "incorrect-type-for-group exception"
 * @raises "ambiguous-name exception"
 * @raises "exclamation-mark-must-follow-an-alternation-group exception"
 * @raises "incorrect-type-for-complex-group exception"
 * @raises "incorrect-use-of-double-dagger exception"
 * @raises "unbalanced-guillemets exception"
 * @raises "method-name-is-not-canonical exception"
 * @raises "expected-operator-after-backquote exception"
 * @raises "incorrect-type-for-boolean-group exception"
 * @raises "incorrect-type-for-counting-group exception"
 * @raises "octothorp-must-follow-a-simple-group-or-ellipsis exception"
 * @raises "question-mark-must-follow-a-simple-group exception"
 * @raises "case-insensitive-expression-canonization exception"
 * @raises "double-question-mark-must-follow-a-token-or-simple-group exception"
 * @raises "alternative-must-not-contain-arguments exception"
 * @raises "vertical-bar-must-separate-tokens-or-simple-groups exception"
 * @raises "incorrect-type-for-numbered-choice exception"
 * @raises "cannot-define-during-compilation exception"
 * @raises "loading-is-over exception"
 * @raises "up-arrow-must-follow-argument exception"
 * @raises "inconsistent-argument-reordering exception"
 */
Primitive "Grammatical restriction_is_" is
[
	methodsToRestrict : nonempty set of string,
	exclusions : tuple of set of string
|
	Primitive GrammaticalRestriction (failureCode : {
		incorrect-number-of-arguments code,
		incorrect-argument-type code,
		incorrect-type-for-group code,
		ambiguous-name code,
		exclamation-mark-must-follow-an-alternation-group code,
		incorrect-type-for-complex-group code,
		incorrect-use-of-double-dagger code,
		unbalanced-guillemets code,
		method-name-is-not-canonical code,
		expected-operator-after-backquote code,
		incorrect-type-for-boolean-group code,
		incorrect-type-for-counting-group code,
		octothorp-must-follow-a-simple-group-or-ellipsis code,
		question-mark-must-follow-a-simple-group code,
		case-insensitive-expression-canonization code,
		double-question-mark-must-follow-a-token-or-simple-group code,
		alternative-must-not-contain-arguments code,
		vertical-bar-must-separate-tokens-or-simple-groups code,
		incorrect-type-for-numbered-choice code,
		cannot-define-during-compilation code,
		loading-is-over code,
		up-arrow-must-follow-argument code,
		inconsistent-argument-reordering code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Define the indicated grammatical restrictions. Each method name in
 * {@param "methodsToRestrict"} must accept the same number of arguments, though
 * not necessarily the same types (or the same order of types). Each element `e`
 * of {@param "exclusions"}, itself a set of method names, corresponds to an
 * argument position `n` of any method name in {@param "methodsToRestrict"}. The
 * compiler rejects parses of source text that invoke methods named in `e` when
 * they occur grammatically at argument position `n` of an invocation of any
 * method named in {@param "methodsToRestrict"}.
 *
 * Note that "argument position" corresponds to a blank, not to a top-level
 * repeating sequence (indicated by guillemet notation).
 *
 * @category "Primitives" "Name Resolution" "Methods" "Constructors" "Mutators"
 * @method "Grammatical restriction_is_"
 * @param "methodsToRestrict" "{atom|1..∞}"
 *        A set of method names, each of which should be restricted.
 * @param "exclusions" "<{atom|}…|>"
 *        A tuple of sets of method names. The method names in the
 *       `n`-th set are restricted from occurring grammatically at the `n`-th
 *       argument position of any invocation of a method named in
 *       {@param "methodsToRestrict"}.
 * @returns "⊤"
 * @raises "incorrect-number-of-arguments exception"
 * @raises "incorrect-argument-type exception"
 * @raises "incorrect-type-for-group exception"
 * @raises "exclamation-mark-must-follow-an-alternation-group exception"
 * @raises "incorrect-type-for-complex-group exception"
 * @raises "incorrect-use-of-double-dagger exception"
 * @raises "unbalanced-guillemets exception"
 * @raises "method-name-is-not-canonical exception"
 * @raises "expected-operator-after-backquote exception"
 * @raises "incorrect-type-for-boolean-group exception"
 * @raises "incorrect-type-for-counting-group exception"
 * @raises "octothorp-must-follow-a-simple-group-or-ellipsis exception"
 * @raises "question-mark-must-follow-a-simple-group exception"
 * @raises "case-insensitive-expression-canonization exception"
 * @raises "double-question-mark-must-follow-a-token-or-simple-group exception"
 * @raises "alternative-must-not-contain-arguments exception"
 * @raises "vertical-bar-must-separate-tokens-or-simple-groups exception"
 * @raises "incorrect-type-for-numbered-choice exception"
 * @raises "cannot-define-during-compilation exception"
 * @raises "loading-is-over exception"
 * @raises "up-arrow-must-follow-argument exception"
 * @raises "inconsistent-argument-reordering exception"
 */
Primitive "Grammatical restriction_is_" is
[
	methodsToRestrict : nonempty set of atom,
	exclusions : tuple of set of atom
|
	Primitive GrammaticalRestrictionFromAtoms (failureCode : {
		incorrect-number-of-arguments code,
		incorrect-argument-type code,
		incorrect-type-for-group code,
		exclamation-mark-must-follow-an-alternation-group code,
		incorrect-type-for-complex-group code,
		incorrect-use-of-double-dagger code,
		unbalanced-guillemets code,
		method-name-is-not-canonical code,
		expected-operator-after-backquote code,
		incorrect-type-for-boolean-group code,
		incorrect-type-for-counting-group code,
		octothorp-must-follow-a-simple-group-or-ellipsis code,
		question-mark-must-follow-a-simple-group code,
		case-insensitive-expression-canonization code,
		double-question-mark-must-follow-a-token-or-simple-group code,
		alternative-must-not-contain-arguments code,
		vertical-bar-must-separate-tokens-or-simple-groups code,
		incorrect-type-for-numbered-choice code,
		cannot-define-during-compilation code,
		loading-is-over code,
		up-arrow-must-follow-argument code,
		inconsistent-argument-reordering code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Answer the method uniquely named by the specified atom.
 *
 * @category "Primitives" "Atoms" "Queries"
 * @method "method for_"
 * @param "anAtom" "atom"
 *        An atom.
 * @returns "method"
 *    The requested method.
 * @raises "incorrect-argument-type exception"
 * @raises "incorrect-type-for-group exception"
 * @raises "exclamation-mark-must-follow-an-alternation-group exception"
 * @raises "incorrect-type-for-complex-group exception"
 * @raises "incorrect-use-of-double-dagger exception"
 * @raises "unbalanced-guillemets exception"
 * @raises "method-name-is-not-canonical exception"
 * @raises "expected-operator-after-backquote exception"
 * @raises "incorrect-type-for-boolean-group exception"
 * @raises "incorrect-type-for-counting-group exception"
 * @raises "octothorp-must-follow-a-simple-group-or-ellipsis exception"
 * @raises "question-mark-must-follow-a-simple-group exception"
 * @raises "case-insensitive-expression-canonization exception"
 * @raises "double-question-mark-must-follow-a-token-or-simple-group exception"
 * @raises "alternative-must-not-contain-arguments exception"
 * @raises "vertical-bar-must-separate-tokens-or-simple-groups exception"
 * @raises "incorrect-type-for-numbered-choice exception"
 * @raises "up-arrow-must-follow-argument exception"
 * @raises "inconsistent-argument-reordering exception"
 */
Primitive "method for_" is
[
	anAtom : atom
|
	Primitive MethodFromName (failureCode : {
		incorrect-argument-type code,
		incorrect-type-for-group code,
		exclamation-mark-must-follow-an-alternation-group code,
		incorrect-type-for-complex-group code,
		incorrect-use-of-double-dagger code,
		unbalanced-guillemets code,
		method-name-is-not-canonical code,
		expected-operator-after-backquote code,
		incorrect-type-for-boolean-group code,
		incorrect-type-for-counting-group code,
		octothorp-must-follow-a-simple-group-or-ellipsis code,
		question-mark-must-follow-a-simple-group code,
		case-insensitive-expression-canonization code,
		double-question-mark-must-follow-a-token-or-simple-group code,
		alternative-must-not-contain-arguments code,
		vertical-bar-must-separate-tokens-or-simple-groups code,
		incorrect-type-for-numbered-choice code,
		up-arrow-must-follow-argument code,
		inconsistent-argument-reordering code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : method;

/**
 * Does the specified message contain any lexical groups?
 *
 * @category "Primitives" "Name Resolution" "Methods" "Queries"
 * @method "message_contains groups"
 * @param "methodName" "string"
 *        A method name.
 * @returns "boolean"
 *    `true` if the specified message contains lexical groups, or `false`
 *    otherwise.
 * @raises "incorrect-argument-type exception"
 * @raises "incorrect-type-for-group exception"
 * @raises "exclamation-mark-must-follow-an-alternation-group exception"
 * @raises "incorrect-type-for-complex-group exception"
 * @raises "incorrect-use-of-double-dagger exception"
 * @raises "unbalanced-guillemets exception"
 * @raises "method-name-is-not-canonical exception"
 * @raises "expected-operator-after-backquote exception"
 * @raises "incorrect-type-for-boolean-group exception"
 * @raises "incorrect-type-for-counting-group exception"
 * @raises "octothorp-must-follow-a-simple-group-or-ellipsis exception"
 * @raises "question-mark-must-follow-a-simple-group exception"
 * @raises "case-insensitive-expression-canonization exception"
 * @raises "double-question-mark-must-follow-a-token-or-simple-group exception"
 * @raises "alternative-must-not-contain-arguments exception"
 * @raises "vertical-bar-must-separate-tokens-or-simple-groups exception"
 * @raises "incorrect-type-for-numbered-choice exception"
 * @raises "up-arrow-must-follow-argument exception"
 * @raises "inconsistent-argument-reordering exception"
 */
Primitive "message_contains groups" is
[
	methodName : string
|
	Primitive MethodNameContainsGroups (failureCode : {
		incorrect-argument-type code,
		incorrect-type-for-group code,
		exclamation-mark-must-follow-an-alternation-group code,
		incorrect-type-for-complex-group code,
		incorrect-use-of-double-dagger code,
		unbalanced-guillemets code,
		method-name-is-not-canonical code,
		expected-operator-after-backquote code,
		incorrect-type-for-boolean-group code,
		incorrect-type-for-counting-group code,
		octothorp-must-follow-a-simple-group-or-ellipsis code,
		question-mark-must-follow-a-simple-group code,
		case-insensitive-expression-canonization code,
		double-question-mark-must-follow-a-token-or-simple-group code,
		alternative-must-not-contain-arguments code,
		vertical-bar-must-separate-tokens-or-simple-groups code,
		incorrect-type-for-numbered-choice code,
		up-arrow-must-follow-argument code,
		inconsistent-argument-reordering code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : boolean;

/**
 * Compute and answer the number of parameters required by a valid send of a
 * message {@param "methodName"}.
 *
 * @category "Primitives" "Name Resolution" "Methods" "Queries"
 * @method "`|message_'s⁇parameters`|"
 * @param "methodName" "string"
 *        A method name.
 * @returns "[0..∞)"
 *    The number of parameters required to send the specified message.
 * @raises "incorrect-argument-type exception"
 * @raises "incorrect-type-for-group exception"
 * @raises "exclamation-mark-must-follow-an-alternation-group exception"
 * @raises "incorrect-type-for-complex-group exception"
 * @raises "incorrect-use-of-double-dagger exception"
 * @raises "unbalanced-guillemets exception"
 * @raises "method-name-is-not-canonical exception"
 * @raises "expected-operator-after-backquote exception"
 * @raises "incorrect-type-for-boolean-group exception"
 * @raises "incorrect-type-for-counting-group exception"
 * @raises "octothorp-must-follow-a-simple-group-or-ellipsis exception"
 * @raises "question-mark-must-follow-a-simple-group exception"
 * @raises "case-insensitive-expression-canonization exception"
 * @raises "double-question-mark-must-follow-a-token-or-simple-group exception"
 * @raises "alternative-must-not-contain-arguments exception"
 * @raises "vertical-bar-must-separate-tokens-or-simple-groups exception"
 * @raises "incorrect-type-for-numbered-choice exception"
 * @raises "up-arrow-must-follow-argument exception"
 * @raises "inconsistent-argument-reordering exception"
 */
Primitive "`|message_'s⁇parameters`|" is
[
	methodName : string
|
	Primitive MethodNameParametersCount (failureCode : {
		incorrect-argument-type code,
		incorrect-type-for-group code,
		exclamation-mark-must-follow-an-alternation-group code,
		incorrect-type-for-complex-group code,
		incorrect-use-of-double-dagger code,
		unbalanced-guillemets code,
		method-name-is-not-canonical code,
		expected-operator-after-backquote code,
		incorrect-type-for-boolean-group code,
		incorrect-type-for-counting-group code,
		octothorp-must-follow-a-simple-group-or-ellipsis code,
		question-mark-must-follow-a-simple-group code,
		case-insensitive-expression-canonization code,
		double-question-mark-must-follow-a-token-or-simple-group code,
		alternative-must-not-contain-arguments code,
		vertical-bar-must-separate-tokens-or-simple-groups code,
		incorrect-type-for-numbered-choice code,
		up-arrow-must-follow-argument code,
		inconsistent-argument-reordering code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : whole number;

/**
 * Seal the named method at the specified signature. No further definitions
 * may be added at or below this signature. This facility is provided to secure
 * methods against dangerous, unscrupulous, or confusing extensions.
 *
 * @category "Primitives" "Name Resolution" "Methods" "Constructors" "Mutators"
 * @method "Seal method_at_"
 * @param "methodName" "string"
 *        The name of the method to seal.
 * @param "signature" "<(any)'s type…|>"
 *        A tuple of parameter types. This is the signature at which the
 *       seal will be placed.
 * @returns "⊤"
 * @raises "incorrect-number-of-arguments exception"
 * @raises "incorrect-argument-type exception"
 * @raises "incorrect-type-for-group exception"
 * @raises "ambiguous-name exception"
 * @raises "exclamation-mark-must-follow-an-alternation-group exception"
 * @raises "incorrect-type-for-complex-group exception"
 * @raises "incorrect-use-of-double-dagger exception"
 * @raises "unbalanced-guillemets exception"
 * @raises "method-name-is-not-canonical exception"
 * @raises "expected-operator-after-backquote exception"
 * @raises "incorrect-type-for-boolean-group exception"
 * @raises "incorrect-type-for-counting-group exception"
 * @raises "octothorp-must-follow-a-simple-group-or-ellipsis exception"
 * @raises "question-mark-must-follow-a-simple-group exception"
 * @raises "case-insensitive-expression-canonization exception"
 * @raises "double-question-mark-must-follow-a-token-or-simple-group exception"
 * @raises "alternative-must-not-contain-arguments exception"
 * @raises "vertical-bar-must-separate-tokens-or-simple-groups exception"
 * @raises "incorrect-type-for-numbered-choice exception"
 * @raises "cannot-define-during-compilation exception"
 * @raises "loading-is-over exception"
 * @raises "up-arrow-must-follow-argument exception"
 * @raises "inconsistent-argument-reordering exception"
 */
Primitive "Seal method_at_" is
[
	methodName : string,
	signature : tuple of any meta
|
	Primitive SealMethod (failureCode : {
		incorrect-number-of-arguments code,
		incorrect-argument-type code,
		incorrect-type-for-group code,
		ambiguous-name code,
		exclamation-mark-must-follow-an-alternation-group code,
		incorrect-type-for-complex-group code,
		incorrect-use-of-double-dagger code,
		unbalanced-guillemets code,
		method-name-is-not-canonical code,
		expected-operator-after-backquote code,
		incorrect-type-for-boolean-group code,
		incorrect-type-for-counting-group code,
		octothorp-must-follow-a-simple-group-or-ellipsis code,
		question-mark-must-follow-a-simple-group code,
		case-insensitive-expression-canonization code,
		double-question-mark-must-follow-a-token-or-simple-group code,
		alternative-must-not-contain-arguments code,
		vertical-bar-must-separate-tokens-or-simple-groups code,
		incorrect-type-for-numbered-choice code,
		cannot-define-during-compilation code,
		loading-is-over code,
		up-arrow-must-follow-argument code,
		inconsistent-argument-reordering code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Seal the named method at the specified signature. No further definitions
 * may be added at or below this signature. This facility is provided to secure
 * methods against dangerous, unscrupulous, or confusing extensions.
 *
 * @category "Primitives" "Methods" "Constructors" "Mutators"
 * @method "Seal method_at_"
 * @param "methodName" "atom"
 *        The atom that uniquely designates the method to seal.
 * @param "signature" "<(any)'s type…|>"
 *        A tuple of parameter types. This is the signature at which the seal
 *        will be placed.
 * @returns "⊤"
 * @raises "incorrect-number-of-arguments exception"
 * @raises "incorrect-argument-type exception"
 * @raises "incorrect-type-for-group exception"
 * @raises "exclamation-mark-must-follow-an-alternation-group exception"
 * @raises "incorrect-type-for-complex-group exception"
 * @raises "incorrect-use-of-double-dagger exception"
 * @raises "unbalanced-guillemets exception"
 * @raises "method-name-is-not-canonical exception"
 * @raises "expected-operator-after-backquote exception"
 * @raises "incorrect-type-for-boolean-group exception"
 * @raises "incorrect-type-for-counting-group exception"
 * @raises "octothorp-must-follow-a-simple-group-or-ellipsis exception"
 * @raises "question-mark-must-follow-a-simple-group exception"
 * @raises "case-insensitive-expression-canonization exception"
 * @raises "double-question-mark-must-follow-a-token-or-simple-group exception"
 * @raises "alternative-must-not-contain-arguments exception"
 * @raises "vertical-bar-must-separate-tokens-or-simple-groups exception"
 * @raises "incorrect-type-for-numbered-choice exception"
 * @raises "cannot-define-during-compilation exception"
 * @raises "loading-is-over exception"
 * @raises "up-arrow-must-follow-argument exception"
 * @raises "inconsistent-argument-reordering exception"
 */
Primitive "Seal method_at_" is
[
	methodName : atom,
	signature : tuple of any meta
|
	Primitive SealMethodByAtom (failureCode : {
		incorrect-number-of-arguments code,
		incorrect-argument-type code,
		incorrect-type-for-group code,
		exclamation-mark-must-follow-an-alternation-group code,
		incorrect-type-for-complex-group code,
		incorrect-use-of-double-dagger code,
		unbalanced-guillemets code,
		method-name-is-not-canonical code,
		expected-operator-after-backquote code,
		incorrect-type-for-boolean-group code,
		incorrect-type-for-counting-group code,
		octothorp-must-follow-a-simple-group-or-ellipsis code,
		question-mark-must-follow-a-simple-group code,
		case-insensitive-expression-canonization code,
		double-question-mark-must-follow-a-token-or-simple-group code,
		alternative-must-not-contain-arguments code,
		vertical-bar-must-separate-tokens-or-simple-groups code,
		incorrect-type-for-numbered-choice code,
		cannot-define-during-compilation code,
		loading-is-over code,
		up-arrow-must-follow-argument code,
		inconsistent-argument-reordering code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Seal the each method named by an element of `methodNames` at each of its
 * existing abstract and method definitions. Ignore any macros.
 *
 * @category "Primitives" "Methods" "Mutators"
 * @method "Seal method|methods_at existing definitions"
 * @param "methodNames" "{atom|}"
 *        A set of atoms that serve as method names.
 * @returns "⊤"
 * @raises "cannot-define-during-compilation exception"
 * @raises "loading-is-over exception"
 */
Primitive "Seal method|methods_at existing definitions" is
[
	methodNames : set of atom
|
	Primitive SealMethodsAtExistingDefinitions (failureCode : {
		cannot-define-during-compilation code,
		loading-is-over code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Compute and answer the semantic restrictions that would run at a call site
 * of {@param "aMethod"} applied with the specified tuple of arguments.
 *
 * @category "Primitives" "Methods" "Semantic Restrictions" "Queries"
 * @method "semantic restrictions for_given_"
 * @param "aMethod" "method"
 *        A method.
 * @param "arguments" "<(any)'s type…|>"
 *        The tuple of arguments that should be used to filter the semantic
 *        restrictions.
 * @returns "<[…]→(⊤)'s type…|>"
 *    The requested semantic restrictions.
 * @raises "incorrect-number-of-arguments exception"
 */
Primitive "semantic restrictions for_given_" is
[
	aMethod : method,
	arguments : tuple of any meta
|
	Primitive SemanticRestrictions (failureCode : {
		incorrect-number-of-arguments code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : tuple of semantic restriction function;

/**
 * Define a new lexer.  When it's imported into a module, it will attempt
 * lexical scanning.  Its filter function is used to classify which lexers
 * should run when a particular character is encountered, and its body attempts
 * to produce tokens in that circumstance.
 *
 * @category "Primitives"
 * @method "Lexer_when_is_"
 * @param "lexerName" "atom"
 *        The atom that names the lexer.
 * @param "filterFunction" "[character]→boolean"
 *        The filter function of the lexer.
 * @param "bodyFunction" "[string, [1..∞), [1..∞)]→{<token…|1..∞>|}"
 *        The body of the lexer.
 * @returns "⊤"
 * @raises "incorrect-argument-type exception"
 * @raises "incorrect-type-for-group exception"
 * @raises "exclamation-mark-must-follow-an-alternation-group exception"
 * @raises "incorrect-type-for-complex-group exception"
 * @raises "incorrect-use-of-double-dagger exception"
 * @raises "unbalanced-guillemets exception"
 * @raises "method-name-is-not-canonical exception"
 * @raises "expected-operator-after-backquote exception"
 * @raises "incorrect-type-for-boolean-group exception"
 * @raises "incorrect-type-for-counting-group exception"
 * @raises "octothorp-must-follow-a-simple-group-or-ellipsis exception"
 * @raises "question-mark-must-follow-a-simple-group exception"
 * @raises "case-insensitive-expression-canonization exception"
 * @raises "double-question-mark-must-follow-a-token-or-simple-group exception"
 * @raises "alternative-must-not-contain-arguments exception"
 * @raises "vertical-bar-must-separate-tokens-or-simple-groups exception"
 * @raises "incorrect-type-for-numbered-choice exception"
 * @raises "cannot-define-during-compilation exception"
 * @raises "loading-is-over exception"
 * @raises "up-arrow-must-follow-argument exception"
 * @raises "inconsistent-argument-reordering exception"
 */
Primitive "Lexer_when_is_" is
[
	lexerName : atom,
	filterFunction : lexer filter function,
	bodyFunction : lexer body function
|
	Primitive SimpleLexerDefinitionForAtom (failureCode : {
		incorrect-argument-type code,
		incorrect-type-for-group code,
		exclamation-mark-must-follow-an-alternation-group code,
		incorrect-type-for-complex-group code,
		incorrect-use-of-double-dagger code,
		unbalanced-guillemets code,
		method-name-is-not-canonical code,
		expected-operator-after-backquote code,
		incorrect-type-for-boolean-group code,
		incorrect-type-for-counting-group code,
		octothorp-must-follow-a-simple-group-or-ellipsis code,
		question-mark-must-follow-a-simple-group code,
		case-insensitive-expression-canonization code,
		double-question-mark-must-follow-a-token-or-simple-group code,
		alternative-must-not-contain-arguments code,
		vertical-bar-must-separate-tokens-or-simple-groups code,
		incorrect-type-for-numbered-choice code,
		cannot-define-during-compilation code,
		loading-is-over code,
		up-arrow-must-follow-argument code,
		inconsistent-argument-reordering code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Define a macro with the specified name and body. A macro is a method invoked
 * directly by the compiler as a consequence of parsing a sequence of tokens.
 * The arguments of a macro are phrases that structurally represent the
 * corresponding lexical expressions. The result of a macro is a phrase that
 * completely replaces the macro invocation; the compiler proceeds as if it had
 * built this phrase from the original tokens instead of the macro
 * invocation phrase.
 *
 * If a macro name contains the section sign (§), it must have a prefix function
 * for each occurrence of that character in the name.  The prefix function will
 * be invoked each time that character is "reached" in the method name while
 * parsing a potential call site, giving the macro the opportunity to alter the
 * current variable scope and other parsing state.
 *
 * Macro definitions are parametric by parameter types. They participate in
 * multiply polymorphic dispatch just as do methods.
 *
 * @category "Primitives" "Name Resolution" "Methods" "Constructors" "Mutators"
 * @method "Macro_is«_,»_«styled by_»?"
 * @param "macroName" "string"
 *        The name of the macro to define.
 * @param "prefixFunctions" "<[…]→⊤…|>"
 *        A tuple of zero or more prefix functions.
 * @param "body" "[…]→phrase⇒⊤"
 *        The function that implements the macro.
 * @param "optionalStyler" "<[send phrase⇒⊤, phrase⇒⊤]→⊤…|0..1>"
 *        The optional function used for styling invocations of this macro.
 * @returns "⊤"
 * @raises "incorrect-number-of-arguments exception"
 * @raises "incorrect-argument-type exception"
 * @raises "incorrect-type-for-group exception"
 * @raises "macro-argument-must-be-a-phrase exception"
 * @raises "ambiguous-name exception"
 * @raises "exclamation-mark-must-follow-an-alternation-group exception"
 * @raises "redefined-with-same-argument-types exception"
 * @raises "incorrect-type-for-complex-group exception"
 * @raises "incorrect-use-of-double-dagger exception"
 * @raises "unbalanced-guillemets exception"
 * @raises "method-name-is-not-canonical exception"
 * @raises "expected-operator-after-backquote exception"
 * @raises "incorrect-type-for-boolean-group exception"
 * @raises "incorrect-type-for-counting-group exception"
 * @raises "octothorp-must-follow-a-simple-group-or-ellipsis exception"
 * @raises "question-mark-must-follow-a-simple-group exception"
 * @raises "case-insensitive-expression-canonization exception"
 * @raises "double-question-mark-must-follow-a-token-or-simple-group exception"
 * @raises "alternative-must-not-contain-arguments exception"
 * @raises "vertical-bar-must-separate-tokens-or-simple-groups exception"
 * @raises "incorrect-type-for-numbered-choice exception"
 * @raises "macro-prefix-functions-must-return-top exception"
 * @raises "cannot-define-during-compilation exception"
 * @raises "macro-prefix-function-index-out-of-bounds exception"
 * @raises "macro-prefix-function-argument-must-be-a-phrase exception"
 * @raises "macro-must-return-a-phrase exception"
 * @raises "loading-is-over exception"
 * @raises "up-arrow-must-follow-argument exception"
 * @raises "inconsistent-argument-reordering exception"
 */
Primitive "Macro_is«_,»_«styled by_»?" is
[
	macroName : string,
	prefixFunctions : tuple of function,
	body : macro function,
	optionalStyler : optionalStylerFunction
|
	Primitive SimpleMacroDeclaration (failureCode : {
		incorrect-number-of-arguments code,
		incorrect-argument-type code,
		incorrect-type-for-group code,
		macro-argument-must-be-a-phrase code,
		ambiguous-name code,
		exclamation-mark-must-follow-an-alternation-group code,
		redefined-with-same-argument-types code,
		incorrect-type-for-complex-group code,
		incorrect-use-of-double-dagger code,
		unbalanced-guillemets code,
		method-name-is-not-canonical code,
		expected-operator-after-backquote code,
		incorrect-type-for-boolean-group code,
		incorrect-type-for-counting-group code,
		octothorp-must-follow-a-simple-group-or-ellipsis code,
		question-mark-must-follow-a-simple-group code,
		case-insensitive-expression-canonization code,
		double-question-mark-must-follow-a-token-or-simple-group code,
		alternative-must-not-contain-arguments code,
		vertical-bar-must-separate-tokens-or-simple-groups code,
		incorrect-type-for-numbered-choice code,
		macro-prefix-functions-must-return-top code,
		cannot-define-during-compilation code,
		macro-prefix-function-index-out-of-bounds code,
		macro-prefix-function-argument-must-be-a-phrase code,
		macro-must-return-a-phrase code,
		loading-is-over code,
		up-arrow-must-follow-argument code,
		inconsistent-argument-reordering code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Define a macro with the specified name and body. A macro is a method invoked
 * directly by the compiler as a consequence of parsing a sequence of tokens.
 * The arguments of a macro are phrases that structurally represent the
 * corresponding lexical expressions. The result of a macro is a phrase that
 * completely replaces the macro invocation; the compiler proceeds as if it had
 * built this phrase from the original tokens instead of the macro
 * invocation phrase.
 *
 * If a macro name contains the section sign (§), it must have a prefix function
 * for each occurrence of that character in the name.  The prefix function will
 * be invoked each time that character is "reached" in the method name while
 * parsing a potential call site, giving the macro the opportunity to alter the
 * current variable scope and other parsing state.
 *
 * Macro definitions are parametric by parameter types. They participate in
 * multiply polymorphic dispatch just as do methods.
 *
 * @category "Primitives" "Name Resolution" "Methods" "Constructors" "Mutators"
 * @method "Macro_is«_,»_«styled by_»?"
 * @param "macroName" "atom"
 *        The name of the macro to define.
 * @param "prefixFunctions" "<[…]→⊤…|>"
 *        A tuple of zero or more prefix functions.
 * @param "body" "[…]→phrase⇒⊤"
 *        The function that implements the macro.
 * @param "optionalStyler" "<[send phrase⇒⊤, phrase⇒⊤]→⊤…|0..1>"
 *        The optional function used for styling invocations of this macro.
 * @returns "⊤"
 * @raises "incorrect-number-of-arguments exception"
 * @raises "incorrect-argument-type exception"
 * @raises "incorrect-type-for-group exception"
 * @raises "macro-argument-must-be-a-phrase exception"
 * @raises "exclamation-mark-must-follow-an-alternation-group exception"
 * @raises "redefined-with-same-argument-types exception"
 * @raises "incorrect-type-for-complex-group exception"
 * @raises "incorrect-use-of-double-dagger exception"
 * @raises "unbalanced-guillemets exception"
 * @raises "method-name-is-not-canonical exception"
 * @raises "expected-operator-after-backquote exception"
 * @raises "incorrect-type-for-boolean-group exception"
 * @raises "incorrect-type-for-counting-group exception"
 * @raises "octothorp-must-follow-a-simple-group-or-ellipsis exception"
 * @raises "question-mark-must-follow-a-simple-group exception"
 * @raises "case-insensitive-expression-canonization exception"
 * @raises "double-question-mark-must-follow-a-token-or-simple-group exception"
 * @raises "alternative-must-not-contain-arguments exception"
 * @raises "vertical-bar-must-separate-tokens-or-simple-groups exception"
 * @raises "incorrect-type-for-numbered-choice exception"
 * @raises "macro-prefix-functions-must-return-top exception"
 * @raises "cannot-define-during-compilation exception"
 * @raises "macro-prefix-function-index-out-of-bounds exception"
 * @raises "macro-prefix-function-argument-must-be-a-phrase exception"
 * @raises "macro-must-return-a-phrase exception"
 * @raises "loading-is-over exception"
 * @raises "up-arrow-must-follow-argument exception"
 * @raises "inconsistent-argument-reordering exception"
 * @raises "{38}"
 */
Primitive "Macro_is«_,»_«styled by_»?" is
[
	macroName : atom,
	prefixFunctions : tuple of function,
	body : macro function,
	optionalStyler : optionalStylerFunction
|
	Primitive SimpleMacroDefinitionForAtom (failureCode : {
		incorrect-number-of-arguments code,
		incorrect-argument-type code,
		incorrect-type-for-group code,
		macro-argument-must-be-a-phrase code,
		exclamation-mark-must-follow-an-alternation-group code,
		redefined-with-same-argument-types code,
		incorrect-type-for-complex-group code,
		incorrect-use-of-double-dagger code,
		unbalanced-guillemets code,
		method-name-is-not-canonical code,
		expected-operator-after-backquote code,
		incorrect-type-for-boolean-group code,
		incorrect-type-for-counting-group code,
		octothorp-must-follow-a-simple-group-or-ellipsis code,
		question-mark-must-follow-a-simple-group code,
		case-insensitive-expression-canonization code,
		double-question-mark-must-follow-a-token-or-simple-group code,
		alternative-must-not-contain-arguments code,
		vertical-bar-must-separate-tokens-or-simple-groups code,
		incorrect-type-for-numbered-choice code,
		macro-prefix-functions-must-return-top code,
		cannot-define-during-compilation code,
		macro-prefix-function-index-out-of-bounds code,
		macro-prefix-function-argument-must-be-a-phrase code,
		macro-must-return-a-phrase code,
		loading-is-over code,
		up-arrow-must-follow-argument code,
		inconsistent-argument-reordering code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Register the given function for callback after the module undergoing
 * compilation has been unloaded.
 *
 * @category "Primitives" "Modules" "Mutators"
 * @method "After the current module is unloaded,⁇do_"
 * @param "aFunction" "[…]→⊤"
 *        The post-unload function.
 * @returns "⊤"
 * @raises "loading-is-over exception"
 */
Primitive "After the current module is unloaded,⁇do_" is
[
	aFunction : function
|
	Primitive AddUnloadFunction (failureCode : {
		loading-is-over code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Close the specified anonymous {@type "module"}, thereby preventing the
 * performance of any new side effects upon it.
 *
 * @category "Primitives" "Modules"
 * @method "Close module_"
 * @param "aModule" "module"
 *        The module to close.
 * @returns "⊤"
 * @raises "module-is-closed exception"
 *    If {@param "aModule"} is already closed.
 */
Primitive "Close module_" is
[
	aModule : module
|
	Primitive CloseModule (failureCode : {
		module-is-closed code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Create an anonymous {@type "module"} that privately imports exactly the
 * supplied modules with optional import structures.
 *
 * @category "Primitives" "Modules"
 * @method "new anonymous module importing_"
 * @param "allImports" "<<string, <<<<boolean, <character…|1..∞>, <<character…|1..∞>…|0..1>…|3>…|>, boolean…|2>…|0..1>…|2>…|1..∞>"
 *        Every module and name to be imported privately by the new module.
 * @returns "module"
 *    The new module.
 * @raises "incorrect-argument-type exception"
 *    If the module import specifications are invalid in some way.
 */
Primitive "new anonymous module importing_" is
[
	allImports : module imports tuple
|
	Primitive CreateAnonymousModule (failureCode : {
		incorrect-argument-type code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : module;

/**
 * Answer the module currently undergoing compilation.
 *
 * @category "Primitives" "Modules" "Queries"
 * @method "current module"
 * @returns "module"
 *    The module currently undergoing compilation.
 * @raises "loading-is-over exception"
 */
Primitive "current module" is
[
	Primitive CurrentModule (failureCode : {
		loading-is-over code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : module;

/**
 * Answer the set of all atoms exported by the current module.
 *
 * @category "Primitives" "Modules" "Queries"
 * @method "current module's exported names"
 * @returns "{atom|}"
 *    The set of atoms exported by the current module.
 * @raises "natural number"
 */
Primitive "current module's exported names" is
[
	Primitive ExportedNames (failureCode : natural number);
	Private invoke _fail_primitive with failureCode
] : set of atom;

/**
 * Answer the atom referenced by the specified name in the module currently
 * undergoing compilation. If this name already refers to an atom in scope,
 * i.e., either one 1) imported through the "Uses" or "Extends" sections of the
 * current module's header, 2) introduced by the "Names" section of the
 * current module's header, or 3) introduced by dynamic publication then answer
 * this atom. Otherwise, privately introduce a new atom.
 *
 * @category "Primitives" "Name Resolution" "Queries"
 * @method "atom for_"
 * @param "localName" "string"
 *        The name by which this atom is known locally.
 * @returns "atom"
 *    The requested atom.
 * @raises "ambiguous-name exception"
 * @raises "loading-is-over exception"
 */
Primitive "atom for_" is
[
	localName : string
|
	Primitive LookupName (failureCode : {
		ambiguous-name code,
		loading-is-over code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : atom;

/**
 * Dynamically introduce {@param "newName"} as a public name. This has the same
 * effect as listing in the "Names" section of the current module, i.e., the
 * module currently undergoing compilation. This facilitates code generation in
 * some circumstances. This operation may only be invoked during compilation,
 * i.e., as the result of parsing or executing a top-level statement.
 *
 * @category "Primitives" "Modules" "Name Resolution" "Mutators"
 * @method "Export_as a new name"
 * @param "newName" "string"
 *        The name that should be introduced.
 * @returns "⊤"
 * @raises "ambiguous-name exception"
 * @raises "cannot-define-during-compilation exception"
 * @raises "loading-is-over exception"
 */
Primitive "Export_as a new name" is
[
	newName : string
|
	Primitive PublishName (failureCode : {
		ambiguous-name code,
		cannot-define-during-compilation code,
		loading-is-over code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Answer every grammatical {@type "atom"} visible within the {@method
 * "current module"}.
 *
 * @category "Primitives" "Modules" "Atoms"
 * @method "current module's visible names"
 * @returns "{atom|}"
 *    The {@type "set"} of visible {@type "atom"}s.
 * @raises "loading-is-over exception"
 */
Primitive "current module's visible names" is
[
	Primitive VisibleAtoms (failureCode : {
		loading-is-over code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : set of atom;

/**
 * Compute and answer the sum of the arguments.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "_+_"
 * @param "augend" "number"
 *        The augend.
 * @param "addend" "number"
 *        The addend.
 * @returns "number"
 *    The sum of the augend and the addend.
 * @raises "cannot-add-unlike-infinities exception"
 */
Primitive "_+_" is
[
	augend : number,
	addend : number
|
	Primitive Addition (failureCode : {
		cannot-add-unlike-infinities code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : number;

/**
 * Compute and answer the quotient of the arguments.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "_÷_"
 * @param "dividend" "number"
 *        The dividend.
 * @param "divisor" "number"
 *        The divisor.
 * @returns "number"
 *    The quotient of the dividend and the divisor.
 * @raises "cannot-divide-by-zero exception"
 * @raises "cannot-divide-infinities exception"
 */
Primitive "_÷_" is
[
	dividend : number,
	divisor : number
|
	Primitive Division (failureCode : {
		cannot-divide-by-zero code,
		cannot-divide-infinities code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : number;

/**
 * Compute and answer the product of the arguments.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "_×_"
 * @param "multiplicand" "number"
 *        The multiplicand.
 * @param "multiplier" "number"
 *        The multiplier.
 * @returns "number"
 *    The product of the multiplicand and the multiplier.
 * @raises "cannot-multiply-zero-and-infinity exception"
 */
Primitive "_×_" is
[
	multiplicand : number,
	multiplier : number
|
	Primitive Multiplication (failureCode : {
		cannot-multiply-zero-and-infinity code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : number;

/**
 * Compute and answer the difference of the arguments.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "_-_"
 * @param "minuend" "number"
 *        The minuend.
 * @param "subtrahend" "number"
 *        The subtrahend.
 * @returns "number"
 *    The difference of the minuend and the subtrahend.
 * @raises "cannot-subtract-like-infinities exception"
 */
Primitive "_-_" is
[
	minuend : number,
	subtrahend : number
|
	Primitive Subtraction (failureCode : {
		cannot-subtract-like-infinities code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : number;

/**
 * Extract a field's value from an object.
 *
 * @category "Primitives" "Objects" "Queries"
 * @method "_[_]"
 * @param "object" "object"
 *        An object.
 * @param "field" "atom"
 *        The field for which to extract the value.
 * @returns "any"
 *    The field's value.
 * @raises "no-such-field exception"
 */
Primitive "_[_]" is
[
	object : object,
	field : atom
|
	Primitive GetObjectField (failureCode : {
		no-such-field code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : any;

/**
 * Extract a field's type from an object type.
 *
 * @category "Primitives" "Types" "Objects" "Queries"
 * @method "_[_]"
 * @param "objectType" "(object)'s type"
 *        An object type.
 * @param "field" "atom"
 *        The field for which to extract the type.
 * @returns "(any)'s type"
 *    The field's constraining type.
 * @raises "no-such-field exception"
 */
Primitive "_[_]" is
[
	objectType : object meta,
	field : atom
|
	Primitive GetObjectTypeField (failureCode : {
		no-such-field code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : any meta;

/**
 * Construct and answer a map based on the supplied object type.
 *
 * @category "Primitives" "Types" "Objects" "Maps" "Conversions"
 * @method "_→map"
 * @param "anObjectType" "(object)'s type"
 *        An object type whose fields should be the keys of the new map and
 *        whose values are the corresponding values.
 * @returns "{atom→(any)'s type|}"
 *    The requested map.
 * @raises "no-such-field exception"
 */
Primitive "_→map" is
[
	anObjectType : object meta
|
	Primitive ObjectTypeToMap (failureCode : {
		no-such-field code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : field type map;

/**
 * Construct and answer a tuple based on the supplied object type.
 *
 * @category "Primitives" "Types" "Tuples" "Objects" "Conversions"
 * @method "_→tuple"
 * @param "anObjectType" "(object)'s type"
 *        An object type.
 * @returns "<<atom, (any)'s type…|2>…|>"
 *    A tuple that represents the composition of the object type. Its elements
 *    are 2-tuples. Each 2-tuple's first element is an atom (i.e., the field
 *    identifier) and its second element is the value type permitted by the
 *    field.
 * @raises "no-such-field exception"
 */
Primitive "_→tuple" is
[
	anObjectType : object meta
|
	Primitive ObjectTypeToTuple (failureCode : {
		no-such-field code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : field type tuple;

/**
 * Construct and answer an assignment expression.
 *
 * @category "Primitives" "Phrases" "Constructors"
 * @method "`«(_:=_)`»"
 * @param "variableUse" "variable use phrase⇒any"
 *        A variable use expression.
 * @param "valueExpression" "expression phrase⇒any"
 *        An expression.
 * @returns "assignment phrase⇒⊤"
 *    An expression that describes assigning to the variable indicated by
 *    {@param "variableUse"} the result of running {@param "valueExpression"}.
 *    The result yields the same answer as {@param "valueExpression"}.
 * @raises "cannot-store-incorrectly-typed-value exception"
 * @raises "declaration-kind-does-not-support-assignment exception"
 */
Primitive "`«(_:=_)`»" is
[
	variableUse : variable use phrase,
	valueExpression : expression yielding any
|
	Primitive CreateAssignmentExpression (failureCode : {
		cannot-store-incorrectly-typed-value code,
		declaration-kind-does-not-support-assignment code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : assignment phrase;

/**
 * Construct and answer an assignment statement.
 *
 * @category "Primitives" "Phrases" "Constructors"
 * @method "`«_:=_`»"
 * @param "variableUse" "variable use phrase⇒any"
 *        A variable use expression.
 * @param "valueExpression" "expression phrase⇒any"
 *        An expression.
 * @returns "assignment phrase⇒⊤"
 *    A statement that describes assigning to the variable indicated by
 *    {@param "variableUse"} the result of running {@param "valueExpression"}.
 * @raises "cannot-store-incorrectly-typed-value exception"
 * @raises "declaration-kind-does-not-support-assignment exception"
 */
Primitive "`«_:=_`»" is
[
	variableUse : variable use phrase,
	valueExpression : expression yielding any
|
	Primitive CreateAssignmentStatement (failureCode : {
		cannot-store-incorrectly-typed-value code,
		declaration-kind-does-not-support-assignment code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : assignment phrase;

/**
 * Construct and answer a block from the specified tuple of argument
 * declarations, primitive linkage number, tuple of statements, return type, and
 * set of declared exceptions.
 *
 * @category "Primitives" "Phrases" "Constructors"
 * @method "`«[_`|Primitive__]:_^_`»"
 * @param "argumentDeclarations" "<argument phrase⇒⊤…|>"
 *        A tuple of argument declarations.
 * @param "primitiveName" "string"
 *        The primitive linkage number, or 0 for no primitive linkage.
 * @param "statements" "<phrase⇒⊤…|>"
 *        A tuple of statements. Each element except for the last must be an
 *        assignment, declaration, label, sequence, or ⊤-valued send.
 * @param "returnType" "(⊤)'s type"
 *        The return type.
 * @param "exceptions" "{exception|}"
 *        The set of exceptions that may be raised.
 * @returns "block phrase⇒[…]→⊤"
 *    The requested block.
 * @raises "invalid-primitive-name exception"
 * @raises "block-contains-invalid-statements exception"
 */
Primitive "`«[_`|Primitive__]:_^_`»" is
[
	argumentDeclarations : argument tuple,
	primitiveName : string,
	statements : phrase tuple,
	returnType : type,
	exceptions : set of exception
|
	Primitive CreateBlockExpression (failureCode : {
		invalid-primitive-name code,
		block-contains-invalid-statements code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : block phrase;

/**
 * Construct and answer a first-of-sequence phrase from the specified tuple of
 * statements.
 *
 * @category "Primitives"
 * @method "first-of-seq`«_`»"
 * @param "statements" "<phrase⇒⊤…|>"
 *        A tuple of statements.
 * @returns "first of sequence phrase⇒⊤"
 *    The requested first-of-sequence phrase.
 * @raises "sequence-contains-invalid-statements exception"
 */
Primitive "first-of-seq`«_`»" is
[
	statements : phrase tuple
|
	Primitive CreateFirstOfSequenceOfStatements (failureCode : {
		sequence-contains-invalid-statements code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : first of sequence phrase;

/**
 * Construct and answer a literal token.
 *
 * @category "Primitives" "Tokens" "Constructors"
 * @method "``_``(_)@_:_«from phrase_»?"
 * @param "value" "any"
 *        The value of the literal.
 * @param "lexeme" "string"
 *        The source text of the literal.
 * @param "start" "[0..∞)"
 *        The one-based starting character position of the literal. A {@code 0}
 *        indicates that the character position is unknown or meaningless.
 * @param "line" "[0..∞)"
 *        The one-based line number of the literal. A {@code 0}
 *        indicates that the line number is unknown or meaningless.
 * @param "optionalGeneratingPhrase" "<phrase⇒⊤…|0..1>"
 *        The optional phrase from which this token is considered to have been
 *        constructed.
 * @returns "literal token⇒any"
 *          The requested literal token.
 * @raises "exceeds-VM-limit exception"
 *         If a numeric parameter is outside the range supported by the VM.
 */
Primitive "``_``(_)@_:_«from phrase_»?" is
[
	value : any,
	lexeme : string,
	start : whole number,
	line : whole number,
	optionalGeneratingPhrase : optionalPhrase
|
	Primitive CreateLiteralToken (failureCode : {
		exceeds-VM-limit code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : literal token;

/**
 * Construct and answer a {@type "permuted list phrase"} given the specified
 * {@type "list phrase"} and permutation {@type "tuple"}.
 *
 * @category "Primitives"
 * @method "_permuted by_"
 * @param "list" "list phrase⇒tuple (subexpressions tuple type=<phrase⇒any…|>)"
 *        The {@type "list phrase"} whose subexpressions should be permuted.
 * @param "permutation" "<[1..∞)…|1..∞>"
 *        The permutation imposed by the resultant {@type
 *        "permuted list phrase"}. This is a {@type "tuple"} of target indices,
 *        index by source index.
 * @returns "permuted list phrase⇒tuple (subexpressions tuple type=<phrase⇒any…|>)"
 *    The requested {@type "permuted list phrase"}.
 * @raises "inconsistent-argument-reordering exception"
 */
Primitive "_permuted by_" is
[
	list : list phrase,
	permutation : permutation tuple
|
	Primitive CreatePermutedListPhrase (failureCode : {
		inconsistent-argument-reordering code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : permuted list phrase;

/**
 * Construct and answer a value reference expression.
 *
 * @category "Primitives" "Phrases" "Constructors"
 * @method "`«`↑_`»"
 * @param "variableUse" "variable use phrase⇒any"
 *        A variable use expression.
 * @returns "reference phrase⇒read ⊤/write ⊥"
 *    A variable reference expression that answers the variable described by
 *    {@param "variableUse"}.
 * @raises "declaration-kind-does-not-support-reference exception"
 */
Primitive "`«`↑_`»" is
[
	variableUse : variable use phrase
|
	Primitive CreateReferenceExpression (failureCode : {
		declaration-kind-does-not-support-reference code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : variable reference phrase;

/**
 * Create a send phrase from the supplied message name (atom), list phrase of
 * arguments, and return type.  Strengthen the return type based on the
 * applicable method definitions.  Also launch a fiber for each applicable
 * semantic restriction and strengthen the return type with their eventual
 * results.
 *
 * If any semantic restrictions reject parsing, collect the failure messages
 * into an aggregate message.  Answer a tuple where the first element is either
 * an empty tuple or a tuple containing the send phrase, and where the second
 * element is either the report from rejecting semantic restrictions or the
 * empty string.
 *
 * @category "Primitives"
 * @method "restricted report and send_with_:_"
 * @param "message" "atom"
 *        The atom that names the method to be invoked by the send phrase.
 * @param "args" "list phrase⇒tuple (subexpressions tuple type=<phrase⇒any…|>)"
 *        The list phrase of phrases that are supplied as arguments of the send
 *        phrase.
 * @param "basicReturnType" "(⊤)'s type"
 *        The return type of the send phrase, prior to strengthening by
 *        applicable method definitions and semantic restrictions.
 * @returns "<<send phrase⇒⊤…|0..1>, string…|2>"
 *        A pair of the optional restricted send phrase and report string.
 * @raises "incorrect-number-of-arguments exception"
 * @raises "incorrect-argument-type exception"
 * @raises "incorrect-type-for-group exception"
 * @raises "exclamation-mark-must-follow-an-alternation-group exception"
 * @raises "incorrect-type-for-complex-group exception"
 * @raises "incorrect-use-of-double-dagger exception"
 * @raises "unbalanced-guillemets exception"
 * @raises "method-name-is-not-canonical exception"
 * @raises "expected-operator-after-backquote exception"
 * @raises "incorrect-type-for-boolean-group exception"
 * @raises "incorrect-type-for-counting-group exception"
 * @raises "octothorp-must-follow-a-simple-group-or-ellipsis exception"
 * @raises "question-mark-must-follow-a-simple-group exception"
 * @raises "case-insensitive-expression-canonization exception"
 * @raises "double-question-mark-must-follow-a-token-or-simple-group exception"
 * @raises "alternative-must-not-contain-arguments exception"
 * @raises "vertical-bar-must-separate-tokens-or-simple-groups exception"
 * @raises "incorrect-type-for-numbered-choice exception"
 * @raises "loading-is-over exception"
 * @raises "up-arrow-must-follow-argument exception"
 * @raises "no-method-definition exception"
 * @raises "inconsistent-argument-reordering exception"
 */
Primitive "restricted report and send_with_:_" is
[
	message : atom,
	args : list phrase,
	basicReturnType : type
|
	Primitive CreateRestrictedSendExpression (failureCode : {
		incorrect-number-of-arguments code,
		incorrect-argument-type code,
		incorrect-type-for-group code,
		exclamation-mark-must-follow-an-alternation-group code,
		incorrect-type-for-complex-group code,
		incorrect-use-of-double-dagger code,
		unbalanced-guillemets code,
		method-name-is-not-canonical code,
		expected-operator-after-backquote code,
		incorrect-type-for-boolean-group code,
		incorrect-type-for-counting-group code,
		octothorp-must-follow-a-simple-group-or-ellipsis code,
		question-mark-must-follow-a-simple-group code,
		case-insensitive-expression-canonization code,
		double-question-mark-must-follow-a-token-or-simple-group code,
		alternative-must-not-contain-arguments code,
		vertical-bar-must-separate-tokens-or-simple-groups code,
		incorrect-type-for-numbered-choice code,
		loading-is-over code,
		up-arrow-must-follow-argument code,
		no-method-definition code,
		inconsistent-argument-reordering code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : optional send phrase and report string;

/**
 * Construct and answer a message send. {@param "messageName"} must be an atom
 * which has a message bundle.  The number and types of the argument expressions
 * must satisfy at least one of the method's existing definitions.
 *
 * @category "Primitives" "Phrases" "Constructors"
 * @method "send_with_:_"
 * @param "messageName" "atom"
 *        The name of the method to be invoked.
 * @param "argumentsList" "list phrase⇒tuple (subexpressions tuple type=<phrase⇒any…|>)"
 *        The list phrase containing the argument expressions, corresponding
 *        left-to-right with the arguments of the method.
 * @param "returnType" "(⊤)'s type"
 *        The expected (strengthened) return type of the method send.
 * @returns "send phrase⇒⊤"
 *    The requested message send.
 * @raises "incorrect-number-of-arguments exception"
 * @raises "incorrect-argument-type exception"
 * @raises "incorrect-type-for-group exception"
 * @raises "exclamation-mark-must-follow-an-alternation-group exception"
 * @raises "incorrect-type-for-complex-group exception"
 * @raises "incorrect-use-of-double-dagger exception"
 * @raises "unbalanced-guillemets exception"
 * @raises "method-name-is-not-canonical exception"
 * @raises "expected-operator-after-backquote exception"
 * @raises "incorrect-type-for-boolean-group exception"
 * @raises "incorrect-type-for-counting-group exception"
 * @raises "octothorp-must-follow-a-simple-group-or-ellipsis exception"
 * @raises "question-mark-must-follow-a-simple-group exception"
 * @raises "case-insensitive-expression-canonization exception"
 * @raises "double-question-mark-must-follow-a-token-or-simple-group exception"
 * @raises "alternative-must-not-contain-arguments exception"
 * @raises "vertical-bar-must-separate-tokens-or-simple-groups exception"
 * @raises "incorrect-type-for-numbered-choice exception"
 * @raises "up-arrow-must-follow-argument exception"
 * @raises "inconsistent-argument-reordering exception"
 */
Primitive "send_with_:_" is
[
	messageName : atom,
	argumentsList : list phrase,
	returnType : type
|
	Primitive CreateSendExpression (failureCode : {
		incorrect-number-of-arguments code,
		incorrect-argument-type code,
		incorrect-type-for-group code,
		exclamation-mark-must-follow-an-alternation-group code,
		incorrect-type-for-complex-group code,
		incorrect-use-of-double-dagger code,
		unbalanced-guillemets code,
		method-name-is-not-canonical code,
		expected-operator-after-backquote code,
		incorrect-type-for-boolean-group code,
		incorrect-type-for-counting-group code,
		octothorp-must-follow-a-simple-group-or-ellipsis code,
		question-mark-must-follow-a-simple-group code,
		case-insensitive-expression-canonization code,
		double-question-mark-must-follow-a-token-or-simple-group code,
		alternative-must-not-contain-arguments code,
		vertical-bar-must-separate-tokens-or-simple-groups code,
		incorrect-type-for-numbered-choice code,
		up-arrow-must-follow-argument code,
		inconsistent-argument-reordering code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : send phrase;

/**
 * Construct and answer a sequence from the specified tuple of statements.
 *
 * @category "Primitives" "Phrases" "Constructors"
 * @method "seq`«_`»"
 * @param "statements" "<phrase⇒⊤…|>"
 *        A tuple of statements.
 * @returns "sequence phrase⇒⊤"
 *    The requested sequence.
 * @raises "sequence-contains-invalid-statements exception"
 */
Primitive "seq`«_`»" is
[
	statements : phrase tuple
|
	Primitive CreateSequenceOfStatements (failureCode : {
		sequence-contains-invalid-statements code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : sequence phrase;

/**
 * Construct a supercast phrase.
 *
 * @category "Primitives"
 * @method "`«supercast(_::_)`»"
 * @param "baseExpression" "expression phrase⇒any"
 *        The base phrase that produces the argument to be passed in a call.
 * @param "lookupType" "(any)'s type"
 *        The type to use to lookup this argument rather than its actual type.
 * @returns "super cast phrase⇒any"
 *    A supercast phrase.
 * @raises "supercast-expression-type-must-not-be-top-or-bottom exception"
 * @raises "supercast-expression-must-not-also-be-a-supercast exception"
 * @raises "supercast-must-be-strict-supertype-of-expression-type exception"
 */
Primitive "`«supercast(_::_)`»" is
[
	baseExpression : expression yielding any,
	lookupType : any meta
|
	Primitive CreateSuperCastExpression (failureCode : {
		supercast-expression-type-must-not-be-top-or-bottom code,
		supercast-expression-must-not-also-be-a-supercast code,
		supercast-must-be-strict-supertype-of-expression-type code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : super cast phrase;

/**
 * Answer a {@type "token"} with the specified {@param "classifier"}, {@param
 * "lexeme"}, {@param "start" one-based source position}, and {@param "line"
 * one-based source line number}.
 *
 * @category "Primitives" "Tokens" "Constructors"
 * @method "_(_)@_:_"
 * @param "classifier" "{whitespace, comment, operator, keyword, end of file}ᵀ"
 *        A {@type "atom" classifier} that specifies the lexical role of the
 *        {@type "token"}.
 * @param "lexeme" "string"
 *        The source text of the {@type "token"}.
 * @param "start" "[0..∞)"
 *        The one-based character position within the Avail source module, or
 *        {@code "0"} if the character position is unknown or meaningless.
 * @param "line" "[0..∞)"
 *        The one-based line number within the Avail source module, or {@code
 *        "0"} if the line number is unknown or meaningless.
 * @returns "token"
 *          The requested {@type "token"}.
 * @raises "exceeds-VM-limit exception"
 *         If a numeric parameter is outside the range supported by the VM.
 */
Primitive "_(_)@_:_" is
[
	classifier : token classifiers,
	lexeme : string,
	start : whole number,
	line : whole number
|
	Primitive CreateToken (failureCode : {
		exceeds-VM-limit code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : token;

/**
 * Answer this declaration's initializing expression, or fail if it does not
 * have one.  Its presence can be checked with {@code
 * "_has initializing expression"}.
 *
 * @category "Primitives"
 * @method "_'s⁇initializing expression"
 * @param "decl" "declaration phrase⇒⊤"
 *        The declaration.
 * @returns "expression phrase⇒any"
 *    The declaration's initializing expression.
 * @raises "declaration-does-not-have-initializer exception"
 *    If the declaration does not have an initializing expression.
 */
Primitive "_'s⁇initializing expression" is
[
	decl : declaration phrase
|
	Primitive DeclarationInitializingExpression (failureCode : {
		declaration-does-not-have-initializer code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : expression yielding any;

/**
 * Look up the macro under the given atom, using the provided phrases to
 * choose the most specific one.
 *
 * @category "Primitives"
 * @method "lookup macro_with phrases_"
 * @param "macro" "atom"
 *        The atom naming the macro.
 * @param "phrases" "<phrase⇒⊤…|>"
 *        The tuple of phrases to use as arguments for the lookup.
 * @returns "[…]→phrase⇒⊤"
 *    The body function of the looked up macro.
 * @raises "incorrect-number-of-arguments exception"
 * @raises "no-method-definition exception"
 * @raises "ambiguous-method-definition exception"
 */
Primitive "lookup macro_with phrases_" is
[
	macro : atom,
	phrases : phrase tuple
|
	Primitive LookupMacro (failureCode : {
		incorrect-number-of-arguments code,
		no-method-definition code,
		ambiguous-method-definition code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : macro function;

/**
 * Construct and answer a variable that, when read or written, will pass
 * through to the instance field uniquely specified by the given pojo and field
 * name.
 *
 * @category "Primitives" "Variables" "POJO" "Constructors"
 * @method "_'s⁇_field"
 * @param "aPojo" "java.lang.Object"
 *        The pojo whose instance field should be bound to the answered
 *        variable.
 * @param "fieldName" "string"
 *        The name of the desired field.
 * @returns "read ⊤/write ⊥"
 *    A variable bound to the specified instance field.
 * @raises "Java-field-not-available exception"
 */
Primitive "_'s⁇_field" is
[
	aPojo : pojo,
	fieldName : string
|
	Primitive BindPojoInstanceField (failureCode : {
		Java-field-not-available code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : write-only variable;

/**
 * Construct and answer a variable that, when read or written, will pass
 * through to the static field specified by the given pojo type and field
 * name.
 *
 * @category "Primitives" "Variables" "POJO" "Constructors"
 * @method "_'s⁇_field"
 * @param "aPojoType" "(any)'s type"
 *        A pojo type whose static field should be bound to the answered
 *        variable.
 * @param "fieldName" "string"
 *        The name of the desired field.
 * @returns "read ⊤/write ⊥"
 *    A variable bound to the specified static field.
 * @raises "Java-field-not-available exception"
 * @raises "Java-field-reference-is-ambiguous exception"
 */
Primitive "_'s⁇_field" is
[
	aPojoType : any meta,
	fieldName : string
|
	Primitive BindPojoStaticField (failureCode : {
		Java-field-not-available code,
		Java-field-reference-is-ambiguous code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : write-only variable;

/**
 * Construct and answer a function that, when applied with arguments
 * corresponding to the specified parameter types, constructs a new pojo of
 * the specified type.
 *
 * The answered function adapts a reflective invocation of the Java constructor,
 * if any, that accepts the specified number and types of arguments. To
 * establish type conformance between Avail types and Java types for the purpose
 * of reflective constructor lookup and invocation, the following marshaling
 * rules are applied:
 *
 * <ul>
 * <li>{@type "Java byte"} is marshaled to {@code "java.lang.Byte.TYPE"}.</li>
 * <li>{@type "Java short"} is marshaled to {@code "java.lang.Short.TYPE"}.</li>
 * <li>{@type "Java int"} is marshaled to {@code "java.lang.Integer.TYPE"}.</li>
 * <li>{@type "Java long"} is marshaled to {@code "java.lang.Long.TYPE"}.</li>
 * <li>{@type "boolean"} is marshaled to {@code "java.lang.Boolean.TYPE"}.</li>
 * <li>{@type "Java char"} is marshaled to {@code "java.lang.Character.TYPE"}.</li>
 * <li>{@type "float"} is marshaled to {@code "java.lang.Float.TYPE"}.</li>
 * <li>{@type "double"} is marshaled to {@code "java.lang.Double.TYPE"}.</li>
 * <li>{@type "string"} is marshaled to {@code "java.lang.String"}.</li>
 * <li>{@method "_[_]"} is marshaled to {@code
 *     "java.lang.reflect.Array.newInstance().getClass()"}.</li>
 * <li>{@method "_parameterized by_"} is marshaled to the reflected Java class
 *     or interface.</li>
 * <li>All other values are marshaled to
 *     {@code "avail.descriptor.representation.AvailObject"}.</li>
 * </ul>
 *
 * @category "Primitives" "Functions" "POJO" "Constructors"
 * @method "constructor of_,⁇parameterized by_"
 * @param "aPojoType" "(any)'s type"
 *        A pojo type.
 * @param "parameterTypes" "<(any)'s type…|>"
 *        The parameter types accepted by the desired constructor.
 * @returns "[…]→any"
 *    The requested constructor invocation function.
 * @raises "pojo-type-is-abstract exception"
 * @raises "Java-method-not-available exception"
 * @raises "Java-marshaling-failed exception"
 */
Primitive "constructor of_,⁇parameterized by_" is
[
	aPojoType : any meta,
	parameterTypes : tuple of any meta
|
	Primitive CreatePojoConstructorFunction (failureCode : {
		pojo-type-is-abstract code,
		Java-method-not-available code,
		Java-marshaling-failed code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : function returning any;

/**
 * Construct and answer a function that, when applied with arguments
 * corresponding to the specified parameter types, invokes a particular
 * instance method.
 *
 * The answered function adapts a reflective invocation of the Java method,
 * if any, that has the specified name and accepts the specified number and
 * types of arguments. The receiver is specified as the first argument. To
 * establish type conformance between Avail types and Java types for the purpose
 * of reflective method lookup and invocation, the following marshaling rules
 * are applied:
 *
 * <ul>
 * <li>{@type "Java byte"} is marshaled to {@code "java.lang.Byte.TYPE"}.</li>
 * <li>{@type "Java short"} is marshaled to {@code "java.lang.Short.TYPE"}.</li>
 * <li>{@type "Java int"} is marshaled to {@code "java.lang.Integer.TYPE"}.</li>
 * <li>{@type "Java long"} is marshaled to {@code "java.lang.Long.TYPE"}.</li>
 * <li>{@type "boolean"} is marshaled to {@code "java.lang.Boolean.TYPE"}.</li>
 * <li>{@type "Java char"} is marshaled to {@code "java.lang.Character.TYPE"}.</li>
 * <li>{@type "float"} is marshaled to {@code "java.lang.Float.TYPE"}.</li>
 * <li>{@type "double"} is marshaled to {@code "java.lang.Double.TYPE"}.</li>
 * <li>{@type "string"} is marshaled to {@code "java.lang.String"}.</li>
 * <li>{@method "_[_]"} is marshaled to {@code
 *     "java.lang.reflect.Array.newInstance().getClass()"}.</li>
 * <li>{@method "_parameterized by_"} is marshaled to the reflected Java class
 *     or interface.</li>
 * <li>All other values are marshaled to
 *     {@code "avail.descriptor.representation.AvailObject"}.</li>
 * </ul>
 *
 * @category "Primitives" "Functions" "POJO" "Constructors"
 * @method "method_._,⁇parameterized by_"
 * @param "aPojoType" "(any)'s type"
 *        A pojo type.
 * @param "methodName" "string"
 *        The name of the desired method.
 * @param "parameterTypes" "<(any)'s type…|>"
 *        The parameter types accepted by the desired method.
 * @returns "[…]→⊤"
 *    The requested instance method invocation function.
 * @raises "Java-method-not-available exception"
 * @raises "Java-method-reference-is-ambiguous exception"
 */
Primitive "method_._,⁇parameterized by_" is
[
	aPojoType : any meta,
	methodName : string,
	parameterTypes : tuple of any meta
|
	Primitive CreatePojoInstanceMethodFunction (failureCode : {
		Java-method-not-available code,
		Java-method-reference-is-ambiguous code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : function;

/**
 * Construct and answer a function that, when applied with arguments
 * corresponding to the specified parameter types, invokes a particular
 * static method.
 *
 * The answered function adapts a reflective invocation of the Java method,
 * if any, that has the specified name and accepts the specified number and
 * types of arguments. To establish type conformance between Avail types and
 * Java types for the purpose of reflective method lookup and invocation, the
 * following marshaling rules are applied:
 *
 * <ul>
 * <li>{@type "Java byte"} is marshaled to {@code "java.lang.Byte.TYPE"}.</li>
 * <li>{@type "Java short"} is marshaled to {@code "java.lang.Short.TYPE"}.</li>
 * <li>{@type "Java int"} is marshaled to {@code "java.lang.Integer.TYPE"}.</li>
 * <li>{@type "Java long"} is marshaled to {@code "java.lang.Long.TYPE"}.</li>
 * <li>{@type "boolean"} is marshaled to {@code "java.lang.Boolean.TYPE"}.</li>
 * <li>{@type "Java char"} is marshaled to {@code "java.lang.Character.TYPE"}.</li>
 * <li>{@type "float"} is marshaled to {@code "java.lang.Float.TYPE"}.</li>
 * <li>{@type "double"} is marshaled to {@code "java.lang.Double.TYPE"}.</li>
 * <li>{@type "string"} is marshaled to {@code "java.lang.String"}.</li>
 * <li>{@method "_[_]"} is marshaled to {@code
 *     "java.lang.reflect.Array.newInstance().getClass()"}.</li>
 * <li>{@method "_parameterized by_"} is marshaled to the reflected Java class
 *     or interface.</li>
 * <li>All other values are marshaled to
 *     {@code "avail.descriptor.representation.AvailObject"}.</li>
 * </ul>
 *
 * @category "Primitives" "Functions" "POJO" "Constructors"
 * @method "static method_._,⁇parameterized by_"
 * @param "aPojoType" "(any)'s type"
 *        A pojo type.
 * @param "methodName" "string"
 *        The name of the desired method.
 * @param "parameterTypes" "<(any)'s type…|>"
 *        The parameter types accepted by the desired method.
 * @returns "[…]→⊤"
 *    The requested static method invocation function.
 * @raises "Java-method-not-available exception"
 * @raises "Java-method-reference-is-ambiguous exception"
 */
Primitive "static method_._,⁇parameterized by_" is
[
	aPojoType : any meta,
	methodName : string,
	parameterTypes : tuple of any meta
|
	Primitive CreatePojoStaticMethodFunction (failureCode : {
		Java-method-not-available code,
		Java-method-reference-is-ambiguous code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : function;

/**
 * Construct and answer a fully parameterized pojo type.
 *
 * @category "Primitives" "Types" "POJO" "Constructors"
 * @method "_parameterized by_"
 * @param "javaName" "string"
 *        The fully qualified name of the Java class or interface.
 * @param "typeParameters" "<(any)'s type…|>"
 *        The type arguments. The cardinality of this tuple must agree with the
 *        number of type parameters required by the Java class or interface.
 * @returns "(any)'s type"
 *    The requested pojo type.
 * @raises "incorrect-number-of-arguments exception"
 * @raises "Java-class-not-available exception"
 */
Primitive "_parameterized by_" is
[
	javaName : string,
	typeParameters : tuple of any meta
|
	Primitive CreatePojoType (failureCode : {
		incorrect-number-of-arguments code,
		Java-class-not-available code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : any meta;

/**
 * Answer the {@param "index"}-th element of the specified pojo array.
 *
 * @category "Primitives" "POJO" "Queries"
 * @method "_[_]"
 * @param "anArray" "any[]"
 *        A pojo array.
 * @param "index" "[1..∞)"
 *        A one-based index into the pojo array.
 * @returns "any"
 *    The {@param "index"}-th element of {@param "anArray"}.
 * @raises "subscript-out-of-bounds exception"
 * @raises "Java-marshaling-failed exception"
 */
Primitive "_[_]" is
[
	anArray : pojo array,
	index : natural number
|
	Primitive PojoArrayGet (failureCode : {
		subscript-out-of-bounds code,
		Java-marshaling-failed code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : any;

/**
 * Mutate the specified pojo array such that its {@param "index"}-th element is
 * overwritten by {@param "value"}.
 *
 * @category "Primitives" "POJO" "Mutators"
 * @method "_[_]:=_"
 * @param "anArray" "any[]"
 *        A pojo array.
 * @param "index" "[1..∞)"
 *        A one-based index into the pojo array.
 * @param "value" "any"
 *        The value that should be written into the pojo array.
 * @returns "⊤"
 * @raises "cannot-store-incorrectly-typed-value exception"
 * @raises "subscript-out-of-bounds exception"
 * @raises "Java-marshaling-failed exception"
 */
Primitive "_[_]:=_" is
[
	anArray : pojo array,
	index : natural number,
	value : any
|
	Primitive PojoArraySet (failureCode : {
		cannot-store-incorrectly-typed-value code,
		subscript-out-of-bounds code,
		Java-marshaling-failed code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Associate a styler function with this atom's bundle's method. The styling
 * mechanism is applied to each top-level phrase of a module to style its
 * tokens. Of the stylers from visible modules, choose the styler of the most
 * specific module.
 *
 * If there is no most specific module, a special conflict style will be
 * produced instead, to indicate this conflict.
 *
 * @category "Primitives"
 * @method "Style_with_"
 * @param "anAtom" "atom"
 *        The bundle for which invocations should be styled.
 * @param "aFunction" "[send phrase⇒⊤, phrase⇒⊤]→⊤"
 *        The function that applies the styling.
 * @returns "⊤"
 * @raises "incorrect-argument-type exception"
 * @raises "styler-already-set-by-this-module exception"
 * @raises "incorrect-type-for-group exception"
 * @raises "exclamation-mark-must-follow-an-alternation-group exception"
 * @raises "incorrect-type-for-complex-group exception"
 * @raises "incorrect-use-of-double-dagger exception"
 * @raises "unbalanced-guillemets exception"
 * @raises "method-name-is-not-canonical exception"
 * @raises "expected-operator-after-backquote exception"
 * @raises "incorrect-type-for-boolean-group exception"
 * @raises "incorrect-type-for-counting-group exception"
 * @raises "octothorp-must-follow-a-simple-group-or-ellipsis exception"
 * @raises "question-mark-must-follow-a-simple-group exception"
 * @raises "case-insensitive-expression-canonization exception"
 * @raises "double-question-mark-must-follow-a-token-or-simple-group exception"
 * @raises "alternative-must-not-contain-arguments exception"
 * @raises "vertical-bar-must-separate-tokens-or-simple-groups exception"
 * @raises "incorrect-type-for-numbered-choice exception"
 * @raises "cannot-define-during-compilation exception"
 * @raises "loading-is-over exception"
 * @raises "up-arrow-must-follow-argument exception"
 * @raises "inconsistent-argument-reordering exception"
 */
Primitive "Style_with_" is
[
	anAtom : atom,
	aFunction : styler function
|
	Primitive SetStylerFunction (failureCode : {
		incorrect-argument-type code,
		styler-already-set-by-this-module code,
		incorrect-type-for-group code,
		exclamation-mark-must-follow-an-alternation-group code,
		incorrect-type-for-complex-group code,
		incorrect-use-of-double-dagger code,
		unbalanced-guillemets code,
		method-name-is-not-canonical code,
		expected-operator-after-backquote code,
		incorrect-type-for-boolean-group code,
		incorrect-type-for-counting-group code,
		octothorp-must-follow-a-simple-group-or-ellipsis code,
		question-mark-must-follow-a-simple-group code,
		case-insensitive-expression-canonization code,
		double-question-mark-must-follow-a-token-or-simple-group code,
		alternative-must-not-contain-arguments code,
		vertical-bar-must-separate-tokens-or-simple-groups code,
		incorrect-type-for-numbered-choice code,
		cannot-define-during-compilation code,
		loading-is-over code,
		up-arrow-must-follow-argument code,
		inconsistent-argument-reordering code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Apply the bootstrap method name styler to the specified method name. Awards
 * a distinct style to literal character data ({@code "#string-literal"}),
 * character escapes and literal delimiters
 * ({@code "#string-escape-sequence"}), and method name metacharacters
 * ({@code "#method-name"}).
 *
 * @category "Primitives"
 * @method "Style method name_"
 * @param "methodName" "literal phrase⇒literal token⇒string"
 *    The string literal phrase to style as a method name.
 * @returns "⊤"
 * @raises "cannot-define-during-compilation exception"
 * @raises "loading-is-over exception"
 */
Primitive "Style method name_" is
[
	methodName : string literal phrase
|
	Primitive StyleMethodName (failureCode : {
		cannot-define-during-compilation code,
		loading-is-over code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Apply the given style to the contiguous span of source bounded by all tokens
 * within the given phrase and its constituents.
 *
 * @category "Primitives"
 * @method "Style span of_with_«overwriting»?"
 * @param "phrase" "phrase⇒⊤"
 *        The phrase to style.
 * @param "styleName" "string"
 *        The name of the style to apply.
 * @param "overwriting" "boolean"
 *        Whether to overwrite existing styles in this span.
 * @returns "⊤"
 * @raises "cannot-define-during-compilation exception"
 * @raises "loading-is-over exception"
 */
Primitive "Style span of_with_«overwriting»?" is
[
	phrase : phrase,
	styleName : string,
	overwriting : boolean
|
	Primitive StyleSpanOfPhrase (failureCode : {
		cannot-define-during-compilation code,
		loading-is-over code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Apply the bootstrap string literal styler to the specified string literal.
 * Awards a distinct style to literal character data
 * ({@code "#string-literal"}) and character escapes and literal delimiters
 * ({@code "#string-escape-sequence"}).
 *
 * @category "Primitives"
 * @method "Style string literal_"
 * @param "stringLiteral" "literal phrase⇒literal token⇒string"
 *    The string literal phrase to style.
 * @returns "⊤"
 * @raises "cannot-define-during-compilation exception"
 * @raises "loading-is-over exception"
 */
Primitive "Style string literal_" is
[
	stringLiteral : string literal phrase
|
	Primitive StyleStringLiteral (failureCode : {
		cannot-define-during-compilation code,
		loading-is-over code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Apply the given style name to the region of the current module covered by the
 * given token.  If `overwriting` is true, replace the style entirely for that
 * region, otherwise merge the style with the existing styles in that region.
 *
 * @category "Primitives"
 * @method "Style token_as_«overwriting»?"
 * @param "token" "token"
 *        The token to style.
 * @param "styleName" "string"
 *        The name of the style to apply.
 * @param "overwriting" "boolean"
 *        `true` to completely overwrite the style, `false` to merge them.
 * @returns "⊤"
 * @raises "cannot-define-during-compilation exception"
 * @raises "loading-is-over exception"
 */
Primitive "Style token_as_«overwriting»?" is
[
	token : token,
	styleName : string,
	overwriting : boolean
|
	Primitive StyleToken (failureCode : {
		cannot-define-during-compilation code,
		loading-is-over code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Construct and answer a slice (i.e. subtuple) of the specified tuple.
 *
 * @category "Primitives" "Tuples" "Transformers" "Queries"
 * @method "_[_.._]"
 * @param "aTuple" "tuple"
 *        A tuple.
 * @param "sliceStart" "[1..∞)"
 *        The one-based start index (inclusive) of the desired slice.
 * @param "sliceEnd" "[0..∞)"
 *        The one-based end index (inclusive) of the desired slice.
 * @returns "tuple"
 *    The requested tuple.
 * @raises "subscript-out-of-bounds exception"
 */
Primitive "_[_.._]" is
[
	aTuple : tuple,
	sliceStart : natural number,
	sliceEnd : whole number
|
	Primitive ExtractSubtuple (failureCode : {
		subscript-out-of-bounds code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : tuple;

/**
 * Construct and answer an integer interval tuple.
 *
 * @category "Primitives" "Tuples" "Constructors"
 * @method "_to_by_"
 * @param "start" "(-∞..∞)"
 *        The first value in the tuple.
 * @param "end" "(-∞..∞)"
 *        The last allowed value in the tuple. This value will only be the
 *        last value in the tuple if the difference between the first and last
 *        values is a multiple of the step size.
 * @param "delta" "(-∞..∞)"
 *        The step size of the interval, which must not be zero.
 * @returns "<(-∞..∞)…|>"
 *    The requested tuple.
 * @raises "incorrect-argument-type exception"
 *    If {@param "delta"} is zero.
 */
Primitive "_to_by_" is
[
	start : integer,
	end : integer,
	delta : integer
|
	Primitive IntegerIntervalTuple (failureCode : {
		incorrect-argument-type code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : tuple of integer;

/**
 * Construct and answer a tuple whose elements are each {@param "value"}.
 *
 * @category "Primitives" "Tuples" "Constructors"
 * @method "_occurrences⁇of_"
 * @param "count" "[0..∞)"
 *        The number of elements in the resulting tuple.
 * @param "value" "any"
 *        The repeated value.
 * @returns "tuple"
 *    A tuple containing {@param "count"} occurrences of {@param "value"}.
 * @raises "exceeds-VM-limit exception"
 */
Primitive "_occurrences⁇of_" is
[
	count : whole number,
	value : any
|
	Primitive RepeatedElementTuple (failureCode : {
		exceeds-VM-limit code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : tuple;

/**
 * Answer the {@param "index"}-th element of {@param "aTuple"}.
 *
 * @category "Primitives" "Tuples" "Queries"
 * @method "_[_]"
 * @param "aTuple" "tuple"
 *        A tuple.
 * @param "index" "[1..∞)"
 *        The one-based index of the desired element.
 * @returns "any"
 *    The requested element.
 * @raises "subscript-out-of-bounds exception"
 */
Primitive "_[_]" is
[
	aTuple : tuple,
	index : natural number
|
	Primitive TupleAt (failureCode : {
		subscript-out-of-bounds code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : any;

/**
 * Construct and answer a tuple based on the one provided but such that its
 * {@param "index"}-th element is {@param "value"}.
 *
 * @category "Primitives" "Tuples" "Transformers"
 * @method "_[_]→_"
 * @param "aTuple" "tuple"
 *        A tuple.
 * @param "index" "[1..∞)"
 *        The one-based index of the element that should (potentially) differ
 *        in the resultant tuple.
 * @param "value" "any"
 *        The "replacement" value.
 * @returns "tuple"
 *    The requested tuple.
 * @raises "subscript-out-of-bounds exception"
 */
Primitive "_[_]→_" is
[
	aTuple : tuple,
	index : natural number,
	value : any
|
	Primitive TupleReplaceAt (failureCode : {
		subscript-out-of-bounds code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : tuple;

/**
 * Replace the value with a new value in the tuple at the location indicated
 * by the path tuple. If the replacement value type differs from the type of
 * the value at the replacement location, the answered tuple will have a
 * different type than the original source tuple.
 *
 * @category "Primitives" "Tuples" "Maps" "Transformers"
 * @method "_«[_]»→_"
 * @param "aTuple" "tuple"
 *        The target tuple.
 * @param "pathTuple" "<any…|2..∞>"
 *        The tuple providing the path to follow to reach the location
 *        to be updated.
 * @param "newValue" "any"
 *        The replacement value.
 * @returns "tuple"
 *    A new tuple with the new value installed at the proposed location.
 * @raises "subscript-out-of-bounds exception"
 *    If an index in the pathTuple attempts to access an index that is greater
 *    than the size of the targeted tuple within aTuple.
 * @raises "incorrect-argument-type exception"
 *    If an index in the pathTuple, that is not the final index where the
 *    replacement is made, attempts to access a value as if it were a
 *    map or a tuple but the value at that location is neither.
 * @raises "key-not-found exception"
 *    If an index in the pathTuple attempts to access a map in aTuple with a key
 *    not in the map.
 */
Primitive "_«[_]»→_" is
[
	aTuple : tuple,
	pathTuple : two or more tuple,
	newValue : any
|
	Primitive TupleReplaceAtNAry (failureCode : {
		subscript-out-of-bounds code,
		incorrect-argument-type code,
		key-not-found code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : tuple;

/**
 * Given a tuple and range of indices, produce a new tuple that has that range
 * replaced by the given replacement tuple.  The replacement does not need to be
 * the same size as the range.
 *
 * @category "Primitives"
 * @method "_[_.._]→_"
 * @param "aTuple" "tuple"
 *        The basis tuple.
 * @param "startIndex" "[1..∞)"
 *        The inclusive start of the range to replace.  This may be as high as
 *        the tuple's size plus one, to indicate the replacement should be
 *        appended.
 * @param "endIndex" "[0..∞)"
 *        The inclusive end of the range to replace.  This may be as low as one
 *        less than the start.
 * @param "replacementSubtuple" "tuple"
 *        The replacement subtuple.
 * @returns "tuple"
 *    A tuple consisting of the first {@param "startIndex"} - 1 elements of
 *    {@param "aTuple"}, followed by the elements of
 *    {@param "replacementSubtuple"}, followed by the elements of
 *    {@param "aTuple"} starting at {@param "endIndex"} + 1,
 * @raises "subscript-out-of-bounds exception"
 * @raises "negative-size exception"
 */
Primitive "_[_.._]→_" is
[
	aTuple : tuple,
	startIndex : natural number,
	endIndex : whole number,
	replacementSubtuple : tuple
|
	Primitive TupleReplaceRange (failureCode : {
		subscript-out-of-bounds code,
		negative-size code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : tuple;

/**
 * Given a multi-level data structure where the outermost layer is a tuple, the
 * intervening layers are maps or tuples, and the innermost target reached by
 * the provided path is a tuple, answer a variant of the data structure such
 * that the indicated slice of the innermost target has been replaced with the
 * provided tuple. The replacement tuple can differ in size from the slice.
 *
 * @category "Primitives" "Tuples" "Maps" "Transformers"
 * @method "_«[_]»[_.._]→_"
 * @param "aTuple" "tuple"
 *        The target tuple.
 * @param "pathTuple" "<any…|1..∞>"
 *        The tuple providing the path to follow to reach the location
 *        to be updated.
 * @param "sliceStartIndex" "[1..∞)"
 *        The start index of the tuple slice to be replaced.
 * @param "sliceEndIndex" "[0..∞)"
 *        The end index of the tuple slice to be replaced.
 * @param "newValues" "tuple"
 *        The tuple containing the replacement values.
 * @returns "tuple"
 *    a new tuple with the new values installed at the proposed locations.
 * @raises "subscript-out-of-bounds exception"
 * @raises "incorrect-argument-type exception"
 * @raises "key-not-found exception"
 * @raises "negative-size exception"
 */
Primitive "_«[_]»[_.._]→_" is
[
	aTuple : tuple,
	pathTuple : nonempty tuple,
	sliceStartIndex : natural number,
	sliceEndIndex : whole number,
	newValues : tuple
|
	Primitive TupleReplaceRangeAtNary (failureCode : {
		subscript-out-of-bounds code,
		incorrect-argument-type code,
		key-not-found code,
		negative-size code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : tuple;

/**
 * Produce a tuple like the given tuple, but with the elements at the given
 * indices interchanged.
 *
 * @category "Primitives"
 * @method "_[_↔_]"
 * @param "aTuple" "tuple"
 *        The initial tuple.
 * @param "index1" "[1..∞)"
 *        An index into the tuple.
 * @param "index2" "[1..∞)"
 *        Another index into the tuple.
 * @returns "tuple"
 *    A tuple like the input, but with the specified indices swapped.
 * @raises "subscript-out-of-bounds exception"
 */
Primitive "_[_↔_]" is
[
	aTuple : tuple,
	index1 : natural number,
	index2 : natural number
|
	Primitive TupleSwapElements (failureCode : {
		subscript-out-of-bounds code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : tuple;

/**
 * Compute and answer a tuple containing the requested element types. Indices
 * that are out of bounds report {@type "⊥"} as their element type.
 *
 * @category "Primitives" "Types" "Tuples" "Queries"
 * @method "_[_.._]"
 * @param "aTupleType" "(tuple)'s type"
 *        A tuple type.
 * @param "sliceStart" "[1..∞)"
 *        The one-based index (inclusive) of the start of the slice.
 * @param "sliceEnd" "[0..∞)"
 *        The one-based index (inclusive) of the end of the slice.
 * @returns "<(any)'s type…|>"
 *    The requested slice of element types.
 * @raises "subscript-out-of-bounds exception"
 * @raises "negative-size exception"
 */
Primitive "_[_.._]" is
[
	aTupleType : tuple meta,
	sliceStart : natural number,
	sliceEnd : whole number
|
	Primitive TupleTypeSequenceOfTypes (failureCode : {
		subscript-out-of-bounds code,
		negative-size code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : tuple of any meta;

/**
 * Answer the instances of the enumeration.
 *
 * @category "Primitives" "Types" "Queries"
 * @method "_'s⁇instances"
 * @param "enum" "(⊤)'s type"
 *        An enumeration.
 * @returns "set"
 *    A set whose members are the instances of the enumeration.
 * @raises "not-an-enumeration exception"
 */
Primitive "_'s⁇instances" is
[
	enum : type
|
	Primitive Instances (failureCode : {
		not-an-enumeration code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : set;

/**
 * Atomically add or replace a key → value binding of the map within a variable.
 *
 * @category "Primitives"
 * @method "_[_]:=_"
 * @param "var" "read map/write ⊥"
 *        The variable containing a map.
 * @param "key" "any"
 *        The key to add or overwrite.
 * @param "value" "any"
 *        The value to store at that key.
 * @returns "⊤"
 *    Nothing.
 * @raises "cannot-read-unassigned-variable exception"
 * @raises "cannot-store-incorrectly-typed-value exception"
 */
Primitive "_[_]:=_" is
[
	var : map variable,
	key : any,
	value : any
|
	Primitive AtomicAddToMap (failureCode : {
		cannot-read-unassigned-variable code,
		cannot-store-incorrectly-typed-value code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Atomically remove a key from the map within a variable.
 *
 * @category "Primitives"
 * @method "_-=_"
 * @param "var" "read map/write ⊥"
 *        The variable containing a map.
 * @param "key" "any"
 *        The key to remove.
 * @returns "⊤"
 *    Nothing.
 * @raises "cannot-read-unassigned-variable exception"
 * @raises "cannot-store-incorrectly-typed-value exception"
 */
Primitive "_-=_" is
[
	var : map variable,
	key : any
|
	Primitive AtomicRemoveFromMap (failureCode : {
		cannot-read-unassigned-variable code,
		cannot-store-incorrectly-typed-value code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : ⊤;

/**
 * Construct and answer a new variable with the specified containment type,
 * after initializing it to the given value.
 *
 * @category "Primitives" "Variables" "Constructors"
 * @method "new`↑_initialized to_"
 * @param "containmentType" "(any)'s type"
 *        The containment type.
 * @param "initialValue" "any"
 *        The initial value to write into the new variable.
 * @returns "read ⊤/write ⊥"
 *    A new variable capable of retrieving and storing values of the specified
 *    containment type.
 * @raises "cannot-store-incorrectly-typed-value exception"
 */
Primitive "new`↑_initialized to_" is
[
	containmentType : any meta,
	initialValue : any
|
	Primitive CreateInitializedVariable (failureCode : {
		cannot-store-incorrectly-typed-value code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : write-only variable;

/**
 * Answer the value contained within the specified variable.
 *
 * @category "Primitives" "Variables" "Queries"
 * @method "↓_"
 * @param "var" "read ⊤/write ⊥"
 *        A variable.
 * @returns "any"
 *    The value contained within the specified variable.
 * @raises "cannot-read-unassigned-variable exception"
 * @raises "Java-marshaling-failed exception"
 */
Primitive "↓_" is
[
	var : write-only variable
|
	Primitive GetValue (failureCode : {
		cannot-read-unassigned-variable code,
		Java-marshaling-failed code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : any;

/**
 * Answer whether the given key is present in the map in the given variable.
 *
 * @category "Primitives"
 * @method "_∈_"
 * @param "key" "any"
 *        The key to search for.
 * @param "mapVariable" "read map/write ⊥"
 *        The variable holding a map whose keys are to be searched.
 * @returns "boolean"
 *    Whether the key is present in the variable's map.
 * @raises "cannot-read-unassigned-variable exception"
 */
Primitive "_∈_" is
[
	key : any,
	mapVariable : map variable
|
	Primitive KeyInVariableMap (failureCode : {
		cannot-read-unassigned-variable code}ᵀ);
	Private invoke _fail_primitive with failureCode
] : boolean;

