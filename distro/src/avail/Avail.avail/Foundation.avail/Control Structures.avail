/*
 * Control Structures.avail
 * Copyright © 1993-2019, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Control Structures"
Versions
	"1.4.0"
Extends
	"Early Control Structures" =
	(
		"Cast|cast_into_",
		"Ignore:_",
		"(_)",
		"((_))"
	)
Uses
	"Bootstrap",
	"Definers",
	"Early Assertions",
	"Early Conditionals",
	"Early Functions",
	"Early Maps",
	"Early Tuples",
	"Early Sets",
	"Enumeration Support",
	"Literals",
	"Logic",
	"Macro Support",
	"Math",
	"Types",
	"Variables"
Names
	"Cast|cast_into«_‡,»«else_»",
	"Choose|choose_from_where«_is_‡,»«,else_»",
	"Do_until_",
	"Do_until_alternate with_",
	"Do_while_",
	"Do_while_alternate with_",
	"Exit_",
	"Exit_if_",
	"For each…from_to_§do_",
	"For each…from_to_by_§do_",
	"From_to_by_do_",
	"From_to_do_",
	"here",
	"If|if_then_«else if_then_»«else_»?",
	"Repeat_",
	"Repeat__times",
	"Unless|unless_then_«else unless_then_»«else_»?",
	"Until_",
	"Until_do_",
	"Until_do_alternate with_",
	"While_",
	"While_do_",
	"While_do_alternate with_",

	/* Support methods for semantic restrictions, exported for use by other
	 * library- and user-defined control structures.
	 */
	"Require:_accepts subscripts from_to_by_",
	"Require:_'s⁇keeper is valid"
Body

Method "<«_‡,»`…`|_.._>" is stable at
	[<any meta…|1..>, whole number, [0..∞]]→tuple meta;
Method "<«_‡,»`…`|_..>" is stable at [<any meta…|1..>, whole number]→tuple meta;
Method "<«_‡,»`…`|.._>" is stable at [<any meta…|1..>, [0..∞]]→tuple meta;
Method "<«_‡,»`…`|_>" is stable at [<any meta…|1..>, whole number]→tuple meta;
Method "<«_‡,»`…`|>" is stable at [<any meta…|1..>]→tuple meta;
Method "_*" is stable at [any meta]→tuple meta;
Method "_+" is stable at [any meta]→tuple meta;
Method "_`?" is stable at [any meta]→tuple meta;

/*
 * Helper methods for building macro, "If|if_then_«else if_then_»«else_»?"
 */
Private method "block from_" is
[
	sendPhrase : send phrase ⇒ ⊤
|
	returnType ::= sendPhrase's return type;
	cast «[<sendPhrase>]:returnType» into [b: block phrase ⇒ []→⊤| b]
] : expression phrase ⇒ []→⊤;

Private method "basic send phrase_conditional_then_else_" is
[
	anAtom : atom,
	predicatePhrase : expression phrase ⇒ boolean,
	thenBlock : expression phrase ⇒ []→⊤,
	elseBlock : expression phrase ⇒ []→⊤
|
	elseBlockReturnType ::= elseBlock's semantic type;
	thenBlockReturnType ::= thenBlock's semantic type;
	boolType ::= predicatePhrase's semantic type;
	returnType ::= strengthen ⊤ for call of anAtom
		using <boolType, thenBlockReturnType, elseBlockReturnType>;
	restricted send anAtom with
		«<predicatePhrase, thenBlock, elseBlock>» : returnType
] : send phrase ⇒ ⊤;

/*
 * Recursive method to build up nested blocks for a chained conditional
 * macro
 */
Private abstract method "for_nest_in_" is
[
	atom, expression phrase ⇒ []→⊤, <list phrase ⇒ <boolean, []→⊤…|2>…|1..>
]→(expression phrase ⇒ []→⊤);

Method "for_nest_in_" is
[
	anAtom : atom,
	elseBlock : expression phrase ⇒ []→⊤,
	elseConditionalPairTuple : <list phrase ⇒ <boolean, []→⊤…|2>…|1>
|
	elseConditionalPair ::= elseConditionalPairTuple[1]'s expressions;
	predicate ::= elseConditionalPair[1];
	thenBlock ::= elseConditionalPair[2];
	block from basic send phrase anAtom conditional predicate then
		thenBlock else elseBlock
] : expression phrase ⇒ []→⊤;

Method "for_nest_in_" is
[
	anAtom : atom,
	elseBlock : expression phrase ⇒ []→⊤,
	elseConditionalPairTuple : <list phrase ⇒ <boolean, []→⊤…|2>…|2..>
|
	size ::= |elseConditionalPairTuple|;
	end ::= size - 1;
	newElseBlock ::= for anAtom nest elseBlock in
		<elseConditionalPairTuple[size]>;
	for anAtom nest newElseBlock in elseConditionalPairTuple[1..end]
] : expression phrase ⇒ []→⊤;

/**
 * Multiply branching conditional statement/expression. Execute the first
 * action for which the associated predicate answers {@method "true"}. If none
 * of the predicates answer {@method "true"}, then execute the "else" action. If
 * no "else" action is provided, then do not execute any of the action blocks.
 *
 * @method "If|if_then_«else if_then_»«else_»?"
 * @param "firstPredicate" "expression phrase ⇒ boolean"
 *        The first predicate to check.
 * @param "firstThen" "expression phrase ⇒ []→⊤"
 *        The action to perform if {@param "firstPredicate"} is {@method
 *        "true"}.
 * @param "elseIfTuple" "list phrase ⇒ (<boolean, []→⊤…|2>+)"
 *        A lexically constructed tuple of 2-tuples. Each 2-tuple has as its
 *        first element a predicate and as its second element an action
 *        to perform if the predicate answers {@method "true"}.
 * @param "else" "list phrase ⇒ (([]→⊤)?)"
 *        A lexically constructed tuple that optionally contains the action to
 *        perform if {@param "firstPredicate"} is {@method "false"} and all
 *        predicates of {@param "elseIfTuple"} answer {@method "false"}.
 * @returns "⊤"
 *          If used as an expression, then the value of the selected action.
 * @category "Control Structures" "Conditionals"
 */
Public macro "If|if_then_«else if_then_»«else_»?" is
[
	firstPredicate : expression phrase ⇒ boolean,
	firstThenBlock : expression phrase ⇒ []→⊤,
	elseIfPairTuplePhrase : list phrase ⇒ (<boolean, []→⊤…|2>+),
	optionalElseBlock : list phrase ⇒ (([]→⊤)?)
|
	elseBlock ::= if |optionalElseBlock's expressions| = 1 then
		[optionalElseBlock's expressions[1]]
		else [cast «[<>]:⊤» into [b : expression phrase ⇒ []→⊤ | b]];
	elseIfPairTuple ::= cast elseIfPairTuplePhrase's expressions into
		[l : <list phrase⇒<boolean, []→⊤…|2>…|1..∞> | l];
	anAtom ::= $"If|if_then_else_";
	finalElseBlock ::= for anAtom nest elseBlock in elseIfPairTuple;
	basic send phrase anAtom conditional firstPredicate then firstThenBlock
		else finalElseBlock
] : send phrase ⇒ ⊤;

/**
 * Exit the continuation. Execution proceeds as though the continuation had just
 * returned from its current function. The current continuation is completely
 * replaced by the specified continuation's resumed caller.
 *
 * @method "Exit_"
 * @param "aContinuation" "$[…]→⊤"
 *        The continuation to exit.
 * @returns "⊥"
 * @category "Control Structures" "Continuations"
 */
Public macro "Exit_" is
[
	aContinuation : expression phrase ⇒ $[…]→⊤
|
	/* Since the continuation's return type is ⊤, the primitive will discard
	 * the argument, so it can be anything.
	 */
	restricted send $"Exit_with_if_"
		with «<
			aContinuation,
			‘123’,
			‘true’>»
		: ⊥
] : expression phrase ⇒ ⊥;

/**
 * Exit the continuation conditionally. If the condition is true, Execution
 * proceeds as though the continuation had just returned from its current
 * function, and the current continuation is completely replaced by the
 * specified continuation's resumed caller.
 *
 * If the condition is false, do nothing.
 *
 * @method "Exit_if_"
 * @param "aContinuation" "$[…]→⊤"
 *        The continuation to exit.
 * @param "condition" "boolean"
 *        Whether to exit.
 * @returns "⊥"
 * @category "Control Structures" "Continuations"
 */
Public macro "Exit_if_" is
[
	aContinuation : expression phrase ⇒ $[…]→⊤,
	condition : expression phrase ⇒ boolean
|
	/* Since the continuation's return type is ⊤, the primitive will discard
	 * the argument, so it can be anything.
	 */
	restricted send $"Exit_with_if_"
		with «<
			aContinuation,
			‘123’,
			condition>»
		: ⊤
] : expression phrase ⇒ ⊤;

/**
 * Reject the current parse unless the value supplied upon exit of a
 * continuation conforms to its function type's return type.
 *
 * @method "Exit_with_"
 * @restricts "continuation meta"
 * @restricts "any meta"
 */
Semantic restriction "Exit_with_" is
[
	continuationType : continuation meta,
	exitType : any meta
|
	functionType ::= continuationType's function type;
	If ¬exitType ⊆ functionType's return type then
	[
		Reject parse, expected:
			"continuation ("
			++ “continuationType”
			++ ") to accept value ("
			++ “exitType”
			++ ")"
	];
	⊥
];

/**
 * Reject the current parse unless the value supplied upon exit of a
 * continuation conforms to its function type's return type.
 *
 * @method "Exit_with_if_"
 * @restricts "continuation meta"
 * @restricts "any meta"
 */
Semantic restriction "Exit_with_if_" is
[
	continuationType : continuation meta,
	exitType : any meta,
	conditionType : boolean's type
|
	functionType ::= continuationType's function type;
	If ¬exitType ⊆ functionType's return type then
	[
		Reject parse, expected:
			"continuation ("
			++ “continuationType”
			++ ") to accept value ("
			++ “exitType”
			++ ")"
	];
	⊤
];

/* These are error messages. */
sizesIncompatibleMessage ::=
	"size of argument tuple to be compatible with size of\
	\| continuation's parameter tuple";

/**
 * Reject the current parse if the argument tuple cannot possibly match the
 * continuation's parameter tuple.
 *
 * @method "Restart_with_"
 * @restricts "continuation meta"
 * @restricts "tuple meta"
 */
Semantic restriction "Restart_with_" is
[
	continuationType : continuation meta,
	argumentsType : tuple meta
|
	functionType ::= continuationType's function type;
	parametersType ::= functionType's parameters' type;
	parametersSizes ::= ||parametersType||;
	/* If `parameterSizes` = ⊥, then `parametersType` = ⊥. In this case, we
	 * cannot statically ascertain anything interesting about the function and
	 * the arguments to apply.
	 */
	If parametersSizes ≠ ⊥ then
	[
		argumentsSizes ::= ||argumentsType||;
		validSizes ::= parametersSizes ∩ argumentsSizes;
		If validSizes = ⊥ then
		[
			Reject parse, expected: sizesIncompatibleMessage
		];
	];
	⊥
];

/**
 * Answer a continuation that represents (approximately) the current
 * continuation. This facility may be used to simulate labels within (but not at
 * the start of) blocks. The answer may be restarted, but not exited, which
 * causes execution to resume at the point where the continuation is computed
 * and answered.
 *
 * @method "here"
 * @returns "$[]→⊥"
 *          A continuation which, when restarted, causes {@method "here"} to
 *          answer the continuation again.
 * @category "Control Structures" "Continuations"
 */
Public method "here" is
[
	$body : $[]→⊥;
	body
] : $[]→⊥;

/**
 * Basic unconditional loop. Repeatedly invoke {@param "action"}.
 *
 * @method "Repeat_"
 * @param "action" "[]→⊤"
 *        The function that should be invoked repeatedly.
 * @returns "⊥"
 * @category "Control Structures" "Loops"
 */
Public method "Repeat_" is
[
	action : []→⊤
|
	$loop;
	action();
	Restart loop
] : ⊥;

/**
 * Apply the specified function exactly {@param "count"} times.
 *
 * @method "Repeat__times"
 * @param "action" "[]→⊤"
 *        A function.
 * @param "count" "[0..∞]"
 *        The number of times to apply {@param "action"}.
 * @returns "⊤"
 * @category "Control Structures" "Loops"
 */
Public method "Repeat__times" is
[
	action : []→⊤,
	count : [0..∞]
|
	$loop : ⊤;
	Exit loop if count < 1;
	action();
	Restart loop with <action, cast count - 1 into [i : [0..∞] | i]>
] : ⊤;

/**
 * If the count is ∞, then answer ⊥ (because the loop will never terminate).
 *
 * @method "Repeat__times"
 * @restricts "[]→⊤'s type"
 * @restricts "[0..∞]'s type"
 */
Semantic restriction "Repeat__times" is
[
	action : []→⊤'s type,
	count : [0..∞]'s type
|
	if ⎣count⎦ = ∞ then
	[
		⊥
	]
	else
	[
		⊤
	]
];

/**
 * Counting loop with customizable step and early exit support. Invoke {@param
 * "action"} once for every consecutive value = {@param "start"} + N × {@param
 * "step"} ≤ {@param "end"}, aborting if {@param "action"} answers {@method
 * "false"} after an iteration.
 *
 * @method "From_to_by_do_"
 * @param "integer" "start"
 *        The start value, inclusive.
 * @param "end" "extended integer"
 *        The end value, inclusive.
 * @param "step" "integer"
 *        The amount by which to adjust the value after each iteration.
 * @param "action" "[⊥]→boolean"
 *        A function that accepts a value in the specified range. If it answers
 *        {@method "true"}, then continue to iterate; if it answers {@method
 *        "false"}, then terminate iteration early.
 * @returns "⊤"
 * @category "Control Structures" "Loops"
 */
Abstract method "From_to_by_do_" is
	[integer, extended integer, integer, [⊥]→boolean]→⊤;

/**
 * Counting loop with customizable step and early exit support. Invoke {@param
 * "action"} once for every consecutive value = {@param "start"} + N × {@param
 * "step"} ≤ {@param "end"}, aborting if {@param "action"} answers {@method
 * "false"} after an iteration.
 *
 * @method "From_to_by_do_"
 * @param "start" "integer"
 *        The start value, inclusive.
 * @param "end" "extended integer"
 *        The end value, inclusive.
 * @param "step" "[0..∞)"
 *        The amount by which to adjust the value after each iteration.
 * @param "action" "[⊥]→boolean"
 *        A function that accepts a value in the specified range. If it answers
 *        {@method "true"}, then continue to iterate; if it answers {@method
 *        "false"}, then terminate iteration early.
 * @returns "⊤"
 * @category "Control Structures" "Loops"
 */
Public method "From_to_by_do_" is
[
	start : integer,
	end : extended integer,
	step : [0..∞),
	action : [⊥]→boolean
|
	$loop : ⊤;
	Exit loop if end < start;
	Exit loop if action(start) = false;
	Restart loop with <start + step, end, step, action>
] : ⊤;

/**
 * Counting loop with customizable step and early exit support. Invoke {@param
 * "action"} once for every consecutive value = {@param "start"} + N × {@param
 * "step"} ≥ {@param "end"}, aborting if {@param "action"} answers {@method
 * "false"} after an iteration.
 *
 * @method "From_to_by_do_"
 * @param "start" "integer"
 *        The start value, inclusive.
 * @param "end" "extended integer"
 *        The end value, inclusive.
 * @param "step" "(-∞..-1]"
 *        The amount by which to adjust the value after each iteration.
 * @param "action" "[⊥]→boolean"
 *        A function that accepts a value in the specified range. If it answers
 *        {@method "true"}, then continue to iterate; if it answers {@method
 *        "false"}, then terminate iteration early.
 * @returns "⊤"
 * @category "Control Structures" "Loops"
 */
Public method "From_to_by_do_" is
[
	start : integer,
	end : extended integer,
	step : (-∞..-1],
	action : [⊥]→boolean
|
	$loop : ⊤;
	Exit loop if start < end;
	Exit loop if action(start) = false;
	Restart loop with <start + step, end, step, action>
] : ⊤;

/**
 * If possible, then enforce that the specified function will accept all values
 * in the implied range.
 *
 * @method "From_to_by_do_"
 * @restricts "integer's type"
 * @restricts "extended integer's type"
 * @restricts "integer's type"
 * @restricts "[⊥]→boolean's type"
 */
Semantic restriction "From_to_by_do_" is
[
	start : integer's type,
	end : extended integer's type,
	step : integer's type,
	action : [⊥]→boolean's type
|
	subscripts ::=
		if step ⊆ [0..∞) then
		[
			(⎣start⎦ - 1 .. ⎡end⎤ + 1)
		]
		else
		[
			if step ⊆ (-∞..-1] then
			[
				(⎣end⎦ - 1 .. ⎡start⎤ + 1)
			]
			else
			[
				(start ∪ end) ∩ integer
			]
		];
	If action[1] ≠ ⊥ ∧ ¬subscripts ⊆ action[1] then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all values in the range "
			++ “subscripts”
			++ ", but it only accepts "
			++ “action[1]”
	];
	return ::= action's return type;
	endSet ::= {⎣end⎦, ⎡end⎤};
	definitelyRuns ::=
		if step ⊆ [0..∞) then
		[
			⎡start⎤ ≤ ⎣end⎦
		]
		else
		[
			if step ⊆ (-∞..-1] then
			[
				⎣start⎦ ≥ ⎡end⎤
			]
			else
			[
				false
			]
		];
	/* These are four circumstances which lead to non-termination:
	 *
	 * 1. The step is 0.
	 * 2. The step is positive, the end is ∞, and the action answers `true`.
	 * 3. The step is negative, the end is -∞, and the action answers `true`.
	 * 4. The action is definitely invoked and it never terminates.
	 */
	if step ⊆ [0..0]
		∨ (step ⊆ [0..∞) ∧ endSet = {∞} ∧ return = true's type)
		∨ (step ⊆ (-∞..-1] ∧ endSet = {-∞} ∧ return = true's type)
		∨ (definitelyRuns ∧ return = ⊥)
	then [⊥]
	else [⊤]
];

/**
 * Counting loop with customizable step. Invoke {@param "action"} once for every
 * consecutive value = {@param "start"} + N × {@param "step"} ≤ {@param "end"}.
 *
 * @method "From_to_by_do_"
 * @param "start" "integer"
 *        The start value, inclusive.
 * @param "end" "extended integer"
 *        The end value, inclusive.
 * @param "step" "integer"
 *        The amount by which to adjust the value after each iteration.
 * @param "action" "[⊥]→⊤"
 *        A function that accepts a value in the implied range.
 * @returns "⊤"
 * @category "Control Structures" "Loops"
 */
Abstract method "From_to_by_do_" is
	[integer, extended integer, integer, [⊥]→⊤]→⊤;

/**
 * Counting loop with customizable step. Invoke {@param "action"} once for every
 * consecutive value = {@param "start"} + N × {@param "step"} ≤ {@param "end"}.
 *
 * @method "From_to_by_do_"
 * @param "start" "integer"
 *        The start value, inclusive.
 * @param "end" "extended integer"
 *        The end value, inclusive.
 * @param "step" "integer"
 *        The amount by which to adjust the value after each iteration.
 * @param "action" "[⊥]→⊤"
 *        A function that accepts a value in the specified range.
 * @returns "⊤"
 * @category "Control Structures" "Loops"
 */
Public method "From_to_by_do_" is
[
	start : integer,
	end : extended integer,
	step : [0..∞),
	action : [⊥]→⊤
|
	$loop : ⊤;
	Exit loop if end < start;
	action(start);
	Restart loop with <start + step, end, step, action>
];

/**
 * Counting loop with customizable step. Invoke {@param "action"} once for every
 * consecutive value = {@param "start"} + N × {@param "step"} ≥ {@param "end"}.
 *
 * @method "From_to_by_do_"
 * @param "start" "integer"
 *        The start value, inclusive.
 * @param "end" "extended integer"
 *        The end value, inclusive.
 * @param "step" "integer"
 *        The amount by which to adjust the value after each iteration.
 * @param "action" "[⊥]→⊤"
 *        A function that accepts a value in the specified range.
 * @returns "⊤"
 * @category "Control Structures" "Loops"
 */
Public method "From_to_by_do_" is
[
	start : integer,
	end : extended integer,
	step : (-∞..-1],
	action : [⊥]→⊤
|
	$loop : ⊤;
	Exit loop if start < end;
	action(start);
	Restart loop with <start + step, end, step, action>
];

/**
 * Reject the current parse if {@param "action"} cannot accept every {@type
 * "integer"} implied by the specified range and step.
 *
 * @method "Require:_accepts subscripts from_to_by_"
 * @param "action" "[⊥]→⊤"
 * @param "start" "integer's type"
 * @param "end" "extended integer's type"
 * @param "step" "integer's type"
 * @returns "⊤"
 * @category "Control Structures"
 */
Public method "Require:_accepts subscripts from_to_by_" is
[
	action : [⊥]→⊤'s type,
	start : integer's type,
	end : extended integer's type,
	step : integer's type
|
	subscripts ::=
		if step ⊆ [0..∞) then
		[
			(⎣start⎦ - 1 .. ⎡end⎤ + 1)
		]
		else
		[
			if step ⊆ (-∞..-1] then
			[
				(⎣end⎦ - 1 .. ⎡start⎤ + 1)
			]
			else
			[
				union ::= (start ∪ end) ∩ integer;
				(⎣union⎦ - 1 .. ⎡union⎤ + 1)
			]
		];
	If action[1] ≠ ⊥ ∧ ¬subscripts ⊆ action[1] then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all values in the range "
			++ “subscripts”
			++ ", but it only accepts "
			++ “action[1]”
	];
] : ⊤;

/**
 * If possible, then enforce that the specified function will accept all values
 * in the implied range.
 *
 * @method "From_to_by_do_"
 * @restricts "integer's type"
 * @restricts "extended integer's type"
 * @restricts "integer's type"
 * @restricts "[⊥]→⊤'s type"
 */
Semantic restriction "From_to_by_do_" is
[
	start : integer's type,
	end : extended integer's type,
	step : integer's type,
	action : [⊥]→⊤'s type
|
	Require: action accepts subscripts from start to end by step;
	return ::= action's return type;
	endSet ::= {⎣end⎦, ⎡end⎤};
	definitelyRuns ::=
		if step ⊆ [0..∞) then
		[
			⎡start⎤ ≤ ⎣end⎦
		]
		else
		[
			if step ⊆ (-∞..-1] then
			[
				⎣start⎦ ≥ ⎡end⎤
			]
			else
			[
				false
			]
		];
	/* These are four circumstances which lead to non-termination:
	 *
	 * 1. The step is 0.
	 * 2. The step is positive and the end is ∞.
	 * 3. The step is negative and the end is -∞.
	 * 4. The action is definitely invoked and it never terminates.
	 */
	if step ⊆ [0..0]
		∨ (step ⊆ [0..∞) ∧ endSet = {∞})
		∨ (step ⊆ (-∞..-1] ∧ endSet = {-∞})
		∨ (definitelyRuns ∧ return = ⊥)
	then [⊥]
	else [⊤]
];

/**
 * Counting loop with customizable step. Invoke {@param "action"} once for every
 * consecutive value = {@param "start"} + N × {@param "step"} ≤ {@param "end"}.
 *
 * @macro "For each…from_to_by_§do_"
 * @param "i" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type (based on {@param
 *        "start"}, {@param "end"}, and {@param "step"}).
 * @param "start" "expression phrase ⇒ integer"
 *        An {@type "expression phrase"} that yields the start value, inclusive.
 * @param "end" "expression phrase ⇒ extended integer"
 *        An {@type "expression phrase"} that yields the end value, inclusive.
 * @param "step" "expression phrase ⇒ integer"
 *        An {@type "expression phrase"} that yields the amount by which to
 *        adjust the value after each iteration.
 * @param "action" "block phrase ⇒ []→⊤"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        loop.
 * @returns "send phrase ⇒ ⊤"
 * @category "Control Structures" "Loops"
 */
Public macro "For each…from_to_by_§do_" is
[
	counterPhrase : literal phrase ⇒ token,
	start : expression phrase ⇒ integer,
	end : expression phrase ⇒ extended integer,
	step : expression phrase ⇒ integer
|
	Declare loop variable counterPhrase as
	[
		startType ::= start's semantic type;
		endType ::= end's semantic type;
		stepType ::= step's semantic type;
		counterType ::=
			if stepType ⊆ [0..∞) then [(⎣startType⎦ - 1 .. ⎡endType⎤ + 1)]
			else
			[
				if stepType ⊆ (-∞..-1] then [(⎣endType⎦-1 .. ⎡startType⎤+1)]
				else [(startType ∪ endType) ∩ integer]
			];
		counterType
	];
],
[
	counterPhrase : literal phrase ⇒ token,
	start : expression phrase ⇒ integer,
	end : expression phrase ⇒ extended integer,
	step : expression phrase ⇒ integer,
	action : block phrase ⇒ []→⊤
|
	name ::= counterPhrase's token's lexeme;
	declaration ::= scope map[name];
	statements ::= action's statements;
	blockReturnType ::= cast statements
		into [t : phrase+ | t[|t|]'s semantic type]
		else [⊤];
	Undeclare name;
	restricted send $"From_to_by_do_" with
		«<
			start,
			end,
			step,
			«[
				<cast declaration into [d : argument phrase | d]>
			|
				statements
			] : blockReturnType»
		>» : ⊤
] : send phrase ⇒ ⊤;

/**
 * Counting loop with early exit support. Invoke {@param "action"} once for
 * every consecutive number in the range established by {@param "start"} and
 * {@param "end"}, aborting if {@param "action"} answers {@method "false"} after
 * an iteration.
 *
 * @method "From_to_do_"
 * @param "start" "integer"
 *        The start value, inclusive.
 * @param "end" "extended integer"
 *        The end value, inclusive.
 * @param "action" "[⊥]→boolean"
 *        A function that accepts a value in the specified range. If it answers
 *        {@method "true"}, then continue to iterate; if it answers {@method
 *        "false"}, then terminate iteration early.
 * @returns "⊤"
 * @category "Control Structures" "Loops"
 */
Public method "From_to_do_" is
[
	start : integer,
	end : extended integer,
	action : [⊥]→boolean
|
	$loop : ⊤;
	Exit loop if end < start;
	Exit loop if ¬action(start);
	Restart loop with <start + 1, end, action>
];

/**
 * If possible, then enforce that the specified function will accept all values
 * in the implied range.
 *
 * @method "From_to_do_"
 * @restricts "integer's type"
 * @restricts "extended integer's type"
 * @restricts "[⊥]→boolean's type"
 */
Semantic restriction "From_to_do_" is
[
	start : integer's type,
	end : extended integer's type,
	action : [⊥]→boolean's type
|
	Require: action accepts subscripts from start to end by 1's type;
	return ::= action's return type;
	endSet ::= {⎣end⎦, ⎡end⎤};
	definitelyRuns ::= ⎡start⎤ ≤ ⎣end⎦;
	if (endSet = {∞} ∧ return = true's type) ∨ (definitelyRuns ∧ return = ⊥)
	then [⊥]
	else [⊤]
];

/**
 * Counting loop with early exit support. Invoke {@param "action"} once for every
 * consecutive number in the range established by {@param "start"} and {@param
 * "end"}.
 *
 * @method "From_to_do_"
 * @param "start" "integer"
 *        The start value, inclusive.
 * @param "end" "extended integer"
 *        The end value, inclusive.
 * @param "action" "[⊥]→⊤"
 *        A function that accepts a value in the specified range.
 * @returns "⊤"
 * @category "Control Structures" "Loops"
 */
Public method "From_to_do_" is
[
	start : integer,
	end : extended integer,
	action : [⊥]→⊤
|
	$loop : ⊤;
	Exit loop if end < start;
	action(start);
	Restart loop with <start + 1, end, action>
];

/**
 * If possible, then enforce that the specified function will accept all values
 * in the implied range.
 *
 * @method "From_to_do_"
 * @restricts "integer's type"
 * @restricts "extended integer's type"
 * @restricts "[⊥]→⊤'s type"
 */
Semantic restriction "From_to_do_" is
[
	start : integer's type,
	end : extended integer's type,
	action : [⊥]→⊤'s type
|
	Require: action accepts subscripts from start to end by 1's type;
	return ::= action's return type;
	endSet ::= {⎣end⎦, ⎡end⎤};
	definitelyRuns ::= ⎡start⎤ ≤ ⎣end⎦;
	if endSet = {∞} ∨ (definitelyRuns ∧ return = ⊥) then [⊥] else [⊤]
];

/**
 * Counting loop with customizable step. Invoke {@param "action"} once for every
 * consecutive number in the range established by {@param "start"} and {@param
 * "end"}.
 *
 * @macro "For each…from_to_§do_"
 * @param "i" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type (based on {@param
 *        "start"}, {@param "end"}, and {@param "step"}).
 * @param "start" "expression phrase ⇒ integer"
 *        An {@type "expression phrase"} that yields the start value, inclusive.
 * @param "end" "expression phrase ⇒ extended integer"
 *        An {@type "expression phrase"} that yields the end value, inclusive.
 * @param "action" "block phrase ⇒ []→⊤"
 *        A zero-argument {@type "block phrase"} that represents the body of the
 *        loop.
 * @returns "send phrase ⇒ ⊤"
 * @category "Control Structures" "Loops"
 */
Public macro "For each…from_to_§do_" is
[
	counterPhrase : literal phrase ⇒ token,
	start : expression phrase ⇒ integer,
	end : expression phrase ⇒ extended integer
|
	Declare loop variable counterPhrase as
		[(⎣start's semantic type⎦-1 .. ⎡end's semantic type⎤+1)];
],
[
	counterPhrase : literal phrase ⇒ token,
	start : expression phrase ⇒ integer,
	end : expression phrase ⇒ extended integer,
	action : block phrase ⇒ []→⊤
|
	name ::= counterPhrase's token's lexeme;
	declaration ::= scope map[name];
	Undeclare name;
	startType ::= start's semantic type;
	endType ::= end's semantic type;
	stepType ::= 1's type;
	anAtom ::= $"From_to_by_do_";
	blockType ::= [⊥]→(action's semantic type's return type);

	returnType ::= strengthen ⊤ for call of anAtom
		using <startType, endType, stepType, blockType>;

	statements ::= action's statements;
	blockReturnType ::= cast statements
		into [t : phrase+ | t[|t|]'s semantic type]
		else [⊤];
	restricted send anAtom with
		«<
			start,
			end,
			‘1’,
			«[
				<cast declaration into [d : argument phrase | d]>
			|
				statements
			] : blockReturnType»
		>» : returnType
] : send phrase ⇒ ⊤;

/**
 * Restart the continuation with the specified arguments. Execution proceeds as
 * though the continuation's caller had just invoked the continuation's current
 * function with the given arguments instead of the original arguments. The
 * current continuation (in which this primitive was invoked) is completely
 * replaced by the restarted continuation.
 *
 * @method "_(«_‡,»)"
 * @param "aContinuation" "continuation"
 *        The continuation to restart.
 * @param "arguments" "tuple"
 *        The new arguments with which to restart {@param "aContinuation"}.
 * @returns "⊥"
 * @category "Control Structures" "Loops"
 */
Method "_(«_‡,»)" is
[
	aContinuation : continuation,
	arguments : tuple
|
	Primitive RestartContinuationWithArguments (failureCode : natural number);
	Invoke early failure function with <failureCode>
] : ⊥;

/**
 * Reject the current parse if the argument types do not conform to the
 * continuation's parameter types.
 *
 * @method "_(«_‡,»)"
 * @restricts "continuation meta"
 * @restricts "tuple meta"
 */
Semantic restriction "_(«_‡,»)" is
[
	continuationType : continuation meta,
	argumentsType : tuple meta
|
	functionType ::= continuationType's function type;
	parametersType ::= functionType's parameters' type;
	parametersSizes ::= ||parametersType||;
	/* If `parameterSizes` = ⊥, then `parametersType` = ⊥. In this case, we
	 * cannot statically ascertain anything interesting about the function and
	 * the arguments to apply.
	 */
	If parametersSizes ≠ ⊥ then
	[
		argumentsSizes ::= ||argumentsType||;
		validSizes ::= parametersSizes ∩ argumentsSizes;
		If validSizes = ⊥ then
		[
			Reject parse, expected: sizesIncompatibleMessage
		];
		/* Verify each of the arguments. */
		From 1 to ⎣argumentsSizes⎦ do
		[
			index : natural number
		|
			If ¬argumentsType[index] ⊆ parametersType[index] then
			[
				Reject parse, expected:
					"argument #"
					++ “index”
					++ " of type ("
					++ “argumentsType[index]”
					++ ") to agree with corresponding continuation's "
					++ "parameter type ("
					++ “parametersType[index]”
					++ ")"
			];
		];
	];
	⊥
];

/**
 * Helper method for semantic restrictions of {@method "map and filter_by_"}: If
 * {@param "action"}'s last parameter does not accept an arity-one procedure,
 * then reject the current parse.
 *
 * @method "Require:_'s⁇keeper is valid"
 * @param "action" "function meta"
 *        A function type whose last parameter type must permit a one-argument
 *        procedure.
 * @returns "⊤"
 * @category "Assertions" "Types"
 */
Public method "Require:_'s⁇keeper is valid" is
[
	action : function meta
|
	parametersType ::= action's parameters' type;
	parametersSizes ::= ||parametersType||;
	Assert: ⎣parametersSizes⎦ = ⎡parametersSizes⎤
		("number of parameters cannot be determined");
	parametersSize ::= cast ⎣parametersSizes⎦
		into [ t : natural number | t ];
	expectedType ::= [⊥]→⊤;
	If ¬action[parametersSize] ⊆ expectedType then
	[
		Reject parse, expected:
			"last argument ⊆ "
			++ “expectedType”
			++ " (but instead it was "
			++ “action[parametersSize]”
			++ ")"
	];
];

/**
 * Multiply branching conditional statement/expression. Execute the first
 * action for which the associated predicate answers {@method "true"}. If none
 * of the predicates answer {@method "true"}, then execute the "else" action. If
 * no "else" action is provided, then do not execute any of the action blocks.
 *
 * @method "If|if_then_«else if_then_»«else_»?"
 * @param "firstPredicate" "boolean"
 *        The first predicate. This argument is a raw boolean rather than a
 *        function answering a boolean, because it must always be evaluated
 *        (and hence there is no point deferring its evaluation).
 * @param "firstThen" "[]→⊤"
 *        The action to perform if {@param "firstPredicate"} is {@method
 *        "true"}.
 * @param "elseIfTuple" "<<[]→boolean, []→⊤…|2>…|1..>"
 *        A lexically constructed tuple of 2-tuples. Each 2-tuple has as its
 *        first element a predicate function and as its second element an action
 *        to perform if the predicate function answers {@method "true"}.
 * @param "else" "([]→⊤)?"
 *        A lexically constructed tuple that optionally contains the action to
 *        perform if {@param "firstPredicate"} is {@method "false"} and all
 *        predicates of {@param "elseIfTuple"} answer {@method "false"}.
 * @returns "⊤"
 *          If used as an expression, then the value of the selected action.
 * @category "Control Structures" "Conditionals"
 */
Public method "If|if_then_«else if_then_»«else_»?" is
[
	firstPredicate : boolean,
	firstThen : []→⊤,
	elseIfTuple : <[]→boolean, []→⊤…|2>+,
	else : ([]→⊤)?
|
	if firstPredicate then firstThen
	else
	[
		/* Choose the first of the remaining clauses for which the associated
		 * predicate is `true`.
		 */
		action : []→⊤;
		From 1 to |elseIfTuple| do
		[
			index : natural number
		|
			If elseIfTuple[index][1]() then
			[
				action := elseIfTuple[index][2];
			];
			action is unassigned
		];
		/* If none of the predicates answered `true`, then choose the "else"
		 * clause (if one was provided).
		 */
		If action is unassigned ∧ |else| = 1 then
		[
			action := else[1];
		];
		if action is unassigned then
		[
			/* Do nothing. */
		]
		else
		[
			action();
		];
	];
] : ⊤;

/**
 * Provide the strongest possible return type. If no "else" action is provided,
 * but the chain of predicates does not definitely indicate a particular action,
 * then answer ⊤. The weakest possible (but actual) strengthening is the type
 * union of the return types of all actions whose associated predicates are not
 * guaranteed to answer {@method "false"}. The greatest possible strengthening
 * occurs when an action whose predicate is guaranteed to answer {@method
 * "true"} is preceded only by actions whose predicates are guaranteed to answer
 * {@method "false"}; in this case, answer this action's return type.
 *
 * @method "If|if_then_«else if_then_»«else_»?"
 * @restricts "boolean's type"
 * @restricts "[]→⊤'s type"
 * @restricts "<<[]→boolean, []→⊤…|2>…|1..>'s type"
 * @restricts "([]→⊤)?'s type"
 */
Semantic restriction "If|if_then_«else if_then_»«else_»?" is
[
	firstPredicate : boolean's type,
	firstThen : []→⊤'s type,
	elseIfTuple : <<[]→boolean, []→⊤…|2>…|1..>'s type,
	else : ([]→⊤)?'s type
|
	/* `ambiguous` tracks whether any of the predicates cannot be proven to
	 * answer a specific value. It is set to `true` when a predicate's return
	 * type cannot be specifically established, i.e., when it is only known to
	 * be `boolean`.
	 */
	ambiguous : boolean := false;
	/* `exact` is assigned only if an exact type can be established for the
	 * current call site. In particular, this occurs when a predicate's return
	 * type is `true's type` but `ambiguous` is not set. `exact` is set in only
	 * two cases: 1) every previous predicate answers `false's type` but the
	 * current predicate answers `true's type` and 2) no preceding predicate
	 * has answered `true's type` and no "else" action has been provided.
	 */
	exact : type;
	/* `union` tracks the general type of the expression. Every predicate that
	 * answers `boolean` prior to the first predicate that answers `true's type`
	 * should have its action's return type accumulated via type union with
	 * `union`. (Every predicate/action pair after the first that answers
	 * `true's type` may be ignored, as its action's return value does not
	 * participate in the final result.)
	 */
	union : type := ⊥;
	/* Handle `firstPredicate` specially (because it is lexically distinct from
	 * `elseIfTuple`).
	 */
	If firstPredicate = true's type then
	[
		exact := firstThen's return type;
	]
	else
	[
		/* If `firstPredicate` is `boolean`, then the expression is already
		 * ambiguous. Set the flag and begin accumulating the expression's type.
		 */
		If firstPredicate = boolean then
		[
			ambiguous := true;
			union := eject union ∪ firstThen's return type;
		];
		elseIfTupleSize ::= relevant |elseIfTuple|;
		/* `keepLooping` tracks whether it is necessary to continue examining
		 * predicate/action pairs. It is set to `false` when a predicate is
		 * discovered that answers `true's type`. No predicate/action pairs
		 * beyond such a one participate in determination of the result type,
		 * i.e., they are guaranteed not to execute at runtime.
		 */
		keepLooping : boolean := true;
		From 1 to elseIfTupleSize do
		[
			index : natural number
		|
			elseIf ::= elseIfTuple[index];
			predicateReturnType ::= elseIf[1]'s return type;
			actionReturnType ::= elseIf[2]'s return type;
			If ¬ambiguous ∧ predicateReturnType = true's type then
			[
				exact := actionReturnType;
			];
			keepLooping :=
				if exact is assigned then
				[
					false
				]
				else
				[
					If predicateReturnType ≠ false's type then
					[
						ambiguous := true;
						union := eject union ∪ actionReturnType;
					];
					/* If the predicate's return type is `true's type`, then we
					 * want to exit the loop early no matter what else has
					 * happened up to this point. No further predicate/action
					 * pairs can participate in determining a result.
					 */
					predicateReturnType ≠ (true's type)
				];
			keepLooping
		];
		/* Unless we exited the loop early (`keepLooping` = `false`), then we
		 * want to give the "else" action an opportunity to participate.
		 */
		If keepLooping then
		[
			If ⎣else⎦ = 1 then
			[
				elseReturnType ::= else[1]'s return type;
				If ¬ambiguous then
				[
					exact := elseReturnType;
				]
				else
				[
					union := eject union ∪ elseReturnType;
				];
			]
			else
			[
				exact := ⊤;
			];
		];
	];
	/* Produce the final answer. */
	if exact is assigned then
	[
		exact
	]
	else
	[
		if ambiguous then
		[
			union
		]
		else
		[
			⊤
		]
	]
];

/**
 * Establish a conditional expression whose static return type is the type union
 * of its two possible functions' return types.
 *
 * @method "Unless|unless_then_else_"
 * @restricts "boolean's type"
 * @restricts "[]→⊤'s type"
 * @restricts "[]→⊤'s type"
 */
Semantic restriction "Unless|unless_then_else_" is
[
	predicate : boolean's type,
	falseFunction : []→⊤'s type,
	trueFunction : []→⊤'s type
|
	trueFunction's return type ∪ falseFunction's return type
];

/**
 * Strengthen the static return type to that of the function to invoke when the
 * predicate is false (which it is).
 *
 * @method "Unless|unless_then_else_"
 * @restricts "false's type's type"
 * @restricts "[]→⊤'s type"
 * @restricts "[]→⊤'s type"
 */
Semantic restriction "Unless|unless_then_else_" is
[
	contradiction : false's type's type,
	falseFunction : []→⊤'s type,
	trueFunction : []→⊤'s type
|
	falseFunction's return type
];

/**
 * Strengthen the static return type to that of the function to invoke when the
 * predicate is true (which it is).
 *
 * @method "Unless|unless_then_else_"
 * @restricts "true's type's type"
 * @restricts "[]→⊤'s type"
 * @restricts "[]→⊤'s type"
 */
Semantic restriction "Unless|unless_then_else_" is
[
	tautology : true's type's type,
	falseFunction : []→⊤'s type,
	trueFunction : []→⊤'s type
|
	trueFunction's return type
];

/**
 * Multiply branching conditional statement/expression. Execute the first
 * action for which the associated predicate answers {@method "false"}. If none
 * of the predicates answer {@method "false"}, then execute the "else" action.
 * If no "else" action is provided, then do not execute any of the action
 * blocks.
 *
 * @method "Unless|unless_then_«else unless_then_»«else_»?"
 * @param "firstPredicate" "expression phrase ⇒ boolean"
 *        The first predicate to check.
 * @param "firstThen" "expression phrase ⇒ []→⊤"
 *        The action to perform if {@param "firstPredicate"} is {@method
 *        "false"}.
 * @param "elseIfTuple" "list phrase ⇒ (<boolean, []→⊤…|2>+)"
 *        A lexically constructed tuple of 2-tuples. Each 2-tuple has as its
 *        first element a predicate and as its second element an action
 *        to perform if the predicate answers {@method "true"}.
 * @param "else" "list phrase ⇒ (([]→⊤)?)"
 *        A lexically constructed tuple that optionally contains the action to
 *        perform if {@param "firstPredicate"} is {@method "false"} and all
 *        predicates of {@param "elseIfTuple"} answer {@method "false"}.
 * @returns "⊤"
 *          If used as an expression, then the value of the selected action.
 * @category "Control Structures" "Conditionals"
 */
Public macro "Unless|unless_then_«else unless_then_»«else_»?" is
[
	firstPredicate : expression phrase ⇒ boolean,
	firstThenBlock : expression phrase ⇒ []→⊤,
	elseUnlessPairTuplePhrase : list phrase ⇒ (<boolean, []→⊤…|2>+),
	optionalElseBlock : list phrase ⇒ (([]→⊤)?)
|
	elseBlock ::= if |optionalElseBlock's expressions| = 1 then
		[optionalElseBlock's expressions[1]]
		else [cast «[<>]:⊤» into [b : expression phrase ⇒ []→⊤ | b]];
	elseUnlessPairTuple ::= cast elseUnlessPairTuplePhrase's expressions into
		[l : <list phrase⇒<boolean, []→⊤…|2>…|1..∞> | l];

	anAtom ::= $"Unless|unless_then_else_";
	finalElseBlock ::= for anAtom nest elseBlock in elseUnlessPairTuple;

	basic send phrase anAtom conditional firstPredicate
		then firstThenBlock else finalElseBlock
]: send phrase ⇒ ⊤;

/**
 * Multiply branching conditional statement/expression. Execute the first
 * action for which the associated predicate answers {@method "false"}. If none
 * of the predicates answer {@method "false"}, then execute the "else" action.
 * If no "else" action is provided, then do not execute any of the action
 * blocks.
 *
 * @method "Unless|unless_then_«else unless_then_»«else_»?"
 * @param "firstPredicate" "boolean"
 *        The first predicate. This argument is a raw boolean rather than a
 *        function answering a boolean, because it must always be evalutated
 *        (and hence there is no point deferring its evaluation).
 * @param "firstThen" "[]→⊤"
 *        The action to perform if {@param "firstPredicate"} is {@method
 *        "false"}.
 * @param "elseUnlessTuple" "<<[]→boolean, []→⊤…|2>…|1..>"
 *        A lexically constructed tuple of 2-tuples. Each 2-tuple has as its
 *        first element a predicate function and as its second element an
 *        action to perform if the predicate function answers {@method "false"}.
 * @param "else" "([]→⊤)?"
 *        A lexically constructed tuple that optionally contains the action to
 *        perform if {@param "firstPredicate"} is {@method "true"} and all
 *        predicates of {@param "elseIfTuple"} answer {@method "true"}.
 * @returns "⊤"
 *          If used as an expression, then the value of the selected action.
 * @category "Control Structures" "Conditionals"
 */
Public method "Unless|unless_then_«else unless_then_»«else_»?" is
[
	firstPredicate : boolean,
	firstThen : []→⊤,
	elseUnlessTuple : <<[]→boolean, []→⊤…|2>…|1..>,
	else : ([]→⊤)?
|
	if ¬firstPredicate then
	[
		firstThen();
	]
	else
	[
		/* Choose the first of the remaining clauses for which the associated
		 * predicate is `false`.
		 */
		action : []→⊤;
		From 1 to |elseUnlessTuple| do
		[
			index : natural number
		|
			Unless elseUnlessTuple[index][1]() then
			[
				action := elseUnlessTuple[index][2];
			];
			action is unassigned
		];
		/* If none of the predicates answered `false`, then choose the "else"
		 * clause (if one was provided).
		 */
		If action is unassigned ∧ |else| = 1 then
		[
			action := else[1];
		];
		if action is unassigned then
		[
			/* Do nothing. */
		]
		else
		[
			action();
		];
	];
] : ⊤;

/**
 * Provide the strongest possible return type. If no "else" action is provided,
 * but the chain of predicates does not definitely indicate a particular action,
 * then answer ⊤. The weakest possible (but actual) strengthening is the type
 * union of the return types of all actions whose associated predicates are not
 * guaranteed to answer {@method "true"}. The greatest possible strengthening
 * occurs when an action whose predicate is guaranteed to answer {@method
 * "false"} is preceded only by actions whose predicates are guaranteed to
 * answer {@method "true"}; in this case, answer this action's return type.
 *
 * @method "Unless|unless_then_«else unless_then_»«else_»?"
 * @restricts "boolean's type"
 * @restricts "[]→⊤'s type"
 * @restricts "<[]→boolean, []→⊤…|2>+'s type"
 * @restricts "([]→⊤)?'s type"
 */
Semantic restriction "Unless|unless_then_«else unless_then_»«else_»?" is
[
	firstPredicate : boolean's type,
	firstThen : []→⊤'s type,
	elseUnlessTuple : <[]→boolean, []→⊤…|2>+'s type,
	else : ([]→⊤)?'s type
|
	/* `ambiguous` tracks whether any of the predicates cannot be proven to
	 * answer a specific value. It is set to `true` when a predicate's return
	 * type cannot be specifically established, i.e., when it is only known to
	 * be `boolean`.
	 */
	ambiguous : boolean := false;
	/* `exact` is assigned only if an exact type can be established for the
	 * current call site. In particular, this occurs when a predicate's return
	 * type is `false's type` but `ambiguous` is not set. `exact` is set in only
	 * two cases: 1) every previous predicate answers `true's type` but the
	 * current predicate answers `false's type` and 2) no preceding predicate
	 * has answered `false's type` and no "else" action has been provided.
	 */
	exact : type;
	/* `union` tracks the general type of the expression. Every predicate that
	 * answers `boolean` prior to the first predicate that answers `false's
	 * type` should have its action's return type accumulated via type union
	 * with `union`. (Every predicate/action pair after the first that answers
	 * `false's type` may be ignored, as its action's return value does not
	 * participate in the final result.)
	 */
	union : type := ⊥;
	/* Handle `firstPredicate` specially (because it is lexically distinct from
	 * `elseUnlessTuple`).
	 */
	If firstPredicate = false's type then
	[
		exact := firstThen's return type;
	]
	else
	[
		/* If `firstPredicate` is `boolean`, then the expression is already
		 * ambiguous. Set the flag and begin accumulating the expression's type.
		 */
		If firstPredicate = boolean then
		[
			ambiguous := true;
			union := eject union ∪ firstThen's return type;
		];
		elseUnlessTupleSize ::= relevant |elseUnlessTuple|;
		/* `keepLooping` tracks whether it is necessary to continue examining
		 * predicate/action pairs. It is set to `false` when a predicate is
		 * discovered that answers `false's type`. No predicate/action pairs
		 * beyond such a one participate in determination of the result type,
		 * i.e., they are guaranteed not to execute at runtime.
		 */
		keepLooping : boolean := true;
		From 1 to elseUnlessTupleSize do
		[
			index : natural number
		|
			elseUnless ::= elseUnlessTuple[index];
			predicateReturnType ::= elseUnless[1]'s return type;
			actionReturnType ::= elseUnless[2]'s return type;
			If ¬ambiguous ∧ predicateReturnType = false's type then
			[
				exact := actionReturnType;
			];
			keepLooping :=
				if exact is assigned then
				[
					false
				]
				else
				[
					If predicateReturnType ≠ true's type then
					[
						ambiguous := true;
						union := eject union ∪ actionReturnType;
					];
					/* If the predicate's return type is `false's type`, then we
					 * want to exit the loop early no matter what else has
					 * happened up to this point. No further predicate/action
					 * pairs can participate in determining a result.
					 */
					predicateReturnType ≠ (false's type)
				];
			keepLooping
		];
		/* Unless we exited the loop early (`keepLooping` = `false`), then we
		 * want to give the "else" action an opportunity to participate.
		 */
		If keepLooping then
		[
			If ⎣else⎦ = 1 then
			[
				elseReturnType ::= else[1]'s return type;
				If ¬ambiguous then
				[
					exact := elseReturnType;
				]
				else
				[
					union := eject union ∪ elseReturnType;
				];
			]
			else
			[
				exact := ⊤;
			];
		];
	];
	/* Produce the final answer. */
	if exact is assigned then
	[
		exact
	]
	else
	[
		if ambiguous then
		[
			union
		]
		else
		[
			⊤
		]
	]
];

/**
 * Basic conditional loop. Invoke {@param "action"}. If {@param "action"}
 * answers {@method "true"}, then repeat.
 *
 * @method "While_"
 * @param "action" "[]→boolean"
 *        The function to apply repeatedly. It must answer {@method "true"} if
 *        it should run again.
 * @returns "⊤"
 * @category "Control Structures" "Loops"
 */
Public method "While_" is
[
	action : []→boolean
|
	$loop : ⊤;
	Exit loop if action() = false;
	Restart loop
] : ⊤;

/**
 * If {@param "action"} certainly answers {@method "true"}, then answer ⊥
 * (because the loop will run forever).
 *
 * @method "While_"
 * @restricts "[]→boolean's type"
 */
Semantic restriction "While_" is
[
	action : []→boolean's type
|
	if action's return type = true's type then
	[
		⊥
	]
	else
	[
		⊤
	]
];

/**
 * Basic conditional loop. Invoke {@param "action"}. If {@param "action"}
 * answers {@method "false"}, then repeat.
 *
 * @method "Until_"
 * @param "action" "[]→boolean"
 *        The function to apply repeatedly. It must answer {@method "false"} if
 *        it should run again.
 * @returns "⊤"
 * @category "Control Structures" "Loops"
 */
Public method "Until_" is
[
	action : []→boolean
|
	$loop : ⊤;
	Exit loop if action();
	Restart loop
] : ⊤;

/**
 * If {@param "action"} certainly answers {@method "false"}, then answer ⊥
 * (because the loop will run forever).
 *
 * @method "Until_"
 * @restricts "[]→boolean's type"
 */
Semantic restriction "Until_" is
[
	action : []→boolean's type
|
	if action's return type = false's type then
	[
		⊥
	]
	else
	[
		⊤
	]
];

/**
 * Basic conditional loop. Invoke {@param "predicate"}. If {@param "predicate"}
 * answers {@method "true"}, then invoke {@param "action"} and repeat.
 *
 * @method "While_do_"
 * @param "predicate" "[]→boolean"
 *        The function that guards repeated application of {@param "action"}.
 * @param "action" "[]→⊤"
 *        The function to apply whenever {@param "predicate"} answers {@method
 *        "true"}.
 * @returns "⊤"
 * @category "Control Structures" "Loops"
 */
Public method "While_do_" is
[
	predicate : []→boolean,
	action : []→⊤
|
	$loop : ⊤;
	Exit loop if predicate() = false;
	action();
	Restart loop
] : ⊤;

/**
 * If {@param "predicate"} certainly answers {@method "true"}, then answer ⊥
 * (because the loop will run forever).
 *
 * @method "While_do_"
 * @restricts "[]→boolean's type"
 * @restricts "[]→⊤'s type"
 */
Semantic restriction "While_do_" is
[
	predicate : []→boolean's type,
	action : []→⊤'s type
|
	if predicate's return type = true's type then
	[
		⊥
	]
	else
	[
		⊤
	]
];

/**
 * Basic conditional while loop macro. Invoke {@param "expressionPhrase"}. If
 * {@param "expressionPhrase"} answers {@method "true"}, then invoke
 * {@param "action"} and repeat.
 *
 * @macro "While_do_"
 * @param "expressionPhrase" "expression phrase ⇒ boolean"
 *        An {@type "expression phrase"} that yields a {@type "boolean"}
 * @param "action" "block phrase ⇒ []→⊤"
 *        A zero-argument {@type "block phrase"} that represents the body of
 *        the loop.
 * @returns "send phrase ⇒ ⊤"
 * @category "Control Structures" "Loops"
 */
Macro "While_do_" is
[
	expressionPhrase : expression phrase ⇒ boolean,
	action : block phrase ⇒ []→⊤
|
	restricted send $"While_do_" with
		«<
			«[<> | <expressionPhrase>] : boolean»,
			action
		>» : ⊤
] : send phrase ⇒ ⊤;

/**
 * Basic conditional loop. Invoke {@param "predicate"}. If {@param "predicate"}
 * answers {@method "false"}, then invoke {@param "action"} and repeat.
 *
 * @method "Until_do_"
 * @param "predicate" "[]→boolean"
 *        The function that guards repeated application of {@param "action"}.
 * @param "action" "[]→⊤"
 *        The function to apply whenever {@param "predicate"} answers {@method
 *        "false"}.
 * @returns "⊤"
 * @category "Control Structures" "Loops"
 */
Public method "Until_do_" is
[
	predicate : []→boolean,
	action : []→⊤
|
	$loop : ⊤;
	Exit loop if predicate();
	action();
	Restart loop
] : ⊤;

/**
 * If {@param "predicate"} certainly answers {@method "false"}, then answer ⊥
 * (because the loop will run forever).
 *
 * @method "Until_do_"
 * @restricts "[]→boolean's type"
 * @restricts "[]→⊤'s type"
 */
Semantic restriction "Until_do_" is
[
	predicate : []→boolean's type,
	action : []→⊤'s type
|
	if predicate's return type = false's type then
	[
		⊥
	]
	else
	[
		⊤
	]
];

/**
 * Basic conditional loop macro. Invoke {@param "expressionPhrase"}. If
 * {@param "expressionPhrase"} answers {@method "false"}, then invoke
 * {@param "action"} and repeat.
 *
 * @macro "Until_do_"
 * @param "expressionPhrase" "expression phrase ⇒ boolean"
 *        An {@type "expression phrase"} that yields a {@type "boolean"}
 * @param "action" "block phrase ⇒ []→⊤"
 *        A zero-argument {@type "block phrase"} that represents the body of
 *        the loop.
 * @returns "send phrase ⇒ ⊤"
 * @category "Control Structures" "Loops"
 */
Macro "Until_do_" is
[
	expressionPhrase : expression phrase ⇒ boolean,
	action : block phrase ⇒ []→⊤
|
	restricted send $"Until_do_" with
		«<
			«[<> | <expressionPhrase>] : boolean», action
		>» : ⊤
] : send phrase ⇒ ⊤;

/**
 * Basic conditional loop. Invoke {@param "action"} and then {@param
 * "predicate"}. If {@param "predicate"} answers {@method "true"}, then repeat.
 *
 * @method "Do_while_"
 * @param "action" "[]→⊤"
 *        The function to apply once and then again whenever {@param
 *        "predicate"} answers {@method "true"}.
 * @param "predicate" "[]→boolean"
 *        The function that guards repeated application of {@param "action"}.
 * @returns "⊤"
 * @category "Control Structures" "Loops"
 */
Public method "Do_while_" is
[
	action : []→⊤,
	predicate : []→boolean
|
	$loop : ⊤;
	action();
	Exit loop if predicate() = false;
	Restart loop
] : ⊤;

/**
 * If {@param "action"} does not terminate or {@param "predicate"} certainly
 * answers {@method "true"}, then answer ⊥ (because the loop will run forever).
 *
 * @method "Do_while_"
 * @restricts "[]→⊤'s type"
 * @restricts "[]→boolean's type"
 */
Semantic restriction "Do_while_" is
[
	action : []→⊤'s type,
	predicate : []→boolean's type
|
	if action's return type = ⊥ ∨ predicate's return type = true's type
	then [⊥]
	else [⊤]
];

/**
 * Basic conditional loop. Invoke {@param "action"} and then {@param
 * "expressionPhrase"}. If {@param "expressionPhrase"} answers
 * {@method "true"}, then repeat.
 *
 * @macro "Do_while_"
 * @param "action" "block phrase ⇒ []→⊤"
 *        A zero-argument {@type "block phrase"} that represents the body of
 *        the loop.
 * @param "expressionPhrase" "expression phrase ⇒ boolean"
 *        An {@type "expression phrase"} that yields a {@type "boolean"}
 * @returns "send phrase ⇒ ⊤"
 * @category "Control Structures" "Loops"
 */
Macro "Do_while_" is
[
	action : block phrase ⇒ []→⊤,
	expressionPhrase : expression phrase ⇒ boolean
|
	restricted send $"Do_while_" with
		«<
			action,	«[<> | <expressionPhrase>] : boolean»
		>» : ⊤
] : send phrase ⇒ ⊤;

/**
 * Conditional loop with alternation. Invoke {@param "action"} and then {@param
 * "predicate"}. If {@param "predicate"} answers {@method "true"}, then invoke
 * {@param "between"}. Then repeat.
 *
 * @method "Do_while_alternate with_"
 * @param "action" "[]→⊤"
 *        The function to apply once and then again repeatedly while
 *        {@param "predicate"} answers {@method "true"}.
 * @param "predicate" "[]→boolean"
 *        The function that guards repeated application of {@param "action"}.
 * @param "between" "[]→⊤"
 *        The function to apply between applications of {@param "action"}.
 * @returns "⊤"
 * @category "Control Structures" "Loops"
 */
Public method "Do_while_alternate with_" is
[
	action : []→⊤,
	predicate : []→boolean,
	between : []→⊤
|
	$loop : ⊤;
	action();
	Exit loop if predicate() = false;
	between();
	Restart loop
];

/**
 * If {@param "action"} does not terminate or {@param "predicate"} certainly
 * answers {@method "true"}, then answer ⊥ (because the loop will run forever).
 *
 * @method "Do_while_alternate with_"
 * @restricts "[]→⊤'s type"
 * @restricts "[]→boolean's type"
 * @restricts "[]→⊤'s type"
 */
Semantic restriction "Do_while_alternate with_" is
[
	action : []→⊤'s type,
	predicate : []→boolean's type,
	between : []→⊤'s type
|
	if action's return type = ⊥ ∨ predicate's return type = true's type
	then [⊥]
	else [⊤]
];

/**
 * Conditional loop with alternation. Invoke {@param "action"} and then {@param
 * "expressionPhrase"}. If {@param "expressionPhrase"} answers
 * {@method "true"}, then invoke {@param "between"}. Then repeat.
 *
 * @macro "Do_while_alternate with_"
 * @param "action" "block phrase ⇒ []→⊤"
 *        A zero-argument {@type "block phrase"} that represents the body of
 *        the loop.
 * @param "expressionPhrase" "expression phrase ⇒ boolean"
 *        An {@type "expression phrase"} that yields a {@type "boolean"}
 * @param "between" "block phrase ⇒ []→⊤"
 *        The function to apply between applications of {@param "action"}.
 * @returns "send phrase ⇒ ⊤"
 * @category "Control Structures" "Loops"
 */
Macro "Do_while_alternate with_" is
[
	action : block phrase ⇒ []→⊤,
	expressionPhrase : expression phrase ⇒ boolean,
	between : block phrase ⇒ []→⊤
|
	restricted send $"Do_while_alternate with_" with
		«<
			action,	«[<> | <expressionPhrase>] : boolean», between
		>» : ⊤
] : send phrase ⇒ ⊤;

/**
 * Conditional loop with alternation.
 *
 * @method "While_do_alternate with_"
 * @param "action" "[]→⊤"
 *        The function to apply repeatedly while {@param "predicate"} answers
 *        {@method "true"}. Never invoked if {@param "predicate"} never answers
 *        {@method "true"}.
 * @param "predicate" "[]→boolean"
 *        The function that guards repeated application of {@param "action"}.
 * @param "between" "[]→⊤"
 *        The function to apply between applications of {@param "action"}.
 * @returns "⊤"
 * @category "Control Structures" "Loops"
 */
Public method "While_do_alternate with_" is
[
	predicate : []→boolean,
	action : []→⊤,
	between : []→⊤
|
	If predicate() then
	[
		$loop : ⊤;
		action();
		Exit loop if predicate() = false;
		between();
		Restart loop
	];
];

/**
 * If {@param "action"} does not terminate or {@param "predicate"} certainly
 * answers {@method "true"}, then answer ⊥ (because the loop will run forever).
 *
 * @method "While_do_alternate with_"
 * @restricts "[]→⊤'s type"
 * @restricts "[]→boolean's type"
 * @restricts "[]→⊤'s type"
 */
Semantic restriction "While_do_alternate with_" is
[
	predicate : []→boolean's type,
	action : []→⊤'s type,
	between : []→⊤'s type
|
	if action's return type = ⊥ ∨ predicate's return type = true's type
	then [⊥]
	else [⊤]
];

/**
 * Conditional while loop with alternation.
 *
 * @macro "While_do_alternate with_"
 * @param "expressionPhrase" "expression phrase ⇒ boolean"
 *        An {@type "expression phrase"} that yields a {@type "boolean"}
 * @param "action" "block phrase ⇒ []→⊤"
 *        A zero-argument {@type "block phrase"} that represents the body of
 *        the loop.
 * @param "between" "block phrase ⇒ []→⊤"
 *        The function to apply between applications of {@param "action"}.
 * @returns "send phrase ⇒ ⊤"
 * @category "Control Structures" "Loops"
 */
Macro "While_do_alternate with_" is
[
	expressionPhrase : expression phrase ⇒ boolean,
	action : block phrase ⇒ []→⊤,
	between : block phrase ⇒ []→⊤
|
	restricted send $"While_do_alternate with_" with
		«<
			«[<> | <expressionPhrase>] : boolean», action, between
		>» : ⊤
] : send phrase ⇒ ⊤;

/**
 * Basic conditional loop. Invoke {@param "action"} and then {@param
 * "predicate"}. If {@param "predicate"} answers {@method "false"}, then repeat.
 *
 * @method "Do_until_"
 * @param "action" "[]→⊤"
 *        The function to apply once and then again whenever {@param
 *        "predicate"} answers {@method "false"}.
 * @param "predicate" "[]→boolean"
 *        The function that guards repeated application of {@param "action"}.
 * @returns "⊤"
 * @category "Control Structures" "Loops"
 */
Public method "Do_until_" is
[
	action : []→⊤,
	predicate : []→boolean
|
	$loop : ⊤;
	action();
	Exit loop if predicate();
	Restart loop
] : ⊤;

/**
 * If {@param "action"} does not terminate or {@param "predicate"} certainly
 * answers {@method "false"}, then answer ⊥ (because the loop will run forever).
 *
 * @method "Do_until_"
 * @restricts "[]→⊤'s type"
 * @restricts "[]→boolean's type"
 */
Semantic restriction "Do_until_" is
[
	action : []→⊤'s type,
	predicate : []→boolean's type
|
	if action's return type = ⊥ ∨ predicate's return type = false's type
	then [⊥]
	else [⊤]
];

/**
 * Basic conditional loop. Invoke {@param "action"} and then {@param
 * "expressionPhrase"}. If {@param "expressionPhrase"} answers
 * {@method "false"}, then repeat.
 *
 * @macro "Do_until_"
 * @param "action" "block phrase ⇒ []→⊤"
 *        A zero-argument {@type "block phrase"} that represents the body of
 *        the loop.
 * @param "expressionPhrase" "expression phrase ⇒ boolean"
 *        An {@type "expression phrase"} that yields a {@type "boolean"}
 * @returns "send phrase ⇒ ⊤"
 * @category "Control Structures" "Loops"
 */
Macro "Do_until_" is
[
	action : block phrase ⇒ []→⊤,
	expressionPhrase : expression phrase ⇒ boolean
|
	restricted send $"Do_until_" with
		«<
			action,	«[<> | <expressionPhrase>] : boolean»
		>» : ⊤
] : send phrase ⇒ ⊤;

/**
 * Conditional loop with alternation. Invoke {@param "action"} and then {@param
 * "predicate"}. If {@param "predicate"} answers {@method "false"}, then invoke
 * {@param "between"}. Then repeat.
 *
 * @method "Do_until_alternate with_"
 * @param "action" "[]→⊤"
 *        The function to apply once and then again repeatedly while {@param
 *        "predicate"} answers {@method "false"}.
 * @param "predicate" "[]→boolean"
 *        The function that guards repeated application of {@param "action"}.
 * @param "between" "[]→⊤"
 *        The function to apply between applications of {@param "action"}.
 * @returns "⊤"
 * @category "Control Structures" "Loops"
 */
Public method "Do_until_alternate with_" is
[
	action : []→⊤,
	predicate : []→boolean,
	between : []→⊤
|
	$loop : ⊤;
	action();
	Exit loop if predicate();
	between();
	Restart loop
];

/**
 * If {@param "action"} does not terminate or {@param "predicate"} certainly
 * answers {@method "false"}, then answer ⊥ (because the loop will run forever).
 *
 * @method "Do_until_alternate with_"
 * @restricts "[]→⊤'s type
 * @restricts "[]→boolean's type"
 * @restricts "[]→⊤'s type"
 */
Semantic restriction "Do_until_alternate with_" is
[
	action : []→⊤'s type,
	predicate : []→boolean's type,
	between : []→⊤'s type
|
	if action's return type = ⊥ ∨ [predicate's return type = false's type]
	then [⊥]
	else [⊤]
];

/**
 * Conditional loop with alternation. Invoke {@param "action"} and then {@param
 * "expressionPhrase"}. If {@param "expressionPhrase"} answers
 * {@method "false"}, then invoke {@param "between"}. Then repeat.
 *
 * @macro "Do_until_alternate with_"
 * @param "action" "block phrase ⇒ []→⊤"
 *        A zero-argument {@type "block phrase"} that represents the body of
 *        the loop.
 * @param "expressionPhrase" "expression phrase ⇒ boolean"
 *        An {@type "expression phrase"} that yields a {@type "boolean"}
 * @param "between" "block phrase ⇒ []→⊤"
 *        The function to apply between applications of {@param "action"}.
 * @returns "send phrase ⇒ ⊤"
 * @category "Control Structures" "Loops"
 */
Macro "Do_until_alternate with_" is
[
	action : block phrase ⇒ []→⊤,
	expressionPhrase : expression phrase ⇒ boolean,
	between : block phrase ⇒ []→⊤
|
	restricted send $"Do_until_alternate with_" with
		«<
			action,	«[<> | <expressionPhrase>] : boolean», between
		>» : ⊤
] : send phrase ⇒ ⊤;

/**
 * Conditional loop with alternation.
 *
 * @method "Until_do_alternate with_"
 * @param "action" "[]→⊤"
 *        The function to apply repeatedly while {@param "predicate"} answers
 *        {@method "false"}.
 *        Never applied if {@param "predicate"} never answers {@method "false"}.
 * @param "predicate" "[]→boolean"
 *        The function that guards repeated application of {@param "action"}.
 * @param "between" "[]→⊤"
 *        The function to apply between applications of {@param "action"}.
 * @returns "⊤"
 * @category "Control Structures" "Loops"
 */
Public method "Until_do_alternate with_" is
[
	predicate : []→boolean,
	action : []→⊤,
	between : []→⊤
|
	Unless predicate() then
	[
		$loop : ⊤;
		action();
		Exit loop if predicate();
		between();
		Restart loop
	];
];

/**
 * If {@param "action"} does not terminate or {@param "predicate"} certainly
 * answers {@method "false"}, then answer ⊥ (because the loop will run forever).
 *
 * @method "Until_do_alternate with_"
 * @restricts "[]→⊤'s type"
 * @restricts "[]→boolean's type"
 * @restricts "[]→⊤'s type"
 */
Semantic restriction "Until_do_alternate with_" is
[
	predicate : []→boolean's type,
	action : []→⊤'s type,
	between : []→⊤'s type
|
	if action's return type = ⊥ ∨ predicate's return type = false's type
	then [⊥]
	else [⊤]
];

/**
 * Conditional loop with alternation.
 *
 * @macro "Until_do_alternate with_"
 * @param "action" "block phrase ⇒ []→⊤"
 *        A zero-argument {@type "block phrase"} that represents the body of
 *        the loop.
 * @param "expressionPhrase" "expression phrase ⇒ boolean"
 *        An {@type "expression phrase"} that yields a {@type "boolean"}
 * @param "between" "block phrase ⇒ []→⊤"
 *        The function to apply between applications of {@param "action"}.
 * @returns "send phrase ⇒ ⊤"
 * @category "Control Structures" "Loops"
 */
Macro "Until_do_alternate with_" is
[
	expressionPhrase : expression phrase ⇒ boolean,
	action : block phrase ⇒ []→⊤,
	between : block phrase ⇒ []→⊤
|
	restricted send $"Until_do_alternate with_" with
		«<
			«[<> | <expressionPhrase>] : boolean», action, between
		>» : ⊤
] : send phrase ⇒ ⊤;

/**
 * Invoke the first function of {@param "caseTuple"} that accepts {@param
 * "value"}. If no such function is specified, then invoke {@param "else"}. If
 * {@param "else"} is not specified, then do nothing.
 *
 * @method "Cast|cast_into«_‡,»«else_»"
 * @param "value" "any"
 *        An arbitrary value.
 * @param "caseTuple" "<[⊥]→⊤…|2..>"
 *        A tuple of arity-1 functions. The first of these able to accept
 *        {@param "value"} will be applied to it.
 * @param "else" "([]→⊤)?"
 *        An optional arity-0 function. If provided, then it will be invoked iff
 *        no function of {@param "caseTuple"} is able to accept {@param
 *        "value"}.
 * @returns "⊤"
 *          The result of whatever function is applied.
 * @category "Bootstrap" "Control Structures" "Casts" "Conditionals"
 */
Public method "Cast|cast_into«_‡,»«else_»" is
[
	value : any,
	caseTuple : <[⊥]→⊤…|2..>,
	else : ([]→⊤)?
|
	index : natural number := 1;
	[
		$body;
		if index > |caseTuple| then
		[
			(else[1] else [[]])();
		]
		else if value ∈ caseTuple[index]'s type[1] then
		[
			caseTuple[index](value);
		]
		else
		[
			index++;
			Restart body
		];
	]();
] : ⊤;

/**
 * Strengthen the return type of {@method "Cast|cast_into«_‡,»«else_»"} so that
 * it may be used as a value-producing expression. If any case is unnecessary or
 * invalid, then reject the current parse.
 *
 * @method "Cast|cast_into«_‡,»«else_»"
 * @restricts "any meta"
 * @restricts "<[⊥]→⊤…|2..>'s type"
 * @restricts "([]→⊤)?'s type"
 */
Semantic restriction "Cast|cast_into«_‡,»«else_»" is
[
	valueType : any meta,
	caseTuple : <[⊥]→⊤…|2..>'s type,
	else : ([]→⊤)?'s type
|
	acceptSize ::= relevant |caseTuple|;
	union : type := ⊥;
	From 1 to acceptSize do
	[
		index : natural number
	|
		functionType ::= caseTuple[index];
		If valueType ⊆ functionType[1] then
		[
			Reject parse, expected:
				"necessary cast expression, but "
				++ “valueType”
				++ " is a subtype of "
				++ “functionType[1]”
		];
		If valueType ∩ (functionType[1]) = ⊥ then
		[
			Reject parse, expected:
				"allowed cast expression, but "
				++ “valueType”
				++ " is not a supertype of "
				++ “functionType[1]”
		];
		union := eject union ∪ functionType's return type;
	];
	If ⎣else⎦ = 1 then
	[
		union := eject union ∪ else[1]'s return type;
	];
	union
];

/**
 * Case statement/expression. {@param "enum"} is an enumeration. {@param
 * "value"} must be one of the instances of {@param "enum"}. Choose the case
 * corresponding to {@param "value"} and perform its associated action. If no
 * case corresponds to {@param "value"}, then perform the {@param "else"}
 * action. {@param "else"} must be provided unless {@param "caseTuple"}
 * specifically represents each value of {@param "enum"}.
 *
 * @method "Choose|choose_from_where«_is_‡,»«,else_»"
 * @param "value" "any"
 *        An instance of {@param "enum"}.
 * @param "enum" "type"
 *        An enumeration.
 * @param "caseTuple" "<<any, []→⊤…|2>…|1..>"
 *        A tuple of 2-tuples whose first element is an instance of {@param
 *        "enum"} and whose second element is an arity-0 function. This function
 *        will be performed if {@param "value"} equals the first element.
 * @param "else" "([]→⊤)?"
 *        A tuple optionally containing the function to invoke if {@param
 *        "value"} does not match any of the cases. This represents the default
 *        case.
 * @returns "⊤"
 *          The return value of the chosen function.
 * @category "Control Structures" "Conditionals"
 */
Public method "Choose|choose_from_where«_is_‡,»«,else_»" is
[
	value : any,
	enum : type,
	caseTuple : <<any, []→⊤…|2>…|1..>,
	else : ([]→⊤)?
|
	index : natural number := 1;
	[
		$body;
		if index > |caseTuple| then
		[
			(else[1] else [[]])();
		]
		else if caseTuple[index][1] = value then
		[
			caseTuple[index][2]();
		]
		else
		[
			index++;
			Restart body
		];
	]();
] : ⊤;

/**
 * Reject the current parse unless all of the following are true:
 *
 * - the second parameter's type's sole instance is an enumeration.
 * - the first parameter's type is an instance of meta.
 * - Each case's selector is a statically known value.
 * - Each case's selector is an instance of the enumeration.
 * - Every value of the enumeration is handled by a case, either explicitly or
 *   implicitly by the default case.
 * - Each case's selector occurs only once.
 *
 * @method "Choose|choose_from_where«_is_‡,»«,else_»"
 * @restricts "any meta"
 * @restricts "type's type"
 * @restricts "<<any, []→⊤…|2>…|1..>'s type"
 * @restricts "([]→⊤)?'s type"
 */
Semantic restriction "Choose|choose_from_where«_is_‡,»«,else_»" is
[
	valueType : any meta,
	meta : type's type,
	caseTuple : <<any, []→⊤…|2>…|1..>'s type,
	else : ([]→⊤)?'s type
|
	$body : type;
	If |meta| ≠ 1 ∨ ¬0 < |meta's instance| < ∞ then
	[
		Reject parse, expected: "enumeration to be statically known"
	];
	If ¬valueType ∈ meta then
	[
		Reject parse, expected:
			"case selector ("
			++ “valueType”
			++ ") to be an instance of "
			++ “meta”
	];
	enum ::= meta's instance;
	caseEnum : type := ⊥;
	union : type := ⊥;
	From 1 to relevant |caseTuple| do
	[
		index : natural number
	|
		case ::= caseTuple[index];
		If |case[1]| ≠ 1 then
		[
			Reject parse, expected:
				"all cases to be statically known values, but discovered "
				++ “case[1]”
		];
		instance ::= case[1]'s instance;
		If ¬instance ∈ enum then
		[
			Reject parse, expected:
				"all cases to be instances of "
				++ “enum”
				++ ", but "
				++ “instance”
				++ " is not"
		];
		If case[1] ⊆ caseEnum then
		[
			Reject parse, expected:
				"each case to be unique, but "
				++ “instance”
				++ " occurs more than once"
		];
		caseEnum := eject caseEnum ∪ case[1];
		If |valueType| = 1 ∧ valueType = case[1] then
		[
			Exit body with case[2]'s return type
		];
		If valueType ∩ (case[1]) ≠ ⊥ then
		[
			union := eject union ∪ case[2]'s return type;
		];
	];
	If caseEnum ≠ enum ∧ ⎣else⎦ ≠ 1 then
	[
		allCases ::= enum's instances;
		handledCases ::= caseEnum's instances;
		unhandledCases ::= allCases \ handledCases;
		Reject parse, expected:
			"all cases to be handled, but these cases are not: "
			++ “unhandledCases”
	];
	If ¬valueType ⊆ caseEnum then
	[
		union := eject union ∪ else[1]'s return type;
	];
	union
];
