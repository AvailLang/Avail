/*
 * Late Collections.avail
 * Copyright © 1993-2022, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Late Collections"
Versions
	"Avail-1.6.1"
Extends
	"Bootstrap",
	"Collections"
Uses
	"Bootstrap",
	"Control Structures",
	"Definers",
	"Early Conditionals",
	"Functions",
	"Enumeration Support",
	"Literals",
	"Logic",
	"Macro Support",
	"Maps",
	"Math",
	"Sets",
	"Tuples",
	"Types",
	"Variables"
Names
	/* Concise operators. */
	"∃…∈_`|§_",
	"∀…∈_`|§_",
	"…∈_`|§_",
	"…∈_→§_",

	/* Utilities. */
	"one-line tuple body function(_,_)"
Body

Alias "∃…∈_`|§_" to $"any…in|of_§satisfies_";
Alias "∀…∈_`|§_" to $"each…in|of_§satisfies_";
Alias "…∈_`|§_" to $"select each…from_§where_";
Alias "…∈_→§_" to $"map each…in|of_§through_";

Copy macros from $"any…in|of_§satisfies_" to $"∃…∈_`|§_";
Copy macros from $"each…in|of_§satisfies_" to $"∀…∈_`|§_";
Copy macros from $"select each…from_§where_" to $"…∈_`|§_";
Copy macros from $"map each…in|of_§through_" to $"…∈_→§_";

/**
 * Answer a function that computes a body function.
 *
 * @method "one-line tuple body function(_,_)"
 * @param "anAtom" "atom"
 *   The atom that represents the function that the macro builds.
 * @param "baseReturnType" "type"
 *   The base return type of the method.
 * @returns "[literal phrase ⇒ token, expression phrase ⇒ tuple,
 *   expression phrase ⇒ any]→send phrase ⇒ any"
 *          The requested function.
 */
Public method "one-line tuple body function(_,_)" is
[
	anAtom : atom,
	baseReturnType : type
|
	[
		elementPhrase : literal phrase ⇒ token,
		aTuple : expression phrase ⇒ tuple,
		action : expression phrase ⇒ any
	|
		name ::= elementPhrase's token's lexeme;
		declaration ::= scope map[name];
		blockReturnType ::= action's semantic type;
		actionBlock ::= «[
			<declaration ?→ argument phrase>
		|
			<action>
		] : blockReturnType»;
		returnType ::=
			return type(aTuple, actionBlock, baseReturnType, anAtom);
		Undeclare name;
		send ::= bootstrap restricted send anAtom with
			«<aTuple, actionBlock>» : returnType;
		send ?→ send phrase ⇒ any
	] : send phrase ⇒ any
] : [
	literal phrase ⇒ token,
	expression phrase ⇒ tuple,
	expression phrase ⇒ any
]→send phrase ⇒ any;

/**
 * Iteratively apply {@param "transformer"} to each consecutive element of
 * {@param "aTuple"}, collecting the results into a new tuple (and preserving
 * ordering of the transformed elements). Answer this tuple.
 *
 * @macro "…∈_→§_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic
 *        {@type "literal token"} whose value is the name of the loop variable.
 *        The generated loop variable is given the strongest possible type
 *        based on the type union of the leading types and default type of
 *        {@param "aTuple"}.
 * @param "aTuple" "expression phrase ⇒ any"
 *        An {@type "expression phrase"} that yields the tuple to iterate over.
 * @param "action" "block phrase ⇒ []→⊤"
 *        A zero-argument {@type "block phrase"} that represents the body of
 *        the loop.
 * @returns "send phrase ⇒ ⊤"
 * @category "Control Structures" "Loops" "Collections" "Tuples"
 */
Public macro "…∈_→§_" is
	a tuple iteration prefix function,
	one-line tuple body function($"map_through_", tuple)
styled by loop styler;

q ::= x ∈ 1 to 10 → [x + 3];
