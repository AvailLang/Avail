/*
 * Objects.avail
 * Copyright © 1993-2019, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Objects"
Versions
	"1.4.0"
Uses
	"Atoms",
	"Bootstrap",
	"Control Structures",
	"Definers",
	"Early Assertions",
	"Early Conditionals",
	"Early Functions",
	"Enumeration Support",
	"Error Codes",
	"Literals",
	"Logic",
	"Maps",
	"Math",
	"Phrases",
	"Sets",
	"Tuples",
	"Types",
	"Variables"
Names
	"a|an_«with«_«:»?:=_‡,»»",
	"extend_with«_:_‡,»",
	"«Public»?«Explicit|explicit»?\
		\|Class|class_extends_\
		\|«with immutable⁇field|fields««public»?«reconstructible»?_:_«(accessor⁇_)»‡,»»\
		\|«with mutable field|fields««public»?«shared»?«referable»?«read-only»?\
			\|_:_«(««accessor|mutator|referrer»!_‡,»)»‡,»»\
		\|«with reconstructor|reconstructors««public»?(«_‡,»)‡,»»",
	"_as_«with«_::=_‡,»»"
Body

/**
 * Strengthen object field extraction ({@method "_[_]"}).
 * @method "_[_]"
 * @restricts "object's type"
 * @restricts "atom's type"
 */
Semantic restriction "_[_]" is
[
	anObjectType : object's type,
	field : atom's type
|
	if |field| = 1 then [anObjectType[field's instance]] else [any]
] : any's type;

Method "_→object type" is stable at [field type map]→object meta;

/**
 * @method "_→object type"
 * @restricts "field type map's type"
 */
Semantic restriction "_→object type" is
[
	mapType : field type map's type
|
	/* If the enumeration of keys is known and equals the cardinality of the
	 * map, then answer the nearest object type supertype with these keys.
	 */
	if ⌊mapType⌋ = ⌈mapType⌉ ∧ |mapType's key type| = ⌊mapType⌋ then
	[
		atoms ::= mapType's key type's instances;
		defs ::= atoms→tuple zip |atoms| of mapType's value type's instance;
		(defs→object type)'s type
	]
	/* Can't strengthen. */
	else
	[
		⊤
	]
];

Method "_→object type" is stable at [field type tuple]→object meta;

/**
 * @method "_→object type"
 * @restricts "field type tuple's type"
 */
Semantic restriction "_→object type" is
[
	tupleType : field type tuple's type
|
	limit ::= |tupleType's leading types| + 1;
	/* `defs` are the guaranteed field definitions. A field definition is
	 * only certain when the field atom is certain.
	 */
	defs : field type map := {};
	/* `constraints` are augmented when a particular definition tuple's
	 * field atom is not statically known. This map is used to weaken `defs`
	 * after all definition tuples have been processed.
	 */
	constraints : field type map := {};
	/* `universal` is the type union of all field types for which the
	 * corresponding field is merely `atom`, i.e., the actual fields are not
	 * statically known. It is used to weaken `defs` after all definition
	 * tuples have been processed.
	 */
	universal : any meta := ⊥;
	For each index from 1 to limit do
	[
		defTuple ::= tupleType[index];
		atomType ::= defTuple[1];
		defType ::= defTuple[2]'s instance;
		/* The field atom is known exactly. Therefore, we can confidently
		 * say that the resulting object type must contain this field.
		 */
		if |atomType| = 1 then
		[
			fieldAtom ::= atomType's instance;
			fieldType ::= defs[fieldAtom] else [ ⊥ ] ∪ defType;
			defs := eject defs + fieldAtom→fieldType;
		]
		/* We know one or more fields with which this type is associated, so
		 * record this knowledge into `constraints`.
		 */
		else if |atomType| ≠ ∞ then
		[
			atoms ::= atomType's instances;
			For each fieldAtom of atoms do
			[
				fieldType ::= constraints[fieldAtom] else [ ⊥ ] ∪ defType;
				constraints := eject constraints + fieldAtom→fieldType;
			];
		]
		/* We don't know anything about the field. Treat the field type as a
		 * universal constraint.
		 */
		else
		[
			Assert: atomType = atom;
			universal := eject universal ∪ defType;
		];
	];
	/* Weaken each value of `defs` by all applicable constraints. */
	defs := map each fieldAtom → fieldType in eject defs through
		[
			fieldType ∪ constraints[fieldAtom] else [ ⊥ ] ∪ universal
		];
	(defs→object type)'s type
];

Method "_→object" is stable at [field map]→object;

/**
 * @method "_→object"
 * @restricts "field map's type"
 */
Semantic restriction "_→object" is
[
	mapType : field map's type
|
	/* If the enumeration of keys is known and equals the cardinality of the
	 * map, then answer the nearest object type supertype with these keys.
	 */
	if ⌊mapType⌋ = ⌈mapType⌉ ∧ |mapType's key type| = ⌊mapType⌋ then
	[
		atoms ::= mapType's key type's instances;
		fieldAssignments ::= atoms→tuple zip |atoms| of mapType's value type;
		(fieldAssignments→object)'s type
	]
	/* Can't strengthen. */
	else
	[
		⊤
	]
];

Method "_→object" is stable at [field tuple]→object;

/**
 * @method "_→object"
 * @restricts "field tuple's type"
 */
Semantic restriction "_→object" is
[
	tupleType : field tuple's type
|
	limit ::= |tupleType's leading types| + 1;
	/* `defs` are the guaranteed field definitions. A field definition is
	 * only certain when the field atom is certain.
	 */
	defs : field type map := {};
	/* `constraints` are augmented when a particular definition tuple's
	 * field atom is not statically known. This map is used to weaken `defs`
	 * after all definition tuples have been processed.
	 */
	constraints : field type map := {};
	/* `universal` is the type union of all field types for which the
	 * corresponding field is merely `atom`, i.e., the actual fields are not
	 * statically known. It is used to weaken `defs` after all definition
	 * tuples have been processed.
	 */
	universal : any meta := ⊥;
	For each index from 1 to limit do
	[
		atomType, defType ::= tupleType[index];
		/* The field atom is known exactly. Therefore, we can confidently
		 * say that the resulting object type must contain this field.
		 */
		if |atomType| = 1 then
		[
			fieldAtom ::= atomType's instance;
			fieldType ::= defs[fieldAtom] else [⊥] ∪ defType;
			defs := eject defs + fieldAtom→fieldType;
		]
		/* We know one or more fields with which this type is associated, so
		 * record this knowledge into `constraints`.
		 */
		else if |atomType| ≠ ∞ then
		[
			atoms ::= atomType's instances;
			For each fieldAtom of atoms do
			[
				fieldType ::= constraints[fieldAtom] else [⊥] ∪ defType;
				constraints := eject constraints + fieldAtom→fieldType;
			];
		]
		/* We don't know anything about the field. Treat the field type as a
		 * universal constraint.
		 */
		else
		[
			Assert: atomType = atom;
			universal := eject universal ∪ defType;
		];
	];
	/* Weaken each value of `defs` by all applicable constraints. */
	defs := map each fieldAtom → fieldType in eject defs through
		[
			fieldType ∪ constraints[fieldAtom] else [ ⊥ ] ∪ universal
		];
	defs→object type
];

Method "_→map" is stable at [object]→map;

/**
 * @method "_→map"
 * @restricts "object meta"
 */
Semantic restriction "_→map" is
[
	anObjectType : object meta
|
	objectMap ::= anObjectType→map;
	/* Because we can't know what keys and types the subtypes of the
	 * argument will contain, this is as good as it gets.
	 */
	{atom→any | |objectMap|..}
];

/**
 * @method "_→tuple"
 * @restricts "object meta"
 */
Semantic restriction "_→tuple" is
[
	anObjectType : object meta
|
	objectMap ::= anObjectType→map;
	/* Note that we can't exploit instance types here, because conversion of an
	 * object type to a tuple is an unstable operation. Because we can't know
	 * what keys and types the subtypes of the argument will contain, this is as
	 * good as it gets.
	 */
	<<atom, any…|2>…| |objectMap|..>
];

/**
 * Construct and answer an object type which is a subtype of {@param
 * "supertype"} augmented by the specified tuple of field definitions.
 *
 * @method "extend_with«_:_‡,»"
 * @param "supertype" "object's type"
 *        An object type that must be a supertype of the answer.
 * @param "newDefinitions" "<<atom, any meta…|2>…|1..>"
 *        A tuple of 2-tuples. Each 2-tuple consists of 1) an atom that uniquely
 *        identifies the field and 2) the field type, i.e., the type of value
 *        that instances of the answer may store in the field. If the field atom
 *        is defined by {@param "supertype"}, then the new field type must be a
 *        subtype of the field type as defined in {@param "supertype"}, i.e., it
 *        must be covariantly specialized.
 * @returns "object's type"
 *          The requested object type.
 * @category "Objects" "Types" "Constructors"
 */
Public stable method "extend_with«_:_‡,»" is
[
	supertype : object meta,
	newDefinitions : <<atom, any meta…|2>…|1..>
|
	fieldAtoms ::= stripe newDefinitions at 1;
	If |fieldAtoms→set| ≠ |fieldAtoms| then
	[
		early failure function(object-type-extension-contains-duplicates code)
	];
	subtype ::= (supertype→tuple ++ newDefinitions)→object type;
	If ¬subtype ⊆ supertype then
	[
		early failure function(
			object-type-extension-did-not-produce-subtype code)
	];
	subtype
] : object meta;

/**
 * Object type extension statically requires that:
 *
 * - Every field atom of the extension is known.
 * - Each field atom of the extension appears only once during extension.
 * - Each field atom of the extension is either 1) not present in the supertype
 *   or 2) specifies a type which covaries with the field type expressed in the
 *   supertype.
 *
 * @method "extend_with«_:_‡,»"
 * @restricts "object's type's type"
 * @restricts "<<atom, any meta…|2>…|1..>'s type"
 */
Semantic restriction "extend_with«_:_‡,»" is
[
	meta : object meta's type,
	newDefinitionTypes : <<atom, any meta…|2>…|1..>'s type
|
	supertype ::= meta's instance;
	oldDefinitions ::= supertype→map;
	newDefinitions : field type map := {};
	For each index from 1 to |newDefinitionTypes' leading types| + 1 do
	[
		def ::= newDefinitionTypes[index];
		atomType ::= def[1];
		newType ::= def[2]'s instance;
		If |atomType| ≠ 1 then
		[
			Reject parse, expected: "all field atoms to be known statically"
		];
		fieldAtom ::= atomType's instance;
		If fieldAtom ∈ newDefinitions then
		[
			Reject parse, expected:
				fieldAtom's name
				++ " to appear only once during extension (but it already\
				\| appeared with type = "
				++ “newDefinitions[fieldAtom]”
				++ ")"
		];
		oldType ::= oldDefinitions[fieldAtom] else [ any ];
		If ¬newType ⊆ oldType then
		[
			Reject parse, expected:
				"covariant specialization of "
				++ fieldAtom's name
				++ " (but new field type "
				++ “newType”
				++ " is not a subtype of "
				++ “oldType”
				++ ")"
		];
		newDefinitions := eject newDefinitions + fieldAtom→newType;
	];
	((supertype→tuple ++ newDefinitions' bindings)→object type)'s type
];

/**
 * Bind {@method "_'s⁇type"} more tightly than ad hoc {@type "object meta"
 * object type} extension.
 *
 * @method "_'s⁇type"
 * @forbids 1 "extend_with«_:_‡,»"
 */
Grammatical restriction "_'s⁇type" is <{"extend_with«_:_‡,»"}>;

"accessor name" is a new atom;

/**
 * Answer the default name of the accessor method for this field {@type "atom"}.
 *
 * @method "_'s⁇default accessor name"
 * @param "fieldAtom" "atom"
 * @returns "nonempty string"
 */
Private method "_'s⁇default accessor name" is
[
	fieldAtom : atom
|
	"_'s⁇" ++ fieldAtom's name
] : nonempty string;

/**
 * Answer the name of the accessor method for this field {@type "atom"}.
 *
 * @method "_'s⁇accessor name"
 * @param "fieldAtom" "atom"
 * @returns "nonempty string"
 */
Private method "_'s⁇accessor name" is
[
	fieldAtom : atom
|
	fieldAtom[accessor name]
];

Semantic restriction "_'s⁇accessor name" is
[
	fieldAtom : atom's type
|
	nonempty string
];

Private method "generate immutable read for_,_" is
[
	theObjectType : object meta,
	fieldAtomType : atom
|
	Primitive CreateObjectFieldGetter(
		failureCode : {no-such-field code}ᵀ);
	Invoke early failure function with <failureCode>
] : [⊥] → any;

/**
 * Generate the field accessor for the specified field declaration.
 *
 * @method "generate_field accessor for_:_(mutable=_)"
 * @param "objectType" "object's type"
 * @param "fieldAtom" "atom"
 * @param "fieldType" "any's type"
 * @param "mutable" "boolean"
 *        {@method "true"} if the field is mutable, {@method "false"} otherwise.
 * @returns "function"
 */
Private method "generate_field accessor for_:_(mutable=_)" is
[
	objectType : object meta,
	fieldAtom : atom,
	fieldType : any meta,
	mutable : boolean
|
	if ¬mutable then
	[
		generate immutable read for objectType, fieldAtom
	]
	else
	[
		args ::= <arg «(this token: obj) : objectType»>;
		objectPhrase ::= «↓args[1]»;
		getFieldSend ::= send $"_[_]"
			with «<objectPhrase, ‘fieldAtom’>» : fieldType;
		resultType ::=
			unless mutable then [fieldType]
			else
			[
				varType ::= cast fieldType into [t : variable's type | t];
				varType's read type
			];
		last ::=
			unless mutable then [getFieldSend]
			else [send  $"↓_" with «<getFieldSend>» : resultType];
		newBlock ::= «[args | <last>] : resultType»;
		newBlock→function
	]
];

/**
 * Generate the field accessor semantic restriction for the specified field
 * declaration.
 *
 * @method "generate field accessor restriction for_:_(mutable=_)"
 * @param "objectType" "object's type"
 * @param "fieldAtom" "atom"
 * @param "fieldType" "any's type"
 * @param "mutable" "boolean"
 *        {@method "true"} if the field is mutable, {@method "false"} otherwise.
 * @returns "function"
 */
Private method "generate_field accessor restriction for_:_(mutable=_)" is
[
	objectType : object meta,
	fieldAtom : atom,
	fieldType : any meta,
	mutable : boolean
|
	args ::= <arg «(this token: obj) : objectType's type»>;
	objectTypePhrase ::= «↓args[1]»;
	getFieldTypeSend ::= send $"_[_]"
		with «<objectTypePhrase, ‘fieldAtom’>» : fieldType's type;
	resultType ::=
		unless mutable then [fieldType's type]
		else
		[
			varType ::= cast fieldType into [t : variable meta | t];
			varType's read type's type
		];
	last ::=
		unless mutable then [getFieldTypeSend]
		else [send $"_'s⁇read type" with «<getFieldTypeSend>» : resultType];
	newBlock ::= «[args | <last>] : resultType»;
	newBlock→function
];

/**
 * Generate and install field type and field value accessors for the specified
 * object type and field atom. Generate and install a semantic restriction for
 * the field value accessor.
 *
 * @method "Generate and install_accessor for_"
 * @param "objectType" "object's type"
 *        An object type.
 * @param "isMutable" "boolean"
 *        {@method "true"} if the field is mutable, {@method "false"} otherwise.
 * @param "fieldAtom" "atom"
 *        A field atom.
 * @returns "⊤"
 */
Private method "Generate and install_accessor for«mutable»?_" is
[
	objectType : object meta,
	isMutable : boolean,
	fieldAtom : atom
|
	objectMap ::= objectType→map;
	methodName ::= fieldAtom's accessor name;
	methodAtom ::= atom for methodName;
	fieldType ::= objectMap[fieldAtom];
	defineClassAccessor : boolean := false;
	defineInstanceAccessor : boolean := false;
	/* If the method doesn't exist at all, then define it and install accessors.
	 */
	If ¬method exists named methodAtom
		∨ (methodAtom has definition for <objectType>
			∧ method definition of methodAtom for <objectType>
				∈ abstract definition)
	then
	[
		defineClassAccessor := true;
		defineInstanceAccessor := true;
	]
	/* If the method does already exist, then install accessors for the object
	 * type iff they are not already present.
	 */
	else
	[
		defineClassAccessor :=
			¬methodAtom has definition for <objectType's type>;
		defineInstanceAccessor :=
			¬methodAtom has definition for <objectType>;
	];
	If defineClassAccessor then
	[
		Method methodName is
			new [objectType's type]→(fieldType's type)
			applying [x : object meta | x[fieldAtom]];
		/* Install a semantic restriction if one does not already exist for this
		 * signature.
		 */
		theMethod ::= method for methodAtom;
		restrictions ::= semantic restrictions for theMethod
			given <objectType's type's type>;
		needToRestrict ::= ¬any r of restrictions satisfies
			[r's type[1] = (objectType's type's type)];
		If needToRestrict then
		[
			Semantic restriction methodName is
				new [objectType's type's type]→(any meta's type)
				applying
				[
					x : object meta's type
				|
					(x's instance[fieldAtom])'s type
				];
		];
	];
	If defineInstanceAccessor then
	[
		impl ::= generate objectType field accessor
			for fieldAtom : fieldType (mutable = isMutable);
		Method methodName is impl;
		/* Install a semantic restriction if one does not already exist for this
		 * signature.
		 */
		theMethod ::= method for methodAtom;
		restrictions ::=
			semantic restrictions for theMethod given <objectType's type>;
		needToRestrict ::= ¬any r of restrictions satisfies
			[r's type[1] = (objectType's type)];
		If needToRestrict then
		[
			sem ::= generate objectType field accessor restriction
				for fieldAtom : fieldType (mutable = isMutable);
			Semantic restriction methodName is sem;
		];
	];
] : ⊤;

"referrer name" is a new atom;

/**
 * Answer the default name of the referrer method for this field {@type "atom"}.
 *
 * @method "_'s⁇default referrer name"
 * @param "fieldAtom" "atom"
 * @returns "nonempty string"
 */
Private method "_'s⁇default referrer name" is
[
	fieldAtom : atom
|
	"`↑" ++ fieldAtom's default accessor name
] : nonempty string;

/**
 * Answer the name of the referrer method for this field {@type "atom"}.
 *
 * @method "_'s⁇referrer name"
 * @param "fieldAtom" "atom"
 * @returns "nonempty string"
 */
Private method "_'s⁇referrer name" is
[
	fieldAtom : atom
|
	fieldAtom[referrer name]
];

Semantic restriction "_'s⁇referrer name" is
[
	fieldAtom : atom's type
|
	nonempty string
];

/**
 * Generate and install the field referrer for the specified object type and
 * mutable field atom.
 *
 * @method "Generate and install_referrer for_"
 * @param "objectType" "object's type"
 * @param "fieldAtom" "atom"
 * @returns "⊤"
 */
Private method "Generate and install_referrer for mutable_" is
[
	objectType : object meta,
	fieldAtom : atom
|
	objectMap ::= objectType→map;
	methodName ::= fieldAtom's referrer name;
	methodAtom ::= atom for methodName;
	fieldType ::= objectMap[fieldAtom];
	defineReferrer : boolean :=
		if ¬method exists named methodAtom
			∨ (methodAtom has definition for <objectType>
				∧ method definition of methodAtom for <objectType>
					∈ abstract definition)
		then
		[
			/* If the method doesn't exist at all, then define it and install a
			 * referrer.
			 */
			true
		]
		else
		[
			/* If the method does already exist, then install a referrer for the
			 * object type iff one is not already present.
			 */
			¬methodAtom has definition for <objectType>
		];
	If defineReferrer then
	[
		impl ::= generate objectType field accessor
			for fieldAtom : fieldType (mutable = false);
		Method methodName is impl;
	];
] : ⊤;

"mutator name" is a new atom;

/**
 * Answer the default name of the mutator method for this field {@type "atom"}.
 *
 * @method "_'s⁇default mutator name"
 * @param "fieldAtom" "atom"
 * @returns "nonempty string"
 */
Private method "_'s⁇default mutator name" is
[
	fieldAtom : atom
|
	"_'s⁇" ++ fieldAtom's name ++ ":=_"
] : nonempty string;

/**
 * Answer the name of the mutator method for this field {@type "atom"}.
 *
 * @method "_'s⁇mutator name else_"
 * @param "fieldAtom" "atom"
 * @returns "nonempty string"
 */
Private method "_'s⁇mutator name" is
[
	fieldAtom : atom
|
	fieldAtom[mutator name]
];

Semantic restriction "_'s⁇mutator name" is
[
	fieldAtom : atom's type
|
	nonempty string
];

/**
 * Generate and install the mutator for the specified object type and mutable
 * field atom.
 *
 * @method "Generate and install_mutator for_"
 * @param "objectType" "object's type"
 * @param "fieldAtom" "atom"
 * @returns "⊤"
 */
Private method "Generate and install_mutator for mutable_" is
[
	objectType : object meta,
	fieldAtom : atom
|
	methodName ::= fieldAtom's mutator name;
	methodAtom ::= atom for methodName;
	fieldType ::= objectType[fieldAtom];
	defineMutator : boolean :=
		if ¬method exists named methodAtom
			∨ (methodAtom has definition for <objectType, ⊥>
				∧ method definition of methodAtom for <objectType, ⊥>
					∈ abstract definition)
		then
		[
			/* If the method doesn't exist at all, then define it and install a
			 * referrer.
			 */
			true
		]
		else
		[
			/* If the method does already exist, then install a referrer for the
			 * object type iff one is not already present.
			 */
			varType ::= cast fieldType into [t : variable's type | t];
			readType ::= cast varType's read type into [t : any's type | t];
			¬methodAtom has definition for <objectType, readType>
		];
	If defineMutator then
	[
		varType ::= cast fieldType into [t : variable's type | t];
		readType ::= cast varType's read type into [t : any's type | t];
		objToken ::= this token: obj;
		fieldToken ::= this token: field;
		args ::= <arg «objToken : objectType», arg «fieldToken : readType»>;
		objectPhrase ::= «↓args[1]»;
		getFieldSend ::= send $"_[_]"
			with «<objectPhrase, ‘fieldAtom’>» : varType;
		putSend ::= send $"_`?=_" with «<getFieldSend, «↓args[2]»>» : ⊤;
		newBlock ::= «[args | <putSend>] : ⊤»;
		impl ::= newBlock→function;
		Method methodName is impl;
	];
] : ⊤;

/**
 * Construct and answer the name of the object reconstructor method from the
 * specified tuple of field atoms.
 *
 * @method "reconstructor name for_"
 * @param "fieldAtoms" "atom+"
 *        The atoms of the fields migrated by the reconstructor.
 * @returns "string"
 *          The appropriate method name.
 */
Private method "reconstructor name for_" is
[
	fieldAtoms : atom+
|
	methodName : nonempty string := fieldAtoms[1]'s accessor name ++ "::=_";
	For each fieldAtom of fieldAtoms' tail do
	[
		methodName :=
			eject methodName ++ "," ++ fieldAtom's accessor name[5..] ++ "::=_";
	];
	methodName
];

/**
 * Construct and answer the name of the object reconstructor method from the
 * specified tuple of field atom names.
 *
 * @method "reconstructor name for_"
 * @param "fieldAtomNames" "nonempty string+"
 *        The names of the fields migrated by the reconstructor.
 * @returns "string"
 *          The appropriate method name.
 */
Private method "reconstructor name for_" is
[
	fieldAtomNames : nonempty string+
|
	methodName : nonempty string := fieldAtomNames[1] ++ "::=_";
	For each fieldAtomName of fieldAtomNames' tail do
	[
		methodName := eject methodName ++ "," ++ fieldAtomName[5..] ++ "::=_";
	];
	methodName
];

/**
 * Construct and answer a tuple of argument declarations for an object
 * reconstructor method (or its semantic restriction).
 *
 * @method "_reconstructor arguments for_«(for semantic restriction)»?"
 * @param "objectType" "object's type"
 *        The object type.
 * @param "fieldAtoms" "atom+"
 *        The atoms of the fields migrated by the reconstructor.
 * @param "forSemanticRestriction" "boolean"
 *        {@method "true"} if the argument declarations should be generated for
 *        the semantic restriction, {@method "false"} if they should be
 *        generated for the method.
 * @returns "<argument phrase…|2..>"
 *          The requested argument declarations. The first declaration is for
 *          the object type (or metatype) and the remaining correspond to the
 *          field atoms.
 */
Private method "_reconstructor arguments for_«(for semantic restriction)»?" is
[
	objectType : object meta,
	fieldAtoms : atom+,
	forRestriction : boolean
|
	meta ::= if forRestriction then [objectType's type] else [objectType];
	objectMap ::= objectType→map;
	<arg «`"target"` : meta»> ++ map fieldAtoms through
	[
		fieldAtom : atom,
		index : natural number
	|
		desc ::= “index”;
		argType ::= if forRestriction
			then [objectMap[fieldAtom]'s type]
			else [objectMap[fieldAtom]];
		arg «`"arg" ++ desc` : argType»
	]
] : <argument phrase…|2..>;

/* This atom marks field atoms as sharable across reconstructions. */
"shared" is a new atom;

/**
 * Generate and install a reconstructor for the specified object type and tuple
 * of field atoms.
 *
 * @method "Generate and install_reconstructor for_"
 * @param "objectType" "object's type"
 * @param "fieldAtoms" "atom+"
 * @returns "⊤"
 */
Private method "Generate and install_reconstructor for_" is
[
	objectType : object meta,
	fieldAtoms : atom+
|
	methodName ::= reconstructor name for fieldAtoms;
	args ::= objectType reconstructor arguments for fieldAtoms;
	/* Emit code to convert the object to a map. */
	toMapMSend ::= send $"_→map" with «<«↓args[1]»>» : field map;
	mapDecl ::= «`"objectMap"` : field map := toMapMSend»;
	/* Emit code to migrate the target fields to their new values. */
	assignments ::= map each fieldAtom, index in fieldAtoms through
		[
			ejectSend ::= send $"eject_" with «<«↑«↓mapDecl»»>» : field map;
			addBindingSend ::= send $"_+_→_"
				with «<ejectSend, ‘fieldAtom’, «↓args[index + 1]»>»
				: field map;
			««↓mapDecl» := addBindingSend»
		];
	/* Emit code to clone any mutable fields that are not explicitly being
	 * shared. Take care not to read any unassigned mutable fields.
	 */
	cloning : phrase* := <>;
	For each fieldAtom → fieldType of objectType→map do
	[
		If ¬shared ∈ fieldAtom ∧ fieldType ⊆ variable then
		[
			varType ::= cast fieldType into [t : variable meta | t];
			readType ::= cast varType's read type into [t : any meta | t];
			mapAtSend ::= send $"_[_]"
				with «<«↓mapDecl», ‘fieldAtom’>» : varType;
			decl ::= «`fieldAtom's name` : readType»;
			assignedSend ::= send $"_is assigned" with «<mapAtSend>» : boolean;
			getSend ::= send  $"↓_" with «<mapAtSend>» : readType;
			fieldAssign ::= ««↓decl» := getSend»;
			ifBlock ::= «[<fieldAssign>] : ⊤»;
			ifSend ::= send $"If_then_" with «<assignedSend, ifBlock>» : ⊤;
			ejectSend ::= send $"eject_" with «<«↑«↓mapDecl»»>» : field map;
			addBindingSend ::= send $"_+_→_"
				with «<ejectSend, ‘fieldAtom’, «↑«↓decl»»>»
				: field map;
			mapAssign ::= ««↓mapDecl» := addBindingSend»;
			cloning := eject cloning ++ <decl, ifSend, mapAssign>;
		];
	];
	/* Convert the map back to an object. */
	last ::= send $"_→object" with «<«↓mapDecl»>» : objectType;
	/* Build and install the implementation. */
	statements ::= <mapDecl> ++ assignments ++ cloning ++ <last>;
	newBlock ::= «[ args | statements ] : objectType»;
	reconstructorFunction ::= newBlock→function;
	Method methodName is reconstructorFunction;
] : ⊤;

/**
 * Generate and install a semantic restriction for the reconstructor for the
 * specified object type and tuple of field atoms.
 *
 * @method "Generate and install_reconstructor's semantic restriction for_"
 * @param "objectType" "object's type"
 *        An object type.
 * @param "fieldAtoms" "atom+"
 *        A field atoms.
 * @returns "⊤"
 */
Private method "Generate and install_reconstructor's semantic restriction for_"
is
[
	objectType : object meta,
	fieldAtoms : atom+
|
	methodName ::= reconstructor name for fieldAtoms;
	args ::= objectType reconstructor arguments for fieldAtoms
		(for semantic restriction);
	/* Construct the body of the semantic restriction method. */
	toMapMSend ::= send $"_→map" with «<«↓args[1]»>» : field type map;
	mapDecl ::= «`"objectMap"` : field type map := toMapMSend»;
	assignments ::= map each fieldAtom, index in fieldAtoms through
		[
			ejectSend ::=
				send $"eject_" with «<«↑«↓mapDecl»»>» : field type map;
			addBindingSend ::= send $"_+_→_"
				with «<ejectSend, ‘fieldAtom’, «↓args[index + 1]»>»
				: field type map;
			««↓mapDecl» := addBindingSend»
		];
	last ::= send $"_→object type" with «<«↓mapDecl»>» : objectType's type;
	statements ::= <mapDecl> ++ assignments ++ <last>;
	newBlock ::= «[ args | statements ] : type»;
	Semantic restriction methodName is newBlock→function;
];

/**
 * Define a class. In Avail, a class is simply a named object type supported by
 * 1) a generated method that reliably reproduces the object type, 2) generated
 * methods that provide access to the field definitions, and 3) generated
 * methods that provide access to instance field values. A class is essentially
 * only a lexical construct, and is analogous to the distinction between blocks
 * (lexical) and functions (semantic).
 *
 * @method
 *   "«Public»?«Explicit|explicit»?\
 *     \|Class|class_extends_\
 *     \|«with immutable⁇field|fields««public»?«reconstructible»?_:_«(accessor⁇_)»‡,»»\
 *     \|«with mutable field|fields««public»?«shared»?«referable»?«read-only»?\
 *       \|_:_«(««accessor|mutator|referrer»!_‡,»)»‡,»»\
 *     \|«with reconstructor|reconstructors««public»?(«_‡,»)‡,»»"
 * @param "public" "boolean"
 *        {@method "true"} if the class should be exported by the defining
 *        module, {@method "false"} otherwise.
 * @param "explicit" "boolean"
 *        {@method "true"} if the class should have an artificial identity
 *        introduced (in order to ensure intentional provenance of subtypes),
 *        {@method "false"} otherwise.
 * @param "className" "nonempty string"
 *        The name of the class. A method will be generated with this name. This
 *        method will answer the object type. The object type will also be
 *        christened with this name.
 * @param "supertype" "object's type"
 *        The supertype of the class. Type intersection may be used here to
 *        facilitate inheritance from multiple sources.
 * @param "optionalImmutable"
 *        "<
 *           <
 *             <
 *               boolean,
 *               boolean,
 *               atom,
 *               any meta,
 *               nonempty string?…
 *             |5>…
 *           |1..>…
 *         |0..1>"
 *        The extension fields of this class. An accessor will be generated for
 *        each field. A reconstructor will be generated for each field tagged as
 *        {@code reconstructible}. Each field tagged as {@code public} must be
 *        exported by the defining module. Unless a parenthetical name appears
 *        after a field's type, then its accessor will be given a default name
 *        ("_'s⁇" ++ the field name).
 * @param "optionalMutable"
 *        "<
 *           <
 *             <
 *               boolean,
 *               boolean,
 *               boolean,
 *               boolean,
 *               atom,
 *               any meta,
 *               <
 *                 <
 *                   <
 *                     [1..3],
 *                     nonempty string…
 *                   |2>…
 *                 |1..3>…
 *               |0..1>…
 *             |7>…
 *           |1..>…
 *         |0..1>"
 *        The mutable fields of this class. An accessor will be generated for
 *        each field. A referrer will be generated for each field tagged as
 *        {@code referable}. A mutator will be generated for each field not
 *        tagged as {@code read-only}. Each field tagged as {@code public} must
 *        have its accessor, referrer, and mutator exported by the defining
 *        module. Each field tagged as {@code shared} will not be cloned (using
 *        a new variable) during reconstruction. Unless parenthetical names
 *        appear after a field's type, then the accessor, mutator, and referrer
 *        will be given default names as appropriate.
 * @param "optionalReconstructors"
 *        "<<<boolean, atom+…|2>…|1..>…|0..1>"
 *        The reconstructors of this class. A reconstructor will be generated
 *        for each specification tuple. Each reconstructor tagged as {@code
 *        public} must be exported by the defining module.
 * @returns "⊤"
 * @category "Objects" "Types" "Declarations"
 */
Public method
	"«Public»?«Explicit|explicit»?\
	\|Class|class_extends_\
	\|«with immutable⁇field|fields««public»?«reconstructible»?_:_«(accessor⁇_)»‡,»»\
	\|«with mutable field|fields««public»?«shared»?«referable»?«read-only»?\
		\|_:_«(««accessor|mutator|referrer»!_‡,»)»‡,»»\
	\|«with reconstructor|reconstructors««public»?(«_‡,»)‡,»»"
is
[
	public : boolean,
	explicit : boolean,
	className : nonempty string,
	supertype : object meta,
	optionalImmutable :
		<
			boolean,
			boolean,
			atom,
			any meta,
			nonempty string?…
		|5>+?,
	optionalMutable :
		<
			boolean,
			boolean,
			boolean,
			boolean,
			atom,
			any meta,
			<
				<
					[1..3],
					nonempty string…
				|2>…
			|1..3>?…
		|7>+?,
	optionalReconstructors : <boolean, atom+…|2>+?
|
	newDefinitions : <<atom, any meta…|2>…|> := <>;
	/* Extract the immutable extensions. */
	immutable :
			<
				boolean,
				boolean,
				atom,
				any meta,
				nonempty string?…
			|5>*
		:= <>;
	Unless optionalImmutable is empty then
	[
		immutable := optionalImmutable[1];
		newDefinitions := map each fieldTuple in immutable through
			[
				fieldAtom ::= fieldTuple[3];
				<fieldAtom, fieldTuple[4]>
			];
	];
	/* Extract the mutable fields. */
	mutable :
			<
				boolean,
				boolean,
				boolean,
				boolean,
				atom,
				any meta,
				<
					<
						[1..3],
						nonempty string…
					|2>…
				|1..3>?…
			|7>*
		:= <>;
	Unless optionalMutable is empty then
	[
		mutable := optionalMutable[1];
		newDefinitions := eject newDefinitions ++
			map each fieldTuple in mutable through
			[
				fieldAtom ::= fieldTuple[5];
				<fieldAtom, ↑fieldTuple[6]>
			];
	];
	/* Verify the uniqueness of the field atoms. */
	fieldAtoms ::= stripe newDefinitions at 1;
	If |fieldAtoms→set| ≠ |fieldAtoms| then
	[
		early failure function(object-type-extension-contains-duplicates code)
	];
	/* If necessary, then generate a field definition that guarantees
	 * uniqueness among object types.
	 */
	explicitDef : <atom, any meta…|2>? := <>;
	If explicit then
	[
		explicitAtom ::= new explicit subclass atom named
			"explicit-" ++ className;
		explicitDef := <<explicitAtom, explicitAtom's type>>;
	];
	/* Construct and verify the subtype. */
	subtype ::= (supertype→tuple ++ newDefinitions ++ explicitDef)→object type;
	If ¬subtype ⊆ supertype then
	[
		early failure function(
			object-type-extension-did-not-produce-subtype code)
	];
	/* Define the class: give the object type a name, define a method that
	 * answers the object type, and define methods that access the field
	 * definitions and values.  Also make sure to remove the name if this module
	 * is ever unloaded.
	 */
	subtype's name := className;
	/* Define local temps, since the unload function will be made shared, and
	 * that causes any used outer variables to become shared as well, which
	 * disables the quick-loader summarization mechanism when a shared
	 * variable is subsequently read from further along in this method.
	 */
	classNameShared ::= className;
	subtypeShared ::= subtype;
	After the current module is unloaded,
		do [Unname classNameShared from subtypeShared;];
	classNameBlock ::=
		«[
			<>
		|
			<
				`subtype`(className) → literal phrase
			>
		] : subtype's type»;
	classNameFunction ::= classNameBlock → function;
	Method className is classNameFunction;
	For each fieldTuple of immutable do
	[
		fieldAtom ::= fieldTuple[3];
		accessorName ::= fieldTuple[5][1]
			else [fieldAtom's default accessor name];
		If |message accessorName's parameters| ≠ 1 then
		[
			early failure function(invalid-argument code)
		];
		If ¬accessor name ∈ fieldAtom then
		[
			fieldAtom[accessor name] := accessorName;
		];
		If fieldAtom's accessor name ≠ accessorName then
		[
			early failure function(
				object-type-extension-changed-field-accessor-name code)
		];
		Generate and install subtype accessor for fieldAtom;
	];
	For each fieldTuple of mutable do
	[
		isShared ::= fieldTuple[2];
		referable ::= fieldTuple[3];
		readOnly ::= fieldTuple[4];
		fieldAtom ::= fieldTuple[5];
		namesTuple ::= fieldTuple[7][1] else [<>];
		orderedNames : <nonempty string…|3> :=
			<
				fieldAtom's default accessor name,
				fieldAtom's default mutator name,
				fieldAtom's default referrer name
			>;
		For each namePair of namesTuple do
		[
			orderedNames := eject orderedNames[namePair[1]]→namePair[2];
		];
		/* The shared flag must be set on the field atom *before* any
		 * reconstructors are generated!
		 */
		If isShared then [fieldAtom[shared] := true;];
		/* Set the accessor, referrer, and mutator names for the atom, if
		 * necessary. These names should not be changed in subtypes.
		 */
		accessorName ::= orderedNames[1];
		If |message accessorName's parameters| ≠ 1 then
		[
			early failure function(invalid-argument code)
		];
		If ¬accessor name ∈ fieldAtom then
		[
			fieldAtom[accessor name] := accessorName;
		];
		If fieldAtom's accessor name ≠ accessorName then
		[
			early failure function(
				object-type-extension-changed-field-accessor-name code)
		];
		mutatorName ::= orderedNames[2];
		If |message mutatorName's parameters| ≠ 2 then
		[
			early failure function(invalid-argument code)
		];
		If ¬mutator name ∈ fieldAtom then
		[
			fieldAtom[mutator name] := mutatorName;
		];
		If fieldAtom's mutator name ≠ mutatorName then
		[
			early failure function(
				object-type-extension-changed-field-mutator-name code)
		];
		referrerName ::= orderedNames[3];
		If |message referrerName's parameters| ≠ 1 then
		[
			early failure function(invalid-argument code)
		];
		If ¬referrer name ∈ fieldAtom then
		[
			fieldAtom[referrer name] := referrerName;
		];
		If fieldAtom's referrer name ≠ referrerName then
		[
			early failure function(
				object-type-extension-changed-field-referrer-name code)
		];
		/* Now install the accessor, referrer, and mutator, as appropriate. */
		Generate and install subtype accessor for mutable fieldAtom;
		If referable then
		[
			Generate and install subtype referrer for mutable fieldAtom;
		];
		Unless readOnly then
		[
			Generate and install subtype mutator for mutable fieldAtom;
		];
	];
	/* Determine which reconstructors to create. */
	reconstructors : <atom+…|> := map and filter immutable by
		[
			triple :
				<
					boolean,
					boolean,
					atom,
					any meta,
					nonempty string?…
				|5>,
			accept : [atom+]→⊤
		|
			If triple[2] then
			[
				accept(<triple[3]>);
			];
		];
	Unless optionalReconstructors is empty then
	[
		specs ::= optionalReconstructors[1];
		reconstructors := eject reconstructors ++
			map each spec in specs through [spec[2]];
	];
	/* Generate the reconstructors. */
	For each atoms of reconstructors do
	[
		Generate and install subtype reconstructor for atoms;
		Generate and install subtype reconstructor's semantic restriction
			for atoms;
	];
] : ⊤;

/**
 * Class definition statically requires that:
 *
 * - Every field atom of the extension is known.
 * - Each field atom of the extension appears only once during extension.
 * - Each field atom of the extension is either 1) not present in the supertype
 *   or 2) specifies a type which covaries with the field type expressed in the
 *   supertype.
 *
 * @method
 *   "«Public»?«Explicit|explicit»?\
 *     \|Class|class_extends_\
 *     \|«with immutable⁇field|fields««public»?«reconstructible»?_:_«(accessor⁇_)»‡,»»\
 *     \|«with mutable field|fields««public»?«shared»?«referable»?«read-only»?\
 *       \|_:_«(««accessor|mutator|referrer»!_‡,»)»‡,»»\
 *     \|«with reconstructor|reconstructors««public»?(«_‡,»)‡,»»"
 * @restricts "boolean's type"
 * @restricts "boolean's type"
 * @restricts "nonempty string's type"
 * @restricts "object's type"
 * @restricts
 *        "<
 *           <
 *             <
 *               boolean,
 *               boolean,
 *               atom,
 *               any meta,
 *               nonempty string?…
 *             |5>…
 *           |1..>…
 *         |0..1>'s type"
 * @restricts
 *        "<
 *           <
 *             <
 *               boolean,
 *               boolean,
 *               boolean,
 *               boolean,
 *               atom,
 *               any meta,
 *               <
 *                 <
 *                   <
 *                     [1..3],
 *                     nonempty string…
 *                   |2>…
 *                 |1..3>…
 *               |0..1>…
 *             |7>…
 *           |1..>…
 *         |0..1>'s type"
 * @restricts "<boolean, atom+…|2>+?'s type"
 */
Semantic restriction
	"«Public»?«Explicit|explicit»?\
	\|Class|class_extends_\
	\|«with immutable⁇field|fields««public»?«reconstructible»?_:_«(accessor⁇_)»‡,»»\
	\|«with mutable field|fields««public»?«shared»?«referable»?«read-only»?\
		\|_:_«(««accessor|mutator|referrer»!_‡,»)»‡,»»\
	\|«with reconstructor|reconstructors««public»?(«_‡,»)‡,»»"
is
[
	publicType : boolean's type,
	explicit : boolean's type,
	classNameType : nonempty string's type,
	meta : object meta's type,
	optionalImmutable :
		<
			boolean,
			boolean,
			atom,
			any meta,
			nonempty string?…
		|5>+?'s type,
	optionalMutable :
		<
			boolean,
			boolean,
			boolean,
			boolean,
			atom,
			any meta,
			<
				<
					[1..3],
					nonempty string…
				|2>…
			|1..3>?…
		|7>+?'s type,
	optionalReconstructors : <boolean, atom+…|2>+?'s type
|
	public ::= publicType's instance;
	If public ∧ |classNameType| ≠ 1 then
	[
		Reject parse, expected:
			"public class modifier to be provided only when the class name \
			\|is statically known"
	];
	If |classNameType| = 1 then
	[
		className ::= classNameType's instance;
		If public ∧ ¬current module has public name className then
		[
			Reject parse, expected:
				"\""
				++ className
				++ "\" to be included in the module's \"Names\" section"
		];
	];
	supertype ::= meta's instance;
	oldDefinitions ::= supertype→map;
	newDefinitions : field type map := {};
	allNamesTuple : tuple := <>;
	namesByAtom : {atom→nonempty string|} := {};
	For each index from 1 to relevant |optionalImmutable[1]| do
	[
		def ::= optionalImmutable[1][index];
		publicField ::= def[1]'s instance;
		reconstructible ::= def[2]'s instance;
		atomType ::= def[3];
		newType ::= def[4]'s instance;
		If |atomType| = 1 then
		[
			fieldAtom ::= atomType's instance;
			nameType ::= if def[5][1] = ⊥
				then [fieldAtom's default accessor name's type]
				else [def[5][1]];
			If publicField then
			[
				If ¬public then
				[
					Reject parse, expected:
						"field atom \""
						++ fieldAtom's name
						++ "\" to be private (because the class is private)"
				];
				If |nameType| ≠ 1 then
				[
					Reject parse, expected:
						"accessor name for public field atom \""
						++ fieldAtom's name
						++ "\" to be statically known"
				];
				accessorName ::= nameType's instance;
				If |message accessorName's parameters| ≠ 1 then
				[
					Reject parse, expected:
						"accessor name \""
						++ accessorName
						++ "\" to specify exactly one underscore"
				];
				namesByAtom := eject namesByAtom + fieldAtom → accessorName;
				extantName ::= cast fieldAtom[accessor name] else [accessorName]
					into [t : nonempty string | t];
				If accessorName ≠ extantName then
				[
					Reject parse, expected:
						"accessor name \""
						++ accessorName
						++ "\" to agree with previous definition ("
						++ extantName
						++ ")"
				];
				If ¬current module has public name accessorName then
				[
					Reject parse, expected:
						"\""
						++ accessorName
						++ "\" to be included in the module's \"Names\" section\
						\| (because it is public)"
				];
				If reconstructible then
				[
					reconstructorName ::= reconstructor name for <accessorName>;
					If ¬current module has public name reconstructorName then
					[
						Reject parse, expected:
							"\""
							++ reconstructorName
							++ "\" to be included in the module's \"Names\"\
								\| section (because it is public)"
					];
				];
				allNamesTuple := eject allNamesTuple ++ <accessorName>;
			];
			If fieldAtom ∈ newDefinitions then
			[
				Reject parse, expected:
					fieldAtom's name
					++ " to appear only once during extension (but it already\
					\| appeared with type = "
					++ “newDefinitions[fieldAtom]”
					++ ")"
			];
			oldType ::= oldDefinitions[fieldAtom] else [any];
			If ¬newType ⊆ oldType then
			[
				Reject parse, expected:
					"covariant specialization of "
					++ fieldAtom's name
					++ " (but new field type "
					++ “newType”
					++ " is not a subtype of "
					++ “oldType”
					++ ")"
			];
			newDefinitions := eject newDefinitions + fieldAtom→newType;
		];
	];
	For each index from 1 to relevant |optionalMutable[1]| do
	[
		def ::= optionalMutable[1][index];
		publicField ::= def[1]'s instance;
		referable ::= def[3]'s instance;
		readOnly ::= def[4]'s instance;
		atomType ::= def[5];
		newType ::= def[6]'s instance;
		If |atomType| = 1 then
		[
			fieldAtom ::= atomType's instance;
			orderedNames : <nonempty string's type…|3> :=
			<
				fieldAtom's default accessor name's type,
				fieldAtom's default mutator name's type,
				fieldAtom's default referrer name's type
			>;
			If def[7][1] ≠ ⊥ then
			[
				namesType ::= def[7][1];
				choicesSeen : {[1..3]|} := ∅;
				For each nameIndex from 1 to relevant |namesType| do
				[
					nameTuple ::= namesType[nameIndex];
					choice ::= nameTuple[1]'s instance;
					If choice ∈ choicesSeen then
					[
						choiceNames ::= <"accessor", "mutator", "referrer">;
						Reject parse, expected:
							choiceNames[choice]
							++ " name not to be supplied more than once"
					];
					choicesSeen := eject choicesSeen + choice;
					orderedNames := eject orderedNames[choice]→nameTuple[2];
				];
			];
			If publicField then
			[
				If ¬public then
				[
					Reject parse, expected:
						"field atom \""
						++ fieldAtom's name
						++ "\" to be private (because the class is private)"
				];
				If |orderedNames[1]| ≠ 1 then
				[
					Reject parse, expected:
						"accessor name for public field atom \""
						++ fieldAtom's name
						++ "\" to be statically known"
				];
				accessorName ::= orderedNames[1]'s instance;
				If |message accessorName's parameters| ≠ 1 then
				[
					Reject parse, expected:
						"accessor name \""
						++ accessorName
						++ "\" to specify exactly one underscore"
				];
				extantAccessorName ::=
					cast fieldAtom[accessor name] else [accessorName]
					into [t : nonempty string | t];
				If accessorName ≠ extantAccessorName then
				[
					Reject parse, expected:
						"accessor name \""
						++ accessorName
						++ "\" to agree with previous definition ("
						++ extantAccessorName
						++ ")"
				];
				If ¬current module has public name accessorName then
				[
					Reject parse, expected:
						"\""
						++ accessorName
						++ "\" to be included in the module's \"Names\" section\
						\| (because it is public)"
				];
				allNamesTuple := eject allNamesTuple ++ <accessorName>;
				If referable then
				[
					If |orderedNames[3]| ≠ 1 then
					[
						Reject parse, expected:
							"referrer name for public field atom \""
							++ fieldAtom's name
							++ "\" to be statically known"
					];
					referrerName ::= orderedNames[3]'s instance;
					If |message referrerName's parameters| ≠ 1 then
					[
						Reject parse, expected:
							"referrer name \""
							++ referrerName
							++ "\" to specify exactly one underscore"
					];
					extantReferrerName ::=
						cast fieldAtom[referrer name] else [referrerName]
						into [t : nonempty string | t];
					If referrerName ≠ extantReferrerName then
					[
						Reject parse, expected:
							"referrer name \""
							++ referrerName
							++ "\" to agree with previous definition ("
							++ extantReferrerName
							++ ")"
					];
					If ¬current module has public name referrerName then
					[
						Reject parse, expected:
							"\""
							++ referrerName
							++ "\" to be included in the module's \"Names\"\
								\| section (because it is public)"
					];
					allNamesTuple := eject allNamesTuple ++ <referrerName>;
				]
				else
				[
					If def[7][1] ≠ ⊥ then
					[
						namesType ::= def[7][1];
						For each nameIndex from 1 to relevant |namesType| do
						[
							nameTuple ::= namesType[nameIndex];
							choice ::= nameTuple[1]'s instance;
							If choice = 3 then
							[
								Reject parse, expected:
									"referrer name to be omitted for \
									\|non-referable field \""
									++ fieldAtom's name
									++ "\""
							];
						];
					];
				];
				Unless readOnly then
				[
					If |orderedNames[2]| ≠ 1 then
					[
						Reject parse, expected:
							"mutator name for public field atom \""
							++ fieldAtom's name
							++ "\" to be statically known"
					];
					mutatorName ::= orderedNames[2]'s instance;
					If |message mutatorName's parameters| ≠ 2 then
					[
						Reject parse, expected:
							"mutator name \""
							++ mutatorName
							++ "\" to specify exactly two underscores"
					];
					extantMutatorName ::=
						cast fieldAtom[mutator name] else [mutatorName]
						into [t : nonempty string | t];
					If mutatorName ≠ extantMutatorName then
					[
						Reject parse, expected:
							"mutator name \""
							++ mutatorName
							++ "\" to agree with previous definition ("
							++ extantMutatorName
							++ ")"
					];
					If ¬current module has public name mutatorName then
					[
						Reject parse, expected:
							"\""
							++ mutatorName
							++ "\" to be included in the module's \"Names\"\
								\| section (because it is public)"
					];
					allNamesTuple := eject allNamesTuple ++ <mutatorName>;
				];
			];
			If fieldAtom ∈ newDefinitions then
			[
				Reject parse, expected:
					fieldAtom's name
					++ " to appear only once during extension (but it already\
					\| appeared with type = "
					++ “newDefinitions[fieldAtom]”
					++ ")"
			];
			oldType ::= oldDefinitions[fieldAtom] else [newType];
			Unless newType = oldType then
			[
				Reject parse, expected:
					"equivalent specification of "
					++ fieldAtom's name
					++ " (but new field type "
					++ “newType”
					++ " is not equivalent to "
					++ “oldType”
					++ ")"
			];
			newDefinitions := eject newDefinitions + fieldAtom→newType;
		];
	];
	For each index from 1 to relevant |optionalReconstructors[1]| do
	[
		spec ::= optionalReconstructors[1][index];
		publicSpec ::= spec[1]'s instance;
		atomsType ::= spec[2];
		fieldAtoms : atom* := <>;
		For each atomTypeIndex from 1 to relevant |atomsType| do
		[
			atomType ::= atomsType[atomTypeIndex];
			If |atomType| = 1 then
			[
				fieldAtoms := eject fieldAtoms ++ <atomType's instance>;
			];
		];
		If publicSpec ∧ |fieldAtoms| = relevant |atomsType| then
		[
			nonemptyFieldAtoms ::= cast fieldAtoms into [ t : atom+ | t ];
			reconstructorName ::= reconstructor name for
				map each a of nonemptyFieldAtoms through [namesByAtom[a]];
			If ¬public then
			[
				Reject parse, expected:
					"\""
					++ reconstructorName
					++ "\" to be private (because the class is private)"
			];
			If ¬current module has public name reconstructorName then
			[
				Reject parse, expected:
					"\""
					++ reconstructorName
					++ "\" to be included in the module's \"Names\" section\
					\| (because it is public)"
			];
		];
	];
	If |allNamesTuple| ≠ |allNamesTuple→set| then
	[
		Reject parse, expected:
			"no duplication of names among accessors, mutators, and referrers"
	];
	⊤
];

/**
 * Construct and answer an object which is an instance of {@param "objectType"}
 * and whose field values are determined by {@param "optional"}.
 *
 * @method "a|an_«with«_«:»?:=_‡,»»"
 * @param "objectType" "object's type"
 *        An object type that must be a supertype of the answer.
 * @param "optional" "<<<atom, boolean, any…|3>…|1..>…|0..1>"
 *        A tuple of field assignments. The outermost tuple may be empty (but
 *        only to support the case that {@code "objectType = object"}), but
 *        usually contains a single tuple of field assignments. A field
 *        assignment is a 3-tuple that consists of 1) an atom that uniquely
 *        identifies the field, 2) a boolean that is {@method "false"} if the
 *        field is mutable and a variable should be created and initialized, and
 *        3) the field value.
 * @returns "object"
 *          The requested object type.
 * @category "Objects" "Constructors"
 */
Public method "a|an_«with«_«:»?:=_‡,»»" is
[
	objectType : object meta,
	optional : <<<atom, boolean, any…|3>…|1..>…|0..1>
|
	objectMap ::= objectType→map;
	defs ::= optional[1] else [<>];
	fieldAtoms : {atom|} := ∅;
	/* Process each field definition, ensuring its uniqueness. Create
	 * appropriately typed variables whenever assignment forms are encountered.
	 */
	assignments ::=
		map each def in defs through
		[
			fieldAtom ::= def[1];
			If fieldAtom ∈ fieldAtoms then
			[
				early failure function(
					object-instantiation-contains-duplicates code)
			];
			fieldAtoms := eject fieldAtoms + fieldAtom;
			/* If the assignment form (:=) was used, then create a new variable
			 * and initialize it with the specified value.
			 */
			value ::= def[3];
			/* Construct the field assignment. */
			<fieldAtom,
				if ¬def[2] then
				[
					/* The semantic restriction ensures that this will not fail
					 * at runtime.
					 */
					cast objectMap[fieldAtom] into
					[
						varType : variable meta
					|
						readType ::= cast varType's read type
							into [t : any meta | t];
						var ::= new ↑readType;
						var ?= value;
						var
					]
				]
				else
				[
					value
				]>
		];
	/* Synthesize assignments whenever appropriate and necessary, taking care
	 * not to override any user assignments.
	 */
	syntheticAssignments : field tuple := <>;
	For each fieldAtom → fieldType of objectMap do
	[
		/* Don't override the user's assignments. */
		If ¬fieldAtom ∈ fieldAtoms then
		[
			/* Any field whose type is an instance type on a nontype may have
			 * its value synthesized.
			 */
			If |fieldType| = 1 ∧ fieldType ⊆ nontype then
			[
				syntheticAssignments := eject syntheticAssignments
					++ <<fieldAtom, fieldType's instance>>;
			]
			else
			[
				/* Create any variables not explicitly assigned by the user. */
				Cast fieldType into
				[
					varType : variable meta
				|
					readType ::= cast varType's read type
						into [t : any meta | t];
					var ::= new ↑readType;
					syntheticAssignments := eject syntheticAssignments
						++ <<fieldAtom, var>>;
				]
				else
				[
					/* Do nothing. */
				];
			];
		];
	];
	/* Instantiate the object and certify its type. */
	newObject ::= (assignments ++ syntheticAssignments)→object;
	If ¬newObject ∈ objectType then
	[
		early failure function(
			object-instantiation-did-not-produce-instance code)
	];
	newObject
] : object;

/**
 * Object instantiation statically requires that:
 *
 * - Every field atom of the instantiation tuple is known.
 * - Each field atom of the instantiation tuple appears only once during
 *   instantiation.
 * - An assigned value conforms to the field type.
 * - An assignment occurs for every field of the object type except those for
 *   which the exact types are known; these will be supplied automatically.
 *
 * @method "a|an_«with«_«:»?:=_‡,»»"
 * @restricts "object's type's type"
 * @restricts "<<<atom, boolean, any…|3>…|1..>…|0..1>'s type"
 */
Semantic restriction "a|an_«with«_«:»?:=_‡,»»" is
[
	meta : object meta's type,
	optional : <<<atom, boolean, any…|3>…|1..>…|0..1>'s type
|
	$body : object meta;
	objectType ::= meta's instance;
	definitions ::= objectType→map;
	assignments : field type map := {};
	For each index from 1 to relevant |optional[1]| do
	[
		def ::= optional[1][index];
		atomType ::= def[1];
		Exit body with objectType if |def[2]| ≠ 1;
		assign ::= ¬def[2]'s instance;
		valueType ::= def[3];
		Exit body with objectType if |atomType| ≠ 1;
		fieldAtom ::= atomType's instance;
		If fieldAtom ∈ assignments then
		[
			Reject parse, expected:
				fieldAtom's name
				++ " to appear only once during instantiation (but it already\
				\| appeared with type = "
				++ “assignments[fieldAtom]”
				++ ")"
		];
		requiredType ::=
			if assign then
			[
				fieldType ::= definitions[fieldAtom] else
					[
						Reject parse, expected:
							"mutable field assignment not to introduce \
							\|target field "
							++ fieldAtom's name
							++ " (but it is not present in the object type)"
					];
				cast fieldType into
				[
					varType : variable meta
				|
					cast varType's read type into [t : any meta | t]
				]
				else
				[
					Reject parse, expected:
						"mutable field assignment to target a mutable field \
						\|(but "
						++ fieldAtom's name
						++ " is not a mutable field)"
				]
			]
			else
			[
				definitions[fieldAtom] else [any]
			];
		If ¬valueType ⊆ requiredType then
		[
			Reject parse, expected:
				"valid assignment to "
				++ fieldAtom's name
				++ " (but "
				++ “valueType”
				++ " is not a subtype of "
				++ “requiredType”
				++ ")"
		];
		assignments := eject assignments + fieldAtom→valueType;
	];
	For each fieldAtom → fieldType of definitions do
	[
		If |fieldType| = 1 ∧ ¬fieldType ⊆ type then
		[
			assignments := eject assignments + fieldAtom→fieldType;
		]
		else if fieldType ⊆ variable then
		[
			assignments := eject assignments + fieldAtom→fieldType;
		];
	];
	missing ::= reject each a from definitions' keys where [a ∈ assignments];
	If |missing| ≠ 0 then
	[
		Reject parse, expected:
			"assignments for all immutable fields of "
			++ “objectType”
			++ " (but assignments are missing for "
			++ “missing”
			++ ")"
	];
	assignments→object type
];

/**
 * Given an object and a target object type, answer an object that retains the
 * field assignments of the original object but which 1) is also an instance of
 * the new object type and 2) reflects the new (optional) field assignments.
 *
 * @method "_as_«with«_::=_‡,»»"
 * @param "instance" "object"
 *        An object.
 * @param "objectType" "object's type"
 *        An object type that must be a supertype of the answer.
 * @param "optional" "<<<atom, any…|2>…|1..>…|0..1>"
 *        An optional tuple of field assignments. A field assignment is a
 *        2-tuple that consists of 1) an atom that uniquely identifies the field
 *        and 2) the field value.
 * @returns "object"
 *          The requested object type.
 * @category "Objects" "Constructors"
 */
Public method "_as_«with«_::=_‡,»»" is
[
	instance : object,
	objectType : object meta,
	optional : <<<atom, any…|2>…|1..>…|0..1>
|
	assignments ::= optional[1] else [<>];
	fieldAtoms ::= stripe assignments at 1;
	If |fieldAtoms→set| ≠ |fieldAtoms| then
	[
		early failure function(object-instantiation-contains-duplicates code)
	];
	objectMap ::= objectType→map;
	identityAssignments : <<atom, any…|2>…|> := <>;
	For each fieldAtom → fieldType of objectMap do
	[
		If |fieldType| = 1 ∧ ¬fieldType ⊆ type then
		[
			identityAssignments := eject identityAssignments
				++ <<fieldAtom, fieldType's instance>>;
		];
	];
	newObject ::=
		(instance→map's bindings ++ assignments ++ identityAssignments)→object;
	If ¬newObject ∈ objectType then
	[
		early failure function(
			object-instantiation-did-not-produce-instance code)
	];
	newObject
] : object;

/**
 * Object adoption statically requires that:
 *
 * - Every field atom of the instantiation tuple is known.
 * - Each field atom of the instantiation tuple appears only once during
 *   instantiation.
 * - An assigned value conforms to the field type.
 * - An assignment occurs for every field of the object type except those for
 *   which the exact types are known; these will be supplied automatically.
 *
 * @method "_as_«with«_::=_‡,»»"
 * @restricts "object's type"
 * @restricts "object's type's type"
 * @restricts "<<<atom, any…|2>…|1..>…|0..1>'s type"
 */
Semantic restriction "_as_«with«_::=_‡,»»" is
[
	instance : object meta,
	meta : object meta's type,
	optional : <<<atom, any…|2>…|1..>…|0..1>'s type
|
	$body : object meta;
	objectType ::= meta's instance;
	definitions ::= objectType→map;
	assignments : field type map := instance→map;
	For each index from 1 to relevant |optional[1]| do
	[
		atomType, valueType ::= optional[1][index];
		Exit body with objectType if |atomType| ≠ 1;
		fieldAtom ::= atomType's instance;
		If fieldAtom ∈ assignments then
		[
			Reject parse, expected:
				fieldAtom's name
				++ " to appear only once during instantiation (but it already\
				\| appeared with type = "
				++ “assignments[fieldAtom]”
				++ ")"
		];
		requiredType ::= definitions[fieldAtom] else [ any ];
		If ¬valueType ⊆ requiredType then
		[
			Reject parse, expected:
				"valid assignment to "
				++ fieldAtom's name
				++ " (but "
				++ “valueType”
				++ " is not a subtype of "
				++ “requiredType”
				++ ")"
		];
		assignments := eject assignments + fieldAtom→valueType;
	];
	For each fieldAtom → fieldType of definitions do
	[
		If |fieldType| = 1 ∧ ¬fieldType ⊆ type then
		[
			assignments := eject assignments + fieldAtom→fieldType;
		];
	];
	missing ::= reject each a from definitions' keys where [a ∈ assignments];
	If |missing| ≠ 0 then
	[
		Reject parse, expected:
			"assignments for all fields of "
			++ “objectType”
			++ " (but assignments are missing for "
			++ “missing”
			++ ")"
	];
	assignments→object type
];
