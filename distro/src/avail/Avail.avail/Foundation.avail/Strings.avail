/*
 * Strings.avail
 * Copyright © 1993-2015, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Strings"
Versions
	"1.0.0 DEV 2014-04-28"
Uses
	"Atoms",
	"Bootstrap",
	"Characters",
	"Control Structures",
	"Definers",
	"Early Assertions",
	"Early Conditionals",
	"Early Functions",
	"Enumeration Support",
	"Error Codes",
	"Literals",
	"Logic",
	"Maps",
	"Math",
	"Sets",
	"Tuples",
	"Types",
	"Variables"
Names
	/* Formatting. */
	"format_with unchecked_",
	"format_with_",
	"format_with«…!::=_‡,»",
	"format_with«_‡,»",
	"partially format_with_",
	"partially format_with«…::=_‡,»",

	/* English language. */
	"(A`|An)“_”«else_»",
	"(The)“_”«else_»",
	"(a`|an)“_”«else_»",
	"(the)“_”«else_»",

	/* Formatting lists. */
	"“_”«else_»(as list partitioned by_)",
	"“_”«else_»(as simple list)",
	"“_”«else_»(as«conjunctive|disjunctive»!list)",
	"“_”«else_»\
	\|(as«conjunctive|disjunctive»!list with serial|Oxford|Harvard comma)",

	/* Conversions. */
	"_(base_)",
	"_→string",

	/* Hexadecimal. */
	"“_”(hex)",
	"“_”(UUID)",

	/* Trimming. */
	"trim_",

	/* Code points. */
	"_→code points",

	/* Avail message metacharacter rejection. */
	"_contains Avail message⁇metacharacters",
	"Require:_contains no Avail message⁇metacharacters"
Body

/* These are the circled numbers. */
circledNumbers ::=
	"①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳㉑㉒㉓㉔㉕\
	\|㉖㉗㉘㉙㉚㉛㉜㉝㉞㉟㊱㊲㊳㊴㊵㊶㊷㊸㊹㊺㊻㊼㊽㊾㊿";

/* This is a map from circled numbers to their implied numeric values. */
circledNumberValues ::= (circledNumbers zip 1 to 50)→map;

"description" is a new atom;
"text" is a new atom;
"escape" is a new atom;
interpolationMode ::= enumeration of {description, text, escape};

/**
 * Answer the enumeration of variable interpolation modes:
 *
 * <ul>
 * <li>{@method "description"} : The result of converting the corresponding
 *     argument, which may be any value, to a string via {@method "“_”"} will be
 *     copied into the formatted output.</li>
 * <li>{@method "text"} : The corresponding argument is a string and should be
 *     copied directly into the formatted output.</li>
 * <li>{@method "escape"} : There is no corresponding argument. There is an
 *     escaped metacharacter at the format site that should be copied,
 *     unescaped, into the result.</li>
 * <ul>
 * 
 * @method "interpolation mode"
 * @returns "{description, text, escape}ᵀ"
 */
Private method "interpolation mode" is [interpolationMode];

/**
 * Answer the type of a format site. Each instance is a 4-tuple whose elements
 * are:
 *
 * <ol>
 * <li>The format variable whose value should be interpolated at this site.</li>
 * <li>The variable interpolation type.</li>
 * <li>The start subscript of the site.</li>
 * <li>The end subscript of the site.</li>
 * </ol>
 * 
 * @method "format site"
 * @returns "<string, interpolation mode, natural number, natural number…|4>"
 *          The tuple type described above.
 */
Private method "format site" is
[
	<string, interpolation mode, natural number, natural number…|4>
];

/**
 * Answer the enumeration of format metacharacters:
 *
 * <ul>
 * <li>{@code "¢“"} : Begins a format site whose interpolation mode is
 *     {@method "description"}.</li>
 * <li>{@code "¢”"} : Ends a format site whose interpolation mode is {@method
 *     "description"}.</li>
 * <li>{@code "¢‘"} : Begins a format site whose interpolation mode is {@method
 *     "text"}.</li>
 * <li>{@code "¢’"} : Ends a format site whose interpolation mode is {@method
 *     "text"}.</li>
 * <li>{@code "¢`"} : Indicates a format site whose interpolation mode is
 *     {@method "$escape"}.</li>
 * <li>{@code "¢① .. ¢㊿"} : Indicates a positional format variable.</li>
 * </ul>
 *
 * @method "format metacharacters"
 * @returns "character's type"
 *          An enumeration of the characters listed above.
 */
Private method "format metacharacters" is
[
	enumeration of ("“”‘’`" ++ circledNumbers)→set
];

/**
 * Compute and answer the tuple of format sites for the specified template.
 * 
 * @method "format sites for_"
 * @param "template" "string"
 *        A template.
 * @returns "<<string, interpolation mode, natural number, natural number…|4>…|>"
 *          A tuple comprising the format sites for the specified template.
 */
Private stable method "format sites for_" is
[
	template : string
|
	sites : <format site…|> := <>;
	index : natural number := 1;
	addSite ::=
		[
			closeDelimiter : character,
			interpType : interpolation mode
		|
			start ::= index;
			Do [ index++; ] while
			[
				If index > |template| then
				[
					early failure function(runaway-format-variable code)
				];
				template[index] ≠ closeDelimiter
			];
			If index - start = 1 then
			[
				early failure function(empty-format-variable code)
			];
			varName ::= template[start + 1..index - 1];
			sites := eject sites ++ <<varName, interpType, start, index>>;
		];
	invalid ::= [early failure function(invalid-format-metacharacter-use code)];
	While  index ≤ |template| do
	[
		char ::= template[index];
		/* Handle a metacharacter. */
		Cast template[index] into
		[
			metachar : format metacharacters
		|
			Choose metachar from format metacharacters where
				¢‘ is [ addSite(¢’, text); ],
				¢“ is [ addSite(¢”, description); ],
				¢` is
				[
					start ::= (index++);
					If index > |template|
						∨ ¬template[index] ∈ format metacharacters
					then
					[
						early failure function(
							invalid-format-metacharacter-escape code)
					];
					escaped ::= <template[index]>;
					sites := eject sites ++ <<escaped, escape, start, index>>;
				],
				¢’ is invalid,
				¢” is invalid,
				else
				[
					Assert: metachar ∈ circledNumberValues;
					invalid()
				];
		]
		/* The typical case: this is an ordinary character. */
		else
		[
			/* No implementation required. */
		];
		/* Each case above must position `index` at the last character of
		 * interest to it. The following statement skips that character. This
		 * factoring ensures that progress is always made through the template.
		 */
		index++;
	];
	sites
] : <format site…|>;

/**
 * Answer the result of partially formatting the specified template using format
 * variable bindings contained in the given map. If a format variable does not
 * have a corresponding binding in the map, then re-emit it into the (partially)
 * formatted result.
 *
 * A template intermixes raw character data with format variable interpolation
 * sites. An interpolation site begins with either the ¢‘ or ¢“ metacharacter
 * and ends with the corresponding close metacharacter, either ¢’ or ¢”,
 * respectively. An interpolation site may contain any character except the
 * expected close metacharacter. The contents are understood to name a variable
 * that may appear as a key within the specified map; the associated value is
 * this variable's value. If an interpolation site uses ¢“ (and ¢”), then the
 * value will be converted to a string via `“_”` when it is copied into the
 * result. If an interpolation site uses ¢‘ (and ¢’), then the value must be a
 * string and will be copied directly into the result. To escape a
 * metacharacter, precede it immediately by ¢`.
 *
 * For example:
 * 
 *    {@code Assert:
 *        partially format "‘greeting’, ‘recipient’!\n"
 *            with {"greeting"→"Hello"}
 *        = "Hello, ‘recipient’!\n";
 *    Assert:
 *        partially format
 *            (partially format "‘greeting’, ‘recipient’!\n"
 *                with {"greeting"→"Hello"})
 *            with {"recipient"→"world"}
 *       = "Hello, world!\n";}
 *
 * @method "partially format_with_"
 * @param "template" "string"
 *        A template string.
 * @param "vars" "{string→any|}"
 *        A map from format variables to their bindings.
 * @returns "string"
 *          The result of partially formatting the template usings the specified
 *          bindings.
 * @category "Formatting" "Strings"
 */
Public stable method "partially format_with_" is
[
	template : string,
	vars : {string→any|}
|
	sites ::= format sites for template;
	formatted : string := "";
	badType ::=
		[early failure function(format-variable-interpolation-failed code)];
	index : natural number := 1;
	For each site of sites do
	[
		/* Append any characters between the last site and the previous site
		 * onto the output.
		 */
		formatted := eject formatted ++ template[index..site[3] - 1];
		/* Interpolate the variable. */
		var ::= site[1];
		interpolation ::= choose site[2] from interpolation mode where
			description is
			[
				“vars[var] else ["“" ++ var ++ "”"]”
			],
			text is
			[
				If var ∈ vars ∧ ¬var ∈ string then badType;
				cast vars[var] else ["‘" ++ var ++ "’"] into [ t : string | t ]
			],
			escape is
			[
				"`" ++ var
			];
		formatted := eject formatted ++ interpolation;
		/* Update the template subscript (to point just beyond this site). */
		index := site[4] + 1;
	];
	Assert: 1 ≤ index ≤ |template| + 1;
	formatted := eject formatted ++ template[index..];
	formatted
] : string;

/**
 * Compute and answer the minimum size of the result of formatting the specified
 * template.
 * 
 * @method "minimum`|_after formatting`|"
 * @param "template" "string"
 *        A template.
 * @returns "whole number"
 *          The minimum size of the formatted string.
 */
Private method "minimum`|_after formatting`|" is
[
	template : string
|
	left fold <|template|> ++ format sites for template through
	[
		site : format site,
		partial : whole number
	|
		cast partial - (|site[1]| + 2) into [ t : whole number | t ]
	]
] : whole number;

/**
 * @method "partially format_with_"
 * @restricts "string's type"
 * @restricts "{string→any|}'s type"
 */
Semantic restriction "partially format_with_" is
[
	template : string's type,
	vars : {string→any|}'s type
|
	if |template| = 1 then
	[
		<character… | minimum |template's instance after formatting|..>
	]
	else
	[
		⊤
	]
];

/**
 * Answer the result of fully formatting the specified template using format
 * variable bindings contained in the given map. The map must contain bindings
 * for all variables embedded within the template.
 *
 * A template intermixes raw character data with format variable interpolation
 * sites. An interpolation site begins with either the ¢‘ or ¢“ metacharacter
 * and ends with the corresponding close metacharacter, either ¢’ or ¢”,
 * respectively. An interpolation site may contain any character except the
 * expected close metacharacter. The contents are understood to name a variable
 * that may appear as a key within the specified map; the associated value is
 * this variable's value. If an interpolation site uses ¢“ (and ¢”), then the
 * value will be converted to a string via `“_”` when it is copied into the
 * result. If an interpolation site uses ¢‘ (and ¢’), then the value must be a
 * string and will be copied directly into the result. To escape a
 * metacharacter, precede it immediately by ¢`.
 *
 * For example:
 * 
 *    {@code Assert:
 *        format "‘greeting’, ‘recipient’!\n"
 *            with {"greeting"→"Hello", "recipient"→"world"}
 *        = "Hello, world!\n";}
 *
 * @method "format_with_"
 * @param "template" "string"
 *        A template string.
 * @param "vars" "{string→any|}"
 *        A map from format variables to their bindings. This map must include a
 *        binding for every variable mentioned within the template.
 * @returns "string"
 *          The result of formatting the template usings the specified bindings.
 * @category "Formatting" "Strings"
 */
Public stable method "format_with_" is
[
	template : string,
	vars : {string→any|}
|
	sites ::= format sites for template;
	formatted : string := "";
	missing ::= [early failure function(missing-format-variable-binding code)];
	badType ::=
		[early failure function(format-variable-interpolation-failed code)];
	index : natural number := 1;
	For each site of sites do
	[
		/* Append any characters between the last site and the previous site
		 * onto the output.
		 */
		formatted := eject formatted ++ template[index..site[3] - 1];
		/* Interpolate the variable. */
		interpolation ::= choose site[2] from interpolation mode where
			description is
			[
				value ::= vars[site[1]] else missing;
				“value”
			],
			text is
			[
				value ::= vars[site[1]] else missing;
				cast value into [ t : string | t ] else badType
			],
			escape is
			[
				site[1]
			];
		formatted := eject formatted ++ interpolation;
		/* Update the template subscript (to point just beyond this site). */
		index := site[4] + 1;
	];
	Assert: 1 ≤ index ≤ |template| + 1;
	formatted := eject formatted ++ template[index..];
	formatted
] : string;

/**
 * @method "format_with_"
 * @restricts "string's type"
 * @restricts "{string→any|}'s type"
 */
Semantic restriction "format_with_" is
[
	template : string's type,
	vars : {string→any|}'s type
|
	if |template| = 1 then
	[
		<character… | minimum |template's instance after formatting|..>
	]
	else
	[
		⊤
	]
];

/**
 * Answer the name of the format variable that should be derived from the
 * specified token.
 * 
 * @method "format variable for_"
 * @param "aToken" "token"
 * @returns "string"
 *          A format variable name.
 */
Private method "format variable for_" is
[
	aToken : token
|
	cast aToken into
	[
		literal : literal token
	|
		value ::= literal's value;
		cast value into [ t : string | t ]
		else [ “value” ]
	]
	else
	[
		aToken's lexeme
	]
] : string;

/**
 * Answer the result of partially formatting the specified template using
 * lexically specified format variable bindings. If a format variable does not
 * have a corresponding binding, then re-emit it into the (partially) formatted
 * result.
 *
 * A template intermixes raw character data with format variable interpolation
 * sites. An interpolation site begins with either the ¢‘ or ¢“ metacharacter
 * and ends with the corresponding close metacharacter, either ¢’ or ¢”,
 * respectively. An interpolation site may contain any character except the
 * expected close metacharacter. The contents are understood to name a variable
 * that may appear as a key within the specified map; the associated value is
 * this variable's value. If an interpolation site uses ¢“ (and ¢”), then the
 * value will be converted to a string via `“_”` when it is copied into the
 * result. If an interpolation site uses ¢‘ (and ¢’), then the value must be a
 * string and will be copied directly into the result. To escape a
 * metacharacter, precede it immediately by ¢`.
 *
 * For example:
 * 
 *    {@code Assert:
 *        (partially format "‘greeting’, ‘recipient’!\n"
 *            with greeting ::= "Hello")
 *        = "Hello, “recipient”!\n";
 *    Assert:
 *        (partially format
 *            (partially format "‘greeting’, ‘recipient’!\n"
 *                with greeting ::= "Hello")
 *            with recipient ::= "world")
 *        = "Hello, world!\n";}
 *
 * The semantic restriction ensures that every lexically specified binding
 * corresponds to a format variable embedded within the template.
 *
 * @method "partially format_with«…::=_‡,»"
 * @param "template" "string"
 *        A template string.
 * @param "bindings" "<<token, any…|2>…|1..>"
 *        The format variable bindings.
 * @returns "string"
 *          The result of partially formatting the template usings the specified
 *          bindings.
 * @category "Formatting" "Strings"
 */
Public stable method "partially format_with«…::=_‡,»" is
[
	template : string,
	bindings : <<token, any…|2>…|1..>
|
	realBindings ::= map each binding in bindings through
		[<format variable for binding[1], binding[2]>];
	partially format template with realBindings→map
] : string;

/**
 * If the template is statically known, then ensure that 1) each lexical binding
 * references a valid format variable and 2) each format variable that uses
 * the $text interpolation mode is actually bound to a string.
 * 
 * @method "partially format_with«…::=_‡,»"
 * @restricts "string's type"
 * @restricts "<<token, any…|2>…|1..>'s type"
 */
Semantic restriction "partially format_with«…::=_‡,»" is
[
	templateType : string's type,
	bindings : <<token, any…|2>…|1..>'s type
|
	If |templateType| = 1 then
	[
		template ::= templateType's instance;
		sites ::= format sites for template;
		templateVars ::= (stripe sites at 1)→set;
		stringSites ::= select each site from sites where [site[2] = text];
		stringVars ::= (stripe stringSites at 1)→set;
		bindingVars : {string|} := ∅;
		For each index from 1 to ⎣bindings⎦ do
		[
			binding ::= bindings[index];
			var ::= format variable for binding[1]'s instance;
			If var ∈ stringVars ∧ ¬binding[2] ⊆ string then
			[
				Reject parse, expected:
					"format variable "
					++ “var”
					++ " ∈ string, not "
					++ “binding[2]”
					++ " (because at least one format site requires this)"
			];
			bindingVars := eject bindingVars + var;
		];
		unmentionedVars ::= bindingVars \ templateVars;
		If unmentionedVars ≠ ∅ then
		[
			Reject parse, expected:
				"only bindings for format variables, but bindings also include "
				++ “unmentionedVars”
		];
		<character… | minimum |template after formatting|..>
	]
	else
	[
		⊤
	]
];

/**
 * Answer the result of fully formatting the specified template using lexically
 * specified format variable bindings.
 *
 * A template intermixes raw character data with format variable interpolation
 * sites. An interpolation site begins with either the ¢‘ or ¢“ metacharacter
 * and ends with the corresponding close metacharacter, either ¢’ or ¢”,
 * respectively. An interpolation site may contain any character except the
 * expected close metacharacter. The contents are understood to name a variable
 * that may appear as a key within the specified map; the associated value is
 * this variable's value. If an interpolation site uses ¢“ (and ¢”), then the
 * value will be converted to a string via `“_”` when it is copied into the
 * result. If an interpolation site uses ¢‘ (and ¢’), then the value must be a
 * string and will be copied directly into the result. To escape a
 * metacharacter, precede it immediately by ¢`.
 *
 * For example:
 * 
 *    {@code Assert:
 *        (format "‘greeting’, ‘recipient’!\n"
 *            with "greeting" ::= "Hello", "recipient" ::= "world")
 *        = "Hello, world!\n";}
 *
 * @method "format_with«…!::=_‡,»"
 * @param "template" "string"
 *        A template string.
 * @param "bindings" "<<token, any…|2>…|1..>"
 *        The complete format variable bindings.
 * @returns "string"
 *          The result of formatting the template usings the specified bindings.
 * @category "Formatting" "Strings"
 */
Public stable method "format_with«…!::=_‡,»" is
[
	template : string,
	bindings : <<token, any…|2>…|1..>
|
	realBindings ::= map each binding in bindings through
		[<format variable for binding[1], binding[2]>];
	format template with realBindings→map
] : string;

/**
 * If the template is statically known, then ensure that 1) each lexical binding
 * references a valid format variable, 2) each format variable is bound, and
 * 3) each format variable that uses the $text interpolation mode is actually
 * bound to a string.
 * 
 * @method "format_with«…!::=_‡,»"
 * @restricts "string's type"
 * @restricts "<<token, any…|2>…|1..>'s type"
 */
Semantic restriction "format_with«…!::=_‡,»" is
[
	templateType : string's type,
	bindings : <<token, any…|2>…|1..>'s type
|
	If |templateType| = 1 then
	[
		template ::= templateType's instance;
		sites ::= format sites for template;
		templateVars ::= (stripe sites at 1)→set;
		stringSites ::= select each site from sites where [site[2] = text];
		stringVars ::= (stripe stringSites at 1)→set;
		bindingVars : {string|} := ∅;
		For each index from 1 to ⎣bindings⎦ do
		[
			binding ::= bindings[index];
			var ::= format variable for binding[1]'s instance;
			If var ∈ stringVars ∧ ¬binding[2] ⊆ string then
			[
				Reject parse, expected:
					"format variable "
					++ “var”
					++ " ∈ string, not "
					++ “binding[2]”
					++ " (because at least one format site requires this)"
			];
			bindingVars := eject bindingVars + var;
		];
		unboundVars ::= templateVars \ bindingVars;
		If unboundVars ≠ ∅ then
		[
			Reject parse, expected:
				"bindings for format variables "
				++ “unboundVars”
		];
		unmentionedVars ::= bindingVars \ templateVars;
		If unmentionedVars ≠ ∅ then
		[
			Reject parse, expected:
				"only bindings for format variables, but bindings also include "
				++ “unmentionedVars”
		];
		<character… | minimum |template after formatting|..>
	]
	else
	[
		⊤
	]
];

/**
 * Answer the result of fully formatting the specified template using format
 * variable bindings contained in the given tuple. The tuple must contain
 * bindings for all variables embedded within the template.
 *
 * A template intermixes raw character data with format variable interpolation
 * sites. An interpolation site begins with either the ¢‘ or ¢“ metacharacter
 * and ends with the corresponding close metacharacter, either ¢’ or ¢”,
 * respectively. An interpolation site must contain one of the fifty circled
 * number characters (¢①, ¢②, ..., ¢㊿). The circled number character is
 * understood to indicate a subscript within the specified tuple; the value at
 * this subscript is this variable's value. If an interpolation site uses ¢“
 * (and ¢”), then the value will be converted to a string via `primitive
 * description of_` when it is copied into the result. If an interpolation site
 * uses ¢‘ (and ¢’), then the value must be a string and will be copied directly
 * into the result. To escape a metacharacter, precede it immediately by ¢`.
 *
 * For example:
 * 
 *    {@code Assert:
 *        format "‘①’, ‘②’!\n" with unchecked <"Hello", "world">
 *        = "Hello, world!\n";}
 *
 * @method "format_with unchecked_"
 * @param "template" "string"
 *        A template string.
 * @param "vars" "tuple"
 *        A tuple of format variable bindings. This tuple must include a
 *        binding (i.e., subscript) for every variable mentioned within the
 *        template.
 * @returns "string"
 *          The result of formatting the template using the specified bindings.
 * @category "Formatting" "Strings"
 */
Public stable method "format_with unchecked_" is
[
	template : string,
	vars : tuple
|
	sites ::= format sites for template;
	formatted : string := "";
	badName ::= [early failure function(invalid-format-variable code)];
	missing ::= [early failure function(missing-format-variable-binding code)];
	badType ::=
		[early failure function(format-variable-interpolation-failed code)];
	index : natural number := 1;
	For each site of sites do
	[
		/* Append any characters between the last site and the previous site
		 * onto the output.
		 */
		formatted := eject formatted ++ template[index..site[3] - 1];
		/* Interpolate the variable. */
		If |site[1]| > 1 then badName;
		var ::= site[1][1];
		interpolation ::= choose site[2] from interpolation mode where
			description is
			[
				varIndex ::= circledNumberValues[var] else badName;
				value ::= if varIndex ≤ |vars|
					then [ vars[varIndex] ]
					else missing;
				“value”
			],
			text is
			[
				varIndex ::= circledNumberValues[var] else badName;
				value ::= if varIndex ≤ |vars|
					then [ vars[varIndex] ]
					else missing;
				cast value into [ t : string | t ] else badType
			],
			escape is
			[
				site[1]
			];
		formatted := eject formatted ++ interpolation;
		/* Update the template subscript (to point just beyond this site). */
		index := site[4] + 1;
	];
	Assert: 1 ≤ index ≤ |template| + 1;
	formatted := eject formatted ++ template[index..];
	formatted
] : string;

/**
 * @method "format_with unchecked_"
 * @restricts "string's type"
 * @restricts "tuple's type"
 */
Semantic restriction "format_with unchecked_" is
[
	template : string's type,
	vars : tuple's type
|
	if |template| = 1 then
	[
		<character… | minimum |template's instance after formatting|..>
	]
	else
	[
		⊤
	]
];

/**
 * Answer the result of fully formatting the specified template using lexically
 * specified format variable bindings.
 *
 * A template intermixes raw character data with format variable interpolation
 * sites. An interpolation site begins with either the ¢‘ or ¢“ metacharacter
 * and ends with the corresponding close metacharacter, either ¢’ or ¢”,
 * respectively. An interpolation site must contain one of the fifty circled
 * number characters (¢①, ¢②, ..., ¢㊿). The circled number character is
 * understood to indicate a subscript within the specified tuple; the value at
 * this subscript is this variable's value. If an interpolation site uses ¢“
 * (and ¢”), then the value will be converted to a string via `primitive
 * description of_` when it is copied into the result. If an interpolation site
 * uses ¢‘ (and ¢’), then the value must be a string and will be copied directly
 * into the result. To escape a metacharacter, precede it immediately by ¢`.
 *
 * For example:
 * 
 *    {@code Assert:
 *        format "‘①’, ‘②’!\n" with "Hello", "world"
 *        = "Hello, world!\n";}
 *
 * @method "format_with«_‡,»"
 * @param "template" "string"
 *        A template string.
 * @param "vars" "<any…|1..50>"
 *        A tuple of format variable bindings. This tuple must include a
 *        binding (i.e., subscript) for every variable mentioned within the
 *        template.
 * @returns "string"
 *          The result of formatting the template usings the specified bindings.
 * @category "Formatting" "Strings"
 */
Public stable method "format_with«_‡,»" is
[
	template : string,
	vars : <any…|1..50>
|
	format template with unchecked vars
] : string;

/**
 * If the template is statically known, then ensure that 1) each lexical binding
 * references a valid format variable, 2) each format variable is bound, and
 * 3) each format variable that uses the $text interpolation mode is actually
 * bound to a string.
 * 
 * @method "format_with«_‡,»"
 * @restricts "string's type"
 * @restricts "<any…|1..50>'s type"
 */
Semantic restriction "format_with«_‡,»" is
[
	templateType : string's type,
	bindingsType : <any…|1..50>'s type
|
	if |templateType| = 1 then
	[
		template ::= templateType's instance;
		sites ::= format sites for template;
		templateVars ::= (stripe sites at 1)→set;
		stringSites ::= select each site from sites where [site[2] = text];
		stringVars ::= (stripe stringSites at 1)→set;
		bindingVars ::= (map each index in 1 to ⎣bindingsType⎦ through
			[
				var ::= <circledNumbers[index]>;
				bindingType ::= bindingsType[index];
				If var ∈ stringVars ∧ ¬bindingType ⊆ string then
				[
					Reject parse, expected:
						"format variable "
						++ “var”
						++ " ∈ string, not "
						++ “bindingType”
						++ " (because at least one format site requires this)"
				];
				var
			])→set;
		unboundVars ::= templateVars \ bindingVars;
		If unboundVars ≠ ∅ then
		[
			Reject parse, expected:
				"bindings for format variables "
				++ “unboundVars”
		];
		unmentionedVars ::= bindingVars \ templateVars;
		If unmentionedVars ≠ ∅ then
		[
			Reject parse, expected:
				"only bindings for format variables, but bindings also include "
				++ “unmentionedVars”
		];
		<character… | minimum |template after formatting|..>
	]
	else
	[
		⊤
	]
];

/* Code point constants needed by `_(base_)`. */
baseAlphabetTuple ::=
	"0123456789\
	\|ABCDEFGHIJKLMNOPQRSTUVWXYZ\
	\|abcdefghijklmnopqrstuvwxyz";
baseAlphabets ::=
	map each base in 2 to 36 through
	[
		baseAlphabetTuple[..base]
		++ baseAlphabetTuple[37..36 max (36 + base - 10)] → set
	];
cp_0 ::= ¢0's code point;
cp_9 ::= ¢9's code point;
cp_a ::= ¢a's code point;
cp_z ::= ¢z's code point;
cp_A ::= ¢A's code point;
cp_Z ::= ¢Z's code point;

/**
 * Convert the specified string to an extended integer.
 *
 * @method "_(base_)"
 * @param "digits" "string"
 *        A string of digits, chosen from the alphabet ¢0 .. ¢9 ∪ ¢A .. ¢Z ∪ ¢a
 *        .. ¢z.
 * @param "base" "[2..36]"
 *        The base for `digits`. This determines which symbols of the alphabet
 *        are valid, e.g., when `base = 16` then the valid symbols are ¢0 .. ¢9
 *        ∪ ¢A .. ¢F ∪ ¢a .. ¢f.
 * @returns "extended integer"
 *          An extended integer.
 * @category "Numbers" "Integers" "Conversions" "Stringification"
 */
Public stable method "_(base_)" is
[
	digits : string,
	base : [2..36]
|
	fail ::= [early failure function(invalid-argument code)];
	If digits is empty then fail;
	realDigits : string := digits;
	multiplier : {-1, 1}ᵀ := 1;
	If digits[1] = ¢- then
	[
		If |digits| = 1 then fail;
		realDigits := digits[2..];
		multiplier := -1;
	];
	baseAlphabet ::= baseAlphabets[base-1];
	answer ::=
		if realDigits[1] = ¢∞ then [∞]
		else
		[
			partial : whole number := 0;
			For each digit of realDigits do
			[
				If ¬digit ∈ baseAlphabet then fail;
				cp ::= cast digit's code point into [t : [cp_0..cp_z] | t];
				value ::=
					if cp_0 ≤ cp ≤ cp_9 then [cp - cp_0]
					else if cp_a ≤ cp ≤ cp_z then [cp - cp_a + 10]
					else if cp_A ≤ cp ≤ cp_Z then [cp - cp_A + 10]
					else fail;
				strongValue ::= cast value into [t : [0..36) | t];
				partial := eject partial × base + strongValue;
			];
			partial
		];
	answer × multiplier
] : extended integer;

/**
 * Convert the specified string to an integer.
 * 
 * @method "_→_"
 * @param "str" "string"
 *        A string of base-10 digits.
 * @returns "integer"
 * @category "Numbers" "Integers" "Conversions" "Stringification"
 */
Method "_→_" is
[
	str : string,
	range : extended integer's type
|
	fail ::= [early failure function(invalid-argument code)];
	If |str| > 1 ∧ str[1] = ¢0 then fail;
	n ::= str (base 10);
	if n ∈ range then [n] else fail
] : extended integer;

Semantic restriction "_→_" is
[
	str : string's type,
	range : extended integer's type's type
|
	range's instance
];

/**
 * Compare two strings lexicographically by Unicode code point.
 *
 * @method "_≤_"
 * @param "s1" "string"
 * @param "s2" "string"
 * @returns "boolean"
 *          {@method "true"} if {@param "s1"} collates before {@param "s2"},
 *          {@method "false"} otherwise.
 * @category "Strings" "Relations"
 */
Method "_≤_" is
[
	s1 : string,
	s2 : string
|
	$body : boolean;
	For each index from 1 to |s1| min |s2| do
	[
		cp1 ::= s1[index]'s code point;
		cp2 ::= s2[index]'s code point;
		If cp1 < cp2 then [Exit body with true]
		else if cp1 > cp2 then [Exit body with false];
	];
	|s1| ≤ |s2|
] : boolean;

/**
 * Compare two strings lexicographically by Unicode code point.
 *
 * @method "_<_"
 * @param "s1" "string"
 * @param "s2" "string"
 * @returns "boolean"
 *          {@method "true"} if {@param "s1"} collates strictly before
 *          {@param "s2"}, {@method "false"} otherwise.
 * @category "Strings" "Relations"
 */
Method "_<_" is
[
	s1 : string,
	s2 : string
|
	s1 ≤ s2 ∧ s1 ≠ s2
] : boolean;

/**
 * Compare two strings lexicographically by Unicode code point.
 *
 * @method "_≥_"
 * @param "s1" "string"
 * @param "s2" "string"
 * @returns "boolean"
 *          {@method "true"} if {@param "s1"} collates after {@param "s2"},
 *          {@method "false"} otherwise.
 * @category "Strings" "Relations"
 */
Method "_≥_" is
[
	s1 : string,
	s2 : string
|
	$body : boolean;
	For each index from 1 to |s1| min |s2| do
	[
		cp1 ::= s1[index]'s code point;
		cp2 ::= s2[index]'s code point;
		If cp1 > cp2 then [Exit body with true]
		else if cp1 < cp2 then [Exit body with false];
	];
	|s1| ≥ |s2|
] : boolean;

/**
 * Compare two strings lexicographically by Unicode code point.
 *
 * @method "_>_"
 * @param "s1" "string"
 * @param "s2" "string"
 * @returns "boolean"
 *          {@method "true"} if {@param "s1"} collates strictly after
 *          {@param "s2"}, {@method "false"} otherwise.
 * @category "Strings" "Relations"
 */
Method "_>_" is
[
	s1 : string,
	s2 : string
|
	s1 ≥ s2 ∧ s1 ≠ s2
] : boolean;

/**
 * Quicksort a tuple of strings in ascending order.
 * 
 * @method "quicksort_"
 * @param "strings" "string*" The {@type "tuple"} of strings to sort
 * @returns "string*" A sorted {@type "tuple"} of strings
 * @category "Strings" "Sorting"
 */
Method "quicksort_" is
[
	strings : string*
|
	quicksort a, b in strings by [a ≤ b]
] : string*;

/**
 * Merge sort a tuple of strings in ascending order.
 * 
 * @method "merge sort_"
 * @param "strings" "string*" The {@type "tuple"} of strings to sort
 * @returns "string*" A sorted {@type "tuple"} of strings
 * @category "Strings" "Sorting"
 */
Method "merge sort_" is
[
	strings : string*
|
	merge sort a, b in strings by [a ≤ b]
] : string*;

/**
 * Stringify the argument.
 * 
 * @method "“_”"
 * @param "aTuple" "tuple"
 * @returns "string"
 * @category "Tuples" "Stringification"
 */
Method "“_”" is
[
	aTuple : tuple
|
	if aTuple ∈ string then
	[
		cast primitive description of aTuple into [t : <character…|2..> | t]
	]
	else
	[
		Assert: ¬aTuple is empty;
		s : string := "<";
		index : natural number := 1;
		Do
		[
			elem ::= aTuple[index];
			s := eject s ++ “elem”;
			index++;
		]
		while index ≤ |aTuple|
		alternate with [s := eject s ++ ", ";];
		s := eject s ++ ">";
		cast s into [t : <character…|2..> | t]
	]
] : <character…|2..>;

/**
 * Answer a textual rendition of {@param "aTuple"} as a comma-separated list
 * without enclosing angle brackets.
 *
 * @method "“_”«else_»(as simple list)"
 * @param "aTuple" "tuple"
 *        An arbitrary tuple.
 * @param "optionalEmptyText" "([]→string)?"
 *        If specified, then the function to apply if the tuple is empty. If not
 *        specified, then {@code ["(empty)"]} will be used.
 * @returns "string"
 *          The requested textual rendition.
 * @category "Tuples" "Stringification"
 */
Public method "“_”«else_»(as simple list)" is
[
	aTuple : tuple,
	optionalEmptyText : ([]→string)?
|
	if aTuple is empty then [optionalEmptyText[1] else [["(empty)"]]()]
	else
	[
		s : string := "";
		index : natural number := 1;
		Do
		[
			elem ::= aTuple[index];
			s := eject s ++ cast elem into [t : string | t] else [“elem”];
			index++;
		]
		while index ≤ |aTuple|
		alternate with [s := eject s ++ ", ";];
		s
	]
] : string;

/**
 * Stringify the argument.
 * 
 * @method "“_”"
 * @param "aSet" "set"
 * @returns "string"
 * @category "Sets" "Stringification"
 */
Method "“_”" is
[
	aSet : set
|
	if aSet is empty then ["∅"]
	else ["{" ++ “aSet→tuple” (as simple list) ++ "}"]
] : nonempty string;

/**
 * Answer a textual rendition of {@param "aSet"} as a comma-separated list
 * without enclosing curly brackets.
 *
 * @method "“_”«else_»(as simple list)"
 * @param "aSet" "set"
 *        An arbitrary set.
 * @param "optionalEmptyText" "([]→string)?"
 *        If specified, then the function to apply if the set is empty. If not
 *        specified, then {@code ["(empty)"]} will be used.
 * @returns "string"
 *          The requested textual rendition.
 * @category "Sets" "Stringification"
 */
Public method "“_”«else_»(as simple list)" is
[
	aSet : set,
	optionalEmptyText : ([]→string)?
|
	emptyText ::= optionalEmptyText[1] else [["(empty)"]]();
	“aSet→tuple” else [emptyText] (as simple list)
] : string;

/**
 * Stringify the argument.
 * 
 * @method "“_”"
 * @param "aMap" "map"
 * @returns "string"
 * @category "Maps" "Stringification"
 */
Method "“_”" is
[
	aMap : map
|
	s : string := "{";
	index : natural number := 1;
	bindings ::= aMap's bindings;
	While index ≤ |bindings| do
	[
		key, value ::= bindings[index];
		s := eject s ++ “key”;
		s := eject s ++ "→" ++ “value”;
		index++;
	]
	alternate with [s := eject s ++ ", ";];
	s := eject s ++ "}";
	cast s into [t : <character…|2..> | t]
] : <character…|2..>;

/**
 * Answer a textual rendition of {@param "aTuple"} as a list. Use the serial
 * comma, i.e., when {@param "aTuple"} contains three or more elements, then
 * precede each element except for the first with a comma, but output either
 * {@code "and"} or {@code "or"} before the final element.
 *
 * @method
 *    "“_”«else_»\
 *    \|(as«conjunctive|disjunctive»!list with serial|Oxford|Harvard comma)"
 * @param "aTuple" "tuple"
 *        An arbitrary tuple.
 * @param "optionalEmptyText" "([]→string)?"
 *        If specified, then the function to apply if the tuple is empty. If not
 *        specified, then {@code ["(empty)"]} will be used.
 * @param "mode" "[1..2]"
 *        If the mode is {@code 1}, then output the word {@code "and"} before
 *        the final element of a multi-element tuple. If the mode is {@code 2},
 *        then output the word {@code "or"} before the final element of a
 *        multi-element tuple.
 * @returns "string"
 *          The requested textual rendition.
 * @category "Tuples" "Stringification"
 */
Public abstract method
	"“_”«else_»\
	\|(as«conjunctive|disjunctive»!list with serial|Oxford|Harvard comma)"
is [tuple, ([]→string)?, [1..2]]→string;

Method
	"“_”«else_»\
	\|(as«conjunctive|disjunctive»!list with serial|Oxford|Harvard comma)"
is
[
	aTuple : <⊥…|0>,
	optionalEmptyText : ([]→string)?,
	mode : [1..2]
|
	optionalEmptyText[1] else [["(empty)"]]()
] : string;

Method
	"“_”«else_»\
	\|(as«conjunctive|disjunctive»!list with serial|Oxford|Harvard comma)"
is
[
	aTuple : <any…|1>,
	optionalEmptyText : ([]→string)?,
	mode : [1..2]
|
	elem ::= aTuple[1];
	cast elem into [t : string | t] else [“elem”]
] : string;

Method
	"“_”«else_»\
	\|(as«conjunctive|disjunctive»!list with serial|Oxford|Harvard comma)"
is
[
	aTuple : <any…|2>,
	optionalEmptyText : ([]→string)?,
	mode : [1..2]
|
	s1 ::= cast aTuple[1] into [t : string | t] else [“aTuple[1]”];
	s2 ::= cast aTuple[2] into [t : string | t] else [“aTuple[2]”];
	s1 ++ <" and ", " or ">[mode] ++ s2
] : string;

Method
	"“_”«else_»\
	\|(as«conjunctive|disjunctive»!list with serial|Oxford|Harvard comma)"
is
[
	aTuple : <any…|3..>,
	optionalEmptyText : ([]→string)?,
	mode : [1..2]
|
	s : string := "";
	For each index from 1 to |aTuple| - 1 do
	[
		tx ::= cast aTuple[index] into [t : string | t] else [“aTuple[index]”];
		s := eject s ++ tx ++ ", ";
	];
	last ::= aTuple's last;
	tx ::= cast last into [t : string | t] else [“last”];
	s := eject s ++ <"and ", "or ">[mode] ++ tx;
	s
] : string;

/**
 * Answer a textual rendition of {@param "aTuple"} as a list. Use the serial
 * comma, i.e., when {@param "aTuple"} contains three or more elements, then
 * precede each element except for the first with a comma, but output either
 * {@code "and"} or {@code "or"} before the final element.
 *
 * @method "“_”«else_»(as«conjunctive|disjunctive»!list with serial|Oxford|Harvard comma)"
 * @param "aTuple" "tuple"
 *        An arbitrary tuple.
 * @param "optionalEmptyText" "([]→string)?"
 *        If specified, then the function to apply if the tuple is empty. If not
 *        specified, then {@code ["(empty)"]} will be used.
 * @param "mode" "[1..2]"
 *        If the mode is {@code 1}, then output the word {@code "and"} before
 *        the final element of a multi-element tuple. If the mode is {@code 2},
 *        then output the word {@code "or"} before the final element of a
 *        multi-element tuple.
 * @returns "string"
 *          The requested textual rendition.
 * @category "Sets" "Stringification"
 */
Abstract method
	"“_”«else_»\
	\|(as«conjunctive|disjunctive»!list with serial|Oxford|Harvard comma)"
is [set, ([]→string)?, [1..2]]→string;

Method
	"“_”«else_»\
	\|(as«conjunctive|disjunctive»!list with serial|Oxford|Harvard comma)"
is
[
	aSet : {⊥|0},
	optionalEmptyText : ([]→string)?,
	mode : [1..2]
|
	optionalEmptyText[1] else [["(empty)"]]()
] : string;

Method
	"“_”«else_»\
	\|(as«conjunctive|disjunctive»!list with serial|Oxford|Harvard comma)"
is
[
	aSet : {any|1},
	optionalEmptyText : ([]→string)?,
	mode : [1..2]
|
	aTuple ::= aSet→tuple;
	elem ::= aTuple[1];
	cast elem into [t : string | t] else [“elem”]
] : string;

Method
	"“_”«else_»\
	\|(as«conjunctive|disjunctive»!list with serial|Oxford|Harvard comma)"
is
[
	aSet : {any|2},
	optionalEmptyText : ([]→string)?,
	mode : [1..2]
|
	aTuple ::= aSet→tuple;
	s1 ::= cast aTuple[1] into [t : string | t] else [“aTuple[1]”];
	s2 ::= cast aTuple[2] into [t : string | t] else [“aTuple[2]”];
	s1 ++ <" and ", " or ">[mode] ++ s2
] : string;

Method
	"“_”«else_»\
	\|(as«conjunctive|disjunctive»!list with serial|Oxford|Harvard comma)"
is
[
	aSet : {any|3..},
	optionalEmptyText : ([]→string)?,
	mode : [1..2]
|
	aTuple ::= aSet→tuple;
	s : string := "";
	For each index from 1 to |aTuple| - 1 do
	[
		tx ::= cast aTuple[index] into [t : string | t] else [“aTuple[index]”];
		s := eject s ++ tx ++ ", ";
	];
	last ::= aTuple's last;
	tx ::= cast last into [t : string | t] else [“last”];
	s := eject s ++ <"and ", "or ">[mode] ++ tx;
	s
] : string;

/**
 * Answer a textual rendition of {@param "aTuple"} as a list. Elements are
 * separated by commas, except that the last two elements are separated by
 * the appropriate connective conjunction. No comma will occur before the
 * connective conjunction, i.e., do not use the serial comma.
 *
 * @method "“_”«else_»(as«conjunctive|disjunctive»!list)"
 * @param "aTuple" "tuple"
 *        An arbitrary tuple.
 * @param "optionalEmptyText" "([]→string)?"
 *        If specified, then the function to apply if the tuple is empty. If not
 *        specified, then {@code ["(empty)"]} will be used.
 * @param "mode" "[1..2]"
 *        If the mode is {@code 1}, then output the word {@code "and"} before
 *        the final element of a multi-element tuple. If the mode is {@code 2},
 *        then output the word {@code "or"} before the final element of a
 *        multi-element tuple.
 * @returns "string"
 *          The requested textual rendition.
 * @category "Tuples" "Stringification"
 */
Public abstract method "“_”«else_»(as«conjunctive|disjunctive»!list)"
	is [tuple, ([]→string)?, [1..2]]→string;

Method "“_”«else_»(as«conjunctive|disjunctive»!list)" is
[
	aTuple : <⊥…|0>,
	optionalEmptyText : ([]→string)?,
	mode : [1..2]
|
	optionalEmptyText[1] else [["(empty)"]]()
] : string;

Method "“_”«else_»(as«conjunctive|disjunctive»!list)" is
[
	aTuple : <any…|1>,
	optionalEmptyText : ([]→string)?,
	mode : [1..2]
|
	elem ::= aTuple[1];
	cast elem into [t : string | t] else [“elem”]
] : string;

Method "“_”«else_»(as«conjunctive|disjunctive»!list)" is
[
	aTuple : <any…|2>,
	optionalEmptyText : ([]→string)?,
	mode : [1..2]
|
	s1 ::= cast aTuple[1] into [t : string | t] else [“aTuple[1]”];
	s2 ::= cast aTuple[2] into [t : string | t] else [“aTuple[2]”];
	s1 ++ <" and ", " or ">[mode] ++ s2
] : string;

Method "“_”«else_»(as«conjunctive|disjunctive»!list)" is
[
	aTuple : <any…|3..>,
	optionalEmptyText : ([]→string)?,
	mode : [1..2]
|
	s : string := "";
	For each index from 1 to |aTuple| - 2 do
	[
		tx ::= cast aTuple[index] into [t : string | t] else [“aTuple[index]”];
		s := eject s ++ tx ++ ", ";
	];
	nextLast ::= aTuple[|aTuple| - 1];
	tx : string := cast nextLast into [t : string | t] else [“nextLast”];
	s := eject s ++ tx;
	last ::= aTuple's last;
	tx := cast last into [t : string | t] else [“last”];
	s := eject s ++ <" and ", " or ">[mode] ++ tx;
	s
] : string;

/**
 * Answer a textual rendition of {@param "aSet"} as a list. Elements are
 * separated by commas, except that the last two elements are separated by
 * the appropriate connective conjunction. No comma will occur before the
 * connective conjunction, i.e., do not use the serial comma.
 *
 * @method "“_”«else_»(as«conjunctive|disjunctive»!list)"
 * @param "aSet" "set"
 *        An arbitrary set.
 * @param "optionalEmptyText" "([]→string)?"
 *        If specified, then the function to apply if the set is empty. If not
 *        specified, then {@code ["(empty)"]} will be used.
 * @param "mode" "[1..2]"
 *        If the mode is {@code 1}, then output the word {@code "and"} before
 *        the final element of a multi-element tuple. If the mode is {@code 2},
 *        then output the word {@code "or"} before the final element of a
 *        multi-element tuple.
 * @returns "string"
 *          The requested textual rendition.
 * @category "Sets" "Stringification"
 */
Abstract method "“_”«else_»(as«conjunctive|disjunctive»!list)"
	is [set, ([]→string)?, [1..2]]→string;

Method "“_”«else_»(as«conjunctive|disjunctive»!list)" is
[
	aSet : {⊥|0},
	optionalEmptyText : ([]→string)?,
	mode : [1..2]
|
	optionalEmptyText[1] else [["(empty)"]]()
] : string;

Method "“_”«else_»(as«conjunctive|disjunctive»!list)" is
[
	aSet : {any|1},
	optionalEmptyText : ([]→string)?,
	mode : [1..2]
|
	aTuple ::= aSet→tuple;
	elem ::= aTuple[1];
	cast elem into [t : string | t] else [“elem”]
] : string;

Method "“_”«else_»(as«conjunctive|disjunctive»!list)" is
[
	aSet : {any|2},
	optionalEmptyText : ([]→string)?,
	mode : [1..2]
|
	aTuple ::= aSet→tuple;
	s1 ::= cast aTuple[1] into [t : string | t] else [“aTuple[1]”];
	s2 ::= cast aTuple[2] into [t : string | t] else [“aTuple[2]”];
	s1 ++ <" and ", " or ">[mode] ++ s2
] : string;

Method "“_”«else_»(as«conjunctive|disjunctive»!list)" is
[
	aSet : {any|3..},
	optionalEmptyText : ([]→string)?,
	mode : [1..2]
|
	aTuple ::= aSet→tuple;
	s : string := "";
	For each index from 1 to |aTuple| - 2 do
	[
		tx ::= cast aTuple[index] into [t : string | t] else [“aTuple[index]”];
		s := eject s ++ tx ++ ", ";
	];
	nextLast ::= aTuple[|aTuple| - 1];
	tx : string := cast nextLast into [t : string | t] else [“nextLast”];
	s := eject s ++ tx;
	last ::= aTuple's last;
	tx := cast last into [t : string | t] else [“last”];
	s := eject s ++ <" and ", " or ">[mode] ++ tx;
	s
] : string;

/**
 * Answer a textual rendition of {@param "aTuple"} as a list. Elements are
 * separated by {@param "separator"}.
 *
 * @method "“_”«else_»(as list partitioned by_)"
 * @param "aTuple" "tuple"
 *        An arbitrary tuple.
 * @param "optionalEmptyText" "([]→string)?"
 *        If specified, then the function to apply if the tuple is empty. If not
 *        specified, then {@code ["(empty)"]} will be used.
 * @param "separator" "string"
 *        The text that should separate renditions of the elements of {@param
 *        "aTuple"}.
 * @returns "string"
 *          The requested textual rendition.
 * @category "Tuples" "Stringification"
 */
Method "“_”«else_»(as list partitioned by_)" is
[
	aTuple : tuple,
	optionalEmptyText : ([]→string)?,
	separator : string
|
	if aTuple is empty then [optionalEmptyText[1] else [["(empty)"]]()]
	else
	[
		s : string := "";
		i : natural number := 1;
		Do
		[
			tx ::= cast aTuple[i] into [t : string | t] else [“aTuple[i]”];
			s := eject s ++ tx;
			i++;
		]
		while i ≤ |aTuple| alternate with [s := eject s ++ separator;];
		s
	]
] : string;

/**
 * Answer a textual rendition of {@param "aSet"} as a list. Elements are
 * separated by {@param "separator"}.
 *
 * @method "“_”«else_»(as list partitioned by_)"
 * @param "aSet" "set"
 *        An arbitrary set.
 * @param "optionalEmptyText" "([]→string)?"
 *        If specified, then the function to apply if the set is empty. If not
 *        specified, then {@code ["(empty)"]} will be used.
 * @param "separator" "string"
 *        The text that should separate renditions of the elements of {@param
 *        "aSet"}.
 * @returns "string"
 *          The requested textual rendition.
 * @category "Sets" "Stringification"
 */
Method "“_”«else_»(as list partitioned by_)" is
[
	aSet : set,
	optionalEmptyText : ([]→string)?,
	separator : string
|
	emptyText ::= optionalEmptyText[1] else [["(empty)"]];
	“aSet→tuple” else emptyText (as list partitioned by separator)
] : string;

vowels ::=
	("aàáâãäåāăąǎǟǡǻȁȃȧḁạảấầẩẫậắằẳẵặ"
	++ "AÀÁÂÃÄÅĀĂĄǍǞǠǺȀȂȦḀẠẢẤẦẨẪẬẮẰẲẴẶÅ"
	++ "eèéêëēĕėęěȅȇȩḕḗḙḛḝẹẻẽếềểễệ"
	++ "EÈÉÊËĒĔĖĘĚȄȆȨḔḖḘḚḜẸẺẼẾỀỂỄỆ"
	++ "iìíîïĩīĭįıǐȉȋḭḯỉị"
	++ "IÌÍÎÏĨĪĬĮİǏȈȊḬḮỈỊ"
	++ "oòóôõöōŏőơǒǫǭȍȏȫȭȯȱṍṏṑṓọỏốồổỗộ"
	++ "OÒÓÔÕÖŌŎŐƠǑǪǬȌȎȪȬȮȰṌṎṐṒỌỎỐỒỔỖỘỚ"
	++ "uùúûüũūŭůűųưǔǖǘǚǜȕȗṳṵṷṹṻụủứừửữự"
	++ "UÙÚÛÜŨŪŬŮŰŲƯǓǕǗǙǛȔȖṲṴṶṸṺỤỦỨỪỬỮỰ")→set;

/**
 * Answer a rendition of {@param "value"} that begins with the appropriate
 * indefinite article. If {@param "value"} is a string, then it will not be
 * quoted.
 *
 * @method "(a`|an)“_”«else_»"
 * @param "value" "any"
 * @param "optionalMissingText" "string?"
 *        If specified, then the text that will be displayed if {@param "value"}
 *        or its rendering via {@method "“_”"} is an empty string. If not
 *        specified, then {@code "(nothing)"} will be used if necessary.
 * @returns "string"
 * @category "Tuples" "Stringification"
 */
Public method "(a`|an)“_”«else_»" is
[
	value : any,
	optionalMissingText : string?
|
	missingText ::= optionalMissingText[1] else ["(nothing)"];
	s ::= cast value into [t : string | t] else [“value”];
	if s is empty then [missingText]
	else [if s[1] ∈ vowels then ["an "] else ["a "] ++ s]
] : string;

/**
 * Answer a rendition of {@param "value"} that begins with the appropriate
 * uppercased indefinite article. If {@param "value"} is a string, then it will
 * not be quoted.
 *
 * @method "(A`|An)“_”«else_»"
 * @param "value" "any"
 * @param "optionalMissingText" "string?"
 *        If specified, then the text that will be displayed if {@param "value"}
 *        or its rendering via {@method "“_”"} is an empty string. If not
 *        specified, then {@code "(nothing)"} will be used if necessary.
 * @returns "string"
 * @category "Tuples" "Stringification"
 */
Public method "(A`|An)“_”«else_»" is
[
	value : any,
	optionalMissingText : string?
|
	missingText ::= optionalMissingText[1] else ["(nothing)"];
	s ::= cast value into [t : string | t] else [“value”];
	if s is empty then [missingText]
	else [if s[1] ∈ vowels then ["An "] else ["A "] ++ s]
] : string;

/**
 * Answer a rendition of {@param "value"} that begins with the appropriate
 * definite article. If {@param "value"} is a string, then it will not be
 * quoted.
 *
 * @method "(the)“_”«else_»"
 * @param "value" "any"
 * @param "optionalMissingText" "string?"
 *        If specified, then the text that will be displayed if {@param "value"}
 *        or its rendering via {@method "“_”"} is an empty string. If not
 *        specified, then {@code "(nothing)"} will be used if necessary.
 * @returns "string"
 * @category "Tuples" "Stringification"
 */
Public method "(the)“_”«else_»" is
[
	value : any,
	optionalMissingText : string?
|
	missingText ::= optionalMissingText[1] else ["(nothing)"];
	s ::= cast value into [t : string | t] else [“value”];
	if s is empty then [missingText]
	else ["the " ++ s]
] : string;

/**
 * Answer a rendition of {@param "value"} that begins with the appropriate
 * uppercased definite article. If {@param "value"} is a string, then it will
 * not be quoted.
 *
 * @method "(The)“_”«else_»"
 * @param "value" "any"
 * @param "optionalMissingText" "string?"
 *        If specified, then the text that will be displayed if {@param "value"}
 *        or its rendering via {@method "“_”"} is an empty string. If not
 *        specified, then {@code "(nothing)"} will be used if necessary.
 * @returns "string"
 * @category "Tuples" "Stringification"
 */
Public method "(The)“_”«else_»" is
[
	value : any,
	optionalMissingText : string?
|
	missingText ::= optionalMissingText[1] else ["(nothing)"];
	s ::= cast value into [t : string | t] else [“value”];
	if s is empty then [missingText]
	else ["The " ++ s]
] : string;

/**
 * Print object types more neatly.
 * 
 * @method "“_”"
 * @param "anObjectType" "object's type"
 * @returns "string"
 * @category "Objects" "Types" "Stringification"
 */
Method "“_”" is
[
	anObjectType : object's type
|
	“anObjectType's names” (as list partitioned by " ∩ ")
] : string;

/**
 * Print object types more neatly.
 * 
 * @method "“_”"
 * @param "anObject" "object"
 * @returns "string"
 * @category "Objects" "Stringification"
 */
Stable method "“_”" is
[
	anObject : object
|
	(a|an) ““anObject's type's names” (as list partitioned by " ∩ ")”
] : string;

/**
 * Answer a variant of {@param "s"} such that all leading and trailing {@method
 * "_is whitespace" whitespace} has been removed.
 *
 * @method "trim_"
 * @param "s" "string"
 * @returns "string"
 * @category "Tuples" "Strings" "Transformers"
 */
Public stable method "trim_" is
[
	s : string
|
	start ::= 1 max first index of s where [c : character | ¬c is whitespace];
	end ::= last index of s where [c: character | ¬c is whitespace];
	s[start..end]
] : string;

/**
 * Answer a transformation of {@param "aTuple"} such that every constituent
 * {@type "code point"} is replaced with its corresponding {@type "character"},
 * preserving order.
 *
 * @method "_→string"
 * @param "aTuple" "code point*"
 * @returns "string"
 * @category "Tuples" "Strings" "Transformers"
 */
Public stable method "_→string" is
[
	aTuple : code point*
|
	map each c in aTuple through [c→character]
] : string;

/**
 * Render the supplied {@type "tuple"} of {@type "byte"}s as a hexadecimal
 * textual representation.
 *
 * @category "Strings"
 * @method "“_”(hex)"
 * @param "bytes" "byte*"
 * @returns "string"
 * @category "Tuples" "Strings" "Transformers"
 */
Public stable method "“_”(hex)" is
[
	bytes : byte*
|
	s : string := "";
	For each index from 1 to |bytes| do
	[
		high ::= (bytes[index] >> 4) bit∧ 15;
		low ::= bytes[index] bit∧ 15;
		s := eject s ++ <baseAlphabetTuple[high+1], baseAlphabetTuple[low+1]>;
	];
	s
] : string;

Semantic restriction "“_”(hex)" is
[
	bytes : byte*'s type
|
	<<>, character… | [⎣bytes⎦ × 2 .. ⎡bytes⎤ × 2 + 1)>
];

/**
 * Render the supplied {@type "UUID"} as a hexadecimal textual representation.
 *
 * @method "“_”(UUID)"
 * @param "uuid" "UUID"
 * @returns "nonempty string"
 * @category "Tuples" "Strings" "Transformers"
 */
Public stable method "“_”(UUID)" is
[
	uuid : UUID
|
	hex ::= “uuid” (hex);
	format "‘①’-‘②’-‘③’-‘④’-‘⑤’" with
		hex[1..8],
		hex[9..12],
		hex[13..16],
		hex[17..20],
		(hex[21..32])
] : nonempty string;

Semantic restriction "“_”(UUID)" is
[
	uuid : UUID's type
|
	<character…|36>
];

/**
 * Convert {@param "s"} to a {@type "tuple"} of code points, preserving the
 * original order.
 *
 * @method "_→code points"
 * @param "s" "string"
 * @returns "code point*"
 * @category "Tuples" "Strings" "Transformers" 
 */
Public stable method "_→code points" is
[
	s : string
|
	map each c of s through [c's code point]
];

Semantic restriction "_→code points" is
[
	s : string's type
|
	<<>, code point… | ||s||>
];

/**
 * Does the specified {@type "string"} contains any {@type
 * "Avail message⁇metacharacter" Avail message metacharacters}?
 *
 * @method "_contains Avail message⁇metacharacters"
 * @param "s" "string"
 * @returns "boolean"
 *          {@method "true"} if {@param "s"} contains any {@type
 *          "Avail message⁇metacharacter" Avail message metacharacters},
 *          {@method "false"} otherwise.
 * @category "Tuples" "Strings" "Queries"
 */
Public method "_contains Avail message⁇metacharacters" is
[
	s : string
|
	any c of s satisfies [c is an Avail metacharacter]
];

/**
 * Reject the current parse if the specified {@type "string"} {@method
 * "_contains Avail message⁇metacharacters" contains} any {@type
 * "Avail message⁇metacharacter" Avail message metacharacters}.
 *
 * @method "Require:_contains no Avail message⁇metacharacters"
 * @param "s" "string"
 * @returns "⊤"
 * @category "Tuples" "Strings"
 */
Public method "Require:_contains no Avail message⁇metacharacters" is
[
	s : string
|
	metachars ::= select each c from s where [c is an Avail metacharacter];
	If ¬metachars is empty then
	[
		Reject parse, expected:
			format
				"string “①” not to contain Avail message metacharacters, but \
				\|the following included characters are Avail message \
				\|metacharacters: ‘②’"
			with s, “metachars” (as simple list)
	];
];

/**
 * Reject the current parse unless the specified {@type "string"} is statically
 * known and {@method "_contains Avail message⁇metacharacters" contains} no
 * {@type "Avail message⁇metacharacter" Avail message metacharacters}.
 *
 * @method "Require:_contains no Avail message⁇metacharacters"
 * @param "s" "string"
 * @returns "⊤"
 * @category "Tuples" "Strings"
 */
Public method "Require:_contains no Avail message⁇metacharacters" is
[
	sT : string's type
|
	If |sT| ≠ 1 then
	[
		Reject parse, expected:
			"string that forbids Avail message metacharacters to be \
			\|statically known"
	];
	Require: sT's instance contains no Avail metacharacters;
];
