/*
 * Core.avail
 * Copyright © 1993-2015, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Core"
Versions
	"1.0.0 DEV 2014-04-28"
Uses
	"Avail" =
	(
		"_+_" → "_+_(Avail)",
		"_-_" → "_-_(Avail)",
		"_×_" → "_×_(Avail)",
		"_÷_" → "_÷_(Avail)",
		"_mod_" → "_mod_(Avail)",
		"_^_" → "_^_(Avail)",
		…
	),
	"Feature Renames"
Names
	/* Types. */
	"base unit",
	"derived unit",
	"dimensioned quantity",
	"dimensioned_",
	"scalar",
	"unit",
	"unit conversion function",

	/* Exceptions. */
	"incompatible-quantities exception",
	"no-such-conversion exception",

	/* Field atoms. */
	"extent",
	"metric",
	"unit map",

	/* Definers. */
	"Prefer_for printing_",
	"Prefer_for printing_in a dimensioned quantity",
	"_has symbol_",
	"_(_)is a base unit",
	"_(_)is a derived unit equivalent to_",

	/* Derivation. */
	"_·_",
	"_/_",

	/* Derivation helpers. */
	"_·_(unit map)",
	"_/_(unit map)",
	"_^_(unit map)",

	/* Constructors. */
	"__",

	/* Extraction. */
	"_'s⁇unit map",
	"_'s⁇extent",
	"_'s⁇metric",
	"_'s⁇incompatible quantities",
	"_'s⁇source unit",
	"_'s⁇target unit",

	/* Arithmetic. */
	"-_",
	"`|_`|",
	"_mod_",
	"_+_",
	"_-_",
	"_×_",
	"_÷_",

	/* Derivation and arithmetic. */
	"_^_",
	"_²",
	"_³",
	"_⁴",
	"_⁵",
	"_⁶",
	"_⁷",
	"_⁸",
	"_⁹",

	/* Comparison. */
	"_≍_",
	"_<_",
	"_≤_",
	"_>_",
	"_≥_",
	"«_‡«=|≤|<»!»",
	"«_‡«=|≥|>»!»",

	/* Conversion. */
	"Conversion method is_,⁇inverse is_",
	"Conversion rule:_≍_",
	"_converted to_",

	/* Utilities. */
	"Require:_and_are compatible",

	/* Test suites. */
	"Dimensional|dimensional analysis test suite",

	/* Printing (private). */
	"unit map“_”",

	/* State (private). */
	"names by unit",
	"symbols by unit"
Body

Public method "unit map" is [$"unit map"];
Public method "extent" is [$extent];
Public method "metric" is [$metric];
Private method "incompatible quantities" is [$"incompatible quantities"];
Private method "source unit" is [$"source unit"];
Private method "target unit" is [$"target unit"];
Private method "preferred symbol" is [$"preferred symbol"];

/**
 * A unit is a measurement quantum along some dimensional axis.
 *
 * @category "Dimensional Analysis"
 * @type "unit"
 */
Public class "unit" extends object
	with fields
		public unit map : {atom→integer|};

/**
 * A base unit is metrically irreducible; though it may be reduced to smaller
 * quanta, it may not be reduced to simpler terms. Examples of base units are
 * meters (m), seconds (s), or grams (g).
 *
 * @category "Dimensional Analysis"
 * @type "base unit"
 * @supertype "unit"
 */
Public explicit class "base unit" extends unit
	with fields
		unit map : {atom→1's type|1};

/**
 * A derived unit is an algebraic composition of base units. Examples of derived
 * units are newtons (kg·m/s²) or hertz (1/s).
 *
 * @category "Dimensional Analysis"
 * @type "derived unit"
 * @supertype "unit"
 */
Public explicit class "derived unit" extends unit;

/**
 * Scalar is a necessary singularity endemic to the system of type {@type
 * "unit"}s. It represents the absence of meaningful dimensional axes, yet it
 * must be present to support intermediate stages of derivation.
 *
 * @category "Dimensional Analysis"
 * @type "scalar"
 * @supertype "unit"
 */
Public class "scalar" extends derived unit
	with fields
		unit map : {}'s type;

/**
 * A dimensioned quantity combines a numeric extent with a {@type "unit"}.
 * Examples of dimensioned quantities are 4m (four meters), 10 kilograms (ten
 * kilograms), and 20N (twenty Newtons).
 *
 * @category "Dimensional Analysis"
 * @type "dimensioned quantity"
 */
Public class "dimensioned quantity" extends object
	with fields
		public extent : number,
		public metric : unit;

/**
 * Construct and answer a {@type "dimensioned quantity"} type with the specified
 * {@type "number" extent} type.
 *
 * @category "Dimensional Analysis"
 * @method "dimensioned_"
 * @param "magnitudeType" "number's type"
 *        The magnitude type.
 * @returns "dimensioned quantity"
 *          The requested {@type "dimensioned quantity"} type.
 */
Public method "dimensioned_" is
[
	magnitudeType : number's type
|
	extend dimensioned quantity with extent : magnitudeType
] : dimensioned quantity's type;

Semantic restriction "dimensioned_" is
[
	magnitudeType : number's type's type
|
	(extend dimensioned quantity with extent : magnitudeType's instance)'s type
];

/**
 * Construct and answer a {@type "dimensioned quantity"} type with the specified
 * {@type "number" extent} type and {@type "unit" metric}.
 *
 * @category "Dimensional Analysis"
 * @method "__"
 * @param "magnitudeType" "number's type"
 *        The magnitude type.
 * @param "theUnit" "unit"
 *        The {@type "unit" metric}.
 * @returns "dimensioned quantity's type"
 *          The requested {@type "dimensioned quantity"} type.
 */
Public method "__" is
[
	magnitudeType : number's type,
	theUnit : unit
|
	extend dimensioned quantity with
		extent : magnitudeType,
		metric : theUnit's type
] : dimensioned quantity's type;

Semantic restriction "__" is
[
	magnitudeType : number's type's type,
	unitType : unit's type
|
	(if |unitType| = 1 then
	[
		magnitudeType's instance unitType's instance
	]
	else
	[
		extend dimensioned quantity with extent : magnitudeType's instance
	])'s type
];

/**
 * Construct and answer a {@type "dimensioned quantity"} with the specified
 * {@type "number" extent} and {@type "unit" metric}.
 *
 * @category "Dimensional Analysis"
 * @method "__"
 * @param "magnitude" "number"
 *        The magnitude of the answer.
 * @param "theUnit" "unit"
 *        The {@type "unit"} of measurement of the answer.
 * @returns "dimensioned quantity"
 *          The requested {@type "dimensioned quantity"}.
 */
Public stable method "__" is
[
	magnitude : number,
	theUnit : unit
|
	a dimensioned quantity with extent ::= magnitude, metric ::= theUnit
] : dimensioned quantity;

Semantic restriction "__" is
[
	magnitudeType : number's type,
	unitType : unit's type
|
	if |unitType| = 1 then
	[
		magnitudeType (unitType's instance)
	]
	else
	[
		extend dimensioned quantity with
			extent : magnitudeType,
			metric : unitType
	]
];

/**
 * The {@type "non-reentrant mutex" mutex} that guards against concurrent access
 * to global variables.
 *
 * @global "stateLock" "non-reentrant mutex"
 * @category "Dimensional Analysis"
 */
stateLock : non-reentrant mutex := a non-reentrant mutex named "state lock";

/**
 * A map from {@type "unit"}s to the names that should be used to describe them.
 *
 * @global "namesByUnit" "{unit→string|}"
 * @category "Dimensional Analysis"
 */
namesByUnit : {unit→string|} := {};

Public method "names by unit" is
[
	temp : {unit→string|};
	lock stateLock for [temp := namesByUnit;];
	temp
];

/**
 * Prefer {@param "name"} for printing the specified {@type "unit"}.
 *
 * @category "Dimensional Analysis"
 * @method "Prefer_for printing_"
 * @param "name" "string"
 *        The preferred print representation of {@param "aUnit"}.
 * @param "aUnit" "unit"
 *        A {@type "unit"}.
 * @returns "⊤"
 */
Public method "Prefer_for printing_" is
[
	symbol : string,
	aUnit : unit
|
	Lock stateLock for [namesByUnit := namesByUnit + aUnit→symbol;];
	After the current module is unloaded,
		do [Lock stateLock for [namesByUnit := namesByUnit - aUnit (Avail);];];
] : ⊤;

/**
 * A map from {@type "unit"}s to the symbols that should be used to describe
 * them.
 *
 * @global "symbolsByUnit" "{unit→string|}"
 * @category "Dimensional Analysis"
 */
symbolsByUnit : {unit→string|} := {};

Public method "symbols by unit" is
[
	temp : {unit→string|};
	lock stateLock for [temp := symbolsByUnit;];
	temp
];

/**
 * Prefer {@param "symbol"} for printing {@type "dimensioned quantity"
 * dimensioned quantities} of the specified {@type "unit"}.
 *
 * @category "Dimensional Analysis"
 * @method "Prefer_for printing_in a dimensioned quantity"
 * @param "symbol" "string"
 *        The preferred print representation of {@param "aUnit"} (when it
 *        occurs as part of a {@type "dimensioned quantity"}).
 * @param "aUnit" "unit"
 *        A {@type "unit"}.
 * @returns "⊤"
 */
Public method "Prefer_for printing_in a dimensioned quantity" is
[
	symbol : string,
	aUnit : unit
|
	bogus ::= new atom named "bogus";
	unitAtom : atom;
	oldSymbol : any;
	Cast aUnit into
	[
		baseUnit : base unit
	|
		unitAtom := baseUnit's unit map's keys→tuple[1];
		oldSymbol := unitAtom[preferred symbol] else [bogus];
		Lock stateLock for [unitAtom[preferred symbol] := symbol;];
	]
	else
	[
		/* No implementation required. */
	];
	Lock stateLock for [symbolsByUnit := symbolsByUnit + aUnit→symbol;];
	After the current module is unloaded, do
	[
		Lock stateLock for
		[
			symbolsByUnit := symbolsByUnit - aUnit (Avail);
			If unitAtom is assigned then
			[
				If oldSymbol ≠ bogus then
				[
					unitAtom[preferred symbol] := oldSymbol;
				]
				else
				[
					Remove unitAtom[preferred symbol];
				];
			];
		];
	];
] : ⊤;

/**
 * Answer a reasonable description of the specified unit atom.
 *
 * @category "Dimensional Analysis"
 * @method "“_”(unit atom)"
 * @param "unitAtom" "atom"
 * @returns "string"
 *          {@param "unitAtom"}'s preferred symbol, or its name if no preferred
 *          symbol has been set.
 */
Private method "“_”(unit atom)" is
[
	unitAtom : atom
|
	unitAtom[preferred symbol] else [unitAtom's name]
];

Semantic restriction "“_”(unit atom)" is
[
	unitAtom : atom's type
|
	string
];

/* This table is used by "unit map“_”". The first character can technically be
 * anything, since the algorithm doesn't use it, but it's best to use
 * superscript one (¹).
 */
prettyPowers ::= "¹²³⁴⁵⁶⁷⁸⁹";

/**
 * Construct and answer a description of the specified unit map (as the product
 * of powers of base units).
 *
 * @category "Dimensional Analysis"
 * @method "unit map“_”"
 * @param "unitMap" "{atom→integer|}"
 *        A unit map.
 * @returns "string"
 *          The requested unit map.
 */
Public method "unit map“_”" is
[
	unitMap : {atom→integer|}
|
	if unitMap = {} then
	[
		""
	]
	else if unitMap ∈ {atom→1's type|1} then
	[
		/* This is an unnamed base unit. Answer its atom's preferred symbol. */
		unitAtom ::= unitMap's keys→tuple[1];
		“unitAtom” (unit atom)
	]
	else
	[
		/* This is an unnamed derived unit. Compose its description from its
		 * base units.
		 */
		sortedAtoms ::= merge sort a, b in unitMap's keys→tuple by
			[
				“a” (unit atom) ≤ “b” (unit atom)
			];
		expr ::= left fold <""> ++ sortedAtoms through
			[
				unitAtom : atom,
				partial : string
			|
				pow ::= unitMap[unitAtom];
				name ::= “unitAtom” (unit atom);
				term ::=
					cast pow into
					[t : 1's type | name],
					[t : [2..9] | name ++ prettyPowers[t..t]]
					else [name ++ "^" ++ “pow”];
				partial ++ "·" ++ term
			];
		expr[2..]
	]
] : string;

Method "“_”" is
[
	arg : unit
|
	names by unit[arg] else [unit map “arg's unit map”]
];

Method "“_”" is
[
	arg : scalar
|
	"(scalar)"
];

Method "“_”" is
[
	arg : dimensioned quantity
|
	desc ::= symbolsByUnit[arg's metric]
		else [unit map “arg's metric's unit map”];
	“arg's extent” ++ " " ++ desc
] : string;

Method "“_”" is
[
	arg : dimensioned quantity's type
|
	If |arg's metric| = 1 then
	[
		m ::= arg's metric's instance;
		desc ::= namesByUnit[m] else [unit map “m's unit map”];
		“arg's extent” ++ " " ++ desc
	]
	else
	[
		"dimensioned " ++ “arg's extent”
	]
] : string;

Method "“_”" is
[
	arg : extend dimensioned quantity with metric : scalar
|
	“arg's extent”
];

/**
 * TODO: [TLS] This mechanism should be reworked when locales are introduced.
 *
 * Establish {@param "symbol"} as a notation for the specified {@type "unit"}
 * type. In particular, define a method {@param "symbol"} that answers
 * {@param "aUnit"} when its message is sent. Unless a preferred print
 * presentation for this unit has already been established, then establish the
 * specified symbol as the preferred print representation.
 *
 * @category "Dimensional Analysis"
 * @method "_has symbol_"
 * @param "aUnit" "unit"
 *        A {@type "unit"}.
 * @param "symbol" "string"
 *        A symbol which represents the specified {@type "unit"}.
 * @returns "⊤"
 */
Public method "_has symbol_" is
[
	aUnit : unit,
	symbol : nonempty string
|
	/* Generate a factory method. */
	Method symbol is «[ <> | <‘`aUnit` ("")’> ] : aUnit's type»→function;
	/* Set the preferred print representation. */
	Unless aUnit ∈ symbolsByUnit then
	[
		Prefer symbol for printing aUnit in a dimensioned quantity;
	];
] : ⊤;

/**
 * Define a {@type "base unit"}.
 *
 * @category "Dimensional Analysis"
 * @method "_(_)is a base unit"
 * @param "name" "string"
 *        The name of the {@type "base unit"}, e.g., meters, seconds, grams.
 * @param "symbol" "string"
 *        A symbol which represents the defined {@type "base unit"}.
 * @returns "⊤"
 */
Public method "_(_)is a base unit" is
[
	name : nonempty string,
	symbol : nonempty string
|
	id ::= atom for name;
	def ::= {id → 1};
	unitType ::= extend base unit with unit map : def's type;
	aUnit ::= a unitType with unit map ::= def;
	aUnit has symbol name;
	Unless name = symbol then [aUnit has symbol symbol;];
	Unless aUnit ∈ names by unit then
	[
		Prefer name for printing aUnit;
		Prefer symbol for printing aUnit in a dimensioned quantity;
	];
] : ⊤;

/**
 * Compute and answer the product of the specified unit maps.
 *
 * @category "Dimensional Analysis"
 * @method "_·_(unit map)"
 * @param "x" "{atom→integer|}"
 *        A unit map.
 * @param "y" "{atom→integer|}"
 *        A unit map.
 * @returns "{atom→integer|}" The product of the arguments.
 */
Public stable method "_·_(unit map)" is
[
	mapX : {atom→integer|},
	mapY : {atom→integer|}
|
	differenceKeys ::= mapX's keys Δ mapY's keys;
	intersectionKeys ::= mapX's keys ∩ mapY's keys;
	unitMap : {atom→integer|} := {};
	For each key of differenceKeys do
	[
		exponent ::= mapX[key] else [mapY[key]];
		unitMap := eject unitMap + key→exponent;
	];
	For each key of intersectionKeys do
	[
		exponent ::= mapX[key] + mapY[key] (Avail);
		Unless exponent = 0 then
		[
			unitMap := eject unitMap + key→exponent;
		];
	];
	unitMap
] : {atom→integer|};

/**
 * Compute and answer the product of the specified {@type "unit"}s.
 *
 * @category "Dimensional Analysis"
 * @method "_·_"
 * @param "x" "unit"
 *        A {@type "unit"}.
 * @param "y" "unit"
 *        A {@type "unit"}.
 * @returns "unit" The product of the arguments.
 */
Public stable method "_·_" is
[
	x : unit,
	y : unit
|
	unitMap ::= x's unit map · y's unit map (unit map);
	unitType ::= cast unitMap
		into [t : {atom→1's type|1} | base unit]
		else [derived unit];
	a unitType with unit map ::= unitMap
] : unit;

/**
 * Compute and answer the quotient of the specified unit maps. This is the
 * same as the {@method "_·_" product} of {@param "mapX"} and the reciprocal of
 * {@param "mapY"}.
 *
 * @category "Dimensional Analysis"
 * @method "_/_(unit map)"
 * @param "mapX" "{atom→integer|}"
 *        A unit map.
 * @param "mapY" "{atom→integer|}"
 *        A unit map.
 * @returns "{atom→integer|}" The quotient of the arguments.
 */
Public stable method "_/_(unit map)" is
[
	mapX : {atom→integer|},
	mapY : {atom→integer|}
|
	inverseY ::= map mapY through
		[
			key : atom,
			exponent : integer
		|
			-exponent
		];
	mapX · inverseY (unit map)
] : {atom→integer|};

/**
 * Compute and answer the quotient of the specified {@type "unit"}s. This is the
 * same as the {@method "_·_" product} of {@param "x"} and the reciprocal of
 * {@param "y"}.
 *
 * @category "Dimensional Analysis"
 * @method "_/_"
 * @param "x" "unit"
 *        A {@type "unit"}.
 * @param "y" "unit"
 *        A {@type "unit"}.
 * @returns "unit" The quotient of the arguments.
 */
Public stable method "_/_" is
[
	x : unit,
	y : unit
|
	unitMap ::= x's unit map / y's unit map (unit map);
	unitType ::= cast unitMap
		into [t : {atom→1's type|1} | base unit]
		else [derived unit];
	a unitType with unit map ::= unitMap
] : unit;

/**
 * Compute and answer the result of raising the specified unit maps to the
 * specified power.
 *
 * @category "Dimensional Analysis"
 * @method "_^_(unit map)"
 * @param "unitMap" "{atom→integer|}"
 *        A unit map.
 * @param "theExponent" "integer"
 *        The exponent.
 * @returns "unit"
 *          The result of the exponentiation.
 */
Public stable method "_^_(unit map)" is
[
	unitMap : {atom→integer|},
	theExponent : integer
|
	map unitMap through
		[
			key : atom,
			exponent : integer
		|
			theExponent × exponent (Avail)
		]
] : {atom→integer|};

/**
 * Compute and answer the result of raising the specified {@type "unit"} to the
 * specified power.
 *
 * @category "Dimensional Analysis"
 * @method "_^_"
 * @param "theUnit" "unit"
 *        A {@type "unit"}.
 * @param "theExponent" "integer"
 *        The exponent.
 * @returns "unit"
 *          The result of the exponentiation.
 */
Public stable method "_^_" is
[
	theUnit : unit,
	theExponent : integer
|
	unitMap ::= theUnit's unit map ^ theExponent (unit map);
	unitType ::= cast unitMap
		into [t : {atom→1's type|1} | base unit]
		else [derived unit];
	a unitType with unit map ::= unitMap
] : unit;

For each index from 2 to |prettyPowers| do
[
	exponent ::= index;
	Stable method "_" ++ prettyPowers[index..index] is
	[
		theUnit : unit
	|
		theUnit ^ exponent
	] : unit;
];

[
	product     ::= {"_·_", "_/_"};
	power       ::= {"_^_"};
	superscript ::=
		(map prettyPowers[2..] through [x : character | "_" ++ <x>])→set;

	/* Establish the precedence of multiplicative derivation. */
	Grammatical restriction product is <∅, product>;

	/* Establish the precedence of exponentiation. */
	Grammatical restriction power is <product ∪ power, product>;
	Grammatical restriction superscript
		is <product ∪ power ∪ superscript ∪ {"__"}>;
]();

/**
 * Define a {@type "derived unit"}.
 *
 * @category "Dimensional Analysis"
 * @method "_(_)is a derived unit equivalent to_"
 * @param "name" "string"
 *        The name of the {@type "derived unit"}, e.g., newtons, hertz.
 * @param "symbol" "string"
 *        A symbol which represents the defined {@type "dervied unit"}.
 * @param "aUnit" "unit"
 *        An equivalent {@type "unit"}, usually obtained from a lexical
 *        expression.
 * @returns "⊤"
 */
Public method "_(_)is a derived unit equivalent to_" is
[
	name : nonempty string,
	symbol : nonempty string,
	aUnit : unit
|
	aUnit has symbol name;
	Unless name = symbol then [aUnit has symbol symbol;];
	Unless aUnit ∈ names by unit then
	[
		Prefer name for printing aUnit;
		Prefer symbol for printing aUnit in a dimensioned quantity;
	];
] : ⊤;

/**
 * An incompatible-quantities exception is raised whenever an operation is
 * performed on two or more incompatible quantities.
 *
 * @category "Dimensional Analysis"
 * @type "incompatible-quantities exception"
 * @supertype "exception"
 */
Public explicit class "incompatible-quantities exception" extends exception
	with fields
		public incompatible quantities : <dimensioned quantity…|2>;

/**
 * If the arguments do not have the same {@type "unit"}s, then raise an
 * {@type "incompatible-quantities exception"}.
 *
 * @category "Dimensional Analysis"
 * @method "Require:_and_are compatible"
 * @param "a" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @param "b" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @returns "⊤"
 * @raises "incompatible-quantities exception"
 *         If {@param "a"} and {@param "b"} have different {@type "unit"}s.
 */
Public method "Require:_and_are compatible" is
[
	a : dimensioned quantity,
	b : dimensioned quantity
|
	If a's metric ≠ b's metric then
	[
		Raise an incompatible-quantities exception with
			incompatible quantities ::= <a, b>
	];
] : ⊤;

/**
 * Compute and answer the sum of the {@type "dimensioned quantity" arguments}.
 *
 * @category "Dimensional Analysis"
 * @method "_+_"
 * @param "augend" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @param "addend" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @returns "dimensioned quantity"
 *          The sum of {@param "augend"} and {@param "addend"}.
 * @raises "incompatible-quantities exception"
 *         If the arguments are incompatible.
 */
Public stable method "_+_" is
[
	augend : dimensioned quantity,
	addend : dimensioned quantity
|
	Require: augend and addend are compatible;
	(augend's extent + addend's extent (Avail)) (augend's metric)
] : dimensioned quantity;

Method "Require:_and_are compatible" is
[
	x : unit's type,
	y : unit's type
|
	If x ∩ y = ⊥ then
	[
		metricX ::= if |x| = 1 then [x's instance] else [x];
		metricY ::= if |y| = 1 then [y's instance] else [y];
		Reject parse, expected:
			format
				"units to be compatible (but “①” and “②” are not compatible)"
			with metricX, metricY
	];
];

Semantic restriction "_+_" is
[
	x : dimensioned quantity's type,
	y : dimensioned quantity's type
|
	Require: x's metric and y's metric are compatible;
	numericType ::=
		type promotion function for
		[
			a : number,
			b : number
		|
			If {a, b} = {-∞, ∞} then
			[
				Reject parse, expected: "magnitudes not to be unlike infinities"
			];
			a + b (Avail)
		](x's extent, y's extent);
	if |x's metric| = 1 then
	[
		numericType (x's metric's instance)
	]
	else
	[
		dimensioned numericType
	]
];

Semantic restriction "_+_" is
[
	a : dimensioned extended integer's type,
	b : dimensioned extended integer's type
|
	dimensioned (a's extent + b's extent (Avail))
];

/**
 * Compute and answer the difference of the {@type "dimensioned quantity"
 * arguments}.
 *
 * @category "Dimensional Analysis"
 * @method "_-_"
 * @param "minuend" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @param "subtrahend" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @returns "dimensioned quantity"
 *          The difference of {@param "minuend"} and {@param "subtrahend"}.
 * @raises "incompatible-quantities exception"
 *         If the arguments are incompatible.
 */
Public stable method "_-_" is
[
	minuend : dimensioned quantity,
	subtrahend : dimensioned quantity
|
	Require: minuend and subtrahend are compatible;
	(minuend's extent - subtrahend's extent (Avail)) (minuend's metric)
] : dimensioned quantity;

Semantic restriction "_-_" is
[
	x : dimensioned quantity's type,
	y : dimensioned quantity's type
|
	Require: x's metric and y's metric are compatible;
	numericType ::=
		type promotion function for
		[
			a : number,
			b : number
		|
			If {a, b} ∈ {{-∞}, {∞}} then
			[
				Reject parse, expected: "magnitudes not to be like infinities"
			];
			a - b (Avail)
		](x's extent, y's extent);
	if |x's metric| = 1 then
	[
		numericType (x's metric's instance)
	]
	else
	[
		dimensioned numericType
	]
];

Semantic restriction "_-_" is
[
	a : dimensioned extended integer's type,
	b : dimensioned extended integer's type
|
	dimensioned (a's extent - b's extent (Avail))
];

/**
 * Compute and answer the product of the {@type "dimensioned quantity"
 * arguments}.
 *
 * @category "Dimensional Analysis"
 * @method "_×_"
 * @param "multiplicand" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @param "multiplier" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @returns "any"
 *          The product of {@param "multiplicand"} and {@param "multiplier"}. If
 *          the result is a {@type "scalar"}, then its extent will be returned
 *          (i.e., it will be normalized to a {@type "number"}).
 */
Public stable method "_×_" is
[
	multiplicand : dimensioned quantity,
	multiplier : dimensioned quantity
|
	newExtent ::= multiplicand's extent × multiplier's extent (Avail);
	newUnit ::= multiplicand's metric · multiplier's metric;
	product ::= newExtent newUnit;
	cast newUnit
		into [t : scalar | newExtent]
		else [product]
] : any;

Semantic restriction "_×_" is
[
	x : dimensioned quantity's type,
	y : dimensioned quantity's type
|
	numericType ::=
		type promotion function for
		[
			a : number,
			b : number
		|
			terms ::= {a, b};
			If terms = {0, ∞} ∨ terms = {0, -∞} then
			[
				Reject parse, expected: "terms not be 0 and ±∞"
			];
			a × b (Avail)
		](x's extent, y's extent);
	if {|x's metric|, |y's metric|} = {1} then
	[
		unitX ::= x's metric's instance;
		unitY ::= y's metric's instance;
		resultUnit ::= (unitX · unitY);
		cast resultUnit
			into [t : scalar | numericType]
			else [numericType resultUnit]
	]
	else
	[
		⊤
	]
];

Semantic restriction "_×_" is
[
	a : dimensioned extended integer's type,
	b : dimensioned extended integer's type
|
	dimensioned (a's extent × b's extent (Avail))
];

/**
 * Compute and answer the product of the {@type "dimensioned quantity"} and the
 * {@type "number"}.
 *
 * @category "Dimensional Analysis"
 * @method "_×_"
 * @param "multiplicand" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @param "multiplier" "number"
 *        A {@type "number"}.
 * @returns "dimensioned quantity"
 *          The product of {@param "multiplicand"} and {@param "multiplier"}.
 */
Public stable method "_×_" is
[
	multiplicand : dimensioned quantity,
	multiplier : number
|
	(multiplicand's extent × multiplier (Avail)) (multiplicand's metric)
] : dimensioned quantity;

Semantic restriction "_×_" is
[
	x : dimensioned quantity's type,
	y : number's type
|
	numericType ::=
		type promotion function for
		[
			a : number,
			b : number
		|
			terms ::= {a, b};
			If terms = {0, ∞} ∨ terms = {0, -∞} then
			[
				Reject parse, expected: "terms not be 0 and ±∞"
			];
			a × b (Avail)
		](x's extent, y);
	if |x's metric| = 1 then
	[
		numericType (x's metric's instance)
	]
	else
	[
		dimensioned numericType
	]
];

Semantic restriction "_×_" is
[
	a : dimensioned extended integer's type,
	b : extended integer's type
|
	dimensioned (a's extent × b (Avail))
];

/**
 * Compute and answer the product of the {@type "dimensioned quantity"} and the
 * {@type "number"}.
 *
 * @category "Dimensional Analysis"
 * @method "_×_"
 * @param "multiplicand" "number"
 *        A {@type "number"}.
 * @param "multiplier" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @returns "dimensioned quantity"
 *          The product of {@param "multiplicand"} and {@param "multiplier"}.
 */
Public stable method "_×_" is
[
	multiplicand : number,
	multiplier : dimensioned quantity
|
	(multiplicand × multiplier's extent (Avail)) (multiplier's metric)
] : dimensioned quantity;

Semantic restriction "_×_" is
[
	x : number's type,
	y : dimensioned quantity's type
|
	numericType ::=
		type promotion function for
		[
			a : number,
			b : number
		|
			terms ::= {a, b};
			If terms = {0, ∞} ∨ terms = {0, -∞} then
			[
				Reject parse, expected: "terms not be 0 and ±∞"
			];
			a × b (Avail)
		](x, y's extent);
	if |y's metric| = 1 then
	[
		numericType (y's metric's instance)
	]
	else
	[
		dimensioned numericType
	]
];

Semantic restriction "_×_" is
[
	a : extended integer's type,
	b : dimensioned extended integer's type
|
	dimensioned (a × b's extent (Avail))
];

/**
 * Compute and answer the quotient of the {@type "dimensioned quantity"
 * arguments}.
 *
 * @category "Dimensional Analysis"
 * @method "_÷_"
 * @param "dividend" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @param "divisor" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @returns "any"
 *          The quotient of {@param "dividend"} and {@param "divisor"}. If the
 *          result is a {@type "scalar"}, then its extent will be returned
 *          (i.e., it will be normalized to a {@type "number"}).
 */
Public stable method "_÷_" is
[
	dividend : dimensioned quantity,
	divisor : dimensioned quantity
|
	newExtent ::= dividend's extent ÷ divisor's extent (Avail);
	newUnit ::= dividend's metric / divisor's metric;
	quotient ::= newExtent newUnit;
	cast newUnit
		into [t : scalar | newExtent]
		else [quotient]
] : any;

Semantic restriction "_÷_" is
[
	x : dimensioned quantity's type,
	y : dimensioned quantity's type
|
	numericType ::=
		type promotion function for
		[
			a : number,
			b : number
		|
			If b = 0 ∧ a's type ⊆ extended integer then
			[
				Reject parse, expected: "denominator not to be 0"
			];
			infinities ::= {∞, -∞};
			If a ∈ infinities ∧ b ∈ infinities then
			[
				Reject parse, expected:
					"either numerator or denominator to be finite"
			];
			a ÷ b (Avail)
		](x's extent, y's extent);
	if {|x's metric|, |y's metric|} = {1} then
	[
		unitX ::= x's metric's instance;
		unitY ::= y's metric's instance;
		resultUnit ::= (unitX / unitY);
		cast resultUnit
			into [t : scalar | numericType]
			else [numericType resultUnit]
	]
	else
	[
		⊤
	]
];

Semantic restriction "_÷_" is
[
	a : dimensioned extended integer's type,
	b : dimensioned extended integer's type
|
	dimensioned (a's extent ÷ b's extent (Avail))
];

/**
 * Compute and answer the quotient of the {@type "dimensioned quantity"} and the
 * {@type "number"}.
 *
 * @category "Dimensional Analysis"
 * @method "_÷_"
 * @param "dividend" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @param "divisor" "number"
 *        A {@type "number"}.
 * @returns "dimensioned quantity"
 *          The quotient of {@param "dividend"} and {@param "divisor"}.
 */
Public stable method "_÷_" is
[
	dividend : dimensioned quantity,
	divisor : number
|
	(dividend's extent ÷ divisor (Avail)) (dividend's metric)
] : dimensioned quantity;

Semantic restriction "_÷_" is
[
	x : dimensioned quantity's type,
	y : number's type
|
	numericType ::=
		type promotion function for
		[
			a : number,
			b : number
		|
			If b = 0 ∧ a's type ⊆ extended integer then
			[
				Reject parse, expected: "denominator not to be 0"
			];
			infinities ::= {∞, -∞};
			If a ∈ infinities ∧ b ∈ infinities then
			[
				Reject parse, expected:
					"either numerator or denominator to be finite"
			];
			a ÷ b (Avail)
		](x's extent, y);
	if |x's metric| = 1 then
	[
		numericType (x's metric's instance)
	]
	else
	[
		dimensioned numericType
	]
];

Semantic restriction "_÷_" is
[
	a : dimensioned extended integer's type,
	b : extended integer's type
|
	dimensioned (a's extent ÷ b (Avail))
];

/**
 * Compute and answer the quotient of the {@type "number"} and the {@type
 * "dimensioned quantity"}.
 *
 * @category "Dimensional Analysis"
 * @method "_÷_"
 * @param "dividend" "number"
 *        A {@type "number"}.
 * @param "divisor" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @returns "dimensioned quantity"
 *          The quotient of {@param "dividend"} and {@param "divisor"}.
 */
Public stable method "_÷_" is
[
	dividend : number,
	divisor : dimensioned quantity
|
	(dividend ÷ divisor's extent (Avail)) (a scalar / divisor's metric)
] : dimensioned quantity;

Semantic restriction "_÷_" is
[
	x : number's type,
	y : dimensioned quantity's type
|
	numericType ::=
		type promotion function for
		[
			a : number,
			b : number
		|
			If b = 0 ∧ a's type ⊆ extended integer then
			[
				Reject parse, expected: "denominator not to be 0"
			];
			infinities ::= {∞, -∞};
			If a ∈ infinities ∧ b ∈ infinities then
			[
				Reject parse, expected:
					"either numerator or denominator to be finite"
			];
			a ÷ b (Avail)
		](x, y's extent);
	if |y's metric| = 1 then
	[
		numericType (a scalar / y's metric's instance)
	]
	else
	[
		dimensioned numericType
	]
];

Semantic restriction "_÷_" is
[
	a : extended integer's type,
	b : dimensioned extended integer's type
|
	dimensioned (a ÷ b's extent (Avail))
];

/**
 * Compute and answer the remainder after dividing the dividend by the divisor.
 * 
 * @method "_mod_"
 * @param "dividend" "dimensioned quantity"
 *        The dividend.
 * @param "divisor" "number"
 *        The divisor.
 * @returns "dimensioned quantity"
 *          The remainder.
 */
Public stable method "_mod_" is
[
	dividend : dimensioned quantity,
	divisor : number
|
	(dividend's extent mod divisor (Avail)) (dividend's metric)
] : dimensioned quantity;

Semantic restriction "_mod_" is
[
	x : dimensioned quantity's type,
	y : number's type
|
	numericType ::=
		type promotion function for
		[
			a : number,
			b : number
		|
			If b = 0 ∧ a's type ⊆ extended integer then
			[
				Reject parse, expected: "denominator not to be 0"
			];
			infinities ::= {∞, -∞};
			If a ∈ infinities ∧ b ∈ infinities then
			[
				Reject parse, expected:
					"either numerator or denominator to be finite"
			];
			a mod b (Avail)
		](x's extent, y);
	if |x's metric| = 1 then
	[
		numericType (x's metric's instance)
	]
	else
	[
		dimensioned numericType
	]
];

Semantic restriction "_mod_" is
[
	q : dimensioned extended integer's type,
	b : extended integer's type
|
	a ::= q's extent;
	numericType ::=
		if ⎣b⎦ = ⎡b⎤
			∧ ⎣a⎦ is finite
			∧ ⎡a⎤ is finite
			∧ ⎣a⎦ ÷ ⎣b⎦ (Avail) = ⎡a⎤ ÷ ⎣b⎦ (Avail)
		then
		[
			[⎣a⎦ mod ⎣b⎦ (Avail) .. ⎡a⎤ mod ⎣b⎦ (Avail)]
		]
		else
		[
			[0..⎡b⎤)
		];
	if |q's metric| = 1 then
	[
		numericType (q's metric's instance)
	]
	else
	[
		dimensioned numericType
	]
];

/**
 * Compute and answer the exponentiation of {@param "base"} and {@param
 * "power"}.
 *
 * @category "Dimensional Analysis"
 * @method "_^_"
 * @param "base" "dimensioned quantity"
 *        The {@type "dimensioned quantity" base}.
 * @param "power" "whole number"
 *        The {@type "whole number" exponent}.
 * @returns "dimensioned quantity"
 *          The {@type "dimensioned quantity" result} of the exponentiation.
 */
Public stable method "_^_" is
[
	base : dimensioned quantity,
	power : whole number
|
	(base's extent ^ power (Avail)) (base's metric ^ power)
] : dimensioned quantity;

Method "_^_(unit map)" is
[
	aUnit : unit,
	power : whole number's type
|
	minExponent : extended integer := ∞;
	maxExponent : extended integer := -∞;
	unitMap ::= aUnit's unit map;
	For each key → exponent of unitMap do
	[
	 	exponentType ::= exponent's type × power (Avail);
		minExponent := eject minExponent min ⎣exponentType⎦;
		maxExponent := eject maxExponent max ⎡exponentType⎤;
	];
	valueType ::= (minExponent - 1 (Avail) .. maxExponent + 1 (Avail));
	{atom→valueType | |unitMap|'s type}
];

Semantic restriction "_^_" is
[
	base : dimensioned quantity's type,
	power : whole number's type
|
	numericType ::=
		type promotion function for
		[
			a : number,
			b : number
		|
			a ^ b (Avail)
		](base's extent, power);
	resultType ::=
		if |base's metric| = 1 then
		[
			aUnit ::= base's metric's instance;
			unitMapType ::= aUnit ^ power (unit map);
			extend dimensioned quantity with
				extent : numericType,
				metric : (extend unit with unit map : unitMapType)
		]
		else [dimensioned numericType];
	resultType
];

For each index from 2 to |prettyPowers| do
[
	exponent ::= index;
	name ::= "_" ++ prettyPowers[index..index];
	Stable method name is
	[
		base : dimensioned quantity
	|
		(base's extent ^ exponent (Avail)) (base's metric ^ exponent)
	] : dimensioned quantity;
	Semantic restriction name is
	[
		base : dimensioned quantity's type
	|
		numericType ::=
			type promotion function for
			[
				a : number,
				b : number
			|
				a ^ b (Avail)
			](base's extent, exponent's type);
		if |base's metric| = 1 then
		[
			numericType (base's metric's instance)
		]
		else
		[
			dimensioned numericType
		]
	];
];

/**
 * Compute and answer the negation of the {@type "dimensioned quantity"
 * argument}.
 *
 * @category "Dimensional Analysis"
 * @method "-_"
 * @param "x" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @returns "dimensioned quantity"
 *          The negation of {@param "x"}.
 */
Public stable method "-_" is
[
	x : dimensioned quantity
|
	(-x's extent) (x's metric)
] : dimensioned quantity;

Semantic restriction "-_" is
[
	x : dimensioned quantity's type
|
	numericType ::=
		type promotion function for
		[
			a : number,
			b : number
		|
			0 - b (Avail)
		](0's type, x's extent);
	if |x's metric| = 1 then
	[
		numericType (x's metric's instance)
	]
	else
	[
		dimensioned numericType
	]
];

/**
 * Compute and answer the absolute value of the argument.
 * 
 * @method "`|_`|"
 * @param "x" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @returns "dimensioned quantity"
 *          The absolute value of {@param "x"}.
 */
Public stable method "`|_`|" is
[
	x : dimensioned quantity
|
	|x's extent| x's metric
] : dimensioned quantity;

Semantic restriction "`|_`|" is
[
	x : dimensioned quantity's type
|
	numericType ::=
		cast x's extent into [t : extended integer's type | [0..∞]]
		else [x's extent];
	if |x's metric| = 1 then
	[
		numericType (x's metric's instance)
	]
	else
	[
		dimensioned numericType
	]
];

/**
 * Compute and answer the floor of the argument.
 * 
 * @method "⎣_⎦"
 * @param "quantity" "dimensioned extended integer"
 *        An integral {@type "dimensioned quantity"}.
 * @returns "dimensioned extended integer"
 *          The floor of the argument.
 */
Stable abstract method "⎣_⎦" is [dimensioned quantity]→dimensioned quantity;

Method "⎣_⎦" is
[
	quantity : dimensioned extended integer
|
	quantity
] : dimensioned extended integer;

Semantic restriction "⎣_⎦" is
[
	valueType : dimensioned extended integer's type
|
	valueType
];

/**
 * Compute and answer the ceiling of the argument.
 * 
 * @method "⎣_⎦"
 * @param "quantity" "dimensioned extended integer"
 *        An integral {@type "dimensioned quantity"}.
 * @returns "dimensioned extended integer"
 *          The ceiling of the argument.
 */
Stable abstract method "⎡_⎤" is [dimensioned quantity]→dimensioned quantity;

Method "⎡_⎤" is
[
	quantity : dimensioned extended integer
|
	quantity
] : dimensioned extended integer;

Semantic restriction "⎡_⎤" is
[
	valueType : dimensioned extended integer's type
|
	valueType
];

[
	sum      ::= {"_+_", "_-_"};
	product  ::= {"_×_", "_÷_", "_mod_"};
	negation ::= {"-_"};
	jux      ::= {"__"};
	power    ::= {"_^_"};
	abs      ::= {"`|_`|"};
	bounds   ::= {"⎣_⎦", "⎡_⎤"};

	/* Establish the standard grammatical rules for arithmetic. */
	Grammatical restriction sum is <∅, sum>;
	Grammatical restriction product is <sum, sum ∪ product>;
	Grammatical restriction negation is <sum ∪ product ∪ negation ∪ jux>;
	Grammatical restriction power is <
		sum ∪ product ∪ negation ∪ power ∪ jux,
		sum ∪ product ∪ jux>;

	Grammatical restriction abs is <abs>;
	Grammatical restriction bounds is <bounds>;

	/* Forbid any arithmetic operators from occurring as arguments to
	 * dimensioned quantity accessors.
	 */
	accessors ::= {"_'s⁇extent", "_'s⁇metric"};
	Grammatical restriction accessors is <sum ∪ product ∪ negation ∪ power>;

	/* Forbid the first argument to juxtaposition to be an elementary arithmetic
	 * expression.
	 */
	availArith ::=
		{plus atom, minus atom, times atom, divide atom};
	Grammatical restriction jux is <sum ∪ product, ∅>;
	Grammatical restriction $"__" is <availArith, ∅>;
]();

/**
 * Is {@param "a"} < {@param "b"}?
 *
 * @category "Dimensional Analysis"
 * @method "_<_"
 * @param "a" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @param "b" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @returns "boolean"
 *          {@method "true"} if {@param "a"} < {@param "b"}, {@method "false"}
 *          otherwise.
 * @raises "incompatible-quantities exception"
 *         If the arguments are incompatible.
 */
Public method "_<_" is
[
	a : dimensioned quantity,
	b : dimensioned quantity
|
	Require: a and b are compatible;
	a's extent < b's extent
] : boolean;

/**
 * Is {@param "a"} ≤ {@param "b"}?
 *
 * @category "Dimensional Analysis"
 * @method "_≤_"
 * @param "a" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @param "b" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @returns "boolean"
 *          {@method "true"} if {@param "a"} ≤ {@param "b"}, {@method "false"}
 *          otherwise.
 * @raises "incompatible-quantities exception"
 *         If the arguments are incompatible.
 */
Public method "_≤_" is
[
	a : dimensioned quantity,
	b : dimensioned quantity
|
	Require: a and b are compatible;
	a's extent ≤ b's extent
] : boolean;

/**
 * Is {@param "a"} > {@param "b"}?
 *
 * @category "Dimensional Analysis"
 * @method "_>_"
 * @param "a" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @param "b" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @returns "boolean"
 *          {@method "true"} if {@param "a"} > {@param "b"}, {@method "false"}
 *          otherwise.
 * @raises "incompatible-quantities exception"
 *         If the arguments are incompatible.
 */
Public method "_>_" is
[
	a : dimensioned quantity,
	b : dimensioned quantity
|
	Require: a and b are compatible;
	a's extent > b's extent
] : boolean;

/**
 * Is {@param "a"} ≥ {@param "b"}?
 *
 * @category "Dimensional Analysis"
 * @method "_≥_"
 * @param "a" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @param "b" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @returns "boolean"
 *          {@method "true"} if {@param "a"} ≥ {@param "b"}, {@method "false"}
 *          otherwise.
 * @raises "incompatible-quantities exception"
 *         If the arguments are incompatible.
 */
Public method "_≥_" is
[
	a : dimensioned quantity,
	b : dimensioned quantity
|
	Require: a and b are compatible;
	a's extent ≥ b's extent
] : boolean;

Private method "comparison restriction function" is
[
	[
		a : dimensioned quantity's type,
		b : dimensioned quantity's type
	|
		Require: a's metric and b's metric are compatible;
		⊤
	]
];

Semantic restriction "_=_" is comparison restriction function;
Semantic restriction "_≠_" is comparison restriction function;
Semantic restriction "_<_" is comparison restriction function;
Semantic restriction "_≤_" is comparison restriction function;
Semantic restriction "_>_" is comparison restriction function;
Semantic restriction "_≥_" is comparison restriction function;

Semantic restriction "«_‡=»" is
[
	aTupleType : <dimensioned quantity…|3..>'s type
|
	ref ::= aTupleType[1];
	For each index from 2 to |aTupleType's leading types| + 1 (Avail) do
	[
		arg ::= aTupleType[index];
		If arg ∩ ref = ⊥ then
		[
			refMetric ::= if |ref's metric| = 1
				then [ref's metric's instance]
				else [ref's metric];
			argMetric ::= if |arg's metric| = 1
				then [arg's metric's instance]
				else [arg's metric];
			Reject parse, expected:
				format
					"all dimensioned quantities to have compatible units \
					\|(but “①” and “②” are not compatible)"
				with
					refMetric, argMetric
		];
	];
	⊤
] : type;

/* This table of functions is used by the inequality operations. */
predicates ::=
<
	[ a : number, b : number | a < b ],
	[ a : number, b : number | a ≤ b ],
	[ a : number, b : number | a = b ],
	[ a : number, b : number | a ≥ b ],
	[ a : number, b : number | a > b ]
>;

/**
 * Compute and answer the boolean value of the sequence of equals, less than or
 * equal, and less than operators.
 * 
 * @method "«_‡«=|≤|<»!»"
 * @param "args" "<<dimensioned quantity, [1..3]…|1..2>…|3..∞>"
 *        A tuple whose elements are a sequence of 2-tuples following by an
 *        ending 1-tuple. The first element of these 1,2-tuples is a {@type
 *        "dimensioned quantity"}. If present, the second element is 1, 2, or 3,
 *        indicating a comparison to the successive {@type "dimensioned
 *        quantity"} by =, ≤, or <, respectively.
 * @returns "boolean"
 *          {@method "true"} if the entire chain of comparisons is true,
 *          {@method "false"} otherwise.
 * @raises "incompatible-quantities exception"
 *         If the arguments are incompatible.
 */
Public method "«_‡«=|≤|<»!»" is
[
	args : <<dimensioned quantity, [1..3]…|1..2>…|3..∞>
|
	result : boolean := true;
	For each index from 1 to |args| - 1 (Avail) do
	[
		arg ::= args[index];
		Assert: |arg| = 2 ("args ≠ <aNumber, comparisonOperatorSubscript>");
		/* Determine which predicate to apply. */
		predicate ::= predicates[4 - arg[2] (Avail)];
		a ::= arg[1];
		b ::= args[index + 1 (Avail)][1];
		Require: a and b are compatible;
		if predicate(a's extent, b's extent) then
		[
			true
		]
		else
		[
			result := false;
			false
		]
	];
	result
];

/**
 * Compute and answer the boolean value of the sequence of equals, greater than
 * or equal, and greater than operators.
 * 
 * @method "«_‡«=|≥|>»!»"
 * @param "args" "<<dimensioned quantity, [1..3]…|1..2>…|3..∞>"
 *        A tuple whose elements are a sequence of 2-tuples following by an
 *        ending 1-tuple. The first element of these 1,2-tuples is a {@type
 *        "dimensioned quantity"}. If present, the second element is 1, 2, or 3,
 *        indicating a comparison to the successive {@type "dimensioned
 *        quantity"} by =, ≥, or >, respectively.
 * @returns "boolean"
 *          {@method "true"} if the entire chain of comparisons is true,
 *          {@method "false"} otherwise.
 * @raises "incompatible-quantities exception"
 *         If the arguments are incompatible.
 */
Public method "«_‡«=|≥|>»!»" is
[
	args : <<dimensioned quantity, [1..3]…|1..2>…|3..∞>
|
	result : boolean := true;
	For each index from 1 to |args| - 1 (Avail) do
	[
		arg ::= args[index];
		Assert: |arg| = 2 ("args ≠ <aNumber, comparisonOperatorSubscript>");
		/* Determine which predicate to apply. */
		predicate ::= predicates[2 + arg[2] (Avail)];
		a ::= arg[1];
		b ::= args[index + 1 (Avail)][1];
		Require: a and b are compatible;
		if predicate(a's extent, b's extent) then
		[
			true
		]
		else
		[
			result := false;
			false
		]
	];
	result
];

Private method "inequality chain restriction function" is
[
	[
		args : <<dimensioned quantity, [1..3]…|1..2>…|3..∞>'s type
	|
		exactSize ::= ⎣args⎦ - 1 (Avail);
		allEquals : boolean := true;
		ref ::= args[1][1];
		For each index from 1 to exactSize do
		[
			arg ::= args[index];
			If index > 1 ∧ arg[1] ∩ ref = ⊥ then
			[
				Require: ref's metric and arg[1]'s metric are compatible;
			];
			If ¬ 1 ∈ arg[2] then
			[
				allEquals := false;
			];
			allEquals
		];
		If allEquals then
		[
			Reject parse, expected:
				"inequality chain to include at least one inequality"
		];
		⊤
	]
];

Semantic restriction "«_‡«=|≤|<»!»" is
	inequality chain restriction function;
Semantic restriction "«_‡«=|≥|>»!»" is
	inequality chain restriction function;

/* Disallow mixing and recursive parsing of comparison operations. */
[
	binary ::=
		{
			$"_=_", $"_≤_", $"_<_", $"_≥_", $"_>_",
			less-than atom, less-than-equal atom,
			greater-than atom, greater-than-equal atom
		};
	chains ::=
		{
			$"«_‡=»", $"«_‡«=|≤|<»!»", $"«_‡«=|≥|>»!»",
			chained less-than atom, chained greater-than atom
		};
	restrictions ::= binary ∪ chains;
	Grammatical restriction chains is <restrictions>;
	Grammatical restriction binary is <restrictions, restrictions>;
	Grammatical restriction $"Require:_=_" is
		<restrictions, restrictions>;
	Grammatical restriction $"Require:_=_(_)" is
		<restrictions, restrictions, ∅>;
]();

/**
 * An arity-2 function that answers a {@type "dimensioned quantity"} when
 * applied with a {@type "dimensioned quantity"} and a {@type "unit"}.
 *
 * @category "Dimensional Analysis"
 * @type "unit conversion function"
 * @supertype "[⊥, ⊥]→dimensioned quantity"
 */
Public method "unit conversion function" is
[
	[⊥, ⊥]→dimensioned quantity
];

/**
 * A no-such-conversion exception is raised by {@method "_converted to_"} when
 * no conversion function is defined for the specified {@type "unit"}s.
 *
 * @category "Dimensional Analysis"
 * @type "no-such-conversion exception"
 * @supertype "exception"
 */
Public explicit class "no-such-conversion exception" extends exception
	with fields
		public source unit : unit,
		public target unit : unit;

/**
 * The table of defined conversions.
 *
 * @global "converters" "{<unit, unit…|2> → unit conversion function}"
 * @category "Dimensional Analysis"
 */
converters : {<unit, unit…|2> → unit conversion function|} := {};

Private method "all converters" is [lock stateLock for [converters]];

/**
 * Convert the specified {@type "dimensioned quantity"} to the specified {@type
 * "unit"}s and answer the result.
 *
 * @category "Dimensional Analysis"
 * @method "_converted to_"
 * @param "quantity" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @param "targetUnit" "unit"
 *        The {@type "unit" metric} of the result.
 * @returns "dimensioned quantity"
 *          The result of the conversion.
 * @raises "no-such-conversion exception"
 *         If no conversion function was previously defined for the specified
 *         {@type "unit"}s via {@method "Conversion method is_inverse is_"}.
 * @see {@method "Conversion method is_inverse is_"}
 */
Public stable method "_converted to_" is
[
	quantity : dimensioned quantity,
	targetUnit : unit
|
	$body : dimensioned quantity;
	key ::= <quantity's metric, targetUnit>;
	converter ::= all converters[key] else
		[
			If quantity's metric = targetUnit then [Exit body with quantity]
			else
			[
				Raise a no-such-conversion exception with
					source unit ::= key[1],
					target unit ::= key[2]
			]
		];
	converter(quantity, targetUnit)
] : dimensioned quantity;

/**
 * Reject the current parse if the {@type "unit" metrics} are well-known but no
 * conversion function has been defined prior to this send.
 *
 * @category "Dimensional Analysis"
 * @method "_converted to_"
 * @restricts "dimensioned quantity's type"
 * @restricts "unit's type"
 */
Semantic restriction "_converted to_" is
[
	quantityType : dimensioned quantity's type,
	unitType : unit's type
|
	If {|quantityType's metric|, |unitType|} = {1} then
	[
		key ::= <quantityType's metric's instance, unitType's instance>;
		If key[1] = key[2] then
		[
			Reject parse, expected:
				format
					"source and target units to be distinct (but both are “①”)"
				with key[1]
		];
		Unless key ∈ all converters ∨
			$"_converted to_" is implemented at <quantityType, unitType>
		then
		[
			Reject parse, expected:
				format
					"conversion function for “①” → “②” to have been previously\
					\| defined"
				with key[1], key[2]
		];
	];
	extend dimensioned quantity with metric : unitType
];

/**
 * Define {@method "_converted to_" methods} for converting {@type
 * "dimensioned quantity" dimensioned quantities} between two compatible {@type
 * "unit" metrics}.
 *
 * @category "Dimensional Analysis"
 * @method "Conversion method is_,⁇inverse is_"
 * @param "aFunction" "[⊥, ⊥]→dimensioned quantity"
 *        A function whose first parameter type is a subtypes of {@type
 *        "dimensioned quantity"} and whose second parameter type is a subtype
 *        of {@type "unit"}. This function must return a {@type "dimensioned
 *        quantity"} whose metric equals the second parameter type.
 * @param "inverseFunction" "[⊥, ⊥]→dimensioned quantity"
 *        A function whose first parameter type is a subtype of {@type
 *        "dimensioned quantity"} having a metric that equals the second
 *        parameter type of {@param "aFunction"} and whose second parameter type
 *        equals the metric of the first parameter type of same. This function
 *        must return a {@type "dimensioned quantity"} whose metric equals the
 *        second parameter type.
 * @returns "⊤"
 * @see {@method "_converted to_"}
 */
Public method "Conversion method is_,⁇inverse is_" is
[
	aFunction : unit conversion function,
	inverseFunction : unit conversion function
|
	functionParams ::= aFunction's type's parameters' type[1..];
	inverseParams ::= inverseFunction's type's parameters' type[1..];
	Cast each of
		<
			functionParams[1], functionParams[2],
			inverseParams[1], inverseParams[2]
		>
	into
	[
		quantityType : dimensioned quantity's type,
		unitType : unit's type,
		crossQuantityType : dimensioned quantity's type,
		crossUnitType : unit's type
	|
		Assert: quantityType's metric = crossUnitType;
		Assert: unitType = crossQuantityType's metric;
		key ::= <quantityType's metric's instance, unitType's instance>;
		Lock stateLock for
		[
			converters :=
				converters + key→aFunction + <key[2], key[1]>→inverseFunction;
		];
		After the current module is unloaded, do
		[
			Lock stateLock for
			[
				converters :=
					converters - key (Avail) - <key[2], key[1]> (Avail);
			];
		];
	];
] : ⊤;

/**
 * Reject the current parse if:
 *
 * <ul>
 * <li>The first function's parameter types are not subtypes of {@type
 *     "dimensioned quantity"} and {@type "unit"}, respectively.</li>
 * <li>The first function's parameter types' metrics are not precisely
 *     statically known.</li>
 * <li>The first function's first parameter type's metric is not equal to its
 *     second parameter type.</li>
 * <li>The first function's return type's metric is not equal to its second
 *     parameter type.</li>
 * <li>The second function's parameter types' metrics are not the reordering of
 *     the first function's parameter types' metrics.</li>
 * <li>The second function's return type's metric is not equal to its second
 *     parameter type.</li>
 * </ul>
 *
 * @category "Dimensional Analysis"
 * @method "Conversion method is_inverse is_"
 * @restricts "[⊥, ⊥]→dimensioned quantity's type"
 * @restricts "[⊥, ⊥]→dimensioned quantity's type"
 */
Semantic restriction "Conversion method is_,⁇inverse is_" is
[
	functionType : unit conversion function's type,
	inverseType : unit conversion function's type
|
	$body : ⊤'s type;
	If ⊥ ∈ {functionType[1], functionType[2]} then
	[
		Exit body with ⊤
	];
	Unless functionType[1] ⊆ dimensioned quantity ∧ functionType[2] ⊆ unit then
	[
		Reject parse, expected:
			format
				"first function to accept a dimensioned quantity and a unit \
				\|(but it accepts “①” and “②”)"
			with functionType[1], functionType[2]
	];
	strong1 ::= cast functionType[1] into [t : dimensioned quantity's type | t];
	strong2 ::= cast functionType[2] into [t : unit's type | t];
	Unless |strong1's metric| = 1 ∧ |strong2| = 1 then
	[
		Reject parse, expected:
			"units to be statically known"
	];
	Unless strong1's metric ≠ strong2 then
	[
		Reject parse, expected:
			format
				"first function's parameter's metrics not to be equal \
				\|(but both are “①”)"
			with strong2's instance
	];
	Unless functionType's return type's metric = strong2 then
	[
		Reject parse, expected:
			format
				"first function to return a dimensioned quantity with the same \
				\|metric as its second parameter (“①”) (but it returns “②”)"
			with
				strong2's instance,
				functionType's return type's metric's instance
	];
	inverse1 ::= cast inverseType[1] into [t : dimensioned quantity's type | t];
	Unless <inverse1's metric, inverseType[2]> = <strong2, strong1's metric>
	then
	[
		Reject parse, expected:
			format
				"second function's parameter types to be “①” \
				\|(not “②”)"
			with
				<
					extend dimensioned quantity with metric : strong2,
					strong1's metric
				>,
				<
					inverse1,
					inverseType[2]
				>
	];
	Unless inverseType's return type's metric = inverseType[2] then
	[
		Reject parse, expected:
			format
				"second function to return a dimensioned quantity with the same\
				\| metric as its second parameter (“①”) (but it returns “②”)"
			with
				inverseType[2]'s instance,
				inverseType's return type's metric's instance
	];
	⊤
];

/**
 * Are the arguments equivalent? That is, do they represent the same dimensioned
 * quantity after conversion?
 *
 * @category "Dimensional Analysis"
 * @method "_≍_"
 * @param "a" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @param "b" "dimensioned quantity"
 *        A {@type "dimensioned quantity"}.
 * @returns "boolean"
 *          {@method "true"} if the arguments are equivalent, {@method "false"}
 *          otherwise.
 * @raises "no-such-conversion exception"
 *         If no conversion function was previously defined for the specified
 *         {@type "unit"}s via {@method "Conversion method is_inverse is_"}.
 */
Public method "_≍_" is
[
	a : dimensioned quantity,
	b : dimensioned quantity
|
	a converted to b's metric = b
] : boolean;

/**
 * Construct and answer a {@type "function"} suitable for converting between
 * two {@type "unit"}s by merely scaling.
 *
 * @category "Dimensional Analysis"
 * @method "function for scaling from_to_by_using_"
 * @param "a" "unit"
 *        The source unit.
 * @param "b" "unit"
 *        The destination unit.
 * @param "scaleFactor" "number"
 *        The scale factor.
 * @param "scaleOperator" "atom"
 *        The scale operator.
 * @returns "function" "unit conversion function"
 */
Private method "function for scaling from_to_by_using_" is
[
	a : unit,
	b : unit,
	scaleFactor : number,
	scaleOperator : {$"_×_(Avail)", $"_÷_(Avail)"}ᵀ
|
	/* Construct the argument declarations. The first argument is a dimensioned
	 * quantity, the second is the target unit.
	 */
	qA ::= extend dimensioned quantity with metric : (a's type);
	qB ::= extend dimensioned quantity with metric : (b's type);
	args ::= <arg «`"quantity"` : qA», arg «`"aUnit"` : b's type»>;
	/* Construct the expression to obtain the scaled magnitude. */
	extentSend ::= send $"_'s⁇extent" with «<«↓args[1]»>» : number;
	scaled ::= restricted send scaleOperator
		with «<extentSend, ‘`scaleFactor`’>»
		: number;
	/* Construct the expression to obtain the resultant dimensioned quantity. */
	juxtapositionSend ::= restricted send $"__"
		with «<scaled, «↓args[2]»>»
		: qB;
	/* Construct and answer the requested function. */
	newBlock ::= «[ args | <juxtapositionSend> ] : dimensioned quantity»;
	cast newBlock→function into [t : unit conversion function | t]
] : unit conversion function;

/**
 * Define {@method "_converted to_" methods} for converting {@type
 * "dimensioned quantity" dimensioned quantities} between two compatible {@type
 * "unit" metrics} that differ only by a multiplicative constant.
 *
 * @category "Dimensional Analysis"
 * @method "Conversion rule:_≍_"
 * @param "a" "dimensioned (1's type)"
 *        A {@type "dimensioned quantity"} whose extent is {@code 1}.
 * @param "b" "dimensioned quantity"
 *        A {@type "dimensioned quantity"} equivalent to {@param "a"} but
 *        expressed in different {@type "unit"}s.
 * @returns "⊤"
 * @see {@method "_converted to_"}
 */
Public method "Conversion rule:_≍_" is
[
	a : dimensioned (1's type),
	b : dimensioned quantity
|
	metricA ::= a's metric;
	metricB ::= b's metric;
	scaleFactor ::= b's extent;
	Conversion method
		is function for scaling
			from metricA
			to metricB
			by scaleFactor
			using $"_×_(Avail)"
		inverse is function for scaling
			from metricB
			to metricA
			by scaleFactor
			using $"_÷_(Avail)";
] : ⊤;

Seal method "_^_(unit map)" at <any, any>;
Seal method "_·_(unit map)" at <any, any>;
Seal method "_/_(unit map)" at <any, any>;
Completely seal method "_≍_";

/**
 * Answer the dimensional analysis test suite identifier.
 * 
 * @method "dimensional analysis test suite"
 * @returns "atom"
 *          The requsted test suite identifier.
 */
Public method "Dimensional|dimensional analysis test suite"
	is [$"dimensional analysis test suite"];

Dimensional analysis test suite is a new test suite;
