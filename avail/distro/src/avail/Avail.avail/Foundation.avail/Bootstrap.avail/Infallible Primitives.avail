/*
 * Infallible Primitives.avail
 * Copyright ¬© 1993-2023, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * GENERATED FILE
 * * Generator: avail.tools.bootstrap.BootstrapGenerator
 * * Last Generated: 9/30/23, 1:49 PM
 *
 * DO NOT MODIFY MANUALLY. ALL MANUAL CHANGES WILL BE LOST.
 */

Module "Infallible Primitives"
Versions
	"Avail-1.6.1"
Extends
Uses
	"Origin",
	"Special Objects",
	"Primitives" =
	(
		"$_",
		"<_,_`‚Ä¶`|_>",
		"Breakpoint",
		"Cast|cast_into_else_",
		"Crash:_",
		"Exit_if_",
		"Park current fiber",
		"Request termination of_",
		"Restart_",
		"Set name of function implementation_to_",
		"Sleep for_millisecond|milliseconds",
		"Terminate current fiber",
		"Unname_from_",
		"Unpark_",
		"Yield current fiber",
		"[`‚Ä¶]‚Üí_",
		"_'s‚Åáarguments",
		"_'s‚Åáarity",
		"_'s‚Åáatom",
		"_'s‚Åábindings",
		"_'s‚Åábundle",
		"_'s‚Åácaller",
		"_'s‚Åácharacter type number",
		"_'s‚Åácode point",
		"_'s‚Åádeclaration",
		"_'s‚Åádeclared exceptions",
		"_'s‚Åádeclared type",
		"_'s‚Åádefault type",
		"_'s‚Åádefinitions",
		"_'s‚Åáelement type",
		"_'s‚Åáelement|member type",
		"_'s‚Åáentry points",
		"_'s‚Åáexpression",
		"_'s‚Åáexpressions",
		"_'s‚Åáfunction",
		"_'s‚Åáfunction type",
		"_'s‚Åágenuine lower bound",
		"_'s‚Åágenuine upper bound",
		"_'s‚Åáhash",
		"_'s‚Åáimplementation",
		"_'s‚Åákey type",
		"_'s‚Åákeys",
		"_'s‚Åáleading types",
		"_'s‚Åálexeme",
		"_'s‚Åáline number",
		"_'s‚Åálist",
		"_'s‚Åáliterals",
		"_'s‚Åálookup type",
		"_'s‚Åámaximum stack depth",
		"_'s‚Åámessage",
		"_'s‚Åámethod",
		"_'s‚Åáname",
		"_'s‚Åáname:=_",
		"_'s‚Åánames",
		"_'s‚Åánybblecodes",
		"_'s‚Åáouter variables",
		"_'s‚Åáparameters'type",
		"_'s‚Åápermutation",
		"_'s‚Åáprimitive name",
		"_'s‚Åápriority",
		"_'s‚Åápriority:=_",
		"_'s‚Åáprogram counter",
		"_'s‚Åápublic names",
		"_'s‚Åáread type",
		"_'s‚Åáresult type",
		"_'s‚Åáreturn type",
		"_'s‚Åáseals",
		"_'s‚Åásemantic type",
		"_'s‚Åásequence",
		"_'s‚Åástack",
		"_'s‚Åástack pointer",
		"_'s‚Åástarting position",
		"_'s‚Åástatements",
		"_'s‚Åátarget",
		"_'s‚Åátoken",
		"_'s‚Åátokens",
		"_'s‚Åátype",
		"_'s‚Åávalue",
		"_'s‚Åávalue type",
		"_'s‚Åávalues",
		"_'s‚Åáwrite type",
		"_++_",
		"_+_",
		"_+_‚Üí_",
		"_-_",
		"_<_",
		"_=_",
		"_[_]",
		"_\\_",
		"_^_",
		"_bit test_",
		"_bit‚àß_",
		"_bit‚à®_",
		"_bit‚äï_",
		"_has initializing expression",
		"_has public name_",
		"_has result",
		"_has terminated",
		"_is a primitive",
		"_is a valid message",
		"_is open for side effects",
		"_is special",
		"_mod_",
		"_reinterpreted as bits",
		"_reinterpreted as double",
		"_reinterpreted as float",
		"_reversed",
		"_‚Üëis unassigned",
		"_‚ÜíJSON",
		"_‚Üíblock phrase",
		"_‚Üícharacter",
		"_‚Üídouble",
		"_‚Üífloat",
		"_‚Üílist phrase",
		"_‚Üíliteral phrase",
		"_‚Üímap",
		"_‚Üíobject",
		"_‚Üíobject type",
		"_‚Üíset",
		"_‚Üístatement phrase",
		"_‚Üítuple",
		"_‚áí_",
		"_‚àà_",
		"_‚à©_",
		"_‚à™_",
		"_‚â§_",
		"_‚äÜ_",
		"_‚®â_^_",
		"`|_'s‚Åálocal variables`|",
		"`|_'s‚Åáouter variables`|",
		"`|_'s‚Åáparameters`|",
		"`|_`|",
		"`|`|_`|`|",
		"`¬´$_:_`¬ª",
		"`¬´_::=_`¬ª",
		"`¬´_:_:=_`¬ª",
		"`¬´_:_`¬ª",
		"`¬´marker phrase_‚áí_`¬ª",
		"`¬´module variable_(_)`¬ª",
		"`¬´‚Üì_`¬ª",
		"`¬´‚Üì_`¬ª(_)",
		"`‚Üë_",
		"arg`¬´_:_`¬ª",
		"concatenate_",
		"current fiber",
		"current fiber can reject a parse",
		"current fiber[_]:=_",
		"enumeration of_",
		"fiber‚Üí_",
		"function accepting_and returning_",
		"high-precision timer value",
		"integer range from_(inclusive=_)to_(inclusive=_)",
		"literal token‚áí_",
		"ln_",
		"method exists named_",
		"milliseconds since the Epoch",
		"new_[_]",
		"new_applying_",
		"new`‚Üë_",
		"non-canonical problem with_",
		"primfail`¬´_:_`¬ª",
		"primitive description of_",
		"read_/write_",
		"sequence-as-expression`¬´_`¬ª",
		"sin_",
		"termination requested",
		"{_`|_}",
		"{_‚Üí_`|_}",
		"‚à™_",
		"‚à™_[_.._]",
		"‚åà_‚åâ",
		"‚åä_‚åã"
	)
Names
Body

/**
 * Is the specified {@type "atom"} special, i.e., well-known to the Avail
 * implementation?
 *
 * @category "Primitives"
 * @method "_is special"
 * @param "anAtom" "atom"
 *        An arbitrary {@type "atom"}.
 * @returns "boolean"
 *    {@method "true"} if {@param "anAtom"} is special, {@method "false"}
 *    otherwise.
 */
Primitive "_is special" is
[
	anAtom : atom
|
	Primitive AtomIsSpecial;
] : boolean;

/**
 * Answer the debug name of the specified atom.
 *
 * @category "Primitives" "Atoms" "Queries"
 * @method "_'s‚Åáname"
 * @param "anAtom" "atom"
 *        An atom.
 * @returns "string"
 *    The argument's debug name.
 */
Primitive "_'s‚Åáname" is
[
	anAtom : atom
|
	Primitive AtomName;
] : string;

/**
 * Is {@param "name"} a valid message? Do not attempt to look up a method
 * associated with this name. Simply verify that {@param "name"} is a viable
 * name of a method.
 *
 * @category "Primitives" "Methods" "Queries"
 * @method "_is a valid message"
 * @param "name" "atom"
 *        The name in question.
 * @returns "boolean"
 *    {@method "true"} if the argument is a valid message, {@method "false"}
 *    otherwise.
 */
Primitive "_is a valid message" is
[
	name : atom
|
	Primitive IsCanonicalMessage;
] : boolean;

/**
 * Answer the argument's Unicode code point.
 *
 * @category "Primitives" "Integers" "Unicode" "Conversions"
 * @method "_'s‚Åácode point"
 * @param "aCharacter" "character"
 *        A character.
 * @returns "[0..1114111]"
 *    The Unicode code point that encodes the argument.
 */
Primitive "_'s‚Åácode point" is
[
	aCharacter : character
|
	Primitive CharacterCodePoint;
] : code point;

/**
 * Answer the argument as a character.
 *
 * @category "Primitives" "Integers" "Unicode" "Conversions"
 * @method "_‚Üícharacter"
 * @param "codePoint" "[0..1114111]"
 *        A Unicode code point.
 * @returns "character"
 *    The character encoded by the argument.
 */
Primitive "_‚Üícharacter" is
[
	codePoint : code point
|
	Primitive CharacterFromCodePoint;
] : character;

/**
 * Answer the character type of the given character.  The character type is an
 * integer in the range [0..31], corresponding to
 * {@code "java.lang.Character.getType(int)"}.
 *
 * @category "Primitives"
 * @method "_'s‚Åácharacter type number"
 * @param "aCharacter" "character"
 *        The character to categorize.
 * @returns "[0..31]"
 *    The type of character that was provided, encoded as a value in [0..31].
 */
Primitive "_'s‚Åácharacter type number" is
[
	aCharacter : character
|
	Primitive CharacterType;
] : character type number;

/**
 * Construct and answer a variable that holds the caller of the specified
 * continuation. This variable will be unassigned if the continuation has no
 * caller.
 *
 * @category "Primitives" "Continuations" "Variables" "Constructors"
 * @method "_'s‚Åácaller"
 * @param "aContinuation" "$[‚Ä¶]‚Üí‚ä•"
 *        A continuation.
 * @returns "‚Üë$[‚Ä¶]‚Üí‚ä•"
 *    A variable that, if assigned, holds the argument's caller. If unassigned,
 *    then the argument has no caller.
 */
Primitive "_'s‚Åácaller" is
[
	aContinuation : continuation
|
	Primitive ContinuationCaller;
] : continuation variable;

/**
 * Answer the current function of the specified continuation.
 *
 * @category "Primitives" "Continuations" "Queries"
 * @method "_'s‚Åáfunction"
 * @param "aContinuation" "$[‚Ä¶]‚Üí‚ä•"
 *        A continuation.
 * @returns "[‚Ä¶]‚Üí‚ä§"
 *    The argument's current function. This is the function whose execution
 *    will be resumed if the continuation is resumed.
 */
Primitive "_'s‚Åáfunction" is
[
	aContinuation : continuation
|
	Primitive ContinuationFunction;
] : function;

/**
 * Answer the program counter of the specified continuation. Using the current
 * function's tuple of Level One nybblecodes, this is the index of the next
 * instruction to be performed (if the continuation is resumed).
 *
 * @category "Primitives" "Continuations" "Queries"
 * @method "_'s‚Åáprogram counter"
 * @param "aContinuation" "$[‚Ä¶]‚Üí‚ä•"
 *        A continuation.
 * @returns "‚Ñï"
 *    The argument's Level One program counter.
 */
Primitive "_'s‚Åáprogram counter" is
[
	aContinuation : continuation
|
	Primitive ContinuationPC;
] : natural number;

/**
 * Answer the stack of the specified continuation. This tuple contains the
 * arguments, local variables, and temporaries. Any null values, forbidden to
 * leak through into observable Avail macro-state, are replaced with an
 * unassigned variable whose containment type is ‚ä•. Note that such a variable
 * cannot be constructed either syntactically nor through a variable
 * construction primitive.
 *
 * @category "Primitives" "Continuations" "Queries"
 * @method "_'s‚Åástack"
 * @param "aContinuation" "$[‚Ä¶]‚Üí‚ä•"
 *        A continuation.
 * @returns "tuple"
 *    The argument's stack.
 */
Primitive "_'s‚Åástack" is
[
	aContinuation : continuation
|
	Primitive ContinuationStackData;
] : tuple;

/**
 * Answer the stack pointer of the specified continuation. This is the index of
 * the top of the local stack. For an empty stack, this value equals the size of
 * the stack plus one. The stack grows downward.
 *
 * @category "Primitives" "Continuations" "Queries"
 * @method "_'s‚Åástack pointer"
 * @param "aContinuation" "$[‚Ä¶]‚Üí‚ä•"
 *        A continuation.
 * @returns "‚Ñï"
 *    The argument's stack pointer.
 */
Primitive "_'s‚Åástack pointer" is
[
	aContinuation : continuation
|
	Primitive ContinuationStackPointer;
] : natural number;

/**
 * Answer the type of the function represented by the specified continuation.
 *
 * @category "Primitives" "Types" "Continuations" "Queries"
 * @method "_'s‚Åáfunction type"
 * @param "continuationType" "{$[‚Ä¶]‚Üí‚ä•}·µÄ"
 *        A continuation type.
 * @returns "{[‚Ä¶]‚Üí‚ä§}·µÄ"
 *    The argument's current function's type.
 */
Primitive "_'s‚Åáfunction type" is
[
	continuationType : continuation meta
|
	Primitive ContinuationTypeToFunctionType;
] : function meta;

/**
 * Compute and answer a continuation type capable of representing a current
 * function of the specified type.
 *
 * @category "Primitives" "Types" "Continuations" "Constructors"
 * @method "$_"
 * @param "functionType" "{[‚Ä¶]‚Üí‚ä§}·µÄ"
 *        A function type.
 * @returns "{$[‚Ä¶]‚Üí‚ä•}·µÄ"
 *    The requested continuation type.
 */
Primitive "$_" is
[
	functionType : function meta
|
	Primitive FunctionTypeToContinuationType;
] : continuation meta;

/**
 * If the provided boolean is true, exit the ‚ä§-producing continuation. Execution
 * proceeds as though the continuation had just returned normally. The current
 * continuation (in which this primitive was invoked) is completely replaced by
 * the specified continuation's resumed caller.  If the provided boolean is
 * false, do nothing.
 *
 * @category "Primitives" "Continuations" "Control Structures"
 * @method "Exit_if_"
 * @param "aContinuation" "$[‚Ä¶]‚Üí‚ä§"
 *        The continuation to exit.
 * @param "condition" "boolean"
 *        Whether to exit.
 * @raises "‚ä§"
 */
Primitive "Exit_if_" is
[
	aContinuation : continuation returning top,
	condition : boolean
|
	Primitive ExitContinuationIf;
] : ‚ä§;

/**
 * Restart the continuation with its original arguments. Execution proceeds as
 * though the continuation's caller had just invoked the continuation's current
 * function with its original arguments. The current continuation (in which
 * this primitive was invoked) is completely replaced by the restarted
 * continuation.
 *
 * @category "Primitives" "Continuations" "Control Structures"
 * @method "Restart_"
 * @param "aContinuation" "$[‚Ä¶]‚Üí‚ä•"
 *        The continuation to restart.
 * @returns "‚ä•"
 */
Primitive "Restart_" is
[
	aContinuation : continuation
|
	Primitive RestartContinuation;
] : ‚ä•;

/**
 * Compute and answer the numeric argument as a double-precision floating point
 * number.
 *
 * @category "Primitives" "Numbers" "Conversions"
 * @method "_‚Üídouble"
 * @param "aNumeric" "number"
 *        A number.
 * @returns "double"
 *    A {@type "double"} whose value approximates the argument.
 */
Primitive "_‚Üídouble" is
[
	aNumeric : number
|
	Primitive AsDouble;
] : double;

/**
 * Compute and answer the smallest integral double-precision floating point
 * number greater than or equal to the argument, i.e., the ceiling of {@param "x"}.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "‚åà_‚åâ"
 * @param "x" "double"
 *        A double-precision floating point number.
 * @returns "double"
 *    If the `0` is ¬±‚àû or not-a-number, then {@param "x"}, otherwise the ceiling of
 *    {@param "x"}.
 */
Primitive "‚åà_‚åâ" is
[
	x : double
|
	Primitive DoubleCeiling;
] : double;

/**
 * Compute and answer an approximation of the natural exponential function for
 * the given exponent, i.e., e^{@param "x"}.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "_^_"
 * @param "eulerNumber" "{2.718281828459045}·µÄ"
 *        Euler's number.
 * @param "x" "double"
 *        The exponent.
 * @returns "double"
 *    An approximation of e^{@param "x"}.
 */
Primitive "_^_" is
[
	eulerNumber : type of Euler number,
	x : double
|
	Primitive DoubleExp;
] : double;

/**
 * Compute and answer the largest integral double-precision floating point
 * number less than or equal to the argument, i.e., the floor of {@param
 * "x"}.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "‚åä_‚åã"
 * @param "x" "double"
 *        A double-precision floating point number.
 * @returns "double"
 *    If the `0` is ¬±‚àû or not-a-number, then {@param "x"}, otherwise the
 *    floor of {@param "x"}.
 */
Primitive "‚åä_‚åã" is
[
	x : double
|
	Primitive DoubleFloor;
] : double;

/**
 * Reinterpret the 64-bit signed integer as the bit pattern of an IEEE-754
 * double-precision floating point number.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "_reinterpreted as double"
 * @param "anInt64" "i64"
 *        A 64-bit signed integer.
 * @returns "double"
 *    The double having the specified bit representation.
 */
Primitive "_reinterpreted as double" is
[
	anInt64 : int64
|
	Primitive DoubleFromLongBits;
] : double;

/**
 * Compute and answer an approximation of the natural logarithm of the argument,
 * i.e., ln {@param "x"}.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "ln_"
 * @param "x" "double"
 *        A double-precision floating point number.
 * @returns "double"
 *    An approximation of ln {@param "x"}.
 */
Primitive "ln_" is
[
	x : double
|
	Primitive DoubleLn;
] : double;

/**
 * Compute and answer an approximation of {@param "dividend"} modulo {@param "divisor"}, i.e. the
 * remainder produced by dividing the arguments.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "_mod_"
 * @param "dividend" "double"
 *        The dividend.
 * @param "divisor" "double"
 *        The divisor.
 * @returns "double"
 *    An approximation of `0` mod {@param "divisor"}.
 */
Primitive "_mod_" is
[
	dividend : double,
	divisor : double
|
	Primitive DoubleModulus;
] : double;

/**
 * Compute and answer an approximation of sin {@param "theta"}, i.e. the
 * ratio of the altitude to the distance between the origin and a point projected
 * at an angle given by the argument in radians.
 *
 * @category "Primitives"
 * @method "sin_"
 * @param "theta" "double"
 *        The angle in radians.
 * @returns "double"
 *    The sine of the given angle.
 */
Primitive "sin_" is
[
	theta : double
|
	Primitive DoubleSine;
] : double;

/**
 * Compute and answer {@param "a"}‚®â(2^{@param "two"}) without loss of
 * precision or intermediate overflow. This scales {@param "a"} by a power
 * of two (`2`).
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "_‚®â_^_"
 * @param "a" "double"
 *        A single-precision floating point number.
 * @param "two" "{2}·µÄ"
 *        The number two (`2`).
 * @param "b" "‚Ñ§"
 *        The scaling factor.
 * @returns "double"
 *    The requested value.
 */
Primitive "_‚®â_^_" is
[
	a : double,
	two : type of two,
	b : integer
|
	Primitive DoubleTimesTwoPower;
] : double;

/**
 * Treat the IEEE-754 double-precision floating point number's representation as
 * a 64 bit sequence, and answer the (signed) integer having those bits.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "_reinterpreted as bits"
 * @param "aDouble" "double"
 *        The double to reinterpret.
 * @returns "i64"
 *    The double's bit representation as a signed 64-bit integer.
 */
Primitive "_reinterpreted as bits" is
[
	aDouble : double
|
	Primitive DoubleToLongBits;
] : int64;

/**
 * Ascertain whether the current fiber can reject an ongoing parse.
 *
 * @category "Primitives" "Concurrency"
 * @method "current fiber can reject a parse"
 * @returns "boolean"
 *    `true` if the current fiber can reject a parse, `false`
 *    otherwise.
 */
Primitive "current fiber can reject a parse" is
[
	Primitive CanRejectParse;
] : boolean;

/**
 * Construct and answer a fiber type whose result type is {@param "resultType"}.
 *
 * @category "Primitives" "Types" "Concurrency"
 * @method "fiber‚Üí_"
 * @param "resultType" "{‚ä§}·µÄ"
 *        A type.
 * @returns "{fiber‚Üí‚ä§}·µÄ"
 *    The requested fiber type.
 */
Primitive "fiber‚Üí_" is
[
	resultType : type
|
	Primitive CreateFiberType;
] : fiber meta;

/**
 * Answer the current fiber.
 *
 * @category "Primitives" "Concurrency" "Queries"
 * @method "current fiber"
 * @returns "fiber‚Üí‚ä§"
 *    The current fiber.
 */
Primitive "current fiber" is
[
	Primitive CurrentFiber;
] : fiber;

/**
 * Answer the name of the specified fiber.
 *
 * @category "Primitives" "Concurrency" "Queries"
 * @method "_'s‚Åáname"
 * @param "aFiber" "fiber‚Üí‚ä§"
 *        A fiber.
 * @returns "string"
 *    The fiber's name.
 */
Primitive "_'s‚Åáname" is
[
	aFiber : fiber
|
	Primitive FiberName;
] : string;

/**
 * Answer the result type of the specified fiber type.
 *
 * @category "Primitives" "Types" "Concurrency" "Queries"
 * @method "_'s‚Åáresult type"
 * @param "fiberType" "{fiber‚Üí‚ä§}·µÄ"
 *        A fiber type.
 * @returns "{‚ä§}·µÄ"
 *    The argument's result type.
 */
Primitive "_'s‚Åáresult type" is
[
	fiberType : fiber meta
|
	Primitive FiberTypeResultType;
] : type;

/**
 * Extract the priority of a fiber. A fiber with higher priority may receive a
 * larger share of the available CPU time than one with a low priority.
 *
 * @category "Primitives" "Concurrency" "Queries"
 * @method "_'s‚Åápriority"
 * @param "aFiber" "fiber‚Üí‚ä§"
 *        The fiber from which to extract the priority.
 * @returns "u8"
 *    A whole number representing the priority of the fiber.
 */
Primitive "_'s‚Åápriority" is
[
	aFiber : fiber
|
	Primitive GetFiberPriority;
] : byte;

/**
 * Does the specified fiber have a result ready?
 *
 * @category "Primitives" "Concurrency" "Queries"
 * @method "_has result"
 * @param "aFiber" "fiber‚Üí‚ä§"
 *        A fiber.
 * @returns "boolean"
 *    `true` if the fiber has terminated and produced a result, `false`
 *    otherwise.
 */
Primitive "_has result" is
[
	aFiber : fiber
|
	Primitive HasResult;
] : boolean;

/**
 * Has the specified fiber terminated?
 *
 * @category "Primitives" "Concurrency" "Queries"
 * @method "_has terminated"
 * @param "aFiber" "fiber‚Üí‚ä§"
 *        A fiber.
 * @returns "boolean"
 *    `true` if the fiber has terminated, `false` otherwise.
 */
Primitive "_has terminated" is
[
	aFiber : fiber
|
	Primitive HasTerminated;
] : boolean;

/**
 * Has termination of the current fiber been requested? Answer the current value
 * of the appropriate interrupt request flag and simultaneously clear it.
 *
 * @category "Primitives" "Concurrency" "Queries"
 * @method "termination requested"
 * @returns "boolean"
 *    `true` if termination of the current fiber has been requested, `false`
 *    otherwise.
 */
Primitive "termination requested" is
[
	Primitive IsTerminationRequested;
] : boolean;

/**
 * Attempt to acquire the permit associated with the current fiber. If the
 * permit is available, then consume it and return immediately. If the permit is
 * not available, then park the current fiber. A fiber suspended in this fashion
 * may be resumed only by calling `Unpark_`. A newly unparked fiber should
 * always recheck the basis for its having parked, to see if it should park
 * again. Low-level synchronization mechanisms may require the ability to
 * spuriously unpark in order to ensure correctness.
 *
 * @category "Primitives" "Concurrency" "Synchronization" "Control Structures"
 * @method "Park current fiber"
 * @returns "‚ä§"
 */
Primitive "Park current fiber" is
[
	Primitive ParkCurrentFiber;
] : ‚ä§;

/**
 * Request termination of the specified fiber, unparking the fiber at the same
 * time. Termination is consensual only; cooperation of the fiber is required to
 * affect actual termination.
 *
 * @category "Primitives" "Concurrency" "Mutators"
 * @method "Request termination of_"
 * @param "victim" "fiber‚Üí‚ä§"
 *        A fiber.
 * @returns "‚ä§"
 */
Primitive "Request termination of_" is
[
	victim : fiber
|
	Primitive RequestTermination;
] : ‚ä§;

/**
 * Set the name of the specified fiber.
 *
 * @category "Primitives" "Concurrency" "Mutators"
 * @method "_'s‚Åáname:=_"
 * @param "aFiber" "fiber‚Üí‚ä§"
 *        A fiber.
 * @param "name" "string"
 *        The fiber's new name.
 * @returns "‚ä§"
 */
Primitive "_'s‚Åáname:=_" is
[
	aFiber : fiber,
	name : string
|
	Primitive SetFiberName;
] : ‚ä§;

/**
 * Modify the priority of a fiber. A fiber with higher priority may receive a
 * larger share of the available CPU time than one with a low priority.
 *
 * @category "Primitives" "Concurrency" "Mutators"
 * @method "_'s‚Åápriority:=_"
 * @param "aFiber" "fiber‚Üí‚ä§"
 *        The fiber to prioritize.
 * @param "priority" "u8"
 *        The new priority.
 * @returns "‚ä§"
 */
Primitive "_'s‚Åápriority:=_" is
[
	aFiber : fiber,
	priority : byte
|
	Primitive SetFiberPriority;
] : ‚ä§;

/**
 * Set the value bound to {@param "key"} in the current fiber's environment,
 * overwriting any previous value. Since the fiber's environment essentially
 * contains fiber-local variables (i.e. bindings from atoms to arbitrary
 * values), this operation effectively writes a fiber-local variable.
 *
 * @category "Primitives" "Concurrency" "Mutators"
 * @method "current fiber[_]:=_"
 * @param "key" "atom"
 *        The key whose value should be (over)written.
 * @param "value" "any"
 *        The new value.
 * @returns "‚ä§"
 */
Primitive "current fiber[_]:=_" is
[
	key : atom,
	value : any
|
	Primitive SetFiberVariable;
] : ‚ä§;

/**
 * Cause the current fiber to sleep for the specified number of milliseconds.
 * The fiber will sleep for at least the specified amount of time, and a best
 * effort will be made to awaken the fiber as soon as the delay has expired.
 * No real-time guarantees are made.
 *
 * @category "Primitives" "Concurrency" "Time" "Control Structures"
 * @method "Sleep for_millisecond|milliseconds"
 * @param "delayMillis" "[0..‚àû]"
 *        The minimum number of milliseconds to sleep.
 * @returns "‚ä§"
 */
Primitive "Sleep for_millisecond|milliseconds" is
[
	delayMillis : nonnegative extended integer
|
	Primitive Sleep;
] : ‚ä§;

/**
 * Terminate the current fiber.
 *
 * @category "Primitives" "Bootstrap" "Concurrency"
 * @method "Terminate current fiber"
 * @returns "‚ä•"
 */
Primitive "Terminate current fiber" is
[
	Primitive TerminateCurrentFiber;
] : ‚ä•;

/**
 * Unpark the specified fiber. If the permit associated with the fiber is
 * available, then simply continue. If the permit is not available, then restore
 * the permit and schedule resumption of the fiber. A newly unparked fiber
 * should always recheck the basis for its having parked, to see if it should
 * park again. Low-level synchronization mechanisms may require the ability to
 * spuriously unpark in order to ensure correctness.
 *
 * @category "Primitives" "Concurrency" "Synchronization" "Control Structures"
 * @method "Unpark_"
 * @param "aFiber" "fiber‚Üí‚ä§"
 *        A fiber.
 * @returns "‚ä§"
 */
Primitive "Unpark_" is
[
	aFiber : fiber
|
	Primitive UnparkFiber;
] : ‚ä§;

/**
 * Yield the current fiber. That is, give up the fiber's time slice so that
 * other processes of higher or equal priority may run.
 *
 * @category "Primitives" "Concurrency"
 * @method "Yield current fiber"
 * @returns "‚ä§"
 */
Primitive "Yield current fiber" is
[
	Primitive Yield;
] : ‚ä§;

/**
 * Compute and answer the numeric argument as a single-precision floating point
 * number.
 *
 * @category "Primitives" "Numbers" "Conversions"
 * @method "_‚Üífloat"
 * @param "aNumber" "number"
 *        A number.
 * @returns "float"
 *    A {@type "float"} whose value approximates the argument.
 */
Primitive "_‚Üífloat" is
[
	aNumber : number
|
	Primitive AsFloat;
] : float;

/**
 * Compute and answer the smallest integral single-precision floating point
 * number greater than or equal to the argument, i.e., the ceiling of {@param "x"}.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "‚åà_‚åâ"
 * @param "x" "float"
 *        A single-precision floating point number.
 * @returns "float"
 *    If the `0` is ¬±‚àû or not-a-number, then {@param "x"}, otherwise the
 *    ceiling of {@param "x"}.
 */
Primitive "‚åà_‚åâ" is
[
	x : float
|
	Primitive FloatCeiling;
] : float;

/**
 * Compute and answer an approximation of the natural exponential function for
 * the given exponent, i.e., e^{@param "x"}.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "_^_"
 * @param "eulerNumber" "{2.718281828459045}·µÄ"
 *        Euler's number.
 * @param "x" "float"
 *        The exponent.
 * @returns "float"
 *    An approximation of e^{@param "x"}.
 */
Primitive "_^_" is
[
	eulerNumber : type of Euler number,
	x : float
|
	Primitive FloatExp;
] : float;

/**
 * Compute and answer the largest integral single-precision floating point
 * number less than or equal to the argument, i.e., the floor of {@param "x"}.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "‚åä_‚åã"
 * @param "x" "float"
 *        A single-precision floating point number.
 * @returns "float"
 *    If the `0` is ¬±‚àû or not-a-number, then {@param "x"}, otherwise the
 *    floor of {@param "x"}.
 */
Primitive "‚åä_‚åã" is
[
	x : float
|
	Primitive FloatFloor;
] : float;

/**
 * Reinterpret the 32-bit signed integer as the bit pattern of an IEEE-754
 * floating point number.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "_reinterpreted as float"
 * @param "anInt32" "i32"
 *        A 32-bit signed integer.
 * @returns "float"
 *    The single-precision float having the specified bit representation.
 */
Primitive "_reinterpreted as float" is
[
	anInt32 : int32
|
	Primitive FloatFromIntBits;
] : float;

/**
 * Compute and answer an approximation of the natural logarithm of the argument,
 * i.e., ln {@param "x"}.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "ln_"
 * @param "x" "float"
 *        A single-precision floating point number.
 * @returns "float"
 *    An approximation of ln {@param "x"}.
 */
Primitive "ln_" is
[
	x : float
|
	Primitive FloatLn;
] : float;

/**
 * Compute and answer an approximation of {@param "dividend"} modulo {@param "divisor"}, i.e. the
 * remainder produced by dividing the arguments.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "_mod_"
 * @param "dividend" "float"
 *        The dividend.
 * @param "divisor" "float"
 *        The divisor.
 * @returns "float"
 *    An approximation of {@param "dividend"} mod {@param "divisor"}.
 */
Primitive "_mod_" is
[
	dividend : float,
	divisor : float
|
	Primitive FloatModulus;
] : float;

/**
 * Compute and answer {@param "a"}‚®â(2^{@param "b"}) without loss of precision or
 * intermediate overflow. This scales {@param "a"} by a power of two (`2`).
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "_‚®â_^_"
 * @param "a" "float"
 *        A single-precision floating point number.
 * @param "two" "{2}·µÄ"
 *        The number two (`2`).
 * @param "b" "‚Ñ§"
 *        The scaling factor.
 * @returns "float"
 *    The requested value.
 */
Primitive "_‚®â_^_" is
[
	a : float,
	two : type of two,
	b : integer
|
	Primitive FloatTimesTwoPower;
] : float;

/**
 * Treat the IEEE-754 single-precision float's representation as a 32 bit
 * sequence, and answer the (signed) integer having those bits.
 *
 * @category "Primitives" "Numbers" "Mathematics"
 * @method "_reinterpreted as bits"
 * @param "aFloat" "float"
 *        The float to reinterpret.
 * @returns "i32"
 *    The float's bit representation as a signed 32-bit integer.
 */
Primitive "_reinterpreted as bits" is
[
	aFloat : float
|
	Primitive FloatToIntBits;
] : int32;

/**
 * Construct and answer a function type with the specified parameter types and
 * return type.
 *
 * @category "Primitives" "Types" "Functions" "Constructors"
 * @method "function accepting_and returning_"
 * @param "parameterTypes" "{any}·µÄ*"
 *        The parameter types.
 * @param "returnType" "{‚ä§}·µÄ"
 *        The return type.
 * @returns "{[‚Ä¶]‚Üí‚ä§}·µÄ"
 *    The requested function type. Instances of this type accept arguments
 *    whose types conform to the parameter types and whose return value
 *    conforms to the return type.
 */
Primitive "function accepting_and returning_" is
[
	parameterTypes : tuple of any meta,
	returnType : type
|
	Primitive CreateFunctionType;
] : function meta;

/**
 * Construct and answer a function type with the specified return type.
 * Instances of this type include any function that returns a value of the
 * specified return type, irrespective of the number or types of its parameters.
 *
 * @category "Primitives" "Types" "Functions" "Constructors"
 * @method "[`‚Ä¶]‚Üí_"
 * @param "returnType" "{‚ä§}·µÄ"
 *        A type.
 * @returns "{[‚Ä¶]‚Üí‚ä§}·µÄ"
 *    The requested function type. Instances of this type answer values of the
 *    specified return type.
 */
Primitive "[`‚Ä¶]‚Üí_" is
[
	returnType : type
|
	Primitive CreateGeneralFunctionType;
] : function meta;

/**
 * Construct and answer a function that is an instance of {@param "aFunctionType"}
 * and applies {@param "functionToApply"} when itself applied with the appropriate
 * number and types of arguments. The new function answers whatever
 * {@param "functionToApply"} answers.
 *
 * @category "Primitives" "Functions" "Constructors"
 * @method "new_applying_"
 * @param "aFunctionType" "{[‚Ä¶]‚Üí‚ä§}·µÄ"
 *        The desired function type.
 * @param "functionToApply" "[‚Ä¶]‚Üí‚ä§"
 *        The function that the new function will apply when itself applied with
 *        the correct number and types of arguments.
 * @returns "[‚Ä¶]‚Üí‚ä§"
 *    The requested function.
 */
Primitive "new_applying_" is
[
	aFunctionType : function meta,
	functionToApply : function
|
	Primitive CreateStubFunction;
] : function;

/**
 * Compute and answer a block phrase that represents the decompilation of the
 * specified function. Outer variables are treated as literals.
 *
 * @category "Primitives" "Phrases" "Functions" "Conversions"
 * @method "_‚Üíblock phrase"
 * @param "aFunction" "[‚Ä¶]‚Üí‚ä§"
 *        A function.
 * @returns "block phrase‚áí[‚Ä¶]‚Üí‚ä§"
 *    A block phrase.
 */
Primitive "_‚Üíblock phrase" is
[
	aFunction : function
|
	Primitive DecompileFunction;
] : block phrase;

/**
 * Answer the message associated with the {@type "function"}.
 *
 * @category "Primitives"
 * @method "_'s‚Åámessage"
 * @param "aFunction" "[‚Ä¶]‚Üí‚ä§"
 *        A {@type "function"}.
 * @returns "string"
 *    The name of the message associated with {@param "_'s‚Åámessage"}.
 */
Primitive "_'s‚Åámessage" is
[
	aFunction : function
|
	Primitive FunctionMessage;
] : string;

/**
 * Answer all variables captured by the specified function. For functions
 * compiled directly from source code (i.e. the vast majority of them), these
 * variables are lexically captured.
 *
 * @category "Primitives" "Functions" "Queries"
 * @method "_'s‚Åáouter variables"
 * @param "aFunction" "[‚Ä¶]‚Üí‚ä§"
 *        A function.
 * @returns "tuple"
 *    The argument's outer variables.
 */
Primitive "_'s‚Åáouter variables" is
[
	aFunction : function
|
	Primitive OuterVariables;
] : tuple;

/**
 * Answer a tuple type that describes the parameter types of the specified
 * function type.
 *
 * @category "Primitives" "Types" "Functions" "Queries"
 * @method "_'s‚Åáparameters'type"
 * @param "functionType" "{[‚Ä¶]‚Üí‚ä§}·µÄ"
 *        A function type.
 * @returns "{tuple}·µÄ"
 *    A fixed-size tuple type whose element types correspond to the parameter
 *    types of the argument.
 */
Primitive "_'s‚Åáparameters'type" is
[
	functionType : function meta
|
	Primitive ParamsType;
] : tuple meta;

/**
 * Answer the return type of the specified function type.
 *
 * @category "Primitives" "Types" "Functions" "Queries"
 * @method "_'s‚Åáreturn type"
 * @param "functionType" "{[‚Ä¶]‚Üí‚ä§}·µÄ"
 *        A function type.
 * @returns "{‚ä§}·µÄ"
 *    The return type of the argument.
 */
Primitive "_'s‚Åáreturn type" is
[
	functionType : function meta
|
	Primitive ReturnType;
] : type;

/**
 * Cause the Avail virtual machine to raise an
 * `org.availlang.exceptions.AvailBreakpointException` that a Java debugger
 * can trap upon raise.
 *
 * This method exists to facilitate debugging of the Avail virtual machine, and
 * will be withdrawn once the implementation is considered sufficiently stable.
 *
 * @category "Primitives" "Bootstrap"
 * @method "Breakpoint"
 * @returns "‚ä§"
 */
Primitive "Breakpoint" is
[
	Primitive BreakPoint;
] : ‚ä§;

/**
 * Answer the number of milliseconds which have elapsed since midnight
 * Coordinated Universal Time (UTC) of Thursday, January 1, 1970 (i.e. the Unix
 * Epoch).
 *
 * @category "Primitives" "Time" "Queries"
 * @method "milliseconds since the Epoch"
 * @returns "ùïé"
 *    The current time as the number of milliseconds which have elapsed since
 *    the Unix Epoch.
 */
Primitive "milliseconds since the Epoch" is
[
	Primitive CurrentTimeMilliseconds;
] : whole number;

/**
 * Answer the current value of the high-precision timer. The answer has
 * nanosecond precision, but not necessarily nanosecond resolution; the actual
 * resolution is implementation-dependent. The high-precision timer does not
 * have a fixed reference frame, so it should generally only be used to measure
 * the time elapsed between two invocations.
 *
 * @category "Primitives" "Time" "Queries"
 * @method "high-precision timer value"
 * @returns "ùïé"
 *    The current value of the high-precision timer, in nanoseconds.
 */
Primitive "high-precision timer value" is
[
	Primitive CurrentTimeNanoseconds;
] : whole number;

/**
 * Crash the current fiber. Use the specified value to provide contextual
 * debugging information.
 *
 * This method must not leak beyond the bootstrap package. Termination of
 * fibers is dangerous because it avoids cleaning up active continuations and
 * ergo promotes deadlock (by failing to relinquish held locks). Only
 * cooperative termination, e.g. interrupt queues, is supported in ordinary
 * system or application code. This method is provided only for early detection
 * of serious failures in bootstrap code. Real failures in system code outside
 * of the bootstrap package use Avail's usual exception handling machinery.
 *
 * @category "Primitives" "Bootstrap" "Exceptions"
 * @method "Crash:_"
 * @param "value" "any"
 *        A value, provided to establish context for debugging.
 * @returns "‚ä•"
 */
Primitive "Crash:_" is
[
	value : any
|
	Primitive EmergencyExit;
] : ‚ä•;

/**
 * Are the arguments equal?
 *
 * @category "Primitives" "Mathematics" "Relations"
 * @method "_=_"
 * @param "arg1" "any"
 *        A value.
 * @param "arg2" "any"
 *        A value.
 * @returns "boolean"
 *    `true` if the arguments are equal, `false` otherwise.
 */
Primitive "_=_" is
[
	arg1 : any,
	arg2 : any
|
	Primitive Equality;
] : boolean;

/**
 * Answer the hash value of {@param "value"}. The hash values of equal values
 * are always themselves equal. The hash values of differing values will tend
 * to differ, but the pigeonhole principle means that hashing a larger key space
 * into a smaller hash space will lead to occasional collisions.
 *
 * The actual hash value is currently an instance of {@type "[-2^31..2^31)"},
 * but the weaker type is used to facilitate forward migration to larger hash
 * spaces.
 *
 * @category "Primitives"
 * @method "_'s‚Åáhash"
 * @param "value" "any"
 *        An arbitrary value.
 * @returns "i32"
 *    The hash value of the argument.
 */
Primitive "_'s‚Åáhash" is
[
	value : any
|
	Primitive Hash;
] : int32;

/**
 * Does the argument denote a valid primitive?
 *
 * @category "Primitives" "Methods" "Queries"
 * @method "_is a primitive"
 * @param "primitiveName" "string"
 *        A potential primitive name.
 * @returns "boolean"
 *    `true` if the argument denotes a valid primitive, `false` otherwise.
 */
Primitive "_is a primitive" is
[
	primitiveName : string
|
	Primitive IsPrimitiveDefined;
] : boolean;

/**
 * Render the argument into JSON.
 *
 * @category "Primitives"
 * @method "_‚ÜíJSON"
 * @param "value" "any"
 *        An arbitrary value.
 * @returns "string"
 *    A string containing the JSON representation of {@param "value"}.
 */
Primitive "_‚ÜíJSON" is
[
	value : any
|
	Primitive ToJSON;
] : string;

/**
 * Produce a primitive description of the argument. This description is
 * mechanically constructed by the Avail virtual machine. It may not contain
 * appropriately localized text, and is intended to provide
 * implementation-specific information that serves only to assist the
 * Avail virtual machine developers in debugging the implementation.
 *
 * @category "Primitives" "Stringification"
 * @method "primitive description of_"
 * @param "value" "any"
 *        A value.
 * @returns "string"
 *    A mechanically constructed, possibly non-localized,
 *    implementation-specific description of the argument.
 */
Primitive "primitive description of_" is
[
	value : any
|
	Primitive ToString;
] : string;

/**
 * Test a bit of the value, treated as a 2's complement signed integer.  If the
 * bit is 1, answer `true`, otherwise answer `false`.  The bitIndex starts at 0,
 * representing the low bit of the integer.
 *
 * @category "Primitives"
 * @method "_bit test_"
 * @param "value" "‚Ñ§"
 *        The integer to examine.
 * @param "bitIndex" "ùïé"
 *        The zero-based index of the bit to examine.
 * @returns "boolean"
 *    Whether that bit was 1.
 */
Primitive "_bit test_" is
[
	value : integer,
	bitIndex : whole number
|
	Primitive BitTest;
] : boolean;

/**
 * Compute and answer the bitwise {@code "AND"} of the arguments.
 *
 * @category "Primitives" "Numbers" "Integers" "Mathematics" "Bits"
 * @method "_bit‚àß_"
 * @param "arg1" "‚Ñ§"
 *        An integer.
 * @param "arg2" "‚Ñ§"
 *        An integer.
 * @returns "‚Ñ§"
 *    The bitwise AND of {@param "arg1"} and {@param "arg2"}.
 */
Primitive "_bit‚àß_" is
[
	arg1 : integer,
	arg2 : integer
|
	Primitive BitwiseAnd;
] : integer;

/**
 * Compute and answer the bitwise {@code "OR"} of the arguments.
 *
 * @category "Primitives" "Numbers" "Integers" "Mathematics" "Bits"
 * @method "_bit‚à®_"
 * @param "arg1" "‚Ñ§"
 *        An integer.
 * @param "arg2" "‚Ñ§"
 *        An integer.
 * @returns "‚Ñ§"
 *    The bitwise OR of {@param "arg1"} and {@param "arg2"}.
 */
Primitive "_bit‚à®_" is
[
	arg1 : integer,
	arg2 : integer
|
	Primitive BitwiseOr;
] : integer;

/**
 * Compute and answer the bitwise {@code "XOR"} of the arguments.
 *
 * @category "Primitives" "Numbers" "Integers" "Mathematics" "Bits"
 * @method "_bit‚äï_"
 * @param "arg1" "‚Ñ§"
 *        An integer.
 * @param "arg2" "‚Ñ§"
 *        An integer.
 * @returns "‚Ñ§"
 *    The bitwise XOR of {@param "arg1"} and {@param "arg2"}.
 */
Primitive "_bit‚äï_" is
[
	arg1 : integer,
	arg2 : integer
|
	Primitive BitwiseXor;
] : integer;

/**
 * Construct and answer an integral range type whose lower bound is {@param "lowerBound"}
 * and whose upper bound is {@param "upperBound"}.
 *
 * @category "Primitives" "Numbers" "Types" "Constructors"
 * @method "integer range from_(inclusive=_)to_(inclusive=_)"
 * @param "lowerBound" "‚Ñ§‚àû"
 *        The lower bound.
 * @param "lowerBoundInclusive" "boolean"
 *        `true` if the lower bound should be adjudged inclusive, `false`
 *        otherwise.
 * @param "upperBound" "‚Ñ§‚àû"
 *        The upper bound.
 * @param "upperBoundInclusive" "boolean"
 *        `true` if the upper bound should be adjudged inclusive, `false`
 *        otherwise.
 * @returns "{‚Ñ§‚àû}·µÄ"
 *    The requested integral range type.
 */
Primitive "integer range from_(inclusive=_)to_(inclusive=_)" is
[
	lowerBound : extended integer,
	lowerBoundInclusive : boolean,
	upperBound : extended integer,
	upperBoundInclusive : boolean
|
	Primitive CreateIntegerRange;
] : extended integer meta;

/**
 * Answer the lower bound of the specified integral range type.
 *
 * @category "Primitives" "Numbers" "Types" "Queries"
 * @method "_'s‚Åágenuine lower bound"
 * @param "range" "{‚Ñ§‚àû}·µÄ"
 *        An integral range type.
 * @returns "‚Ñ§‚àû"
 *    The lower bound of the argument.
 */
Primitive "_'s‚Åágenuine lower bound" is
[
	range : extended integer meta
|
	Primitive LowerBound;
] : extended integer;

/**
 * Answer the upper bound of the specified integral range type.
 *
 * @category "Primitives" "Numbers" "Types" "Queries"
 * @method "_'s‚Åágenuine upper bound"
 * @param "range" "{‚Ñ§‚àû}·µÄ"
 *        An integral range type.
 * @returns "‚Ñ§‚àû"
 *    The upper bound of the argument.
 */
Primitive "_'s‚Åágenuine upper bound" is
[
	range : extended integer meta
|
	Primitive UpperBound;
] : extended integer;

/**
 * Construct and answer a map from the supplied tuple of bindings.
 *
 * @category "Primitives" "Maps" "Constructors"
 * @method "_‚Üímap"
 * @param "bindings" "any^[2..2]*"
 *        A tuple of bindings. Each element of the argument is a
 *       2-tuple that represents a binding. The first element of each 2-tuple is
 *       a key, the second element is the value that should be bound to that key
 *       in the resultant map.
 * @returns "map"
 *    The requested map.
 */
Primitive "_‚Üímap" is
[
	bindings : key-value tuple
|
	Primitive CreateMap;
] : map;

/**
 * Construct and answer a map type with the specified key type, value type, and
 * range of cardinalities.
 *
 * @category "Primitives" "Types" "Maps" "Constructors"
 * @method "{_‚Üí_`|_}"
 * @param "keyType" "{any}·µÄ"
 *        A type to which all keys of instances must conform.
 * @param "valueType" "{any}·µÄ"
 *        A type to which all values of instances must conform.
 * @param "cardinalityType" "{ùïé}·µÄ"
 *        The range of cardinalities to which all instances must
 *       conform.
 * @returns "{map}·µÄ"
 *    The requested map type.
 */
Primitive "{_‚Üí_`|_}" is
[
	keyType : any meta,
	valueType : any meta,
	cardinalityType : whole number meta
|
	Primitive CreateMapType;
] : map meta;

/**
 * Is {@param "key"} a member of the set of keys of {@param "aMap"}?
 *
 * @category "Primitives" "Maps" "Queries"
 * @method "_‚àà_"
 * @param "key" "any"
 *        The key whose membership should be queried.
 * @param "aMap" "map"
 *        A map.
 * @returns "boolean"
 *    `true` if {@param "key"} if a key of {@param "aMap"}, `false`
 *    otherwise.
 */
Primitive "_‚àà_" is
[
	key : any,
	aMap : map
|
	Primitive KeyInMap;
] : boolean;

/**
 * Answer a tuple containing the bindings of the specified map. A binding is a
 * 2-tuple of key and value.
 *
 * @category "Primitives" "Maps" "Queries"
 * @method "_'s‚Åábindings"
 * @param "aMapType" "map"
 *        A map.
 * @returns "any^[2..2]*"
 *    The argument's bindings.
 */
Primitive "_'s‚Åábindings" is
[
	aMapType : map
|
	Primitive MapBindings;
] : key-value tuple;

/**
 * Answer the set of keys of the specified map.
 *
 * @category "Primitives" "Maps" "Queries"
 * @method "_'s‚Åákeys"
 * @param "aMap" "map"
 *        A map.
 * @returns "set"
 *    The argument's keys.
 */
Primitive "_'s‚Åákeys" is
[
	aMap : map
|
	Primitive MapKeysAsSet;
] : set;

/**
 * Construct and answer a map that is based on the supplied map. The answer
 * (potentially) differs from the argument in that it contains a binding from
 * {@param "key"} to {@param "value"}; any value previously bound to
 * {@param "key"} is "forgotten" in the new map.
 *
 * @category "Primitives" "Maps" "Transformers"
 * @method "_+_‚Üí_"
 * @param "aMap" "map"
 *        A map.
 * @param "key" "any"
 *        A key.
 * @param "value" "any"
 *        The new value for the key.
 * @returns "{any‚Üíany|1..‚àû}"
 *    The requested map.
 */
Primitive "_+_‚Üí_" is
[
	aMap : map,
	key : any,
	value : any
|
	Primitive MapReplacingKey;
] : non-empty map;

/**
 * Answer the cardinality of the specified map.
 *
 * @category "Primitives" "Maps" "Queries"
 * @method "`|_`|"
 * @param "aMap" "map"
 *        A map.
 * @returns "ùïé"
 *    The argument's cardinality.
 */
Primitive "`|_`|" is
[
	aMap : map
|
	Primitive MapSize;
] : whole number;

/**
 * Answer the most specific type to which the keys of all instances must
 * conform.
 *
 * @category "Primitives" "Types" "Maps" "Queries"
 * @method "_'s‚Åákey type"
 * @param "aMapType" "{map}·µÄ"
 *        A map type.
 * @returns "{any}·µÄ"
 *    The argument's key type.
 */
Primitive "_'s‚Åákey type" is
[
	aMapType : map meta
|
	Primitive MapTypeKeyType;
] : any meta;

/**
 * Answer the acceptable range of cardinalities for instances of the specified
 * map type.
 *
 * @category "Primitives" "Types" "Maps" "Queries"
 * @method "`|`|_`|`|"
 * @param "aMapType" "{map}·µÄ"
 *        A map type.
 * @returns "{ùïé}·µÄ"
 *    The argument's cardinality requirement.
 */
Primitive "`|`|_`|`|" is
[
	aMapType : map meta
|
	Primitive MapTypeSizes;
] : whole number meta;

/**
 * Answer the most specific type to which the values of all instances must
 * conform.
 *
 * @category "Primitives" "Types" "Maps" "Queries"
 * @method "_'s‚Åávalue type"
 * @param "aMapType" "{map}·µÄ"
 *        A map type.
 * @returns "{any}·µÄ"
 *    The argument's value type.
 */
Primitive "_'s‚Åávalue type" is
[
	aMapType : map meta
|
	Primitive MapTypeValueType;
] : any meta;

/**
 * Answer a tuple containing the values of the specified map. The values are
 * arranged in no particular order.
 *
 * @category "Primitives" "Maps" "Queries"
 * @method "_'s‚Åávalues"
 * @param "aMapType" "map"
 *        A map.
 * @returns "tuple"
 *    The argument's values.
 */
Primitive "_'s‚Åávalues" is
[
	aMapType : map
|
	Primitive MapValuesAsTuple;
] : tuple;

/**
 * Construct and answer a map that is based on the supplied map. The answer
 * (potentially) differs from the argument in that it does not contain a
 * binding for {@param "key"}; any such previous binding is "forgotten" in the new map.
 *
 * @category "Primitives" "Maps" "Transformers"
 * @method "_-_"
 * @param "aMap" "map"
 *        A map.
 * @param "key" "any"
 *        A key whose binding should be omitted.
 * @returns "map"
 *    The requested map.
 */
Primitive "_-_" is
[
	aMap : map,
	key : any
|
	Primitive MapWithoutKey;
] : map;

/**
 * Answer the number of parameters required by the specified method.
 *
 * @category "Primitives" "Methods" "Queries"
 * @method "`|_'s‚Åáparameters`|"
 * @param "aMessageBundle" "message bundle"
 *        A method.
 * @returns "ùïé"
 *    The number of parameters required by the specified method.
 */
Primitive "`|_'s‚Åáparameters`|" is
[
	aMessageBundle : message bundle
|
	Primitive BundleParametersCount;
] : whole number;

/**
 * Answer the specified definition's function type.
 *
 * @category "Primitives" "Definitions" "Queries"
 * @method "_'s‚Åáfunction type"
 * @param "aDefinition" "definition"
 *        Any definition (method, macro, abstract, forward).
 * @returns "{[‚Ä¶]‚Üí‚ä§}·µÄ"
 *    The requested function type.
 */
Primitive "_'s‚Åáfunction type" is
[
	aDefinition : definition
|
	Primitive DefinitionBodySignature;
] : function meta;

/**
 * Describe why the given proposed message name is invalid.
 *
 * @category "Primitives"
 * @method "non-canonical problem with_"
 * @param "messageName" "string"
 *        The proposed message name.
 * @returns "string"
 *    A string describing the malformation of the proposed message name, or the
 *    empty string if it is well-formed.
 */
Primitive "non-canonical problem with_" is
[
	messageName : string
|
	Primitive DescribeNoncanonicalMessage;
] : string;

/**
 * Is there a method bound to the specified name?
 *
 * @category "Primitives" "Atoms" "Methods" "Queries"
 * @method "method exists named_"
 * @param "trueName" "atom"
 *        An atom.
 * @returns "boolean"
 *    `true` if {@param "trueName"} names a method, `false` otherwise.
 */
Primitive "method exists named_" is
[
	trueName : atom
|
	Primitive ExistsMethodWithName;
] : boolean;

/**
 * Answer the atom that uniquely identifies the specified message bundle.
 *
 * @category "Primitives" "Atoms" "Queries"
 * @method "_'s‚Åáatom"
 * @param "aMessageBundle" "message bundle"
 *        A message bundle for some method.
 * @returns "atom"
 *    The requested atom.
 */
Primitive "_'s‚Åáatom" is
[
	aMessageBundle : message bundle
|
	Primitive MessageBundleName;
] : atom;

/**
 * Answer the specified method definition's function.
 *
 * @category "Primitives" "Definitions" "Queries"
 * @method "_'s‚Åáfunction"
 * @param "aDefinition" "method definition"
 *        A method definition.
 * @returns "[‚Ä¶]‚Üí‚ä§"
 *    The requested function.
 */
Primitive "_'s‚Åáfunction" is
[
	aDefinition : method definition
|
	Primitive MethodDefinitionBody;
] : function;

/**
 * Answer the {@type "definition"}s of the specified {@type "method"}.
 *
 * @category "Primitives"
 * @method "_'s‚Åádefinitions"
 * @param "aMethod" "method"
 *        An arbitrary {@type "method"}.
 * @returns "definition*"
 *    A {@type "tuple"} of {@type "definition"}s.
 */
Primitive "_'s‚Åádefinitions" is
[
	aMethod : method
|
	Primitive MethodDefinitions;
] : tuple of definition;

/**
 * Answer all seals applied to the specified method.
 *
 * @category "Primitives" "Methods" "Queries"
 * @method "_'s‚Åáseals"
 * @param "aMethod" "method"
 *        A method.
 * @returns "{any}·µÄ**"
 *    A tuple comprising the seals applied to {@param "aMethod"}.
 */
Primitive "_'s‚Åáseals" is
[
	aMethod : method
|
	Primitive Seals;
] : tuple of tuple of any meta;

/**
 * Answer the entry points introduced by the specified module.
 *
 * @category "Primitives"
 * @method "_'s‚Åáentry points"
 * @param "aModule" "module"
 *        A module.
 * @returns "{string|}"
 *    A set containing the entry point names introduced by {@param "aModule"}
 */
Primitive "_'s‚Åáentry points" is
[
	aModule : module
|
	Primitive Entries;
] : set of string;

/**
 * Determine whether the provided module defines an atom with the given name.
 *
 * @category "Primitives"
 * @method "_has public name_"
 * @param "aModule" "module"
 *        The module to examine.
 * @param "aString" "string"
 *        The name to look for in the module's new names.
 * @returns "boolean"
 *    Whether the name was defined in the module.
 */
Primitive "_has public name_" is
[
	aModule : module,
	aString : string
|
	Primitive HasNewName;
] : boolean;

/**
 * Determine whether the {@type "module"} is still open to the performance of
 * further side effects upon it.
 *
 * @category "Primitives" "Modules"
 * @method "_is open for side effects"
 * @param "aModule" "module"
 *        The module to query for openness.
 * @returns "boolean"
 *    {@method "true"} if {@param "aModule"} is open, {@method "false"} otherwise.
 */
Primitive "_is open for side effects" is
[
	aModule : module
|
	Primitive IsModuleOpen;
] : boolean;

/**
 * Answer the fully qualified name of the specified module.
 *
 * @category "Primitives" "Modules" "Queries"
 * @method "_'s‚Åáname"
 * @param "aModule" "module"
 *        A module.
 * @returns "string"
 *    The fully qualified name of {@param "aModule"}.
 */
Primitive "_'s‚Åáname" is
[
	aModule : module
|
	Primitive ModuleName;
] : string;

/**
 * Answer the public names introduced by the specified module.  This is a map
 * from string to atom.
 *
 * @category "Primitives" "Modules" "Queries"
 * @method "_'s‚Åápublic names"
 * @param "aModule" "module"
 *        A module.
 * @returns "{string‚Üíatom|}"
 *    A map containing the public names introduced by {@param "aModule"}.
 */
Primitive "_'s‚Åápublic names" is
[
	aModule : module
|
	Primitive NewNames;
] : map from string to atom;

/**
 * Is the first argument less than or equal to the second argument?
 *
 * @category "Primitives" "Numbers" "Mathematics" "Relations"
 * @method "_‚â§_"
 * @param "arg1" "number"
 *        A number.
 * @param "arg2" "number"
 *        A number.
 * @returns "boolean"
 *    `true` if the first argument is less than or equal to the second
 *    argument, `false` otherwise.
 */
Primitive "_‚â§_" is
[
	arg1 : number,
	arg2 : number
|
	Primitive LessOrEqual;
] : boolean;

/**
 * Is the first argument strictly less than the second argument?
 *
 * @category "Primitives" "Numbers" "Mathematics" "Relations"
 * @method "_<_"
 * @param "arg1" "number"
 *        A number.
 * @param "arg2" "number"
 *        A number.
 * @returns "boolean"
 *    `true` if the first argument is strictly less than the second argument,
 *    `false` otherwise.
 */
Primitive "_<_" is
[
	arg1 : number,
	arg2 : number
|
	Primitive LessThan;
] : boolean;

/**
 * Construct and answer an object based on the supplied map.
 *
 * @category "Primitives" "Objects" "Constructors"
 * @method "_‚Üíobject"
 * @param "fieldsToValues" "{atom‚Üíany|}"
 *        A map whose keys are the fields of the new object and whose values are
 *        the corresponding field values.
 * @returns "object"
 *    The requested object.
 */
Primitive "_‚Üíobject" is
[
	fieldsToValues : field map
|
	Primitive MapToObject;
] : object;

/**
 * Construct and answer an object type based on the supplied map.
 *
 * @category "Primitives" "Types" "Objects" "Maps" "Conversions"
 * @method "_‚Üíobject type"
 * @param "fieldsToTypes" "{atom‚Üí{any}·µÄ|}"
 *        A map whose keys are the fields of the new object and whose values are
 *        the corresponding field types.
 * @returns "{object}·µÄ"
 *    The requested object type.
 */
Primitive "_‚Üíobject type" is
[
	fieldsToTypes : field type map
|
	Primitive MapToObjectType;
] : object meta;

/**
 * Construct and answer a map based on the supplied object.
 *
 * @category "Primitives" "Objects" "Maps" "Conversions"
 * @method "_‚Üímap"
 * @param "anObject" "object"
 *        An object whose fields should be the keys of the new map and whose
 *        values are the corresponding values.
 * @returns "{atom‚Üíany|}"
 *    The requested map.
 */
Primitive "_‚Üímap" is
[
	anObject : object
|
	Primitive ObjectToMap;
] : field map;

/**
 * Construct and answer a tuple based on the supplied object.
 *
 * @category "Primitives" "Tuples" "Objects" "Conversions"
 * @method "_‚Üítuple"
 * @param "anObject" "object"
 *        An object.
 * @returns "<atom, any‚Ä¶|2>*"
 *    A tuple that represents the composition of the object. Its elements are
 *    2-tuples. Each 2-tuple's first element is an atom (i.e., the field
 *    identifier) and its second element is associated value.
 */
Primitive "_‚Üítuple" is
[
	anObject : object
|
	Primitive ObjectToTuple;
] : field tuple;

/**
 * For the purpose of debugging, bind a name to an object type. This name will
 * be used for subtypes that do not bind a more specific name to describe their
 * own subtypes.
 *
 * @category "Primitives" "Types" "Objects" "Mutators"
 * @method "_'s‚Åáname:=_"
 * @param "anObjectType" "{object}·µÄ"
 *        An object type.
 * @param "name" "string"
 *        The name that should be bound to the object type. This will replace
 *        a previously bound name.
 * @returns "‚ä§"
 */
Primitive "_'s‚Åáname:=_" is
[
	anObjectType : object meta,
	name : string
|
	Primitive RecordNewTypeName;
] : ‚ä§;

/**
 * Unbind the specified name from the specified object type.  This undoes the
 * action of {@method "_'s‚Åáname:=_"}, generally as an unloading action for a
 * {@type "module"}.
 *
 * @category "Primitives" "Types" "Objects" "Mutators"
 * @method "Unname_from_"
 * @param "name" "string"
 *        The name that should no longer be bound to the object type.
 * @param "anObjectType" "{object}·µÄ"
 *        An object type.
 * @returns "‚ä§"
 */
Primitive "Unname_from_" is
[
	name : string,
	anObjectType : object meta
|
	Primitive RemoveTypeName;
] : ‚ä§;

/**
 * Construct and answer an object based on the supplied tuple.
 *
 * @category "Primitives" "Tuples" "Objects" "Conversions"
 * @method "_‚Üíobject"
 * @param "fieldAssignments" "<atom, any‚Ä¶|2>*"
 *        A tuple whose elements are 2-tuples. Each 2-tuple's first element is
 *        an atom (i.e., the field identifier) and its second element is
 *        associated value.
 * @returns "object"
 *    The requested object.
 */
Primitive "_‚Üíobject" is
[
	fieldAssignments : field tuple
|
	Primitive TupleToObject;
] : object;

/**
 * Construct and answer an object type based on the supplied tuple.
 *
 * @category "Primitives" "Types" "Tuples" "Objects" "Conversions"
 * @method "_‚Üíobject type"
 * @param "fieldDefinitions" "<atom, {any}·µÄ‚Ä¶|2>*"
 *        A tuple whose elements are 2-tuples. Each 2-tuple's first element is
 *        an atom (i.e., the field identifier) and its second element is the
 *        value type permitted by the field.
 * @returns "{object}·µÄ"
 *    The requested object type.
 */
Primitive "_‚Üíobject type" is
[
	fieldDefinitions : field type tuple
|
	Primitive TupleToObjectType;
] : object meta;

/**
 * Answer the set of locally most-specific names bound to the specified object
 * type.
 *
 * @category "Primitives" "Types" "Objects" "Queries"
 * @method "_'s‚Åánames"
 * @param "anObjectType" "{object}·µÄ"
 *        An object type.
 * @returns "{string|}"
 *    The set of locally most-specific names bound to the specified object
 *    type.
 */
Primitive "_'s‚Åánames" is
[
	anObjectType : object meta
|
	Primitive TypeNames;
] : set of string;

/**
 * Answer the specified assignment's target variable.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s‚Åátarget"
 * @param "anAssignment" "assignment phrase‚áí‚ä§"
 *        An assignment.
 * @returns "variable use phrase‚áíany"
 *    The assignment's target variable.
 */
Primitive "_'s‚Åátarget" is
[
	anAssignment : assignment phrase
|
	Primitive AssignmentTarget;
] : variable use phrase;

/**
 * Answer the specified assignment's value expression.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s‚Åávalue"
 * @param "anAssignment" "assignment phrase‚áí‚ä§"
 *        An assignment.
 * @returns "expression phrase‚áíany"
 *    The assignment's value expression.
 */
Primitive "_'s‚Åávalue" is
[
	anAssignment : assignment phrase
|
	Primitive AssignmentValue;
] : expression yielding any;

/**
 * Answer the arguments of the specified block.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s‚Åáarguments"
 * @param "aBlock" "block phrase‚áí[‚Ä¶]‚Üí‚ä§"
 *        A block.
 * @returns "argument phrase‚áí‚ä§*"
 *    A tuple of argument declarations.
 */
Primitive "_'s‚Åáarguments" is
[
	aBlock : block phrase
|
	Primitive BlockArguments;
] : argument tuple;

/**
 * Answer the declared exceptions of the specified block.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s‚Åádeclared exceptions"
 * @param "aBlock" "block phrase‚áí[‚Ä¶]‚Üí‚ä§"
 *        A block.
 * @returns "{exception|}"
 *    The block's set of declared exceptions.
 */
Primitive "_'s‚Åádeclared exceptions" is
[
	aBlock : block phrase
|
	Primitive BlockDeclaredExceptions;
] : set of exception;

/**
 * Answer the specified block's outer variables.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s‚Åáouter variables"
 * @param "aBlock" "block phrase‚áí[‚Ä¶]‚Üí‚ä§"
 *        A block.
 * @returns "declaration phrase‚áí‚ä§*"
 *    A tuple of declarations of outer variables required to complete the
 *    meaning of the block.
 */
Primitive "_'s‚Åáouter variables" is
[
	aBlock : block phrase
|
	Primitive BlockNeededVariables;
] : declaration tuple;

/**
 * Extract the name of the primitive used by this block phrase, or the empty
 * string if the block does not specify a primitive.
 *
 * @category "Primitives"
 * @method "_'s‚Åáprimitive name"
 * @param "aBlock" "block phrase‚áí[‚Ä¶]‚Üí‚ä§"
 *        The block phrase to examine.
 * @returns "string"
 *    Either the name of this block phrase's primitive or the empty string.
 */
Primitive "_'s‚Åáprimitive name" is
[
	aBlock : block phrase
|
	Primitive BlockPrimitiveName;
] : string;

/**
 * Answer the return type of the specified block.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s‚Åáreturn type"
 * @param "aBlock" "block phrase‚áí[‚Ä¶]‚Üí‚ä§"
 *        A block.
 * @returns "{‚ä§}·µÄ"
 *    The block's return type.
 */
Primitive "_'s‚Åáreturn type" is
[
	aBlock : block phrase
|
	Primitive BlockReturnType;
] : type;

/**
 * Answer the statements of the specified block.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s‚Åástatements"
 * @param "aBlock" "block phrase‚áí[‚Ä¶]‚Üí‚ä§"
 *        A block.
 * @returns "phrase‚áí‚ä§*"
 *    A tuple of statements. These are either assignments, declarations, labels,
 *    sequences, or ‚ä§-valued sends.
 */
Primitive "_'s‚Åástatements" is
[
	aBlock : block phrase
|
	Primitive BlockStatements;
] : phrase tuple;

/**
 * Construct and answer an argument declaration.
 *
 * @category "Primitives" "Phrases" "Constructors"
 * @method "arg`¬´_:_`¬ª"
 * @param "name" "token"
 *        The name of the new constant.
 * @param "declaredType" "{any}·µÄ"
 *        The declared type of the named constant.
 * @returns "argument phrase‚áí‚ä§"
 *    The requested argument declaration.
 */
Primitive "arg`¬´_:_`¬ª" is
[
	name : token,
	declaredType : any meta
|
	Primitive CreateArgumentDeclaration;
] : argument phrase;

/**
 * Convert the {@type "expression phrase‚áí‚ä§"} into a
 * {@type "expression as statement phrase‚áí‚ä§"}.
 *
 * @category "Primitives"
 * @method "_‚Üístatement phrase"
 * @param "expr" "expression phrase‚áí‚ä§"
 *        An {@type "expression phrase‚áí‚ä§"}.
 * @returns "expression as statement phrase‚áí‚ä§"
 *    The wrapping {@type "expression as statement phrase‚áí‚ä§"}.
 */
Primitive "_‚Üístatement phrase" is
[
	expr : expression phrase
|
	Primitive CreateExpressionAsStatementPhrase;
] : expression as statement phrase;

/**
 * Construct and answer an initialized local variable declaration.
 *
 * @category "Primitives" "Phrases" "Constructors"
 * @method "`¬´_:_:=_`¬ª"
 * @param "name" "token"
 *        The name of the new variable.
 * @param "declaredType" "{any}·µÄ"
 *        The declared type of the named variable.
 * @param "initializer" "expression phrase‚áíany"
 *        The initialization expression.
 * @returns "local variable phrase‚áí‚ä§"
 *    The requested initialized local variable declaration.
 */
Primitive "`¬´_:_:=_`¬ª" is
[
	name : token,
	declaredType : any meta,
	initializer : expression yielding any
|
	Primitive CreateInitializingVariableDeclaration;
] : local variable phrase;

/**
 * Construct and answer a label declaration.
 *
 * @category "Primitives" "Phrases" "Constructors"
 * @method "`¬´$_:_`¬ª"
 * @param "name" "token"
 *        The name of the label being declared.
 * @param "declaredType" "{$[‚Ä¶]‚Üí‚ä•}·µÄ"
 *        The result type of the block containing the label declaration.
 * @returns "label phrase‚áí‚ä§"
 *    The requested label declaration.
 */
Primitive "`¬´$_:_`¬ª" is
[
	name : token,
	declaredType : continuation meta
|
	Primitive CreateLabelDeclaration;
] : label phrase;

/**
 * Construct and answer a list from the specified tuple of expressions.
 *
 * @category "Primitives" "Phrases" "Constructors"
 * @method "_‚Üílist phrase"
 * @param "aTuple" "expression phrase‚áíany*"
 *        A tuple of expressions.
 * @returns "list phrase‚áítuple (subexpressions tuple type=phrase‚áíany*)"
 *    The requested list.
 */
Primitive "_‚Üílist phrase" is
[
	aTuple : tuple of expressions yielding any
|
	Primitive CreateListExpression;
] : list phrase;

/**
 * Construct and answer a literal expression.
 *
 * @category "Primitives" "Phrases" "Constructors"
 * @method "_‚Üíliteral phrase"
 * @param "aLiteralToken" "literal token‚áíany"
 *        A literal token.
 * @returns "literal phrase‚áíany"
 *    The requested literal expression.
 */
Primitive "_‚Üíliteral phrase" is
[
	aLiteralToken : literal token
|
	Primitive CreateLiteralExpression;
] : literal phrase;

/**
 * Construct a suitably parameterized literal token type.
 *
 * @category "Primitives" "Types" "Phrases" "Constructors"
 * @method "literal token‚áí_"
 * @param "literalValue" "{any}·µÄ"
 *        The literal value's type
 * @returns "{literal token‚áíany}·µÄ"
 *    A literal token type.
 */
Primitive "literal token‚áí_" is
[
	literalValue : any meta
|
	Primitive CreateLiteralTokenType;
] : literal token meta;

/**
 * Construct and answer a local constant declaration.
 *
 * @category "Primitives" "Phrases" "Constructors"
 * @method "`¬´_::=_`¬ª"
 * @param "name" "token"
 *        The name of the new constant.
 * @param "expression" "expression phrase‚áíany"
 *        The initialization expression for the new constant.
 * @returns "local constant phrase‚áí‚ä§"
 *    The requested local constant declaration.
 */
Primitive "`¬´_::=_`¬ª" is
[
	name : token,
	expression : expression yielding any
|
	Primitive CreateLocalConstantDeclaration;
] : local constant phrase;

/**
 * Create a marker phrase with the given value and yield type.
 *
 * @category "Primitives"
 * @method "`¬´marker phrase_‚áí_`¬ª"
 * @param "value" "any"
 *        The marker phrase's value.
 * @param "expressionType" "{‚ä§}·µÄ"
 *        The marker phrase's yield type.
 * @returns "marker phrase‚áí‚ä§"
 *    A marker phrase.
 */
Primitive "`¬´marker phrase_‚áí_`¬ª" is
[
	value : any,
	expressionType : type
|
	Primitive CreateMarkerPhrase;
] : marker phrase;

/**
 * Answer a module variable declaration based on the given variable and token.
 *
 * @category "Primitives"
 * @method "`¬´module variable_(_)`¬ª"
 * @param "aVariable" "read ‚ä§/write ‚ä•"
 *        The variable to use.
 * @param "aToken" "token"
 *        The token to treat as the point of declaration.
 * @returns "module variable phrase‚áí‚ä§"
 *    A module variable declaration phrase.
 */
Primitive "`¬´module variable_(_)`¬ª" is
[
	aVariable : write-only variable,
	aToken : token
|
	Primitive CreateModuleVariableDeclaration;
] : module variable phrase;

/**
 * Construct and answer a phrase type with the specified semantic type.
 *
 * @category "Primitives" "Types" "Phrases" "Constructors"
 * @method "_‚áí_"
 * @param "aPhrase" "{phrase‚áí‚ä§}·µÄ"
 *        A phrase type.
 * @param "semanticType" "{‚ä§}·µÄ"
 *        The semantic type of values producible by phrases that are instances
 *        of the answer.
 * @returns "{phrase‚áí‚ä§}·µÄ"
 *    The requested phrase type.
 * @raises "{6}"
 */
Primitive "_‚áí_" is
[
	aPhrase : phrase meta,
	semanticType : type
|
	Primitive CreatePhraseType;
] : phrase meta;

/**
 * Construct and answer a primitive failure local constant declaration.
 *
 * @category "Primitives" "Phrases" "Constructors"
 * @method "primfail`¬´_:_`¬ª"
 * @param "name" "token"
 *        The name of the new constant.
 * @param "declaredType" "{any}·µÄ"
 *        The declared type of the named constant.
 * @returns "primitive failure reason phrase‚áí‚ä§"
 *    The requested primitive failure local constant declaration.
 */
Primitive "primfail`¬´_:_`¬ª" is
[
	name : token,
	declaredType : any meta
|
	Primitive CreatePrimitiveFailureVariableDeclaration;
] : primitive failure reason phrase;

/**
 * Create a sequence-as-expression from the given sequence.
 *
 * @category "Primitives"
 * @method "sequence-as-expression`¬´_`¬ª"
 * @param "sequence" "sequence phrase‚áí‚ä§"
 *        A sequence phrase.
 * @returns "sequence as expression phrase‚áí‚ä§"
 *    A sequence-as-expression phrase containing the given sequence.
 */
Primitive "sequence-as-expression`¬´_`¬ª" is
[
	sequence : sequence phrase
|
	Primitive CreateSequenceAsExpressionPhrase;
] : sequence-as-expression phrase;

/**
 * Construct and answer a local variable declaration.
 *
 * @category "Primitives" "Phrases" "Constructors"
 * @method "`¬´_:_`¬ª"
 * @param "name" "token"
 *        The name of the new variable.
 * @param "declaredType" "{any}·µÄ"
 *        The declared type of the named variable.
 * @returns "local variable phrase‚áí‚ä§"
 *    The requested local variable declaration.
 */
Primitive "`¬´_:_`¬ª" is
[
	name : token,
	declaredType : any meta
|
	Primitive CreateVariableExpression;
] : local variable phrase;

/**
 * Create a variable use expression from the specified token and declaration.
 *
 * @category "Primitives" "Phrases" "Constructors"
 * @method "`¬´‚Üì_`¬ª(_)"
 * @param "aDeclaration" "declaration phrase‚áí‚ä§"
 *        The declaration that created the referenced entity.
 * @param "aToken" "token"
 *        A token that names the entity at the point of use.
 * @returns "variable use phrase‚áíany"
 *    The requested variable use expression.
 */
Primitive "`¬´‚Üì_`¬ª(_)" is
[
	aDeclaration : declaration phrase,
	aToken : token
|
	Primitive CreateVariableUse;
] : variable use phrase;

/**
 * Answer whether this declaration has an initializing expression.
 *
 * @category "Primitives"
 * @method "_has initializing expression"
 * @param "decl" "declaration phrase‚áí‚ä§"
 *        The declaration.
 * @returns "boolean"
 *    True if the declaration has an initializing expression, false otherwise.
 */
Primitive "_has initializing expression" is
[
	decl : declaration phrase
|
	Primitive DeclarationHasInitializingExpression;
] : boolean;

/**
 * Answer the token that names the entity introduced by the specified
 * declaration.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s‚Åátoken"
 * @param "aDeclaration" "declaration phrase‚áí‚ä§"
 *        A declaration.
 * @returns "token"
 *    The requested token.
 */
Primitive "_'s‚Åátoken" is
[
	aDeclaration : declaration phrase
|
	Primitive DeclarationToken;
] : token;

/**
 * Answer the declared type of the entity introduced by the specified
 * declaration.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s‚Åádeclared type"
 * @param "aDeclaration" "declaration phrase‚áí‚ä§"
 *        A declaration.
 * @returns "{any}·µÄ"
 *    The requested type.
 */
Primitive "_'s‚Åádeclared type" is
[
	aDeclaration : declaration phrase
|
	Primitive DeclarationType;
] : any meta;

/**
 * Answer the {@type "expression phrase‚áí‚ä§"} wrapped by the {@type
 * "expression as statement phrase‚áí‚ä§"}.
 *
 * @category "Primitives"
 * @method "_'s‚Åáexpression"
 * @param "stmt" "expression as statement phrase‚áí‚ä§"
 *        An {@type "expression as statement phrase‚áí‚ä§"}.
 * @returns "expression phrase‚áí‚ä§"
 *    The wrapped {@type "expression phrase‚áí‚ä§"}.
 */
Primitive "_'s‚Åáexpression" is
[
	stmt : expression as statement phrase
|
	Primitive ExpressionAsStatementExpression;
] : expression phrase;

/**
 * Answer the tuple of statements that constitute the specified
 * first-of-sequence.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s‚Åástatements"
 * @param "aFirstOfSequence" "first of sequence phrase‚áí‚ä§"
 *        A first-of-sequence.
 * @returns "phrase‚áí‚ä§*"
 *    The requested tuple of statements.
 */
Primitive "_'s‚Åástatements" is
[
	aFirstOfSequence : first of sequence phrase
|
	Primitive FirstOfSequenceStatements;
] : phrase tuple;

/**
 * Answer the tuple of expressions that constitute the specified list.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s‚Åáexpressions"
 * @param "aList" "list phrase‚áítuple (subexpressions tuple type=phrase‚áíany*)"
 *        A list.
 * @returns "expression phrase‚áíany*"
 *    The requested tuple of expressions.
 */
Primitive "_'s‚Åáexpressions" is
[
	aList : list phrase
|
	Primitive ListExpressions;
] : tuple of expressions yielding any;

/**
 * Answer the specified literal expression's defining token.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s‚Åátoken"
 * @param "aLiteral" "literal phrase‚áíany"
 *        A literal expression.
 * @returns "literal token‚áíany"
 *    The requested literal token.
 */
Primitive "_'s‚Åátoken" is
[
	aLiteral : literal phrase
|
	Primitive LiteralExpressionToken;
] : literal token;

/**
 * Extract this literal token type's value type. That's the type of value
 * that a conforming literal token can produce.
 *
 * @category "Primitives" "Types" "Phrases" "Queries"
 * @method "_'s‚Åávalue type"
 * @param "literalTokenType" "{literal token‚áíany}·µÄ"
 *        The literal token type.
 * @returns "{any}·µÄ"
 *    The type of value that such a literal token can produce.
 */
Primitive "_'s‚Åávalue type" is
[
	literalTokenType : literal token meta
|
	Primitive LiteralTokenTypeValueType;
] : any meta;

/**
 * Answer the literal value associated with the specified token.
 *
 * @category "Primitives" "Tokens" "Queries"
 * @method "_'s‚Åávalue"
 * @param "aLiteralToken" "literal token‚áíany"
 *        A literal token.
 * @returns "any"
 *    The literal value produced by {@param "aLiteralToken"}.
 */
Primitive "_'s‚Åávalue" is
[
	aLiteralToken : literal token
|
	Primitive LiteralTokenValue;
] : any;

/**
 * Extract a marker phrase's value.
 *
 * @category "Primitives"
 * @method "_'s‚Åávalue"
 * @param "markerPhrase" "marker phrase‚áí‚ä§"
 *        A marker phrase.
 * @returns "any"
 *    The marker phrase's value.
 */
Primitive "_'s‚Åávalue" is
[
	markerPhrase : marker phrase
|
	Primitive MarkerPhraseValue;
] : any;

/**
 * Answer the {@type "list phrase"} wrapped by the specified {@type
 * "permuted list phrase"}.
 *
 * @category "Primitives"
 * @method "_'s‚Åálist"
 * @param "permuted" "permuted list phrase‚áítuple (subexpressions tuple type=phrase‚áíany*)"
 *        A {@type "permuted list phrase"}.
 * @returns "list phrase‚áítuple (subexpressions tuple type=phrase‚áíany*)"
 *    The {@type "list phrase"} permuted by {@param "permuted"}.
 */
Primitive "_'s‚Åálist" is
[
	permuted : permuted list phrase
|
	Primitive PermutedListList;
] : list phrase;

/**
 * Answer the permutation {@type "tuple"} for the specified {@type
 * "permuted list phrase"}.
 *
 * @category "Primitives"
 * @method "_'s‚Åápermutation"
 * @param "permuted" "permuted list phrase‚áítuple (subexpressions tuple type=phrase‚áíany*)"
 *        A {@type "permuted list phrase"}.
 * @returns "‚Ñï+"
 *    The permutation {@type "tuple"}. This comprises the target indices,
 *    indexed by source index.
 */
Primitive "_'s‚Åápermutation" is
[
	permuted : permuted list phrase
|
	Primitive PermutedListPermutation;
] : permutation tuple;

/**
 * Answer the semantic type of the specified phrase. This is the type of value
 * produced when the content of the phrase is evaluated (by the compiler and/or
 * runtime).
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s‚Åásemantic type"
 * @param "phrase" "phrase‚áí‚ä§"
 *        A phrase.
 * @returns "{‚ä§}·µÄ"
 *    A type that describes all values producible by evaluations of the
 *    argument.
 */
Primitive "_'s‚Åásemantic type" is
[
	phrase : phrase
|
	Primitive PhraseExpressionType;
] : type;

/**
 * Answer the supplied phrase's tuple of {@code tokens}.  These are generally
 * the tokens that are part of the phrase but not part of any subphrase.
 *
 * @category "Primitives"
 * @method "_'s‚Åátokens"
 * @param "phrase" "phrase‚áí‚ä§"
 *        The phrase to examine.
 * @returns "token*"
 *          The supplied phrase's tuple of tokens.
 */
Primitive "_'s‚Åátokens" is
[
	phrase : phrase
|
	Primitive PhraseTokens;
] : token tuple;

/**
 * Answer the semantic type of the specified phrase type.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s‚Åásemantic type"
 * @param "phraseType" "{phrase‚áí‚ä§}·µÄ"
 *        A phrase type.
 * @returns "{‚ä§}·µÄ"
 *    The requested semantic type.
 */
Primitive "_'s‚Åásemantic type" is
[
	phraseType : phrase meta
|
	Primitive PhraseTypeExpressionType;
] : type;

/**
 * Answer the specified variable reference's referent.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "`¬´‚Üì_`¬ª"
 * @param "aReference" "reference phrase‚áíread ‚ä§/write ‚ä•"
 *        A variable reference.
 * @returns "variable use phrase‚áíany"
 *    The variable use referenced by the argument.
 */
Primitive "`¬´‚Üì_`¬ª" is
[
	aReference : variable reference phrase
|
	Primitive ReferenceTarget;
] : variable use phrase;

/**
 * Answer the specified message send's list of argument expressions.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s‚Åáarguments"
 * @param "aSend" "send phrase‚áí‚ä§"
 *        A message send.
 * @returns "list phrase‚áítuple (subexpressions tuple type=phrase‚áíany*)"
 *    The requested list of argument expressions.
 */
Primitive "_'s‚Åáarguments" is
[
	aSend : send phrase
|
	Primitive SendArgumentsList;
] : list phrase;

/**
 * Extract the message bundle from a send phrase.
 *
 * @category "Primitives"
 * @method "_'s‚Åábundle"
 * @param "sendPhrase" "send phrase‚áí‚ä§"
 *        A send phrase.
 * @returns "message bundle"
 *    The message bundle sent by this send phrase.
 */
Primitive "_'s‚Åábundle" is
[
	sendPhrase : send phrase
|
	Primitive SendBundle;
] : message bundle;

/**
 * Answer the target method of the specified message send.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s‚Åámethod"
 * @param "aSend" "send phrase‚áí‚ä§"
 *        A message send.
 * @returns "method"
 *    The requested method.
 */
Primitive "_'s‚Åámethod" is
[
	aSend : send phrase
|
	Primitive SendMethod;
] : method;

/**
 * Answer the specified message send's expected return type.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s‚Åáreturn type"
 * @param "aSend" "send phrase‚áí‚ä§"
 *        A message send.
 * @returns "{‚ä§}·µÄ"
 *    The requested type.
 */
Primitive "_'s‚Åáreturn type" is
[
	aSend : send phrase
|
	Primitive SendReturnType;
] : type;

/**
 * Extract the sequence phrase from a sequence-as-expression phrase.
 *
 * @category "Primitives"
 * @method "_'s‚Åásequence"
 * @param "sequenceAsExpression" "sequence as expression phrase‚áí‚ä§"
 *        The sequence-as-expression phrase.
 * @returns "sequence phrase‚áí‚ä§"
 *    The contained sequence.
 */
Primitive "_'s‚Åásequence" is
[
	sequenceAsExpression : sequence-as-expression phrase
|
	Primitive SequenceAsExpressionSequence;
] : sequence phrase;

/**
 * Answer the tuple of statements that constitute the specified sequence.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s‚Åástatements"
 * @param "aSequence" "sequence phrase‚áí‚ä§"
 *        A sequence.
 * @returns "phrase‚áí‚ä§*"
 *    The requested tuple of statements.
 */
Primitive "_'s‚Åástatements" is
[
	aSequence : sequence phrase
|
	Primitive SequenceStatements;
] : phrase tuple;

/**
 * Answer a supercast's base expression.
 *
 * @category "Primitives"
 * @method "_'s‚Åáexpression"
 * @param "aSupercast" "super cast phrase‚áíany"
 *        The supercast from which to extract the base expression
 * @returns "expression phrase‚áíany"
 *    The supercast's base expression, which provides the actual argument value
 *    to a message send.
 */
Primitive "_'s‚Åáexpression" is
[
	aSupercast : super cast phrase
|
	Primitive SuperCastExpression;
] : expression yielding any;

/**
 * Answer a supercast's lookup type, the type to be used for method lookup.
 *
 * @category "Primitives"
 * @method "_'s‚Åálookup type"
 * @param "aSupercast" "super cast phrase‚áíany"
 *        The supercast from which to extract the lookup type.
 * @returns "{any}·µÄ"
 *    The type that the supercast uses during method lookup.
 */
Primitive "_'s‚Åálookup type" is
[
	aSupercast : super cast phrase
|
	Primitive SuperCastLookupType;
] : any meta;

/**
 * Answer the lexeme of the specified token. This is the source text that
 * produced the token.
 *
 * @category "Primitives" "Tokens" "Queries"
 * @method "_'s‚Åálexeme"
 * @param "aToken" "token"
 *        A token.
 * @returns "character+"
 *    The source text of {@param "aToken"}.
 */
Primitive "_'s‚Åálexeme" is
[
	aToken : token
|
	Primitive TokenLexeme;
] : nonempty string;

/**
 * Answer the one-based line number of the specified token within the module
 * that supplied it.
 *
 * @category "Primitives" "Tokens" "Queries"
 * @method "_'s‚Åáline number"
 * @param "aToken" "token"
 *        A token.
 * @returns "ùïé"
 *    The one-based line number of {@param "aToken"}.
 */
Primitive "_'s‚Åáline number" is
[
	aToken : token
|
	Primitive TokenLineNumber;
] : whole number;

/**
 * Answer the zero-based starting position of the specified token within the
 * module that supplied it.
 *
 * @category "Primitives" "Tokens" "Queries"
 * @method "_'s‚Åástarting position"
 * @param "aToken" "token"
 *        A token.
 * @returns "ùïé"
 *    The zero-based starting position of {@param "aToken"}.
 */
Primitive "_'s‚Åástarting position" is
[
	aToken : token
|
	Primitive TokenStart;
] : whole number;

/**
 * Answer the declaration that introduced the entity referenced by the specified
 * variable use expression.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s‚Åádeclaration"
 * @param "use" "variable use phrase‚áíany"
 *        A variable use expression.
 * @returns "declaration phrase‚áí‚ä§"
 *    The requested declaration.
 */
Primitive "_'s‚Åádeclaration" is
[
	use : variable use phrase
|
	Primitive VariableUseDeclaration;
] : declaration phrase;

/**
 * Answer the specified variable use expression's token.
 *
 * @category "Primitives" "Phrases" "Queries"
 * @method "_'s‚Åátoken"
 * @param "use" "variable use phrase‚áíany"
 *        A variable use expression.
 * @returns "token"
 *    The token that names the referenced entity at the point of use.
 */
Primitive "_'s‚Åátoken" is
[
	use : variable use phrase
|
	Primitive VariableUseToken;
] : token;

/**
 * Compute and answer a pojo array with the specified element type and length.
 *
 * @category "Primitives" "POJO" "Constructors"
 * @method "new_[_]"
 * @param "elementType" "{any}·µÄ"
 *        The element type.
 * @param "length" "ùïé"
 *        The number of elements.
 * @returns "any[]"
 *    A new pojo array that can store and answer {@param "length"} elements conforming
 *    to {@param "elementType"}.
 */
Primitive "new_[_]" is
[
	elementType : any meta,
	length : whole number
|
	Primitive CreatePojoArray;
] : pojo array;

/**
 * Construct and answer a pojo array type whose element type is {@param "elementType"}
 * and whose cardinality requirement is {@param "cardinalityRequirement"}.
 *
 * @category "Primitives" "Types" "POJO" "Constructors"
 * @method "_[_]"
 * @param "elementType" "{any}·µÄ"
 *        The type of the elements of instances.
 * @param "cardinalityRequirement" "{ùïé}·µÄ"
 *        The range of sizes of instances.
 * @returns "{any[]}·µÄ"
 *    The requested pojo array type.
 */
Primitive "_[_]" is
[
	elementType : any meta,
	cardinalityRequirement : whole number meta
|
	Primitive CreatePojoArrayType;
] : pojo array meta;

/**
 * Construct and answer a tuple whose elements are sourced from the specified
 * pojo array.
 *
 * @category "Primitives" "Tuples" "POJO" "Conversions"
 * @method "_‚Üítuple"
 * @param "aPojoArray" "any[]"
 *        A pojo array.
 * @returns "tuple"
 *    The requested tuple.
 */
Primitive "_‚Üítuple" is
[
	aPojoArray : pojo array
|
	Primitive CreateTupleFromPojoArray;
] : tuple;

/**
 * Answer the number of elements contained by the specified pojo array.
 *
 * @category "Primitives" "POJO" "Queries"
 * @method "`|_`|"
 * @param "anArray" "any[]"
 *        A pojo array.
 * @returns "ùïé"
 *    The size of the argument.
 */
Primitive "`|_`|" is
[
	anArray : pojo array
|
	Primitive PojoArrayLength;
] : whole number;

/**
 * Answer the element type of the specified pojo array type.
 *
 * @category "Primitives" "Types" "POJO" "Queries"
 * @method "_'s‚Åáelement type"
 * @param "pojoArrayType" "{any[]}·µÄ"
 *        A pojo array type.
 * @returns "{any}·µÄ"
 *    The element type of {@param "pojoArrayType"}.
 */
Primitive "_'s‚Åáelement type" is
[
	pojoArrayType : pojo array meta
|
	Primitive PojoArrayTypeContentType;
] : any meta;

/**
 * Answer the cardinality restriction of the specified pojo array type.
 *
 * @category "Primitives" "Types" "POJO" "Queries"
 * @method "`|`|_`|`|"
 * @param "pojoArrayType" "{any[]}·µÄ"
 *        A pojo array type.
 * @returns "{ùïé}·µÄ"
 *    The cardinality restriction of {@param "pojoArrayType"}.
 */
Primitive "`|`|_`|`|" is
[
	pojoArrayType : pojo array meta
|
	Primitive PojoArrayTypeSizes;
] : whole number meta;

/**
 * Answer the function type of any function that could close the specified
 * function implementation.
 *
 * @category "Primitives" "Function Implementations" "Queries"
 * @method "_'s‚Åáfunction type"
 * @param "aFunctionImplementation" "¬¢[‚Ä¶]‚Üí‚ä§"
 *        A function implementation.
 * @returns "{[‚Ä¶]‚Üí‚ä§}·µÄ"
 *    The argument's function type.
 */
Primitive "_'s‚Åáfunction type" is
[
	aFunctionImplementation : function implementation
|
	Primitive CompiledCodeFunctionType;
] : function meta;

/**
 * Answer the literals that support a function implementation's algorithm.
 *
 * @category "Primitives" "Function Implementations" "Queries"
 * @method "_'s‚Åáliterals"
 * @param "aFunctionImplementation" "¬¢[‚Ä¶]‚Üí‚ä§"
 *        A function implementation.
 * @returns "tuple"
 *    A tuple containing the argument's supporting literals.
 */
Primitive "_'s‚Åáliterals" is
[
	aFunctionImplementation : function implementation
|
	Primitive CompiledCodeLiterals;
] : tuple;

/**
 * Answer the arity of a function implementation. This is the number of
 * parameters accepted by the function implementation.
 *
 * @category "Primitives" "Function Implementations" "Queries"
 * @method "_'s‚Åáarity"
 * @param "aFunctionImplementation" "¬¢[‚Ä¶]‚Üí‚ä§"
 *        A function implementation.
 * @returns "ùïé"
 *    The argument's arity.
 */
Primitive "_'s‚Åáarity" is
[
	aFunctionImplementation : function implementation
|
	Primitive CompiledCodeNumArgs;
] : whole number;

/**
 * Answer the number of local variables used by a function implementation.
 *
 * @category "Primitives" "Function Implementations" "Queries"
 * @method "`|_'s‚Åálocal variables`|"
 * @param "aFunctionImplementation" "¬¢[‚Ä¶]‚Üí‚ä§"
 *        A function implementation.
 * @returns "ùïé"
 *    The number of locals used by the argument.
 */
Primitive "`|_'s‚Åálocal variables`|" is
[
	aFunctionImplementation : function implementation
|
	Primitive CompiledCodeNumLocals;
] : whole number;

/**
 * Answer the number of outer variables used by a function implementation.
 *
 * @category "Primitives" "Function Implementations" "Queries"
 * @method "`|_'s‚Åáouter variables`|"
 * @param "aFunctionImplementation" "¬¢[‚Ä¶]‚Üí‚ä§"
 *        A function implementation.
 * @returns "ùïé"
 *    The number of outers used by the argument.
 */
Primitive "`|_'s‚Åáouter variables`|" is
[
	aFunctionImplementation : function implementation
|
	Primitive CompiledCodeNumOuters;
] : whole number;

/**
 * Answer the maximum stack depth of a function implementation. This does not
 * account for arguments and local variables (which occupy the "bottom" stack
 * slots).
 *
 * @category "Primitives" "Function Implementations" "Queries"
 * @method "_'s‚Åámaximum stack depth"
 * @param "aFunctionImplementation" "¬¢[‚Ä¶]‚Üí‚ä§"
 *        A function implementation.
 * @returns "ùïé"
 *    The argument's maximum stack depth.
 */
Primitive "_'s‚Åámaximum stack depth" is
[
	aFunctionImplementation : function implementation
|
	Primitive CompiledCodeNumStackSlots;
] : whole number;

/**
 * Answer the Level One instructions that describe a function implementation's
 * algorithm as a tuple of nybblecodes.
 *
 * @category "Primitives" "Function Implementations" "Queries"
 * @method "_'s‚Åánybblecodes"
 * @param "aFunctionImplementation" "¬¢[‚Ä¶]‚Üí‚ä§"
 *        A function implementation.
 * @returns "[0..15]*"
 *    The argument's nybblecodes.
 */
Primitive "_'s‚Åánybblecodes" is
[
	aFunctionImplementation : function implementation
|
	Primitive CompiledCodeNybbles;
] : tuple of nybble;

/**
 * Answer the implementation of the specified function. A function's
 * implementation comprises its nybblecodes, its literals, its primitive
 * linkage (if any), its function type, and various statistics.
 *
 * @category "Primitives" "Functions" "Queries"
 * @method "_'s‚Åáimplementation"
 * @param "aFunction" "[‚Ä¶]‚Üí‚ä§"
 *        A function.
 * @returns "¬¢[‚Ä¶]‚Üí‚ä§"
 *    The argument's implementation.
 */
Primitive "_'s‚Åáimplementation" is
[
	aFunction : function
|
	Primitive CompiledCodeOfFunction;
] : function implementation;

/**
 * Answer the name of the primitive linked to the specified function
 * implementation. If the function implementation does not have
 * primitive linkage, then answer the empty string.
 *
 * @category "Primitives" "Function Implementations" "Queries"
 * @method "_'s‚Åáprimitive name"
 * @param "aFunctionImplementation" "¬¢[‚Ä¶]‚Üí‚ä§"
 *        A function implementation.
 * @returns "string"
 *    The argument's primitive name, or the empty string if the argument does
 *    not have primitive linkage.
 */
Primitive "_'s‚Åáprimitive name" is
[
	aFunctionImplementation : function implementation
|
	Primitive CompiledCodePrimitiveName;
] : string;

/**
 * Set the descriptive name of the given function implementation.  This value is
 * presented in stack traces and other symbolic circumstances.  This
 * automatically sets the names of the sub-functions in a systematic way.
 *
 * @category "Primitives"
 * @method "Set name of function implementation_to_"
 * @param "rawFunction" "¬¢[‚Ä¶]‚Üí‚ä§"
 *        The function implementation to name.
 * @param "name" "character+"
 *        A string used to name the function implementation.
 * @returns "‚ä§"
 */
Primitive "Set name of function implementation_to_" is
[
	rawFunction : function implementation,
	name : nonempty string
|
	Primitive SetCompiledCodeName;
] : ‚ä§;

/**
 * Construct and answer a set type with the specified element type and range of
 * cardinalities.
 *
 * @category "Primitives" "Types" "Sets" "Constructors"
 * @method "{_`|_}"
 * @param "elementType" "{any}·µÄ"
 *        The element type.
 * @param "cardinalityType" "{ùïé}·µÄ"
 *        The range of allowed cardinalities.
 * @returns "{set}·µÄ"
 *    The requested set type. Instances have elements that conform to
 *    {@param "elementType"} and cardinalities that conform to {@param
 *    "cardinalityType"}.
 */
Primitive "{_`|_}" is
[
	elementType : any meta,
	cardinalityType : whole number meta
|
	Primitive CreateSetType;
] : set meta;

/**
 * Is {@param "element"} an element of {@param "aSet"}?
 *
 * @category "Primitives" "Sets" "Queries"
 * @method "_‚àà_"
 * @param "element" "any"
 *        An arbitrary value.
 * @param "aSet" "set"
 *        A set.
 * @returns "boolean"
 *    `true` if {@param "element"} is an element of {@param "aSet"}, `false`
 *    otherwise.
 */
Primitive "_‚àà_" is
[
	element : any,
	aSet : set
|
	Primitive ElementInSet;
] : boolean;

/**
 * Compute and answer the asymmetric set difference of {@param "minuend"} and
 * {@param "subtrahend"} (also the relative complement of {@param "subtrahend"} in {@param "minuend"}).
 * This is a set that contains only those elements present in {@param "minuend"}
 * but not in {@param "subtrahend"}.
 *
 * @category "Primitives" "Sets" "Mathematics"
 * @method "_\\_"
 * @param "minuend" "set"
 *        The minuend.
 * @param "subtrahend" "set"
 *        The subtrahend.
 * @returns "set"
 *    The asymmetric set difference of {@param "minuend"} and {@param "subtrahend"}.
 */
Primitive "_\\_" is
[
	minuend : set,
	subtrahend : set
|
	Primitive SetDifference;
] : set;

/**
 * Compute and answer the set intersection of the arguments. This is a set that
 * contains only those elements present in each set.
 *
 * @category "Primitives" "Sets" "Mathematics"
 * @method "_‚à©_"
 * @param "arg1" "set"
 *        A set.
 * @param "arg2" "set"
 *        A set.
 * @returns "set"
 *    The set intersection of the arguments.
 */
Primitive "_‚à©_" is
[
	arg1 : set,
	arg2 : set
|
	Primitive SetIntersection;
] : set;

/**
 * Is {@param "arg1"} a subset of or equal to {@param "arg2"}?
 *
 * @category "Primitives" "Sets" "Mathematics" "Relations"
 * @method "_‚äÜ_"
 * @param "arg1" "set"
 *        A set.
 * @param "arg2" "set"
 *        A set.
 * @returns "boolean"
 *    `true` if {@param "arg1"} is a subset of or equal to {@param "arg2"},
 *    `false` otherwise.
 */
Primitive "_‚äÜ_" is
[
	arg1 : set,
	arg2 : set
|
	Primitive SetIsSubset;
] : boolean;

/**
 * Answer the cardinality of the specified set.
 *
 * @category "Primitives" "Sets" "Queries"
 * @method "`|_`|"
 * @param "aSet" "set"
 *        A set.
 * @returns "ùïé"
 *    The argument's cardinality.
 */
Primitive "`|_`|" is
[
	aSet : set
|
	Primitive SetSize;
] : whole number;

/**
 * Construct and answer a tuple that arbitrarily orders the elements of the
 * specified set. The conversion is unstable, and thus different calls given
 * the same argument may produce different orderings.
 *
 * @category "Primitives" "Sets" "Tuples" "Conversions"
 * @method "_‚Üítuple"
 * @param "aSet" "set"
 *        A set.
 * @returns "tuple"
 *    The requested tuple.
 */
Primitive "_‚Üítuple" is
[
	aSet : set
|
	Primitive SetToTuple;
] : tuple;

/**
 * Answer the element type of the specified set type. This is the most specific
 * type to which all elements of instances must conform.
 *
 * @category "Primitives" "Types" "Sets" "Queries"
 * @method "_'s‚Åáelement|member type"
 * @param "aSetType" "{set}·µÄ"
 *        A set type.
 * @returns "{any}·µÄ"
 *    The argument's element type.
 */
Primitive "_'s‚Åáelement|member type" is
[
	aSetType : set meta
|
	Primitive SetTypeElementType;
] : any meta;

/**
 * Answer the acceptable range of cardinalities for instances of the specified
 * set type.
 *
 * @category "Primitives" "Types" "Sets" "Queries"
 * @method "`|`|_`|`|"
 * @param "aSetType" "{set}·µÄ"
 *        A set type.
 * @returns "{ùïé}·µÄ"
 *    The argument's cardinality requirement.
 */
Primitive "`|`|_`|`|" is
[
	aSetType : set meta
|
	Primitive SetTypeSizes;
] : whole number meta;

/**
 * Compute and answer the set union of the arguments. This is a set that
 * contains the elements of both sets.
 *
 * @category "Primitives" "Sets" "Mathematics"
 * @method "_‚à™_"
 * @param "arg1" "set"
 *        A set.
 * @param "arg2" "set"
 *        A set.
 * @returns "set"
 *    The set union of the arguments.
 */
Primitive "_‚à™_" is
[
	arg1 : set,
	arg2 : set
|
	Primitive SetUnion;
] : set;

/**
 * Compute and answer the set union of the specified set and a set containing
 * the supplied element.
 *
 * @category "Primitives" "Sets" "Mathematics"
 * @method "_+_"
 * @param "aSet" "set"
 *        A set.
 * @param "newElement" "any"
 *        The element that must be present in the resultant set.
 * @returns "{any|1..‚àû}"
 *    A set that contains the same elements as {@param "aSet"} but also
 *    contains {@param "newElement"}.
 */
Primitive "_+_" is
[
	aSet : set,
	newElement : any
|
	Primitive SetWith;
] : non-empty set;

/**
 * Compute and answer the asymmetric set difference of the specified set and a
 * set containing the supplied element.
 *
 * @category "Primitives" "Sets" "Mathematics"
 * @method "_-_"
 * @param "aSet" "set"
 *        A set.
 * @param "oldElement" "any"
 *        The element that must not be present in the resultant set.
 * @returns "set"
 *    A set that contains the same elements as {@param "aSet"} except that
 *    it does not contain {@param "oldElement"}.
 */
Primitive "_-_" is
[
	aSet : set,
	oldElement : any
|
	Primitive SetWithout;
] : set;

/**
 * Construct and answer a set that uniquely (by definition) contains the same
 * elements as the specified tuple.
 *
 * @category "Primitives" "Sets" "Tuples" "Conversions"
 * @method "_‚Üíset"
 * @param "aTuple" "tuple"
 *        A tuple.
 * @returns "set"
 *    The requested set.
 */
Primitive "_‚Üíset" is
[
	aTuple : tuple
|
	Primitive TupleToSet;
] : set;

/**
 * Construct and answer a tuple that is the left-to-right concatenation of all
 * elements (i.e. tuples) of the specified tuple.
 *
 * @category "Primitives" "Tuples" "Transformers"
 * @method "concatenate_"
 * @param "tupleOfTuples" "tuple*"
 *        A tuple of tuples.
 * @returns "tuple"
 *    The requested tuple.
 */
Primitive "concatenate_" is
[
	tupleOfTuples : tuple of tuple
|
	Primitive ConcatenateTuples;
] : tuple;

/**
 * Construct and answer a tuple type with the specified leading element types,
 * default element type, and range of cardinalities.
 *
 * @category "Primitives" "Types" "Tuples" "Constructors"
 * @method "<_,_`‚Ä¶`|_>"
 * @param "leadingTypes" "{any}·µÄ*"
 *        The leading types.
 * @param "defaultType" "{any}·µÄ"
 *        The default type.
 * @param "cardinalityType" "{ùïé}·µÄ"
 *        The range of allowed cardinalities.
 * @returns "{tuple}·µÄ"
 *    The requested tuple type.
 */
Primitive "<_,_`‚Ä¶`|_>" is
[
	leadingTypes : tuple of any meta,
	defaultType : any meta,
	cardinalityType : whole number meta
|
	Primitive CreateTupleType;
] : tuple meta;

/**
 * Reverses the order of the given tuple.
 *
 * @category "Primitives" "Tuples" "Transformers"
 * @method "_reversed"
 * @param "aTuple" "tuple"
 *        A tuple.
 * @returns "tuple"
 *    A tuple that is the reverse of the original tuple
 */
Primitive "_reversed" is
[
	aTuple : tuple
|
	Primitive ReverseTuple;
] : tuple;

/**
 * Answer the cardinality of the specified tuple.
 *
 * @category "Primitives" "Tuples" "Queries"
 * @method "`|_`|"
 * @param "aTuple" "tuple"
 *        A tuple.
 * @returns "ùïé"
 *    The argument's cardinality.
 */
Primitive "`|_`|" is
[
	aTuple : tuple
|
	Primitive TupleSize;
] : whole number;

/**
 * Answer the element type of the {@param "index"}-th element of instances of the
 * specified type. If {@param "index"} is out of bounds, then answer
 * {@type "‚ä•"}.
 *
 * @category "Primitives" "Types" "Tuples" "Queries"
 * @method "_[_]"
 * @param "aTupleType" "{tuple}·µÄ"
 *        A tuple type.
 * @param "index" "‚Ñï"
 *        The index of the desired element type.
 * @returns "{any}·µÄ"
 *    The requested element type, or ‚ä• if {@param "index"} is out of bounds.
 */
Primitive "_[_]" is
[
	aTupleType : tuple meta,
	index : natural number
|
	Primitive TupleTypeAt;
] : any meta;

/**
 * Compute and answer the type union of the indicated range of element types.
 *
 * @category "Primitives" "Types" "Tuples" "Queries"
 * @method "‚à™_[_.._]"
 * @param "aTupleType" "{tuple}·µÄ"
 *        A tuple type.
 * @param "startIndex" "‚Ñï"
 *        The one-based index (inclusive) of the start of the range.
 * @param "endIndex" "[0..‚àû]"
 *        The one-based index (inclusive) of the end of the range.
 * @returns "{any}·µÄ"
 *    The type union of all element types in the specified range.
 */
Primitive "‚à™_[_.._]" is
[
	aTupleType : tuple meta,
	startIndex : natural number,
	endIndex : nonnegative extended integer
|
	Primitive TupleTypeAtThrough;
] : any meta;

/**
 * Compute and answer the concatenation of the specified tuple types. This is
 * the most specific type that encompasses all possible concatenations of the
 * instances of the two types.
 *
 * @category "Primitives" "Types" "Tuples" "Transformers"
 * @method "_++_"
 * @param "arg1" "{tuple}·µÄ"
 *        A tuple type.
 * @param "arg2" "{tuple}·µÄ"
 *        A tuple type.
 * @returns "{tuple}·µÄ"
 *    The requested tuple type.
 */
Primitive "_++_" is
[
	arg1 : tuple meta,
	arg2 : tuple meta
|
	Primitive TupleTypeConcatenate;
] : tuple meta;

/**
 * Answer the default element type of instances of the specified type.
 *
 * @category "Primitives" "Types" "Tuples" "Queries"
 * @method "_'s‚Åádefault type"
 * @param "aTupleType" "{tuple}·µÄ"
 *        A tuple type.
 * @returns "{any}·µÄ"
 *    The argument's default element type.
 */
Primitive "_'s‚Åádefault type" is
[
	aTupleType : tuple meta
|
	Primitive TupleTypeDefaultType;
] : any meta;

/**
 * Answer a tuple containing the leading element types of instances of the
 * specified type.
 *
 * @category "Primitives" "Types" "Tuples" "Queries"
 * @method "_'s‚Åáleading types"
 * @param "aTupleType" "{tuple}·µÄ"
 *        A tuple type.
 * @returns "{any}·µÄ*"
 *    The argument's leading element types.
 */
Primitive "_'s‚Åáleading types" is
[
	aTupleType : tuple meta
|
	Primitive TupleTypeLeadingTypes;
] : tuple of any meta;

/**
 * Answer the range of allowed cardinalities of instances of the specified type.
 *
 * @category "Primitives" "Types" "Tuples" "Queries"
 * @method "`|`|_`|`|"
 * @param "aTupleType" "{tuple}·µÄ"
 *        A tuple type.
 * @returns "{ùïé}·µÄ"
 *    The argument's cardinality requirement.
 */
Primitive "`|`|_`|`|" is
[
	aTupleType : tuple meta
|
	Primitive TupleTypeSizes;
] : whole number meta;

/**
 * Compute and answer the type union of the elements of the given tuple of
 * types.
 *
 * @category "Primitives" "Types" "Tuples" "Queries"
 * @method "‚à™_"
 * @param "tupleOfTypes" "{‚ä§}·µÄ*"
 *        A tuple of types.
 * @returns "{‚ä§}·µÄ"
 *    The type union of the elements of the argument.
 */
Primitive "‚à™_" is
[
	tupleOfTypes : tuple of type
|
	Primitive UnionOfTupleOfTypes;
] : type;

/**
 * If {@param "value"} is type-compatible with the parameter expected by the
 * function {@param "intoBlock"}, then invoke it with that argument, otherwise
 * invoke {@param "elseBlock"} with no arguments.  Answer the result of
 * whichever function was evaluated (they may be ‚ä§-valued).
 *
 * @category "Primitives"
 * @method "Cast|cast_into_else_"
 * @param "value" "any"
 *        A value to type-test.
 * @param "intoBlock" "[‚ä•]‚Üí‚ä§"
 *        A function to invoke with the provided value if its type is
 *        compatible with the parameter type.
 * @param "elseBlock" "[]‚Üí‚ä§"
 *        A zero-argument function to invoke if the value was not compatible
 *        with the first function's parameter.
 * @returns "‚ä§"
 *    The value produced by whichever function ran.  May be ‚ä§-valued.
 */
Primitive "Cast|cast_into_else_" is
[
	value : any,
	intoBlock : unary procedure,
	elseBlock : nullary procedure
|
	Primitive CastIntoElse;
] : ‚ä§;

/**
 * Construct and answer an enumeration whose instances are fully determined by
 * the membership of the specified set.
 *
 * @category "Primitives" "Types" "Constructors"
 * @method "enumeration of_"
 * @param "instances" "set"
 *        The complete set of instances of the enumeration.
 * @returns "{any}·µÄ"
 *    The requested enumeration.
 */
Primitive "enumeration of_" is
[
	instances : set
|
	Primitive CreateEnumeration;
] : any meta;

/**
 * Answer the number of instances of the specified type. This is `‚àû` for all
 * types except for enumerations.
 *
 * @category "Primitives" "Types" "Queries"
 * @method "`|_`|"
 * @param "aType" "{‚ä§}·µÄ"
 *        A type.
 * @returns "[0..‚àû]"
 *    The cardinality of the membership of the type.
 */
Primitive "`|_`|" is
[
	aType : type
|
	Primitive InstanceCount;
] : nonnegative extended integer;

/**
 * Is {@param "value"} an instance of {@param "aType"}?
 *
 * @category "Primitives"
 * @method "_‚àà_"
 * @param "value" "any"
 *        The value to test for membership in {@param "aType"}.
 * @param "aType" "{‚ä§}·µÄ"
 *        The target type for the membership check.
 * @returns "boolean"
 *    {@method "true"} if {@param "value"} is an instance of {@param
 *    "aType"}, {@method "false"} otherwise.
 */
Primitive "_‚àà_" is
[
	value : any,
	aType : type
|
	Primitive IsInstanceOf;
] : boolean;

/**
 * Is the first argument a subtype of the second argument? This does not
 * implement the proper subtype relation, so the first argument is considered
 * a subtype of the second argument also if it is equal to the second argument.
 *
 * @category "Primitives" "Types" "Mathematics" "Relations"
 * @method "_‚äÜ_"
 * @param "arg1" "{‚ä§}·µÄ"
 *        A type.
 * @param "arg2" "{‚ä§}·µÄ"
 *        A type.
 * @returns "boolean"
 *    `true` if the first argument is a subtype of, or the same type as, the
 *    second argument, `false` otherwise.
 */
Primitive "_‚äÜ_" is
[
	arg1 : type,
	arg2 : type
|
	Primitive IsSubtypeOf;
] : boolean;

/**
 * Answer the precise instance type of the supplied value. This is the most
 * specific possible type that describes the value.
 *
 * @category "Primitives" "Types" "Constructors"
 * @method "_'s‚Åátype"
 * @param "value" "any"
 *        An arbitrary value.
 * @returns "{any}·µÄ"
 *    The precise instance type of the supplied value.
 */
Primitive "_'s‚Åátype" is
[
	value : any
|
	Primitive Type;
] : any meta;

/**
 * Compute and answer the type intersection of the two types. This is the most
 * general type that is a subtype of both types.
 *
 * @category "Primitives" "Types" "Mathematics"
 * @method "_‚à©_"
 * @param "arg1" "{‚ä§}·µÄ"
 *        A type.
 * @param "arg2" "{‚ä§}·µÄ"
 *        A type.
 * @returns "{‚ä§}·µÄ"
 *    The type intersection of the arguments.
 */
Primitive "_‚à©_" is
[
	arg1 : type,
	arg2 : type
|
	Primitive TypeIntersection;
] : type;

/**
 * Compute and answer the type union of the two types. This is the most
 * specific type that is a supertype of both types.
 *
 * @category "Primitives" "Types" "Mathematics"
 * @method "_‚à™_"
 * @param "arg1" "{‚ä§}·µÄ"
 *        A type.
 * @param "arg2" "{‚ä§}·µÄ"
 *        A type.
 * @returns "{‚ä§}·µÄ"
 *    The type union of the arguments.
 */
Primitive "_‚à™_" is
[
	arg1 : type,
	arg2 : type
|
	Primitive TypeUnion;
] : type;

/**
 * Construct and answer a variable type from the specified read and write types.
 *
 * @category "Primitives" "Variables" "Types" "Constructors"
 * @method "read_/write_"
 * @param "readType" "{‚ä§}·µÄ"
 *        The read type of the variable type.
 * @param "writeType" "{‚ä§}·µÄ"
 *        The write type of the variable type.
 * @returns "{read ‚ä§/write ‚ä•}·µÄ"
 *    The requested variable type.
 */
Primitive "read_/write_" is
[
	readType : type,
	writeType : type
|
	Primitive CreateReadWriteVariableType;
] : variable meta;

/**
 * Construct and answer a new variable with the specified containment type.
 *
 * @category "Primitives" "Variables" "Constructors"
 * @method "new`‚Üë_"
 * @param "containmentType" "{any}·µÄ"
 *        The containment type.
 * @returns "read ‚ä§/write ‚ä•"
 *    A new variable capable of retrieving and storing values of the specified
 *    containment type.
 */
Primitive "new`‚Üë_" is
[
	containmentType : any meta
|
	Primitive CreateVariable;
] : write-only variable;

/**
 * Construct and answer a variable type with the specified containment type.
 *
 * @category "Primitives" "Variables" "Types" "Constructors"
 * @method "`‚Üë_"
 * @param "containmentType" "{any}·µÄ"
 *        The containment type.
 * @returns "{read ‚ä§/write ‚ä•}·µÄ"
 *    The requested variable type.
 */
Primitive "`‚Üë_" is
[
	containmentType : any meta
|
	Primitive CreateVariableType;
] : variable meta;

/**
 * Is the specified variable unassigned?
 *
 * @category "Primitives" "Variables" "Queries"
 * @method "_‚Üëis unassigned"
 * @param "var" "read ‚ä§/write ‚ä•"
 *        A variable.
 * @returns "boolean"
 *    {@method "true"} if the variable does not contain a value, {@method
 *    "false"} otherwise.
 */
Primitive "_‚Üëis unassigned" is
[
	var : write-only variable
|
	Primitive HasNoValue;
] : boolean;

/**
 * Answer the read type of the specified variable type. All values read from
 * instances of the variable type are at least as specific as the answer.
 *
 * @category "Primitives" "Variables" "Types" "Queries"
 * @method "_'s‚Åáread type"
 * @param "varType" "{read ‚ä§/write ‚ä•}·µÄ"
 *        A variable type.
 * @returns "{‚ä§}·µÄ"
 *    The most general type that describes values that can be read from
 *    instances of {@param "varType"}.
 */
Primitive "_'s‚Åáread type" is
[
	varType : variable meta
|
	Primitive VariableReadType;
] : type;

/**
 * Answer the write type of the specified variable type. All values written to
 * instances of the variable type are at least as specific as the answer.
 *
 * @category "Primitives" "Variables" "Types" "Queries"
 * @method "_'s‚Åáwrite type"
 * @param "varType" "{read ‚ä§/write ‚ä•}·µÄ"
 *        A variable type.
 * @returns "{‚ä§}·µÄ"
 *    The most general type that describes values that can be written to
 *    instances of {@param "varType"}.
 */
Primitive "_'s‚Åáwrite type" is
[
	varType : variable meta
|
	Primitive VariableWriteType;
] : type;

