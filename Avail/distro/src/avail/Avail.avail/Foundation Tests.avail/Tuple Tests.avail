/*
 * Tuple Tests.avail
 * Copyright © 1993-2014, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Tuple Tests"
Versions
	"1.0.0 DEV 2014-04-28"
Uses
	"Common",
	"Foundation",
	"Unit Testing"
Names
	"tuple test suite"
Body

/* The test suite identifier. */
"tuple test suite" is a new atom;

New test suite tuple test suite extends foundation test suite;

Test "tuple cardinality" in tuple test suite is
[
	a ::= <1,2,3,4>;
	Require: |a| = 4;
	Require: |<>| = 0;
	Require: <> is empty = true;
];

Test "tuple concatenation" in tuple test suite is
[
	a ::= <1,2>;
	b ::= <3,4>;
	c ::= <"foo", "bar">;
	Require: a ++ b = <1,2,3,4>;
	Require: a ++ c = <1,2,"foo", "bar">;
	Require: c[1] ++ c[2] = "foobar";
	Require: concatenate c = "foobar";
];

Test "tuple ranges" in tuple test suite is
[
	a ::= <1,2,3,4>;
	Require: a[1..] = <1,2,3,4>;
	Require: a[..3] = <1,2,3>;
	Require: a[2..3] = <2,3>;
];

Test "tuple membership" in tuple test suite is
[
 	Require: 2 ∈ <1,2,3>;
 	Require: ¬2 ∈ <1,3>;
];

Test "map through" in tuple test suite is
[
 	a ::= <1,2,3,4>;
 	b ::= map a through [n : natural number | n × 2];
 	Require: b = <2,4,6,8>;
];

Test "map and filter" in tuple test suite is
[
 	a ::= <1,2,3,4>;
 	b ::= map and filter a by 
 	[
 	 	n : natural number,
 	 	accept : [natural number]→⊤
 	 | 
 	 	m ::= n + 2;
 		If m mod 2 = 0 then
 		[
 		 	accept(m);
 		];
 	];
 	Require: b = <4,6>;
];

Test "any satisfies" in tuple test suite is
[
 	a ::= <1,2,3,4>;
 	b ::= any of a satisfies [n : natural number | n mod 2 = 0];
 	c ::= any of a satisfies [n : natural number | n > 200];
 	Require: b = true;
 	Require: c = false;
];

Test "for each of do" in tuple test suite is
[
	a ::= <1,2,3,4>;
	b : tuple := <>;
	For each of a do
	[
	 	n : natural number
	 |
	 	b := b ++ <n>;
	];
	Require: b = a;
];

Test "count of where" in tuple test suite is
[
	a ::= <1,2,3,4>;
 	b ::= count of a where [n : natural number | n mod 2 = 0];
 	c ::= count of a where [n : natural number | n > 2000];
 	Require: b = 2;
 	Require: c = 0;
];

Test "each of satisfies" in tuple test suite is
[
	a ::= <1,2,3,4>;
	counter : whole number := 0;
 	b ::= each of a satisfies [
		n : natural number | 
		counter := counter +1; 
 		n ≤ 2
 	];
 	c ::= each of a satisfies [n : natural number | n > 0];
 	Require: b = false;
 	Require: counter = 3;
 	Require: c = true;
];

Test "filter by" in tuple test suite is
[
	a ::= <1,2,3,4>;
 	b ::= filter a by [n : natural number | n mod 2 = 0];
 	c ::= filter a by [n : natural number | n > 2000];
 	Require: b = <2,4>;
 	Require: c = <>;
];

Test "alternative answer via else" in tuple test suite is
[
	a ::= <1,2,3,4>;
	Require: a[1] else [5] = 1;
	Require: a[6] else [5] = 5;
	Require: a[1..2] else [<5>] = <1,2>;
	Require: a[1..200] else [<5>] = <5>;
	Require: a[..2] else [<5>] = <1,2>;
	Require: a[..200] else [<5>] = <5>;
	Require: a[1..] else [<5>] = <1,2,3,4>;
	Require: a[200..] else [<5>] = <5>;
];

Test "tuple search" in tuple test suite is
[
	a ::= <1,2,3,2,1,4,5,6>;
	b ::= <1,2,3,4,6,2,3>;
	t ::= "The way to the heart is through the chest cavity, not through the \
			\|stomach, silly!";
	Require: all indices of <> in <> = <>;
	Require: all indices of <2> in <> = <>;
	Require: all indices of <2> in a = <2,4>;
	Require: all indices of <> in a = <>;
	Require: all indices of <2,3> in b = <2,6>;
	Require: all indices of "the" in t = <12,33,63>;
	Require: first index of <> in <> = 0;
	Require: first index of <2> in <> = 0;
	Require: first index of <2> in a = 2;
	Require: first index of <2,1,4> in a = 4;
	Require: last index of a where [n : natural number | n < 5] = 6;
	Require: last index of a where [n : natural number | n > 10] = 0;
	Require: first index of a where [n : natural number | n < 5] = 1;
	Require: first index of a where [n : natural number | n > 10] = 0;
	Require: all indices of a where [n : natural number | n < 2] = <1,5>;
	Require: all indices of a where [n : natural number | n > 20] = <>;
];

Test "subtuple replace" in tuple test suite is
[
	a ::= "purple feet on fire";
	b ::= <1,2,3,4,6,2,3>;
	c ::= "We know the truth; yes, know indeed";
	Require: replace all occurrences of <2,3,4> in <> with <9> = <>;
	Require: replace all occurrences of "\t" in "afb	c" with " " = "afb c"; 
	Require: replace all occurrences of "feet" in a with "people" = 
		"purple people on fire";
	Require: replace all occurrences of "know" in c with "hide" = 
		"We hide the truth; yes, hide indeed";
	Require: replace all occurrences of "pickles" in c with "hide" = c;
	Require: replace all occurrences of <2,3> in b with <9,8,7> = 
		<1,9,8,7,4,6,9,8,7>;
	Require: replace all occurrences of <2,3> in b with <> = <1,4,6>;
	Require: replace all occurrences of <2,3> in <2> with <> = <2>;
	Require: replace all occurrences of <2,3> in <2,3> with <9> = <9>;
	Require: replace the first occurrence of <2,3,4> in <> with <9> = <>;
	Require: replace the first occurrence of "know" in c with "fabricate" =
		"We fabricate the truth; yes, know indeed";
	Require: replace the first occurrence of <2,3> in b with <9,8,7> = 
		<1,9,8,7,4,6,2,3>;
	Require: replace the first occurrence of <2,3> in b with <> = <1,4,6,2,3>;
	Require: replace the first occurrence of <2,3> in <2> with <> = <2>;
	Require: replace the first occurrence of <2,3> in <2,3> with <9> = <9>;
];

Test "drop from tuple" in tuple test suite is
[
	a ::= <1,2,3,2,1,4,5,6>;
	Require: drop 4 from a = <1,4,5,6>;
	Require: drop 8 from a = <>;
	Require: drop 0 from a = a;
	Require: drop from a until [n : natural number | n > 3] = <4,5,6>;
	Require: drop from a until [n : natural number | n > 6] = <>;
	Require: drop from a while [n : natural number | n < 3] = <3,2,1,4,5,6>;
	Require: drop from a while [n : natural number | n < 7] = <>;	
];

Test "take from tuple" in tuple test suite is
[
	a ::= <1,2,3,2,1,4,5,6>;
	Require: take 4 from a = <1,2,3,2>;
	Require: take 8 from a = a;
	Require: take 0 from a = <>;
	Require: take from a until [n : natural number | n > 3] = <1,2,3,2,1>;
	Require: take from a until [n : natural number | n > 6] = a;
	Require: take from a while [n : natural number | n ≤ 2] = <1,2>;
	Require: take from a while [n : natural number | n < 7] = a;	
];

Test "split tuple" in tuple test suite is
[
	a ::= <1,2,3,2,1,4,5,6>;
	Require: split a after 3 = <<1,2,3>,<2,1,4,5,6>>;
	Require: split a after 0 = <<>,<1,2,3,2,1,4,5,6>>;
	Require: split a after 8 = <<1,2,3,2,1,4,5,6>,<>>;
	Require: split a before 1 = <<>,<1,2,3,2,1,4,5,6>>;
	Require: split a before 8 = <<1,2,3,2,1,4,5>,<6>>;
	Require: split a before 9 = <<1,2,3,2,1,4,5,6>,<>>;
];

Test "stripe tuple" in tuple test suite is
[
 	a ::= <<1,2>,<3,4>,<5,6,7>>;
 	
 	/*TODO[MvG] Remove right away*/
 	b ::= stripe a at 2;
 	Require: b = <2,4,6>;
 	
 	
 	Require: stripe a at 2 = <2,4,6>;
];

Test "zip tuple" in tuple test suite is
[
 	a ::= <1,2,3>;
 	b ::= <4,5,6>;
 	c ::= <7,8,9>;
 	Require: zip <a,b,c> = <<1,4,7>,<2,5,8>,<3,6,9>>;
 	Require: a zip b zip c = <<1,4,7>,<2,5,8>,<3,6,9>>;
 	Require: c zip b zip a = <<7,4,1>,<8,5,2>,<9,6,3>>;
];

Test "suffixes and prefixes" in tuple test suite is
[
	a ::= <1,2,3,2,1,4,5,6>;
	Require: a starts with <1,2,3>;
	Require: a starts with <1,2,4> = false;
	Require: a ends with <1,4,5,6>;
	Require: a ends with <1,4,5,7> = false;
	Require: a's head = 1;
	Require: a's last = 6;
	Require: a's tail = <2,3,2,1,4,5,6>;
];

Test "slice replacement" in tuple test suite is
[
	a ::= <1,2,3,2,1,4,5,6>;
	Require: a[2..4] → <"foo",¢w,∅> = <1,"foo",¢w,∅,1,4,5,6>; 
];

Test "fold" in tuple test suite is
[
	Require: left fold <6,3,2> through
	[
		input : integer,
		result : integer
	|
		result ÷ input
	] = 1;

	Require: right fold <2,3,5> through
	[
		input : natural number,
		result : natural number
	|
		result ^ input
	] = 15625;
];

Test "element swap" in tuple test suite is
[
 	a ::= <1,2,3,2,1,4,5,6>;
 	Require: a[3↔8] = <1,2,6,2,1,4,5,3>;
];

/*Sorting Tests*/

Test "trivial empty merge sort" in tuple test suite is
[
	ref : <natural number…|>;
	ref := merge sort <>;
	Require: <> = ref;
];

Test "trivial one element merge sort" in tuple test suite is
[
	ref : <natural number…|>;
	ref := merge sort <18>;
	Require: <18> = ref;
];

Test "small merge sort" in tuple test suite is
[
	ref : <natural number…|>;
	ref := merge sort <4,6,1>;
	Require: <1,4,6> = ref;
];

Test "merge sort" in tuple test suite is
[
	ref : <natural number…|>;
	ref := merge sort <4,6,1,2,3,20,18,19,17,14,16,15,12,13,5,7,8,9,10,11>;
	Require: <1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20> = ref;
];

Test "small merge sort with" in tuple test suite is
[
	ref : <natural number…|>;
	ref := merge sort <4,6,1> with 
		[n : natural number, m : natural number | n ≥ m];
	Require: <6,4,1> = ref;
];

Test "merge sort with" in tuple test suite is
[
	ref : <natural number…|>;
	ref := merge sort <14,4,6,1,2,3,20,18,19,17,16,15,12,13,5,7,8,9,10,11> with 
		[n : natural number, m : natural number | n ≥ m];
	Require: <20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1> = ref;
];

Test "complex merge sort with" in tuple test suite is
[
	ref : <natural number…|>;
	ref := merge sort <14,4,6,1,2,3,20,18,19,17,16,15,12,13,5,7,8,9,10,11> with
		[
			n : natural number, 
			m : natural number 
		|
			n is odd ∧ [m is even] ∨ [n is odd ∧ [m is odd ∧ [n ≤ m]]] ∨
				[n is even ∧ [m is even ∧ [n ≥ m]]]];
	Require: <1,3,5,7,9,11,13,15,17,19,20,18,16,14,12,10,8,6,4,2> = ref;
];

Test "trivial empty quicksort" in tuple test suite is
[
	ref : <natural number…|>;
	ref := quicksort <>;
	Require: <> = ref;
];

Test "trivial one element quicksort" in tuple test suite is
[
	ref : <natural number…|>;
	ref := quicksort <18>;
	Require: <18> = ref;
];

Test "small quicksort" in tuple test suite is
[
	ref : <natural number…|>;
	ref := quicksort <4,6,1>;
	Require: <1,4,6> = ref;
];

Test "quicksort" in tuple test suite is
[
	ref : <natural number…|>;
	ref := quicksort <4,6,1,2,3,20,18,19,17,14,16,15,12,13,5,7,8,9,10,11>;
	Require: <1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20> = ref;
];

Test "small quicksort with" in tuple test suite is
[
	ref : <natural number…|>;
	ref := quicksort <4,6,1> with 
		[n : natural number, m : natural number | n ≥ m];
	Require: <6,4,1> = ref;
];

Test "quicksort with" in tuple test suite is
[
	ref : <natural number…|>;
	ref := quicksort <14,4,6,1,2,3,20,18,19,17,16,15,12,13,5,7,8,9,10,11> with 
		[n : natural number, m : natural number | n ≥ m];
	Require: <20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1> = ref;
];

Test "complex quicksort with" in tuple test suite is
[
	ref : <natural number…|>;
	ref := quicksort <14,4,6,1,2,3,20,18,19,17,16,15,12,13,5,7,8,9,10,11> with
		[
			n : natural number, 
			m : natural number 
		|
			n is odd ∧ [m is even] ∨ [n is odd ∧ [m is odd ∧ [n ≤ m]]] ∨
				[n is even ∧ [m is even ∧ [n ≥ m]]]];
	Require: <1,3,5,7,9,11,13,15,17,19,20,18,16,14,12,10,8,6,4,2> = ref;
];

Test "quasi-destructive update" in tuple test suite is
[
	t : <natural number…|> := <1,2,3>;
	n ::= t[2] → 5;
	Require: <1,5,3> = n;
];

Test "quasi-destructive n-ary tuple update" in tuple test suite is
[
	t : <<natural number…|3>…|> := <<1,2,3>,<4,5,6>>;
	n ::= t[1][3] → 7;
	Require: <<1,2,7>,<4,5,6>> = n;
];

Test "quasi-destructive n-ary complex tuple update" in tuple test suite is
[
	t : <<natural number,{string→natural number|1},natural number…|3>…|> := 
		<<1,{"foo"→2},3>,<4,{"boo"→5},6>>;
	n ::= t[1][2]["foo"] → 7;
	Require: <<1,{"foo"→7},3>,<4,{"boo"→5},6>> = n;
];

Test "quasi-destructive n-ary very complex tuple update" in tuple test suite is
[
	t : <<natural number,{string→<string…|2>|1},natural number…|3>…|> := 
		<<1,{"foo"→<"cheese","apples">},3>,<4,{"boo"→<"purple","chariots">},6>>;
	n ::= t[1][2]["foo"][2] → "motor torpedo boat";
	Require: <<1,{"foo"→<"cheese","motor torpedo boat">},3>,
		<4,{"boo"→<"purple","chariots">},6>> = n;
];

Test "integer interval tuple" in tuple test suite is
[
	/*
	 * Create a series of complex small integer interval tuples.
	 */
	From -5 to 5 do
	[
		start : [-5..5]
	|
		From -5 to 5 do
		[
			end : [-5..5]
		|
			From -5 to 5 do
			[
				delta : [-5..5]
			|
				expected : tuple := <>;
				If delta ≠ 0 then
				[
					From start to end by delta do
					[
						i : integer
					|
						expected := expected ++ <i>;
					];
				];
				Guard
				[
					actual ::= start to end by delta;
					Require: actual = expected;
					Require: 0 ≠ delta;
				]
				intercept
				[
					e : incorrect-argument-type exception
				|
					Require: delta = 0;
				];
			];
		];
	];

	/*
	 * Test a delta that results in an actual end value that precedes the
	 * supplied end.
	 */
	Require: 83 to -29 by -17 = <83, 66, 49, 32, 15, -2, -19>;

	/*
	 * Create a simple integer interval tuple that is not small.
	 */
	expected : tuple := <>;
	From 12345678901 to 12345678907 by 2 do
	[
		i : integer
	|
		expected := expected ++ <i>;
	];
	Require: 12345678901 to 12345678907 by 2 = expected;

	/*
	 * Test concatenation of a small and a regular integer interval tuple.
	 */
	tinyTuple ::= 1 to 10 by 1;
	concatOne ::= tinyTuple ++ expected;
	Require: <1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12345678901, 12345678903, 
		12345678905, 12345678907> = concatOne;

	/* 
	 * Test the edges of small integer interval tuples and regular ones.
	 */
	intMaxInterval ::= 2147483640 to 2147483647 by 1;
	tooBigInterval ::= 2147483648 to 2147483655 by 1;
	concatTwo ::= intMaxInterval ++ tooBigInterval;
	Require: 2147483640 to 2147483655 by 1 = concatTwo;

	/* 
	 * Test concatenation of two small integer interval tuples.
	 */
	left ::= 1 to 5 by 1;
	right ::= 6 to 10 by 1;
	concatThree ::= left ++ right;
	Require: 1 to 10 by 1 = concatThree;
];
