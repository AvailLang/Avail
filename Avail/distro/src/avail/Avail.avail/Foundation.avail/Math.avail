/*
 * Math.avail
 * Copyright © 1993-2014, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Math"
Versions
	"dev"
Extends
	"Early Math"
Uses
	"Bootstrap",
	"Definers",
	"Early Assertions",
	"Early Control Structures",
	"Early Functions",
	"Early Logic",
	"Early Sets",
	"Early Tuples",
	"Enumeration Support",
	"Error Codes",
	"Literals",
	"Types",
	"Variables"
Names
	"log_of_",
	"negative integer",
	"nonpositive integer",
	"values in_",
	"_is odd",
	"_is even",
	"-_",
	"π",
	"«_‡«=|≤|<»!»",
	"«_‡«=|≥|>»!»"
Body

Method "“_”" is
[
	n : number
|
	/* Lose the ¢d or ¢f suffix. */
	s ::= primitive description of n;
	s[1..cast |s| - 1 into [t : natural number | t]]
] : string;

Method "“_”" is
[
	n : extended integer
|
	primitive description of n
] : string;

Forward method "_mod_" is [number, number]→number;
Public stable forward method "-_" is [number]→number;

/* Establish grammatical rules. */
[
	ext      ::= {"«_‡max»", "«_‡min»"};
	sum      ::= {"_+_", "_-_"};
	product  ::= {"_×_", "_÷_", "_mod_"};
	negation ::= {"-_"};
	abs      ::= {"`|_`|"};
	power    ::= {"_^_"};
	bounds   ::= {"⎣_⎦", "⎡_⎤"};

	sumAndProduct ::= sum ∪ product;

	/**
	 * Establish the standard grammatical rules for arithmetic.
	 * 
	 * @method "_×_"
	 * @method "_÷_"
	 * @method "_mod_"
	 * @forbids "1" "_+_" "_-_"
	 * @forbids "2" "_×_" "_÷_" "_mod_" "_+_" "_-_"
	 */
	Grammatical restriction product is <sum, sumAndProduct>;
	
	/**
	 * @method "-_"
	 * @forbids "1" "_×_" "_÷_" "_mod_" "_+_" "_-_" "-_" "«_‡max»" "«_‡min»" "∞"
	 */
	Grammatical restriction negation is
		<sumAndProduct ∪ negation ∪ ext ∪ {"∞"}>;

	/**
	 * Establish the precedence of exponentiation.
	 * 
	 * @method "_^_"
	 * @forbids "1" "_×_" "_÷_" "_mod_" "_+_" "_-_" "-_" "_^_"
	 * @forbids "2" "_×_" "_÷_" "_mod_" "_+_" "_-_"
	 */
	Grammatical restriction power is
		<sum ∪ product ∪ negation ∪ power, sum ∪ product>;

	/**
	 * Forbid nesting of absolute value.
	 * 
	 * @method "`|_`|"
	 * @forbids "1" "`|_`|"
	 */
	Grammatical restriction abs is <abs>;

	/**
	 * Forbid nesting of floor and ceiling.
	 * @method "⎣_⎦"
	 * @method "⎡_⎤"
	 * @forbids "1" "⎣_⎦" "⎡_⎤"
	 */
	Grammatical restriction bounds is <bounds>;

	/**
	 * Make left-associative.
	 * @method "_bit∧_"
	 * @forbids "2" "_bit∧_"
	 */
	Grammatical restriction "_bit∧_" is <∅, {"_bit∧_"}>;
	
	/**
	 * Make left-associative.
	 * @method "_bit∨_"
	 * @forbids "2" "_bit∨_"
	 */
	Grammatical restriction "_bit∨_" is <∅, {"_bit∨_"}>;
	
	/**
	 * Make left-associative.
	 * @method "_bit⊕_"
	 * @forbids "2" "_bit⊕_"
	 */
	Grammatical restriction "_bit⊕_" is <∅, {"_bit⊕_"}>;
]();

/* These messages describe arithmetic failure (integers only). */
cannotAddMessage ::= "terms not to be unlike infinities";
cannotSubtractMessage ::= "terms not to be like infinities";
cannotMultiplyMessage ::= "terms not be 0 and ±∞";
cannotDivideByZeroMessage ::= "denominator not to be 0";
cannotDivideTwoInfinitiesMessage ::=
	"either numerator or denominator to be finite";

Semantic restriction "_mod_" is type promotion function for
[
	a : number,
	b : number
|
	If b = 0 ∧ [ a ∈ extended integer ] then
	[
		Reject parse, expected: cannotDivideByZeroMessage
	];
	infinities ::= {∞, -∞};
	If a ∈ infinities ∧ [ b ∈ infinities ] then
	[
		Reject parse, expected: cannotDivideTwoInfinitiesMessage
	];
	a mod b
];

/**
 * Negate the argument. Avail's system dialect has no negative numeric literals,
 * but the associated semantic restriction effectively overcomes this limitation
 * (for literal arguments).
 * 
 * @method "-_"
 * @param "a" "number"
 *        A number.
 * @returns "number"
 *          The negation of the argument.
 * @category "Mathematics" "Numbers"
 */
Method "-_" is
[
	a : number
|
	0 - a
];

/**
 * Compute and answer the strongest possible type of the argument. In
 * particular, an instance type will result in a precise answer that has the
 * same force as a literal.
 * 
 * @method "-_"
 * @restricts "number's type"
 */
Semantic restriction "-_" is
[
	a : number's type
|
	if a ⊆ extended integer then
	[
	 	extended integer
	]
	else
	[
		if a ⊆ double then
		[
			double
		]
		else
		[
			if a ⊆ float then
			[
				float
			]
			else
			[
				number
			]
		]
	]
];

/**
 * Compute and answer the floor of the argument.
 * 
 * @method "⎣_⎦"
 * @param "value" "number"
 * @returns "extended integer"
 *          The floor of the argument.
 * @category "Mathematics" "Numbers"
 */
Stable abstract method "⎣_⎦" is [number]→number;

Method "⎣_⎦" is
[
	value : extended integer
|
	value
] : extended integer;

/**
 * Integers and infinities are their own floors.
 *
 * @method "⎣_⎦"
 * @restricts "extended integer's type"
 */
Semantic restriction "⎣_⎦" is
[
	valueType : extended integer's type
|
	valueType
];

/**
 * Compute and answer the ceiling of the argument.
 * 
 * @method "⎡_⎤"
 * @param "value" "number"
 * @returns "extended integer"
 *          The ceiling of the argument.
 * @category "Mathematics" "Numbers"
 */
Stable abstract method "⎡_⎤" is [number]→number;

Method "⎡_⎤" is
[
	value : extended integer
|
	value
] : extended integer;

/**
 * Integers and infinities are their own ceilings.
 *
 * @method "⎡_⎤"
 * @restricts "extended integer's type"
 */
Semantic restriction "⎡_⎤" is
[
	valueType : extended integer's type
|
	valueType
];

/**
 * Compute and answer the remainder after dividing {@param "dividend"} by 
 * {@param "divisor"}.
 * 
 * @method "_mod_"
 * @param "dividend" "number"
 * @param "divisor" "number"
 * @returns "number"
 *          The remainder.
 * @category "Mathematics" "Numbers"
 */
Method "_mod_" is
[
	dividend : number,
	divisor : number
|
	dividend - divisor × ⎣dividend ÷ divisor⎦
] : number;

Method "_mod_" is
[
	dividend : extended integer,
	divisor : ∞'s type
|
	dividend
] : extended integer;

/**
 * Is the argument odd?
 * 
 * @method "_is odd"
 * @param "a" "integer"
 * @returns "boolean"
 *          {@method "true"} if the argument is odd, {@method "false"}
 *          otherwise.
 * @category "Mathematics" "Integers"
 */
Public stable method "_is odd" is
[
	a : integer
|
	a mod 2 = 1
] : boolean;

/**
 * Is the argument even?
 * 
 * @method "_is even"
 * @param "a" "integer"
 * @returns "boolean"
 *          {@method "true"} if the argument is even, {@method "false"}
 *          otherwise.
 * @category "Mathematics" "Integers"
 */
Public stable method "_is even" is
[
	a : integer
|
	a mod 2 = 0
];

/**
 * Compute and answer the integer range type of the sum of the argument types.
 * 
 * @method "_+_"
 * @param "a" "extended integer's type"
 * @param "b" "extended integer's type"
 * @returns "extended integer's type"
 *          The narrowest integer range type general enough to hold all possible
 *          sums of the arguments' instances.
 * @category "Mathematics" "Integers" "Types"
 */
Method "_+_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	lower ::= ⎣a⎦ + ⎣b⎦ - 1;
	lowerInclusive ::=
		(⎣a⎦ is inclusive ∧ [⎣a⎦ is infinite])
		∨ [⎣b⎦ is inclusive ∧ [⎣b⎦ is infinite]];
	upper ::= ⎡a⎤ + ⎡b⎤ + 1;
	upperInclusive ::=
		(⎡a⎤ is inclusive ∧ [⎡a⎤ is infinite])
		∨ [⎡b⎤ is inclusive ∧ [⎡b⎤ is infinite]];
	integer range
		from lower (inclusive=lowerInclusive)
		to upper (inclusive=upperInclusive)
];

/**
 * Compute and answer the integer range type of the product of the argument
 * types.
 * 
 * @method "_×_"
 * @param "a" "extended integer's type"
 * @param "b" "extended integer's type"
 * @returns "extended integer's type"
 *          The narrowest integer range type general enough to hold all possible
 *          products of the arguments' instances.
 * @category "Mathematics" "Integers" "Types"
 */
Method "_×_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	bounds ::=
	{
		{⎣a⎦, ⎡a⎤},
		{⎣b⎦, ⎡b⎤}
	};
	If bounds = {{0}, {∞}} ∨ [ bounds = {{0}, {-∞}} ] then
	[
		Reject parse, expected: cannotMultiplyMessage
	]
	else
	[
		negativeA : extended integer's type := a ∩ [-∞..-1];
		negativeB : extended integer's type := b ∩ [-∞..-1];
		positiveA : extended integer's type := a ∩ [1..∞];
		positiveB : extended integer's type := b ∩ [1..∞];
		result : extended integer's type := ⊥;
		If positiveA ≠ ⊥ then
		[
			If positiveB ≠ ⊥ then
			[
				lower ::= ⎣positiveA⎦ × ⎣positiveB⎦;
				upper ::= ⎡positiveA⎤ × ⎡positiveB⎤;
				isInfinite ::= ∞ ∈ positiveA ∨ [∞ ∈ positiveB];
				range ::= integer range
					from lower (inclusive=true)
					to upper + 1 (inclusive=isInfinite);
				result := eject ↑result ∪ range;
			];
			If negativeB ≠ ⊥ then
			[
				lower ::= ⎡positiveA⎤ × ⎣negativeB⎦;
				isInfinite ::= ∞ ∈ positiveA ∨ [-∞ ∈ negativeB];
				upper ::= ⎣positiveA⎦ × ⎡negativeB⎤;
				range ::= integer range
					from lower - 1 (inclusive=isInfinite)
					to upper (inclusive=true);
				result := eject ↑result ∪ range;
			];
		];
		If negativeA ≠ ⊥ then
		[
			If positiveB ≠ ⊥ then
			[
				lower ::= ⎣negativeA⎦ × ⎡positiveB⎤;
				isInfinite ::= -∞ ∈ negativeA ∨ [∞ ∈ positiveB];
				upper ::= ⎡negativeA⎤ × ⎣positiveB⎦;
				range ::= integer range
					from lower - 1 (inclusive=isInfinite)
					to upper (inclusive=true);
				result := eject ↑result ∪ range;
			];
			If negativeB ≠ ⊥ then
			[
				lower ::= ⎡negativeA⎤ × ⎡negativeB⎤;
				upper ::= ⎣negativeA⎦ × ⎣negativeB⎦;
				isInfinite ::= -∞ ∈ negativeA ∨ [-∞ ∈ negativeB];
				range ::= integer range
					from lower (inclusive=true)
					to upper + 1 (inclusive=isInfinite);
				result := eject ↑result ∪ range;
			];
		];
		/* Zero is handled specially, to prevent multiplication of 0 and ±∞ by
		 * one of the preceding clauses.
		 */
		If 0's type ⊆ a ∨ [ 0's type ⊆ b ] then
		[
			result := eject ↑result ∪ 0's type;
		];
		result
	]
];

/**
 * Compute and answer the negation of the specified integral type.
 * 
 * @method "-_"
 * @param "a" "extended integer's type"
 * @returns "extended integer's type"
 *          The negation of the argument, e.g., the negation of {@code "[3..5]"}
 *          is {@code "[-5..-3]"}.
 * @category "Mathematics" "Integers" "Types"
 */
Public method "-_" is
[
	a : extended integer's type
|
	a × -1's type
];

/**
 * Strengthen negation.
 * 
 * @method "-_"
 * @restricts "extended integer's type"
 */
Semantic restriction "-_" is
[
	a : extended integer's type
|
	-a
];

/**
 * Compute and answer the integer range type of the difference of the argument
 * types.
 * 
 * @method "_-_"
 * @param "a" "extended integer's type"
 * @param "b" "extended integer's type"
 * @returns "extended integer's type"
 *          The narrowest integer range type general enough to hold all possible
 *          differences of the arguments' instances.
 * @category "Mathematics" "Integers" "Types"
 */
Method "_-_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	a + (- b)
];

/**
 * Compute and answer the integer range type of the sum of the argument types.
 * 
 * @method "_+_"
 * @restricts "extended integer's type"
 * @restricts "extended integer's type"
 */
Semantic restriction "_+_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	bounds ::=
	{
		{⎣a⎦, ⎡a⎤},
		{⎣b⎦, ⎡b⎤}
	};
	If bounds = {{-∞}, {∞}} then
	[
		Reject parse, expected: cannotAddMessage
	];
	a + b
];

/**
 * Compute and answer the integer range type of the difference of the argument
 * types.
 * 
 * @method "_-_"
 * @restricts "extended integer's type"
 * @restricts "extended integer's type"
 */
Semantic restriction "_-_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	negated ::= - b;
	bounds ::=
	{
		{⎣a⎦, ⎡a⎤},
		{⎣negated⎦, ⎡negated⎤}
	};
	If bounds = {{-∞}, {∞}} then
	[
		Reject parse, expected: cannotSubtractMessage
	];
	a + negated
];

/**
 * Compute and answer the integer range type of the product of the argument
 * types.
 * 
 * @method "_×_"
 * @restricts "extended integer's type"
 * @restricts "extended integer's type"
 */
Semantic restriction "_×_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	a × b
];

/**
 * Compute and answer the integer range type of the quotient.
 * 
 * @method "_÷_"
 * @param "numeratorRange" "extended integer's type"
 * @param "denominator" "extended integer"
 * @returns "extended integer's type"
 *          The narrowest integer range type general enough to hold all possible
 *          quotients of {@param "numeratorRange"}'s instances and {@param
 *          "denominator"}.
 * @category "Mathematics" "Integers" "Types"
 */
Method "_÷_" is
[
	numeratorRange : extended integer's type,
	denominator : extended integer
|
	/* Produce ⊥ if the numerator range is ⊥ or the denominator is 0. */
	if numeratorRange = ⊥ ∨ [ denominator = 0 ] then
	[
		⊥
	]
	else
	[
		/* ±∞ divided by any finite nonzero value is 0. */
		if denominator is infinite then
		[
			0's type
		]
		else
		[
			/* The denominator is finite and nonzero. The numerator may be
			 * either finite or infinite. The following handles all cases.
			 */
			numeratorMin ::= ⎣numeratorRange⎦ ÷ denominator;
			lowerInclusive ::= ⎣numeratorRange⎦ is inclusive;
			numeratorMax ::= ⎡numeratorRange⎤ ÷ denominator;
			upperInclusive ::= ⎡numeratorRange⎤ is inclusive;
			if denominator < 0 then
			[
				integer range
					from numeratorMax (inclusive=upperInclusive)
					to numeratorMin (inclusive=lowerInclusive)
			]
			else
			[
				integer range
					from numeratorMin (inclusive=lowerInclusive)
					to numeratorMax (inclusive=upperInclusive)
			]
		]
	]
];

/**
 * Compute and answer the integer range type of the quotient.
 * 
 * @method "_÷_"
 * @param "numeratorRange" "extended integer's type"
 * @param "denominator" "extended integer's type"
 * @returns "extended integer's type"
 *          The narrowest integer range type general enough to hold all possible
 *          quotients of `numeratorRange`'s instances and `denominator`.
 * @category "Mathematics" "Integers" "Types"
 */
Method "_÷_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	denominatorSet ::= {⎣b⎦, ⎡b⎤};
	If denominatorSet = {0} then
	[
		Reject parse, expected: cannotDivideByZeroMessage
	];
	numeratorSet ::= {⎣a⎦, ⎡a⎤};
	infinities ::= {{∞}, {-∞}};
	If numeratorSet ∈ infinities ∧ [ denominatorSet ∈ infinities ] then
	[
		Reject parse, expected: cannotDivideTwoInfinitiesMessage
	];
	union : extended integer's type := ⊥;
	negativeDenominators ::= b ∩ [-∞..-1];
	If negativeDenominators ≠ ⊥ then
	[
		union :=
			eject ↑union ∪ (a ÷ negativeDenominators' genuine lower bound);
		union :=
			eject ↑union ∪ (a ÷ negativeDenominators' genuine upper bound);
	];
	positiveDenominators ::= b ∩ [1..∞];
	If positiveDenominators ≠ ⊥ then
	[
		union :=
			eject ↑union ∪ (a ÷ positiveDenominators' genuine lower bound);
		union :=
			eject ↑union ∪ (a ÷ positiveDenominators' genuine upper bound);
	];
	union
];

/**
 * Compute and answer the integer range type of the quotient of the argument
 * types.
 * 
 * @method "_÷_"
 * @restricts "extended integer's type"
 * @restricts "extended integer's type"
 */
Semantic restriction "_÷_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	a ÷ b
];

/**
 * Compute and answer the integer range type of the remainder of the argument
 * types.
 * 
 * @method "_mod_"
 * @restricts "extended integer's type"
 * @restricts "extended integer's type"
 */
Semantic restriction "_mod_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	denominatorSet ::= {⎣b⎦, ⎡b⎤};
	If denominatorSet = {0} then
	[
		Reject parse, expected: cannotDivideByZeroMessage
	];
	numeratorSet ::= {⎣a⎦, ⎡a⎤};
	infinities ::= {{∞}, {-∞}};
	If numeratorSet ∈ infinities ∧ [ denominatorSet ∈ infinities ] then
	[
		Reject parse, expected: cannotDivideTwoInfinitiesMessage
	];
	if ⎣b⎦ = ⎡b⎤
		∧ [ ⎣a⎦ is finite
		∧ [ ⎡a⎤ is finite
		∧ [ ⎣a⎦ ÷ ⎣b⎦ = ⎡a⎤ ÷ ⎣b⎦ ] ] ]
	then
	[
		[⎣a⎦ mod ⎣b⎦ .. ⎡a⎤ mod ⎣b⎦]
	]
	else
	[
		[0..⎡b⎤)
	]
];

/**
 * Disambiguate {@method "_→_"} and several conversion operations.
 * 
 * @method "_→_"
 * @forbids "1" "double" "extended integer" "float"
 */
Grammatical restriction "_→_" is <∅, {"double", "extended integer", "float"}>;

/**
 * Compute and answer the absolute value of the argument.
 * 
 * @method "`|_`|"
 * @param "a" "number"
 * @returns "number"
 *          The absolute value of the argument.
 * @category "Mathematics" "Numbers"
 */
Stable method "`|_`|" is
[
	a : number
|
	if a < 0 then [ -a ] else [ a ]
] : number;

/**
 * Preserve the numeric type of the argument.
 * 
 * @method "`|_`|"
 * @restricts "double's type"
 */
Semantic restriction "`|_`|" is
[
	a : double's type
|
	a
];

/**
 * Preserve the numeric type of the argument.
 * 
 * @method "`|_`|"
 * @restricts "float's type"
 */
Semantic restriction "`|_`|" is
[
	a : float's type
|
	a
];

/**
 * Strengthen the absolute value operation for integral types.
 * 
 * @method "`|_`|"
 * @restricts "extended integer's type"
 */
Semantic restriction "`|_`|" is
[
	a : extended integer's type
|
	([0..∞] ∩ a) ∪ ([0..∞] ∩ -a)
];

/**
 * Catch accidental use of absolute value on expressions that are strictly
 * non-negative.
 *
 * @method "`|_`|"
 * @restricts "extended integer's type"
 */
Semantic restriction "`|_`|" is
[
	a : extended integer's type
|
	If a ∩ [0..∞] = a then
	[
		Reject parse, expected:
			"argument of absolute value (\"`|_`|\") to be potentially negative."
	];
	⊤
];

/* This table of functions is used by the inequality operations. */
predicates ::=
<
	[ a : number, b : number | a < b ],
	[ a : number, b : number | a ≤ b ],
	[ a : number, b : number | a = b ],
	[ a : number, b : number | a ≥ b ],
	[ a : number, b : number | a > b ]
>;

/**
 * Compute and answer the boolean value of the sequence of equals, less than or
 * equal, and less than operators.
 * 
 * @method "«_‡«=|≤|<»!»"
 * @param "args" "<<number, [1..3]…|1..2>…|3..∞>"
 *        A tuple whose elements are a sequence of 2-tuples following by an
 *        ending 1-tuple. The first element of these 1,2-tuples is a number.
 *        If present, the second element will be an integer in the range {@code
 *        "[1..3]"} to indicate {@code "="}, {@code "≤"}, or {@code "<"},
 *        respectively, as the comparison to be checked with the next number.
 * @returns "boolean"
 *          {@method "true"} if the entire chain of comparisons is true,
 *          {@method "false"} otherwise.
 * @category "Mathematics" "Relations" "Numbers"
 */
Public method "«_‡«=|≤|<»!»" is
[
	args : <<number, [1..3]…|1..2>…|3..∞>
|
	result : boolean := true;
	From 1 to |args| - 1 do
	[
		index : natural number
	|
		arg ::= args[index];
		Assert: |arg| = 2 ("args ≠ <aNumber, comparisonOperatorSubscript>");
		/* Determine which predicate to apply. */
		predicate ::= predicates[4 - arg[2]];
		if predicate(arg[1], args[index + 1][1]) then
		[
			true
		]
		else
		[
			result := false;
			false
		]
	];
	result
];

/**
 * Note that this accepts a very broad type of argument (so it's applicable for
 * non-numeric uses of this selector), but a very specific numbered choice of
 * operator (i.e., only {@code "="}).  It always rejects the parse if it's just
 * a chain of equalities, since there's a separate operator for that which can
 * deal with non-numerics.
 * 
 * @method "comparison chain semantic restriction function"
 * @param "args" "<<any, [1..1]…|1..2>…|3..∞>'s type"
 * 
 */
Private method "comparison chain semantic restriction function" is
[
	[
		args : <<any, [1..1]…|1..2>…|3..∞>'s type
	|
		Reject parse, expected:
			"inequality chain to include at least one inequality"
	]
];

/**
 * @method "«_‡«=|≤|<»!»"
 * @restricts "<<any, [1..1]…|1..2>…|3..∞>'s type"
 */
Semantic restriction "«_‡«=|≤|<»!»" is
	comparison chain semantic restriction function;

/**
 * Compute and answer the boolean value of the sequence of equals, greater than
 * or equal, and greater than operators.
 * 
 * @method "«_‡«=|≥|>»!»"
 * @param "args" "<<number, [1..3]…|1..2>…|3..∞>"
 *        A tuple whose elements are a sequence of 4-tuples following by an
 *        ending 1-tuple. The first element of these 1,4-tuples is a number.
 *        If present, the second element will be a boolean that indicates that
 *        this number should be checked for equality with the next number. If
 *        present, the third element will be a boolean that indicates that this
 *        number should be compared against the next number to see if it is
 *        greater than or equal. If present, the fourth element will be a boolean
 *        that indicates this this number should be compared against the next
 *        number to see if it is strictly greater.
 * @returns "boolean"
 *          {@method "true"} if the entire chain of comparisons is true,
 *          {@method "false"} otherwise.
 * @category "Mathematics" "Relations" "Numbers"
 */
Public method "«_‡«=|≥|>»!»" is
[
	args : <<number, [1..3]…|1..2>…|3..∞>
|
	result : boolean := true;
	From 1 to |args| - 1 do
	[
		index : natural number
	|
		arg ::= args[index];
		Assert: |arg| = 2 ("args ≠ <aNumber, comparisonOperatorSubscript>");
		/* Determine which predicate to apply. */
		predicate ::= predicates[2 + arg[2]];
		if predicate(arg[1], args[index + 1][1]) then
		[
			true
		]
		else
		[
			result := false;
			false
		]
	];
	result
];

/**
 * @method "«_‡«=|≥|>»!»"
 * @restricts "<<any, [1..1]…|1..2>…|3..∞>'s type"
 */
Semantic restriction "«_‡«=|≥|>»!»" is
	comparison chain semantic restriction function;

/**
 * Calculate the logarithm of the specified number to the specified base.
 * 
 * @method "log_of_"
 * @param "b" "float"
 *        The logarithm base to use.
 * @param "n" "float"
 *        The number whose logarithm should be computed.
 * @returns "float"
 *          The logarithm of {@param "n"} to base {@param "b"}.
 * @category "Mathematics" "Numbers"
 */
Public stable method "log_of_" is
[
	b : float,
	n : float
|
	if b ≤ 0.0→float then
	[
		early failure function(
			cannot-compute-logarithm-for-nonpositive-base code)
	]
	else
	[
		if n ≤ 0.0→float then
		[
			early failure function(
				cannot-compute-logarithm-of-nonpositive-number code)
		]
		else
		[
			(ln n) ÷ (ln b)
		]
	]
] : float;

/**
 * Calculate the logarithm of the specified number to the specified base.
 * 
 * @method "log_of_"
 * @param "b" "double"
 *        The logarithm base to use.
 * @param "n" "double"
 *        The number whose logarithm should be computed.
 * @returns "double"
 *          The logarithm of {@param "n"} to base {@param "b"}.
 * @category "Mathematics" "Numbers"
 */
Stable method "log_of_" is
[
	b : double,
	n : double
|
	if b ≤ 0.0 then
	[
		early failure function(
			cannot-compute-logarithm-for-nonpositive-base code)
	]
	else
	[
		if n ≤ 0.0 then
		[
			early failure function(
				cannot-compute-logarithm-of-nonpositive-number code)
		]
		else
		[
			(ln n) ÷ (ln b)
		]
	]
] : double;

/**
 * Answer an approximation of π, the ratio of the circumference of a circle to
 * its diameter.
 *
 * @method "π"
 * @returns "3.141592653589793's type"
 *          {@code "3.141592653589793"}.
 * @category "Mathematics" "Constants" "Numbers"
 */
Public method "π" is [3.141592653589793];

/**
 * Strengthen the result type of bitshift.
 *
 * @method "_<<_"
 * @restricts "baseIntegerType" "integer's type"
 * @restricts "shiftFactorType" "integer's type"
 */
Semantic restriction "_<<_" is
[
	baseIntegerType : integer's type,
	shiftFactorType : integer's type
|
	low : extended integer := ∞;
	high : extended integer := -∞;
	innerBlock ::= [base : extended integer, shift : extended integer |
		shifted ::= cast base into
			[
				baseInteger : integer
			|
				cast shift into
				[
					shiftInteger : integer
				|
					/* Finite case. */
					baseInteger << shiftInteger
				]
				else
				[
					/* Arbitrarily large shift. */
					if shift = ∞ then
					[
						/* Arbitrarily large left shift. */
						if baseInteger > 0 then [∞]
						else
						[
							if baseInteger < 0 then [-∞] else [0]
						]
					]
					else
					[
						/* Arbitrarily large right shift. */
						if baseInteger ≥ 0 then [0] else [-1]
					]
				]
			]
			else
			[
				/* Arbitrarily large (±) number to shift. */
				cast shift into
				[
					shiftInteger : integer
				|
					/* Arbitrarily large number shifted finitely. */
					base
				]
				else
				[
					/* Both the base and the shift are arbitrarily large. */
					if shift = ∞ then
					[
						base
					]
					else
					[
						if base = ∞ then [0] else [-1]
					]
				]
			];
		low := low min shifted;
		high := high max shifted;
	];
	/* Feed the block some characteristic values to compute the extrema. */
	outerBlock ::= [
		base : extended integer
	|
		If 0 ∈ shiftFactorType then [innerBlock(base, 0);];
		If -1 ∈ shiftFactorType then [innerBlock(base, -1);];
		If 1 ∈ shiftFactorType then [innerBlock(base, 1);];
		innerBlock(base, ⎣shiftFactorType⎦);
		innerBlock(base, ⎡shiftFactorType⎤);
	];

	If 0 ∈ baseIntegerType then [outerBlock(0);];
	If -1 ∈ baseIntegerType then [outerBlock(-1);];
	If 1 ∈ baseIntegerType then [outerBlock(1);];
	outerBlock(⎣baseIntegerType⎦);
	outerBlock(⎡baseIntegerType⎤);
	(low - 1 .. high + 1)
] : integer's type;

Private forward method "_positive range pairs"
	is [whole number's type] → <whole number's type…|0..∞>;

/**
 * Compute the ranges as for "_range pairs" (below), but with the knowledge that
 * the range is whole number or a subtype.
 * 
 * @method "_positive range pairs"
 * @param "range" "whole number's type"
 * @returns "<whole number's type…|0..∞>"
 */
Private method "_positive range pairs" is
[
	range : whole number's type
|
	$outer : <whole number's type…|0..∞>;
	If range = ⊥ then
	[
		Exit outer with <>
	];
	/* Find the biggest string of rightmost one-bits that can be added to
	 * low without causing any internal carry and without exceeding the
	 * range.
	 */
	lowBits : integer;
	low ::= ⎣range⎦;
	Cast ⎡range⎤ into
	[
		high : [1..∞)
	|
		If low = 0 then
		[
			/* Range is [0..n]. */
			lowBits := high;
			[
				$here;
				If lowBits bit∧ (lowBits + 1) ≠ 0 then
				[
					/* Not yet of the form 2^n-1 */
					lowBits := lowBits bit∨ (lowBits << -1);
					Restart here
				];
			]();
		]
		else
		[
			lowBits := (-1 - low) bit∧ (low - 1);
		];
	]
	else
	[
		If ⎡range⎤ = 0 then
		[
			Assert: range = [0..0];
			Exit outer with <range>
		];
		Assert: ⎡range⎤ = ∞;
		If low = 0 then
		[
			Assert: range = [0..∞);
			Exit outer with <range>
		];
		/* Find the next higher power of two. */
		boundary : integer := low;
		[
			$here;
			If boundary bit∧ (boundary + 1) ≠ 0 then
			[
				boundary := boundary bit∨ (boundary << -1);
				Restart here
			];
		]();
		Exit outer with
			[low .. boundary] positive range pairs
				++ <[boundary + 1..∞)>
	];
	strongLowBits : whole number :=
		cast lowBits into [x : whole number | x];
	[
		$loop : <whole number's type…|0..∞>;
		subrangeEnd ::= low + strongLowBits;
		If subrangeEnd ∈ range then
		[
			Exit outer with
				<[low .. low + strongLowBits]>
				++ (low + strongLowBits .. ⎡range⎤ + 1)
					positive range pairs
		];
		Assert: strongLowBits ≠ 0;
		strongLowBits := strongLowBits << -1;
		Restart loop
	] : <whole number's type…|0..∞> ()
] : <whole number's type…|0..∞>;

/**
 * Decompose an integer type into a tuple of contiguous smaller integer types.
 * When the lower and upper bounds of a subrange are each finite, they must have
 * the form a*2^b and a*2^b + 2^b-1.  The lower bound ensures the bottom b bits
 * are zero, and the upper bound is the same but with the bottom b bits all one.
 * The low and high values may be the same, indicating a range consisting of a
 * single value.
 *
 * In the special case that the upper end of the subrange is {@code "∞"}, the
 * lower end must be a non-negative power of two.  In the case that the lower
 * end is {@code "-∞"}, the upper end must be one less than the negation of a
 * power of two.
 * 
 * Produce the minimum number of such ranges.
 * 
 * @method "_range pairs"
 * @param "range" "integer's type"
 * @returns "<extended integer's type…|0..∞>"
 */
Private method "_range pairs" is
[
	range : integer's type
|
	rangeKind ::= (⎣range⎦ - 1 .. ⎡range⎤ + 1);
	pairs : <integer's type…|> := <>;
	complementOfNegative ::= ((-1)'s type - rangeKind) ∩ [0..∞);
	subranges ::= complementOfNegative positive range pairs;
	From 1 to |subranges| do
	[
		n : natural number
	|
		subcomplement ::= Cast (-1)'s type - subranges[n]
			into [x : integer's type | x];
		pairs := <subcomplement> ++ pairs;
		true
	];
	positiveRegion ::= rangeKind ∩ [0..∞);
	pairs := pairs ++ positiveRegion positive range pairs;
	pairs
] : <extended integer's type…|0..∞>;

/**
 * Strengthen bitwise-and operation.
 * 
 * @method "_bit∧_"
 * @restricts "integer's type"
 * @restricts "integer's type"
 */
Semantic restriction "_bit∧_" is
[
	arg1 : integer's type,
	arg2 : integer's type
|
	values : {extended integer|0..∞} := ∅;
	include ::=
	[
		x : extended integer,
		y : extended integer
	|
		$includeLabel : ⊤;
		exit ::= [
			moreValues : {extended integer|0..∞}
		|
			values := values ∪ moreValues;
			Exit includeLabel with 123
		];
		If x = ∞ then
		[
			If y ≥ 0 then
			[
				/* For some finite positive y, there exists a large positive
				 * number (implied by x) that has enough low zero bits to
				 * produce zero.  Similarly, there is a large positive number
				 * which is able to preserve all of y's bits.  Finally, when
				 * y is also arbitrarily large it can conspire with x to
				 * produce any whole number.
				 */
				exit({0, y})
			];
			/* Arbitrarily large positive integers can mask a negative
			 * number to ensure arbitrarily large positive integers are
			 * possible.  Other limits will determine how low a (positive)
			 * value can be produced.
			 */
			exit({x})
		];
		If x = -∞ then
		[
			If y ≥ 0 then
			[
				/* An arbitrarily large magnitude negative x can preserve any
				 * positive y.  It could also knock it down to zero.
				 */
				exit({0, y})
			];
			/* An arbitrarily large magnitude negative x can preserve any
			 * bits of y, but it can also zero any finite combination of
			 * bits, keeping it negative.
			 */
			exit({x, y})
		];
		If x ≥ 0 then
		[
			/* A particular finite positive x. */
			If y ∈ {∞, -∞} then
			[
				exit({0, x})
			];
			Cast x into
			[
				xi : integer
			|
				Cast y into
				[
					yi : integer
				|
					exit({xi bit∧ yi})
				]
			]
		];
		/* A particular finite negative x. */
		If y = ∞ then
		[
			exit({y})
		];
		If y = -∞ then
		[
			exit({x, y})
		];
		Cast x into
		[
			xi : integer
		|
			Cast y into
			[
				yi : integer
			|
				exit({xi bit∧ yi})
			]
		]
	] : ⊤;
	arg1Ranges ::= arg1 range pairs;
	arg2Ranges ::= arg2 range pairs;
	From 1 to |arg1Ranges| do
	[
		i1 : natural number
	|
		subrange1 ::= arg1Ranges[i1];
		From 1 to |arg2Ranges| do
		[
			i2 : natural number
		|
			subrange2 ::= arg2Ranges[i2];
			include(⎣subrange1⎦, ⎣subrange2⎦);
			include(⎣subrange1⎦, ⎡subrange2⎤);
			include(⎡subrange1⎤, ⎣subrange2⎦);
			include(⎡subrange1⎤, ⎡subrange2⎤);
			true
		];
		true
	];
	contentType ::= values' type's element type;
	(⎣contentType⎦ - 1 .. ⎡contentType⎤ + 1)
] : integer's type;

/**
 * Strengthen the result type of bounded bitshift, primarily based on the
 * truncation bit count.

 * Given a positive integer B, a shift factor S, and a truncation bit count T,
 * shift B to the left by S bits (treating a negative factor as a right shift),
 * then truncate the result to the bottom T bits by zeroing the rest.
 *
 * @method "_<<_keeping_bits"
 * @restricts "whole number's type"
 * @restricts "integer's type"
 * @restricts "whole number's type"
 */
Semantic restriction "_<<_keeping_bits" is
[
	baseInteger : whole number's type,
	shiftFactor : integer's type,
	truncationBits : whole number's type
|
	high : [0..∞] := ∞;
	If ⎡baseInteger⎤ ≠ ∞ ∧ [ ⎡shiftFactor⎤ ≠ ∞ ] then
	[
		finiteBaseMax : whole number;
		↓↑finiteBaseMax ?= ⎡baseInteger⎤;
		finiteShiftMax : integer;
		↓↑finiteShiftMax ?= ⎡shiftFactor⎤;
		high := finiteBaseMax << finiteShiftMax;
	];
	finiteBaseMin : whole number;
	↓↑finiteBaseMin ?= ⎣baseInteger⎦;
	finiteShiftMin : integer;
	↓↑finiteShiftMin ?= ⎣shiftFactor⎦;
	low : whole number := finiteBaseMin << finiteShiftMin;
	If ⎡truncationBits⎤ ≠ ∞ then
	[
		finiteTruncationMax : whole number;
		↓↑finiteTruncationMax ?= ⎡truncationBits⎤;
		high := high min ((1 << finiteTruncationMax) - 1);
	];
	finiteTruncationMin : whole number;
	↓↑finiteTruncationMin ?= ⎣truncationBits⎦;
	mask : whole number := (1 << finiteTruncationMin) - 1;
	low := low bit∧ mask;
	[low..high+1)
] : whole number's type;

/**
 * {@code "negative integer"} includes every finite {@method "integer"} strictly
 * less than {@code "0"}.
 * 
 * @type "negative integer"
 * @supertype "(-∞..-1]"
 * @category "Mathematics" "Integers" "Types" "Constants"
 */
Public method "negative integer" is [(-∞..-1]];

/**
 * {@code "nonpositive integer"} includes every finite {@method "integer"}
 * strictly less than {@code "1"}.
 * 
 * @type "nonpositive integer"
 * @supertype "(-∞..0]"
 * @category "Mathematics" "Integers" "Types" "Constants"
 */
Public method "nonpositive integer" is [(-∞..0]];
