/*
 * Tuples.avail
 * Copyright © 1993-2014, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Tuples"
Versions
	"dev"
Extends
	"Collections",
	"Early Tuples"
Uses
	"Bootstrap",
	"Control Structures",
	"Definers",
	"Early Assertions",
	"Early Error Codes",
	"Early Functions",
	"Early Maps",
	"Enumeration Support",
	"Literals",
	"Logic",
	"Math",
	"Types",
	"Variables"
Names
	"Require:_accepts_«(check indices)»?",
	"all indices of_in_",
	"all indices of_where_",
	"distinct_",
	"drop from_until_",
	"drop from_while_",
	"drop_from_",
	"first index of_in_",
	"first index of_where_",
	"last index of_where_",
	"left fold_through_",
	"merge sort_",
	"merge sort_with_",
	"quicksort_",
	"quicksort_with_",
	"replace all occurrences of_in_with_",
	"replace the first occurrence of_in_with_",
	"right fold_through_",
	"split_after_",
	"split_before_",
	"stripe_at_",
	"take from_until_",
	"take from_while_",
	"take_from_",
	"zip_",
	"∑_",
	"∏_",
	"_ends with_",
	"_occurrences⁇of_",
	"_starts with_",
	"_to_",
	"_'s⁇head",
	"_'s⁇last",
	"_'s⁇tail",
	"_[_.._]else_",
	"_[_..]else_",
	"_[.._]else_",
	"_[_.._]→_",
	"_[_↔_]",
	"«_‡zip»"
Body

/**
 * @method "“_”"
 * @param "t" "tuple meta"
 * @returns "string"
 * @category "Tuples" "Stringification"
 */
Method "“_”" is
[
	t : tuple meta
|
	if |t| < ∞ then [primitive description of t] 
	else 
	[
		s : nonempty string := "<";
		leadingTypes ::= t's leading types;
		index : natural number := 1;
		While [index ≤ |leadingTypes|]
		do [s := eject ↑s ++ “leadingTypes[(↑index++)]” ++ ", ";];
		s := eject ↑s ++ “t's default type” ++ "…|";
		lower ::= ⎣t⎦;
		upper ::= ⎡t⎤;
		s := eject ↑s ++ “||t||” (cardinality restriction);
		s := eject ↑s ++ ">";
		s
	]
] : string;

/**
 * Is the specified {@param "tuple"} empty?
 * 
 * @method "_is empty"
 * @param "aTuple" "tuple"
 * @returns "boolean"
 *          {@method "true"} if the argument is empty, {@method "false"} 
 *          otherwise.
 * @category "Tuples" "Queries" "Collections"
 */
Stable method "_is empty" is
[
	aTuple : tuple
|
	|aTuple| = 0
] : boolean;

/**
 * Iteratively apply `action` to each consecutive element of `aTuple`.
 * 
 * @method "For each of⁇_do_"
 * @param "aTuple" "tuple"
 * @param "action" "[⊥]→⊤"
 *        A function that accepts the elements of the tuple.
 * @returns "⊤"
 * @category "Tuples" "Collections" "Control Structures"
 */
Method "For each of⁇_do_" is
[
	aTuple : tuple,
	action : [⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			action(aTuple[index]);
			↑index++;
			Restart loop
		];
	]();
] : ⊤;

/**
 * Iteratively apply `action` to each consecutive element of `aTuple`.
 * 
 * @method "For each of⁇_do_"
 * @param "aTuple" "tuple"
 * @param "action" "[⊥, ⊥]→⊤"
 *        A function that accepts 1) an element of the tuple and 2) the index of
 *        that element.
 * @returns "⊤"
 * @category "Tuples" "Collections" "Control Structures"
 */
Method "For each of⁇_do_" is
[
	aTuple : tuple,
	action : [⊥, ⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			action(aTuple[index], index);
			↑index++;
			Restart loop
		];
	]();
] : ⊤;

/**
 * Helper method for semantic restrictions: If {@param "action"} does not accept 
 * the type union of all element types of {@param "tupleType"} and their
 * indices, then reject the current parse.
 * 
 * @method "Require:_accepts_«(check indices)»?"
 * @param "action" "function meta"
 *        A function type whose first parameter must correspond to the type
 *        union of the element types of {@param "tupleType"} and whose second 
 *        parameter, if provided, must correspond to their indices.
 * @param "tupleType" "tuple meta"
 *        A tuple type.
 * @returns "⊤"
 * @category "Tuples" "Collections" "Types" "Assertions"
 */
Method "Require:_accepts_«(check indices)»?" is
[
	action : function meta,
	tupleType : tuple meta,
	checkIndices : boolean
|
	If ⎣action's parameters' type⎦ < 1 then
	[
		Reject parse, expected:
			"repeatedly applied function to accept at least one argument"
	];
	union ::= ∪ tupleType[1..|tupleType's leading types| + 1];
	If action[1] ≠ ⊥ ∧ [¬union ⊆ action[1]] then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all elements of the tuple ⊆ "
			++ “tupleType”
			++ " (but it only accepts "
			++ “action[1]”
			++ ")"
	];
	If checkIndices
		∧ [⎣action's parameters' type⎦ ≥ 2
		∧ [action[2] ≠ ⊥
		∧ [¬[1..⎡tupleType⎤ + 1) ⊆ action[2]]]]
	then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all indices of the tuple ⊆ "
			++ “tupleType”
			++ " (but it only accepts "
			++ “action[2]”
			++ ")"
	];
] : ⊤;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * If the tuple is certainly nonempty and the function certainly does not
 * complete if applied, then answer ⊥.
 * 
 * @method "For each of⁇_do_"
 * @restricts "tuple meta"
 * @restricts "function meta"
 */
Semantic restriction "For each of⁇_do_" is
[
	tupleType : tuple meta,
	action : function meta
|
	Require: action accepts tupleType;
	if ⎣tupleType⎦ > 0 ∧ [ action's return type = ⊥ ] then [⊥] else [⊤]
];

/**
 * Iteratively apply {@param "transformer"} to each consecutive element of 
 * {@param "aTuple"}, collecting the results into a new tuple (and preserving 
 * ordering of the transformed elements). Answer this tuple.
 * 
 * @method "map_through_"
 * @param "aTuple" "tuple"
 * @param "transformer" "[⊥]→any"
 *        A function that accepts the elements of the tuple.
 * @returns "tuple"
 *          A tuple of results of applications of {@param "transformer"} to the
 *          elements of {@param "aTuple"}.
 * @category "Tuples" "Control Structures" "Collections" "Transformers"
 */
Method "map_through_" is
[
	aTuple : tuple,
	transformer : [⊥]→any
|
	index : natural number := 1;
	result : tuple := <>;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			result := eject ↑result ++ <transformer(aTuple[index])>;
			↑index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Iteratively apply {@param "transformer"} to each consecutive element of 
 * {@param "aTuple"}, collecting the results into a new tuple (and preserving 
 * ordering of the transformed elements). Answer this tuple.
 * 
 * @method "map_through_"
 * @param "aTuple" "tuple"
 * @param "transformer" "[⊥, ⊥]→any"
 *        A function that accepts 1) an element of the tuple and 2) the index of
 *        that element.
 * @returns "tuple"
 *          A tuple of results of applications of {@param "transformer"} to the
 *          elements and indices of {@param "aTuple"}.
 * @category "Tuples" "Control Structures" "Collections" "Transformers"
 */
Method "map_through_" is
[
	aTuple : tuple,
	transformer : [⊥, ⊥]→any
|
	index : natural number := 1;
	result : tuple := <>;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			result := eject ↑result ++ <transformer(aTuple[index], index)>;
			↑index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * If the tuple is certainly nonempty, then the function cannot answer ⊥.
 * 
 * @method "map_through_"
 * @restricts "tuple meta"
 * @restricts "[…]→any's type"
 */
Semantic restriction "map_through_" is
[
	tupleType : tuple meta,
	transformer : […]→any's type
|
	Require: transformer accepts tupleType (check indices);
	If ⎣tupleType⎦ > 0 then
	[
		If transformer's return type = ⊥ then
		[
			Reject parse, expected:
				"repeatedly applied function to have a return type other than\
				\| ⊥"
		];
	];
	<<>, transformer's return type… | ||tupleType||>
];

/**
 * Iteratively apply {@param "predicate"} to each consecutive element of 
 * {@param "aTuple"}, collecting those elements for which {@param "predicate"} 
 * answers {@method "true"} into a new tuple (and preserving ordering). Answer 
 * the new tuple.
 * 
 * @method "filter_by_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥]→boolean"
 *        A function that accepts the elements of the tuple and answers 
 *        {@method "true"} iff they should be accumulated into the output tuple.
 * @returns "tuple"
 *          A tuple containing exactly those elements of {@param "aTuple"} for 
 *          which {@param "predicate"} answered {@method "true"}.
 * @category "Tuples" "Control Structures" "Collections" "Transformers"
 */
Method "filter_by_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop;
		If index ≤ end then
		[
			element ::= aTuple[index];
			If predicate(element) then
			[
				result := eject ↑result ++ <element>;
			];
			↑index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Iteratively apply {@param "predicate"} to each consecutive element and index
 * of {@param "aTuple"}, collecting those elements for which {@param 
 * "predicate"} answers {@method "true"} into a new tuple (and preserving 
 * ordering). Answer the new tuple.
 * 
 * @method "filter_by_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥, ⊥]→boolean"
 *        A function that accepts 1) an element of the tuple and 2) the index of
 *        that element and which answers {@method "true"} iff the elements 
 *        should be accumulated into the output tuple.
 * @returns "tuple"
 *          A tuple containing exactly those elements of {@param "aTuple"} for 
 *          which {@param "predicate"} answered {@method "true"}.
 * @category "Tuples" "Control Structures" "Collections" "Transformers"
 */
Method "filter_by_" is
[
	aTuple : tuple,
	predicate : [⊥, ⊥]→boolean
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop;
		If index ≤ end then
		[
			element ::= aTuple[index];
			If predicate(element, index) then
			[
				result := eject ↑result ++ <element>;
			];
			↑index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * 
 * @method "filter_by_"
 * @restricts "tuple meta"
 * @restricts "[…]→boolean's type"
 */
Semantic restriction "filter_by_" is
[
	tupleType : tuple meta,
	predicate : […]→boolean's type
|
	Require: predicate accepts tupleType (check indices);
	if predicate's return type = true's type then [tupleType]
	else
	[
		union ::= ∪ tupleType[1..|tupleType's leading types| + 1];
		sizes ::=
			if predicate's return type = false's type then [0's type]
			else [[0..⎡tupleType⎤ + 1)];
		<<>, union…|sizes>
	]
];

/**
 * Iteratively apply {@param "accumulator"} to the consecutive elements of 
 * {@param "aTuple"} in order to transform and filter its elements into a new 
 * tuple. When {@param "accumulator"} is invoked, it is passed a "keeper" 
 * function. The keeper function may be invoked to "save" a particular value, 
 * i.e., a value that will be copied into the output tuple. The keeper function 
 * will save at most one value per element of {@param "aTuple"}, i.e., each time 
 * that {@param "accumulator"} is invoked, it may invoke the keeper function at 
 * most one time. Answer the new tuple.
 * 
 * @method "map and filter_by_"
 * @param "aTuple" "tuple"
 * @param "accumulator" "[⊥, ⊥]→⊤"
 *        A function that accepts 1) an element from {@param "aTuple"} and 2) a 
 *        keeper function. The keeper function accepts an argument of the type
 *        that should be saved.
 * @returns "tuple"
 *          A tuple whose elements are those saved by the {@param 
 *          "accumulator"}.
 * @category "Tuples" "Control Structures" "Collections" "Transformers"
 */
Method "map and filter_by_" is
[
	aTuple : tuple,
	accumulator : [⊥, ⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop;
		If index ≤ end then
		[
			hasAlreadyKept : boolean := false;
			accumulator
			(
				aTuple[index],
				[
					transformed : any
				|
					If ¬hasAlreadyKept then
					[
						result := eject ↑result ++ <transformed>;
						hasAlreadyKept := true;
					];
				]
			);
			↑index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Iteratively apply {@param "accumulator"} to the consecutive elements and 
 * indices of {@param "aTuple"} in order to transform and filter its elements 
 * into a new tuple. When {@param "accumulator"} is invoked, it is passed a 
 * "keeper" function. The keeper function may be invoked to "save" a particular 
 * value, i.e., a value that will be copied into the output tuple. The keeper 
 * function will save at most one value per element of {@param "aTuple"}, i.e., 
 * each time that {@param "accumulator"} is invoked, it may invoke the keeper 
 * function at most one time. Answer the new tuple.
 * 
 * @method "map and filter_by_"
 * @param "aTuple" "tuple"
 * @param "accumulator" "[⊥, ⊥, ⊥]→⊤"
 *        A function that accepts 1) an element from {@param "aTuple"}, 2) the 
 *        index of that element, and 3) a keeper function. The keeper function 
 *        accepts an argument of the type that should be saved.
 * @returns "tuple"
 *          A tuple whose elements are those saved by the {@param 
 *          "accumulator"}.
 * @category "Tuples" "Control Structures" "Collections" "Transformers"
 */
Method "map and filter_by_" is
[
	aTuple : tuple,
	accumulator : [⊥, ⊥, ⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop;
		If index ≤ end then
		[
			hasAlreadyKept : boolean := false;
			accumulator
			(
				aTuple[index],
				index,
				[
					transformed : any
				|
					If ¬hasAlreadyKept then
					[
						result := eject ↑result ++ <transformed>;
						hasAlreadyKept := true;
					];
				]
			);
			↑index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Ensure that the function will accept all elements of the tuple and also an
 * appropriately typed keeper function.
 * 
 * @method "map and filter_by_"
 * @restricts "tuple meta"
 * @restricts "[⊥, ⊥]→⊤'s type"
 */
Semantic restriction "map and filter_by_" is
[
	tupleType : tuple meta,
	accumulator : [⊥, ⊥]→⊤'s type
|
	Require: accumulator accepts tupleType;
	Require: accumulator's keeper is valid;
	If accumulator's return type ≠ ⊤ then
	[
		Reject parse, expected:
			"repeatedly applied function to have return type ⊤"
	];
	<
		<>,
		cast accumulator[2] into [ t : function meta | t[1] ]…
		| [0..⎡tupleType⎤ + 1)
	>
];

/**
 * Ensure that the function will accept all elements and indices of the tuple
 * and also an appropriately typed keeper function.
 * 
 * @method "map and filter_by_"
 * @restricts "tuple meta"
 * @restricts "[⊥, ⊥, ⊥]→⊤'s type"
 */
Semantic restriction "map and filter_by_" is
[
	tupleType : tuple meta,
	accumulator : [⊥, ⊥, ⊥]→⊤'s type
|
	Require: accumulator accepts tupleType (check indices);
	Require: accumulator's keeper is valid;
	If accumulator's return type ≠ ⊤ then
	[
		Reject parse, expected:
			"repeatedly applied function to have return type ⊤"
	];
	<
		<>,
		cast accumulator[3] into [ t : function meta | t[1] ]…
		| [0..⎡tupleType⎤ + 1)
	>
];

/**
 * Compute and answer whether any of the elements of {@param "aTuple"} satisfies
 * the specified function. Do not examine more elements than necessary.
 * 
 * @method "any of_satisfies_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥]→boolean"
 *        A function that accepts the elements of the tuple and answers a
 *        boolean.
 * @returns "boolean"
 *          {@method "true"} if {@param "predicate"} answers {@method "true"} 
 *          for any element of {@apram "aTuple"}, {@method "false"} otherwise.
 * @category "Tuples" "Control Structures" "Collections" "Queries"
 */
Method "any of_satisfies_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	$body : boolean;
	For each aTuple do
	[
		element : any
	|
		If predicate(element) then
		[
			Exit body with true
		];
	];
	false
] : boolean;

/**
 * Compute and answer whether any of the elements (and indices) of {@param 
 * "aTuple"} satisfies the specified function. Do not examine more elements than 
 * necessary.
 * 
 * @method "any of_satisfies_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥, ⊥]→boolean"
 *        A function that accepts 1) an element of the tuple and 2) the index of
 *        that element.
 * @returns "boolean"
 *          {@method "true"} if {@param "predicate"} answers {@method "true"} 
 *          for any element of {@apram "aTuple"}, {@method "false"} otherwise.
 * @category "Tuples" "Control Structures" "Collections" "Queries"
 */
Method "any of_satisfies_" is
[
	aTuple : tuple,
	predicate : [⊥, ⊥]→boolean
|
	$body : boolean;
	For each aTuple do
	[
		element : any,
		index : natural number
	|
		If predicate(element, index) then
		[
			Exit body with true
		];
	];
	false
] : boolean;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * 
 * @method "any of_satisfies_"
 * @restricts "tuple meta"
 * @restricts "[…]→boolean's type"
 */
Semantic restriction "any of_satisfies_" is
[
	tupleType : tuple meta,
	predicate : […]→boolean's type
|
	Require: predicate accepts tupleType (check indices);
	predicate's return type
];

/**
 * Compute and answer whether each of the elements of {@param "aTuple"} 
 * satisfies the specified function. Do not examine more elements than 
 * necessary.
 * 
 * @method "each of_satisfies_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥]→boolean"
 *        A function that accepts the elements of the tuple and answers a
 *        boolean.
 * @returns "boolean"
 *          {@method "true"} if {@param "predicate"} answers {@method "true"} 
 *          for each element of {@apram "aTuple"}, {@method "false"} otherwise.
 * @category "Tuples" "Control Structures" "Collections" "Queries"
 */
Method "each of_satisfies_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	$body : boolean;
	For each aTuple do
	[
		element : any
	|
		Unless predicate(element) then
		[
			Exit body with false
		];
	];
	true
] : boolean;

/**
 * Compute and answer whether each of the elements (and indices) of {@param 
 * "aTuple"} satisfy the specified function. Do not examine more elements than 
 * necessary.
 * 
 * @method "each of_satisfies_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥, ⊥]→boolean"
 *        A function that accepts 1) an element of the tuple and 2) the index of
 *        that element and answers a boolean.
 * @returns "boolean"
 *          {@method "true"} if {@param "predicate"} answers {@method "true"} 
 *          for each element of {@apram "aTuple"}, {@method "false"} otherwise.
 * @category "Tuples" "Control Structures" "Collections" "Queries"
 */
Method "each of_satisfies_" is
[
	aTuple : tuple,
	predicate : [⊥, ⊥]→boolean
|
	$body : boolean;
	For each aTuple do
	[
		element : any,
		index : natural number
	|
		Unless predicate(element, index) then
		[
			Exit body with false
		];
	];
	true
] : boolean;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * 
 * @method "each of_satisfies_"
 * @restricts "tuple meta"
 * @restricts "[…]→boolean's type"
 */
Semantic restriction "each of_satisfies_" is
[
	tupleType : tuple meta,
	predicate : […]→boolean's type
|
	Require: predicate accepts tupleType (check indices);
	predicate's return type
];

/**
 * Compute and answer the count of elements of {@param "aTuple"} that satisfy 
 * the given predicate.
 * 
 * @method "count of_where_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥]→boolean"
 *        A function that accepts the elements of the tuple and answers {@method 
 *        "true"} if the element should be represented in the resulting count.
 * @returns "whole number"
 *          The number of elements of {@apram "aTuple"} for which {@param 
 *          "predicate"} answers {@method "true"}
 * @category "Tuples" "Control Structures" "Collections" "Queries"
 */
Method "count of_where_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	|filter aTuple by predicate|
] : whole number;

/**
 * Compute and answer the count of elements (and indices) of {@param "aTuple"}
 * that satisfy the given predicate.
 * 
 * @method "count of_where_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥, ⊥]→boolean"
 *        A function that accepts 1) an element of the tuple and 2) the index of
 *        that element and answers {@method "true"} if the element should be 
 *        represented in the resulting count.
 * @returns "whole number"
 *          The number of elements of {@param "aTuple"} for which {@param 
 *          "predicate"} answers {@method "true"}.
 * @category "Tuples" "Control Structures" "Collections" "Queries"
 */
Method "count of_where_" is
[
	aTuple : tuple,
	predicate : [⊥, ⊥]→boolean
|
	|filter aTuple by predicate|
] : whole number;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * 
 * @method "count of_where_"
 * @restricts "tuple meta"
 * @restricts "[…]→boolean's type"
 */
Semantic restriction "count of_where_" is
[
	tupleType : tuple meta,
	predicate : […]→boolean's type
|
	Require: predicate accepts tupleType (check indices);
	[0..⎡tupleType⎤ + 1)
];

/**
 * Compute and answer the distinct elements of {@param "aTuple"}, preserving 
 * order.
 * 
 * @method "distinct_"
 * @param "aTuple" "tuple"
 * @returns "tuple"
 *          A tuple that contains only the distinct elements of {@param 
 *          "aTuple"}, and in the order in which they were encountered.
 * @category "Tuples" "Transformers"
 */
Public stable method "distinct_" is
[
	aTuple : tuple
|
	seen : set := ∅;
	filter aTuple by
	[
		element : any
	|
		if ¬element ∈ seen then
		[
			seen := eject ↑seen + element;
			true
		]
		else
		[
			false
		]
	]
] : tuple;

/* No decent semantic restrictions can be written yet for `distinct_` and
 * `_→set`. An efficient algorithm involves construction and evaluation of a
 * chromatic polynomial over the type intersection graph of the tuple type's
 * element types (the vertices represent the element types and an edge between
 * two vertices indicates that the type intersection of the element types is ⊥).
 * We cannot conveniently build graphs yet. We need object types and objects
 * first.
 */

/**
 * Answer a function that computes the zip of a tuple of tuples.
 * 
 * @method "zip function"
 * @returns "[<tuple…|1..>]→tuple"
 *          The requested function.
 */
Private method "zip function" is
[
	[
		tuples : <tuple…|1..>
	|
		accumulator : <tuple…|> := <>;
		limit ::= min map tuples through [ aTuple : tuple | |aTuple| ];
		From 1 to limit do
		[
			index : natural number
		|
			group : tuple := <>;
			For each tuples do
			[
				aTuple : tuple
			|
				group := eject ↑group ++ <aTuple[index]>;
			];
			accumulator := eject ↑accumulator ++ <group>;
		];
		accumulator
	] : tuple
] : [<tuple…|1..>]→tuple;

/**
 * Compute and answer the zip of the specified tuples. Given N input tuples, the
 * output is the tuple whose i-th element contains the i-th element from each
 * consecutive input tuple. The size of the output equals to the smallest size
 * of the inputs. Each of the output's tuples has length equal to the number of
 * inputs.
 * 
 * @method "zip_"
 * @param "tuples" "<tuple…|1..>"
 *        A tuple of tuples.
 * @returns "tuple"
 *          The zip of the input tuples.
 * @category "Tuples" "Transformers"
 */
Public method "zip_" is zip function;

/**
 * Compute and answer the zip of the specified tuples. Given N input tuples, the
 * output is the tuple whose i-th element contains the i-th element from each
 * consecutive input tuple. The size of the output equals to the smallest size
 * of the inputs. Each of the output's tuples has length equal to the number of
 * inputs.
 * 
 * @method "«_‡zip»"
 * @param "tuples" "<tuple…|1..>"
 *        A tuple of tuples.
 * @returns "tuple"
 *          The zip of the input tuples.
 * @category "Tuples" "Transformers"
 */
Public method "«_‡zip»" is zip function;

/** 
 * Don't parse {@param "«_‡zip»"} recursively. 
 * 
 * @method "«_‡zip»"
 * @forbids "1" "«_‡zip»"
 */
Grammatical restriction {"«_‡zip»"} is <{"«_‡zip»"}>;

/**
 * Answer the semantic restriction function for zipping tuples.
 * 
 * @method "zip semantic restriction"
 * @returns "[<tuple…|1..>'s type]→type"
 *          The semantic restriction function.
 */
Private method "zip semantic restriction" is
[
	[
		tuplesType : <tuple…|1..>'s type
	|
		/* Leverage an instance type if possible. */
		if |tuplesType| = 1 then
		[
			(zip tuplesType's instance)'s type
		]
		else
		[
			types ::= cast tuplesType[1..relevant |tuplesType|]
				into [ t : <tuple meta…|1..> | t ];
			/* Find the smallest of the lower bounds of the inputs. */
			lower ::=
				min map types through
				[
					tupleType : tuple meta
				|
					⎣tupleType⎦
				];
			/* Find the smallest of the upper bounds of the inputs. */
			upper ::=
				min map types through
				[
					tupleType : tuple meta
				|
					⎡tupleType⎤
				];
			/* Find the maximum number of element types to scan. */
			limit ::=
				max map types through
				[
					tupleType : tuple meta
				|
					|tupleType's leading types| + 1
				];
			resultTypes : <tuple meta…|> := <>;
			/* Examine the relevant element types of all inputs. */
			From 1 to limit do
			[
				index : natural number
			|
				zipped : tuple of any meta := <>;
				/* Examine the `index`-th element type of each input. Accumulate
				 * the results into `zipped`.
				 */
				For each types do
				[
					tupleType : tuple meta
				|
					zipped := eject ↑zipped ++ <tupleType[index]>;
				];
				nonempty ::= cast zipped
					into [ t : <any meta…|1..> | t ];
				zippedType ::=
					<nonempty[1..|nonempty| - 1], nonempty[|nonempty|]…
						| ||tuplesType||>;
				resultTypes := eject ↑resultTypes ++ <zippedType>;
			];
			nonempty ::= cast resultTypes into [ t : <tuple meta…|1..> | t ];
			resultSizes ::= [lower..upper + 1);
			<nonempty[1..|nonempty| - 1], nonempty[|nonempty|]… | resultSizes>
		]
	] : type
] : [<tuple…|1..>'s type]→type;

/**
 * @method "zip_"
 * @restricts "<tuple…|1..>'s type"
 */
Semantic restriction "zip_" is zip semantic restriction;

/**
 * @method "«_‡zip»"
 * @restricts "<tuple…|1..>'s type"
 */
Semantic restriction "«_‡zip»" is zip semantic restriction;

/**
 * Reduce {@param "aTuple"} via the binary function, traversing the tuple from 
 * left to right. Answer the result of the reduction.
 *
 * @method "left fold_through_"
 * @param "aTuple" "<any…|1..>"
 *        A nonempty tuple.
 * @param "transformer" "[⊥, ⊥]→any"
 *        A binary function whose second parameter type matches its return type.
 *        The first parameter type must be general enough to accept each element
 *        of {@param "aTuple"}.
 * @returns "any"
 *          The only element of {@param "aTuple"} if {@param "aTuple"} contains 
 *          only one element. Otherwise, the result of iteratively applying 
 *          {@param "transformer"} to 1) the left-to-right consecutive elements 
 *          of {@param "aTuple"} and 2) the previous results of applying 
 *          {@param "transformer"}.
 * @category "Tuples" "Transformers"
 */
Public method "left fold_through_" is
[
	aTuple : <any…|1..>,
	transformer : [⊥, ⊥]→any
|
	result : any := aTuple[1];
	From 2 to |aTuple| do
	[
		index : natural number
	|
		result := transformer(aTuple[index], eject ↑result);
	];
	result
] : any;

/**
 * Left fold has the following requirements:
 *
 * - The function's first parameter must accept every element of the tuple
 *   except for the first (with which it will not be applied at this position).
 * - The function's second parameter must accept the tuple's first element and
 *   also every value producible by the function.
 *
 * Left fold answers either the tuple's first element or the value produced by
 * the final application of the function.
 * 
 * @method "left fold_through_"
 * @restricts "<any…|1..>'s type"
 * @restricts "[⊥, ⊥]→any's type"
 */
Semantic restriction "left fold_through_" is
[
	tupleType : <any…|1..>'s type,
	transformer : [⊥, ⊥]→any's type
|
	headType ::= tupleType[1];
	restType ::= if |tupleType's leading types| > 0
		then [ ∪ tupleType[2..|tupleType's leading types| + 1] ]
		else [ headType ];
	returnType ::= transformer's return type;
	finalType ::= headType ∪ returnType;
	If transformer[1] ≠ ⊥ ∧ [ ¬restType ⊆ transformer[1] ] then
	[
		Reject parse, expected:
			"repeatedly applied function's first parameter to accept all\
			\| non-first elements of the tuple ⊆ "
			++ “restType”
			++ " (but it only accepts "
			++ “transformer[1]”
			++ ")"
	];
	If transformer[2] ≠ ⊥ ∧ [ ¬finalType ⊆ transformer[2] ] then
	[
		Reject parse, expected:
			"repeatedly applied function's second parameter to accept the\
			\| type union ⊆ "
			++ “finalType”
			++ " of the first element ⊆ "
			++ “headType”
			++ " of the tuple and its own return type ⊆ "
			++ “returnType”
			++ " (but it only accepts "
			++ “transformer[2]”
			++ ")"
	];
	finalType
];

/**
 * Reduce {@param "aTuple"} via the binary function, traversing the tuple from 
 * right to left. Answer the result of the reduction.
 *
 * @method "right fold_through_"
 * @param "aTuple" "<any…|1..>"
 *        A nonempty tuple.
 * @param "transformer" "[⊥, ⊥]→any"
 *        A binary function whose second parameter type matches its return type.
 *        The first parameter type must be general enough to accept each element
 *        of {@param "aTuple"}.
 * @returns "any"
 *          The only element of {@param "aTuple"} if {@param "aTuple"} contains 
 *          only one element. Otherwise, the result of iteratively applying 
 *          {@param "transformer"} to 1) the right-to-left consecutive elements 
 *          of {@param "aTuple"} and 2) the previous results of applying 
 *          {@param "transformer"}.
 * @category "Tuples" "Transformers"
 */
Public method "right fold_through_" is
[
	aTuple : <any…|1..>,
	transformer : [⊥, ⊥]→any
|
	result : any := aTuple[|aTuple|];
	From |aTuple| - 1 to 1 by -1 do
	[
		index : natural number
	|
		result := transformer(aTuple[index], eject ↑result);
	];
	result
] : any;

/**
 * Right fold has the following requirements:
 *
 * - The function's first parameter must accept every element of the tuple
 *   except for the last (with which it will not be applied at this position).
 * - The function's second parameter must accept the tuple's last element and
 *   also every value producible by the function.
 *
 * Right fold answers either the tuple's last element or the value produced by
 * the final application of the function.
 * 
 * @method "right fold_through_"
 * @restricts "<any…|1..>'s type"
 * @restricts "[⊥, ⊥]→any's type"
 */
Semantic restriction "right fold_through_" is
[
	tupleType : <any…|1..>'s type,
	transformer : [⊥, ⊥]→any's type
|
	sizes ::= ||tupleType||;

	lastIndexStart ::= 1 max relevant |tupleType|;
	lastIndexEnd ::= lastIndexStart
		max (⎡sizes⎤ min (|tupleType's leading types| + 1));
	lastType ::= ∪ tupleType[lastIndexStart..lastIndexEnd];
	restType ::= ∪ tupleType[1..lastIndexEnd - 1];
	returnType ::= transformer's return type;
	finalType ::= lastType ∪ returnType;
	If transformer[1] ≠ ⊥ ∧ [ ¬restType ⊆ transformer[1] ] then
	[
		Reject parse, expected:
			"repeatedly applied function's first parameter to accept all\
			\| non-last elements of the tuple ⊆ "
			++ “restType”
			++ " (but it only accepts "
			++ “transformer[1]”
			++ ")"
	];
	If transformer[2] ≠ ⊥ ∧ [ ¬finalType ⊆ transformer[2] ] then
	[
		Reject parse, expected:
			"repeatedly applied function's second parameter to accept the\
			\| type union ⊆ "
			++ “finalType”
			++ " of the last element ⊆ "
			++ “lastType”
			++ " of the tuple and its own return type ⊆ "
			++ “returnType”
			++ " (but it only accepts "
			++ “transformer[2]”
			++ ")"
	];
	finalType
];

/**
 * Compute and answer the index of the first element of {@param "aTuple"} that
 * satisfies the specified predicate.
 * 
 * @method "first index of_where_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥]→boolean"
 *        A function that accepts the elements of the tuple.
 * @returns "whole number"
 *          The index of the first satisfactory element, or 0 if no element
 *          satisfied the predicate.
 * @category "Tuples" "Queries"
 */
Public method "first index of_where_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	$body : natural number;
	From 1 to |aTuple| do
	[
		index : natural number
	|
		If predicate(aTuple[index]) then
		[
			Exit body with index
		];
	];
	0
] : whole number;

/**
 * Ensure that the function will accept all elements of the tuple.
 * 
 * @method "first index of_where_"
 * @restricts "tuple meta"
 * @restricts "[⊥]→boolean's type"
 */
Semantic restriction "first index of_where_" is
[
	tupleType : tuple meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts tupleType (check indices);
	[0..⎡tupleType⎤ + 1)
];

/**
 * Compute and answer the index of the last element of {@param "aTuple"} that 
 * satisfies the specified predicate.
 * 
 * @method "last index of_where_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥]→boolean"
 *        A function that accepts the elements of the tuple.
 * @returns "whole number"
 *          The index of the last satisfactory element, or 0 if no element
 *          satisfied the predicate.
 * @category "Tuples" "Queries"
 */
Public method "last index of_where_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	$body : natural number;
	From |aTuple| to 1 by -1 do
	[
		index : natural number
	|
		If predicate(aTuple[index]) then
		[
			Exit body with index
		];
	];
	0
] : whole number;

/**
 * Ensure that the function will accept all elements of the tuple.
 * 
 * @method "last index of_where_"
 * @restricts "tuple meta"
 * @restricts "[⊥]→boolean's type"
 */
Semantic restriction "last index of_where_" is
[
	tupleType : tuple meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts tupleType (check indices);
	[0..⎡tupleType⎤ + 1)
];
	
	
/**
 * Compute and answer the indices of all the elements of {@param "aTuple"} that 
 * satisfies the specified predicate.
 * 
 * @method "all indices of_where_"
 * @param "aTuple" "tuple"
 * 		The tuple to search
 * @param "predicate" "[⊥]→boolean"
 *        A function that accepts the elements of the tuple.
 * @returns "<natural number…|0..∞>"
 *          The indices of all the satisfactory elements of the predicate.
 * @category "Tuples" "Queries"
 */
Public method "all indices of_where_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	indices : <natural number…|0..∞> := <>;
	From 1 to |aTuple| by 1 do
	[
		index : natural number
	|
		If predicate(aTuple[index]) then
		[
			indices := indices ++ <index>;
		];
	];
	indices
] : <natural number…|0..∞>;

/**
 * Ensure that the function will accept all elements of the tuple.
 * 
 * @method "all indices of_where_"
 * @restricts "tuple meta"
 * @restricts "[⊥]→boolean's type"
 */
Semantic restriction "all indices of_where_" is
[
	tupleType : tuple meta,
	predicateType : [⊥]→boolean's type
|
	Require: predicateType accepts tupleType (check indices);
	<natural number…|0..⎡tupleType⎤ + 1>
];

/**
 * Construct and answer a tuple whose elements are each {@param "value"}.
 * 
 * @method "_occurrences⁇of_"
 * @param "count" "whole number"
 *        The number of elements in the resulting tuple.
 * @param "value" "any"
 *        The repeated value.
 * @returns "tuple"
 *          A tuple containing {@param "count"} occurrences of {@param "value"}.
 * @category "Tuples" "Constructors"
 */
Public stable method "_occurrences⁇of_" is
[
	count : whole number,
	value : any
|
	accumulator : tuple := <>;
	Repeat
	[
		accumulator := eject ↑accumulator ++ <value>;
	]
	count times;
	accumulator
];

/**
 * @method "_occurrences⁇of_"
 * @restricts "whole number's type"
 * @restricts "any meta"
 */
Semantic restriction "_occurrences⁇of_" is
[
	countType : whole number's type,
	valueType : any meta
|
	<<>, valueType…|countType>
];

/**
 * Construct and answer a tuple that contains the consecutive integers from
 * {@param "start"} (inclusive) up to {@param "end"} (inclusive), counting up by 
 * 1. If {@param "end"}{@code " < "}{@param "start"}, then answer the empty 
 * tuple.
 * 
 * @method "_to_"
 * @param "start" "integer"
 *        The first value of the resulting tuple.
 * @param "end" "integer"
 *        The last value of the resulting tuple.
 * @returns "<integer…|>"
 *          The interval from {@param "start"} (inclusive) up to {@param "end"} 
 *          (inclusive).
 * @category "Tuples" "Constructors"
 */
Public stable method "_to_" is
[
	start : integer,
	end : integer
|
	start to end by 1
] : <integer…|>;

/**
 * Construct and answer a string that contains the consecutive characters from
 * {@param "start"} (inclusive) to {@param "end"} (inclusive). If 
 * {@param "start"}{@code "'s code point ≤ "}{@param "end"}{@code "'s code 
 * point"}, then {@code "result[i]'s code point < result[i+1]'s code point"}; 
 * otherwise, {@code "result[i]'s code point > result[i+1]'s code point"}.
 * 
 * @method "_to_"
 * @param "start" "character"
 *        The first value of the resulting tuple.
 * @param "end" "character"
 *        The last value of the resulting tuple.
 * @returns "<character…|>"
 *          The interval from {@param "start"} (inclusive) up to {@param "end"}
 *          (inclusive).
 * @category "Tuples" "Constructors"
 */
Public stable method "_to_" is
[
	start : character,
	end : character
|
	accumulator : string := <>;
	startCodePoint ::= start's code point;
	endCodePoint ::= end's code point;
	From startCodePoint to endCodePoint do
	[
		value : code point
	|
		accumulator := eject ↑accumulator ++ <value→character>;
	];
	accumulator
] : string;

/**
 * Leverage the uncertainty of {@param "start"} to produce good leading types 
 * when the upper bound of the result's cardinality can be determined.
 * 
 * @method "_to_"
 * @restricts "integer's type"
 * @restricts "integer's type"
 */
Semantic restriction "_to_" is
[
	start : integer's type,
	end : integer's type
|
	$body : type;
	/* If the arguments are instance types, then bail immediately; let the
	 * stable semantic restriction produce an instance type.
	 */
	If {|start|, |end|} = {1} then [Exit body with ⊤];
	min ::= ⎣start⎦;
	max ::= ⎡end⎤;
	uncertainty ::= ⎡start⎤ - ⎣start⎦;
	sizes ::= [0 max (⎣end⎦ - ⎡start⎤ + 1) .. max - min + 2);
	if uncertainty is finite
		∧ [sizes ≠ ⊥
		∧ [⎡sizes⎤ is finite]] then
	[
		finiteMin ::= cast min into [t : integer | t];
		finiteMax ::= cast max into [t : integer | t];
		/* Don't obsess — just compute the first 100 prefix types. */
		limitedMax ::= finiteMax min (finiteMin + 100);
		types ::=
			map finiteMin to limitedMax through
			[
				x : integer
			|
				[x .. (finiteMax min (x + uncertainty)) + 1)
			];
		defaultType ::=
			if finiteMax ≠ limitedMax then
			[
				[limitedMax .. finiteMax + 1)
			]
			else
			[
				types[|types|] else [⊥]
			];
		cast types
		into [t : <integer's type…|1..> | <t[1..|t|-1], defaultType…|sizes>]
		else [<>'s type]
	]
	else if [sizes = ⊥] then
	[
		<>'s type
	]
	else
	[
		<<>, [min..max + 1)…|sizes>
	]
] : type;

Method "_to_by_" is stable at [integer, integer, integer]→<integer…|>;

Method "_to_by_" is
[
	start : integer,
	end : integer,
	delta : 0's type
|
	early failure function(incorrect-argument-type code)
] : ⊥;

/**
 * Reject invocations with size-zero step, and narrow the return type if 
 * possible.
 * 
 * @method "_to_by_"
 * @restricts "integer's type"
 * @restricts "integer's type"
 * @restricts "integer's type"
 */
Semantic restriction "_to_by_" is
[
	start : integer's type,
	end : integer's type,
	delta : integer's type
|
	low : extended integer;
	high : extended integer;
	sizes : whole number's type;

	If delta ⊆ [0..0] then
	[
		Reject parse, expected: "delta value not to be zero"
	];

	If delta ⊆ [0..∞) then
	[
		low := ⎣start⎦;
		high := ⎡end⎤;
		rangeFrom ::= 0 max ((⎣end⎦ - ⎡start⎤) ÷ ⎡delta⎤ + 1);
		rangeTo ::= (high - low) ÷ ⎣delta⎦ + 1;
		sizes := [rangeFrom .. rangeTo + 1);
	]
	else if [delta ⊆ (-∞..-1]] then
	[
		low := ⎣end⎦;
		high := ⎡start⎤;
		rangeFrom ::= 0 max ((⎣start⎦ - ⎡end⎤) ÷ -⎡delta⎤ + 1);
		rangeTo ::= (high - low) ÷ -⎣delta⎦ + 1;
		sizes := [rangeFrom .. rangeTo + 1);
	]
	else
	[
		/* There is no need to divide by any value of delta here because if
		 * delta's value cannot be determined, then 1 and -1 are possible
		 * values. So, the largest possible size should remain.
		 */
		low := ⎣start⎦ min ⎣end⎦;
		high := ⎡start⎤ max ⎡end⎤;
		sizes := [0 .. high - low + 2);
	];
	<<>, [low..high + 1)…|sizes>
];

/**
 * Is {@param "value"} an element of {@param "aTuple"}?
 * 
 * @method "_∈_"
 * @param "value" "any"
 *        An arbitrary value.
 * @param "aTuple" "tuple"
 * @returns "boolean"
 *          {@method "true"} if {@param "value"} is an element of {@param 
 *          "aTuple"}, {@method "false"} otherwise.
 * @category "Tuples" "Collections" "Queries"
 */
Stable method "_∈_" is
[
	value : any,
	aTuple : tuple
|
	any of aTuple satisfies [ element : any | element = value ]
] : boolean;

/**
 * @method "_∈_"
 * @restricts "any meta"
 * @restricts "tuple meta"
 */
Semantic restriction "_∈_" is
[
	valueType : any meta,
	tupleType : tuple meta
|
	if valueType ∩ (∪ tupleType[1..∞]) = ⊥ then
	[
		false's type
	]
	else
	[
		/* Can't strengthen. */
		⊤
	]
];

/**
 * Is {@param "subtuple"} a subsequence of {@param "aTuple"}?
 * 
 * @method "_⊆_"
 * @param "subtuple" "tuple"
 *        The search tuple.
 * @param "aTuple" "tuple"
 *        The tuple which should be searched for {@param "subtuple"}.
 * @returns "boolean"
 *          {@method "true"} if some subsequence of {@param "aTuple"} equals 
 *          {@param "subtuple"}, {@method "false"} otherwise.
 * @category "Tuples" "Collections" "Queries"
 */
Method "_⊆_" is
[
	subtuple : tuple,
	aTuple : tuple
|
	matched : boolean := false;
	From 1 to |aTuple| - |subtuple| + 1 do
	[
		index : natural number
	|
		matched := aTuple[index..index + |subtuple| - 1] = subtuple;
		¬matched
	];
	matched
] : boolean;

/**
 * Is {@param "subtuple"} a subsequence of {@param "aTuple"}?
 * 
 * @method "_⊆_"
 * @param "aTuple" "tuple"
 *        The tuple which should be searched for {@param "subtuple"}.
 * @param "subtuple" "tuple"
 *        The search tuple.
 * @returns "boolean"
 *          {@method "true"} if some subsequence of {@param "aTuple"} equals 
 *          {@param "subtuple"}, {@method "false"} otherwise.
 * @category "Tuples" "Collections" "Queries"
 */
Method "_⊇_" is
[
	aTuple : tuple,
	subtuple : tuple
|
	subtuple ⊆ aTuple
] : boolean;

/**
 * Answer a function suitable for use as the semantic restriction for
 * subsequence containment.
 *
 * @method "subsequence restriction function"
 * @returns "[tuple meta, tuple meta]→type"
 *          A function suitable for use as the semantic restriction of `_⊆_` and
 *          `_⊇_`.
 */
Private method "subsequence restriction function" is
[
	[
		subtuple : tuple meta,
		aTuple : tuple meta
	|
		if |subtuple| = 1 ∧ [ |aTuple| = 1 ] then
		[
			(subtuple's instance ⊆ aTuple's instance)'s type
		]
		else if [ ⎣subtuple⎦ > ⎡aTuple⎤ ] then
		[
			false's type
		]
		else
		[
			subtupleElementType ::=
				∪ subtuple[1..|subtuple's leading types| + 1];
			elementType ::= ∪ aTuple[1..|aTuple's leading types| + 1];
			if subtupleElementType ∩ elementType = ⊥ then
			[
				false's type
			]
			/* Can't strengthen. */
			else
			[
				⊤
			]
		]
	] : type
] : [tuple meta, tuple meta]→type;

/**
 * Does {@param "aTuple"} start with the subsequence {@param "prefix"}?
 * 
 * @method "_starts with_"
 * @param "aTuple" "tuple"
 *        The tuple whose prefix should be checked against {@param "prefix"}.
 * @param "prefix" "tuple"
 *        The search tuple.
 * @returns "boolean"
 *          {@method "true"} if {@param "aTuple"} starts with the subsequence 
 *          {@param "prefix"}, {@method "false"} otherwise.
 * @category "Tuples" "Queries"
 */
Public method "_starts with_" is
[
	aTuple : tuple,
	prefix : tuple
|
	aTuple[..|prefix| min |aTuple|] = prefix
] : boolean;

/**
 * Does {@param "aTuple"} end with the subsequence {@param "suffix"}?
 * 
 * @method "_ends with_"
 * @param "aTuple" "tuple"
 *        The tuple whose suffix should be checked against {@param "suffix"}.
 * @param "suffix" "tuple"
 *        The search tuple.
 * @returns "boolean"
 *          {@method "true"} if {@param "aTuple"} ends with the subsequence 
 *          {@param "suffix"}, {@method "false"} otherwise.
 * @category "Tuples" "Queries"
 */
Public method "_ends with_" is
[
	aTuple : tuple,
	suffix : tuple
|
	aTuple[1 max (|aTuple| - (|suffix| min |aTuple|) + 1)..] = suffix
] : boolean;

/**
 * If {@param "subtuple"} is guaranteed longer than {@param "aTuple"} or if the 
 * element types of {@param "subtuple"} and {@param "aTuple"} are completely 
 * disjoint, then {@param "subtuple"}'s instance cannot possibly be a 
 * subsequence of {@param "aTuple"}'s instance.
 * 
 * @method "_⊆_"
 * @restricts "tuple meta"
 * @restricts "tuple meta"
 */
Semantic restriction "_⊆_" is subsequence restriction function;

/**
 * If {@param "subtuple"} is guaranteed longer than {@param "aTuple"} or if the 
 * element types of {@param "subtuple"} and {@param "aTuple"} are completely 
 * disjoint, then {@param "subtuple"}'s instance cannot possibly be a 
 * subsequence of {@param "aTuple"}'s instance.
 * 
 * @method "_⊇_"
 * @restricts "tuple meta"
 * @restricts "tuple meta"
 */
Semantic restriction "_⊇_" is
[
	aTuple : tuple meta,
	subtuple : tuple meta
|
	subsequence restriction function(subtuple, aTuple)
];

/**
 * If {@param "subtuple"} is guaranteed longer than {@param "aTuple"} or if the 
 * element types of {@param "subtuple"} and {@param "aTuple"} are completely 
 * disjoint, then {@param "subtuple"}'s instance cannot possibly be a 
 * prefix of {@param "aTuple"}'s instance.
 * 
 * @method "_starts with_"
 * @restricts "tuple meta"
 * @restricts "tuple meta"
 */
Semantic restriction "_starts with_" is
[
	aTuple : tuple meta,
	subtuple : tuple meta
|
	subsequence restriction function(subtuple, aTuple)
];

/**
 * If {@param "subtuple"} is guaranteed longer than {@param "aTuple"} or if the 
 * element types of {@param "subtuple"} and {@param "aTuple"} are completely 
 * disjoint, then {@param "subtuple"}'s instance cannot possibly be a 
 * suffix of {@param "aTuple"}'s instance.
 * 
 * @method "_ends with_"
 * @restricts "tuple meta"
 * @restricts "tuple meta"
 */
Semantic restriction "_ends with_" is
[
	aTuple : tuple meta,
	subtuple : tuple meta
|
	subsequence restriction function(subtuple, aTuple)
];

/**
 * Split a {@param "aTuple"} into two tuples between {@param "pivot"} and 
 * {@param "pivot"}{@code " + 1"} and answer a 2-tuple containing the results.
 *
 * @method "split_after_"
 * @param "aTuple" "tuple"
 * @param "pivot" "whole number"
 *        The index (inclusive) at which to split {@param "aTuple"}.
 * @returns "<tuple…|2>"
 *          A 2-tuple. The first tuple contains the first {@param "pivot"} 
 *          elements of {@param "aTuple"}. The second tuple contains the 
 *          remaining elements of {@param "aTuple"}.
 * @category "Tuples" "Transformers"
 */
Public stable method "split_after_" is
[
	aTuple : tuple,
	pivot : whole number
|
	<aTuple[..pivot], aTuple[pivot + 1..]>
] : <tuple…|2>;

/**
 * Construct the strongest possible 2-tuple type for the given arguments. The
 * first element type is a tuple type whose elements are drawn from the original
 * tuple type. The second element type is a tuple type whose element type are
 * smears (i.e., type unions) of the trailing element types of the original
 * tuple type. The pivot is used to determine the cardinality ranges of the
 * these element types.
 * 
 * @method "split_after_"
 * @restricts "tuple meta"
 * @restricts "whole number's type"
 */
Semantic restriction "split_after_" is
[
	tupleType : tuple meta,
	pivot : whole number's type
|
	If ⎣pivot⎦ > ⎡tupleType⎤ then
	[
		Reject parse, expected:
			"pivot ∈ "
			++ “pivot”
			++ " ever to be valid for the tuple ∈ "
			++ “tupleType”
	];
	pivotPlusOne ::= cast pivot + 1's type
		into [ t : natural number's type | t ];
	firstType ::= tuple type of tupleType[1's type..pivot];
	secondType ::= tuple type of tupleType[pivotPlusOne..||tupleType||];
	<firstType, secondType…|2>
];

/**
 * Split a {@param "aTuple"} into two tuples between {@param "pivot"}{@code 
 * " - 1"} and {@param "pivot"} and answer a 2-tuple containing the results.
 *
 * @method "split_before_"
 * @param "aTuple" "tuple"
 * @param "pivot" "natural number"
 *        The index (exclusive) at which to split {@param "aTuple"}.
 * @returns "<tuple…|2>"
 *          A 2-tuple. The first tuple contains the first {@param "pivot"}{@code
 *          " - 1"} elements of {@param "aTuple"}. The second tuple contains the 
 *          remaining elements of {@param "aTuple"}.
 * @category "Tuples" "Transformers"
 */
Public stable method "split_before_" is
[
	aTuple : tuple,
	pivot : natural number
|
	<aTuple[..pivot - 1], aTuple[pivot..]>
] : <tuple…|2>;

/**
 * Construct the strongest possible 2-tuple type for the given arguments. The
 * first element type is a tuple type whose elements are drawn from the original
 * tuple type. The second element type is a tuple type whose element type are
 * smears (i.e., type unions) of the trailing element types of the original
 * tuple type. The pivot is used to determine the cardinality ranges of the
 * these element types.
 * 
 * @method "split_before_"
 * @restricts "tuple meta"
 * @restricts "natural number's type"
 */
Semantic restriction "split_before_" is
[
	tupleType : tuple meta,
	pivot : natural number's type
|
	If ⎣pivot⎦ > ⎡tupleType⎤ + 1 then
	[
		Reject parse, expected:
			"pivot ∈ "
			++ “pivot”
			++ " ever to be valid for the tuple ∈ "
			++ “tupleType”
	];
	pivotMinusOne ::= cast pivot - 1's type
		into [ t : whole number's type | t ];
	firstType ::= tuple type of tupleType[1's type..pivotMinusOne];
	secondType ::= tuple type of tupleType[pivot..||tupleType||];
	<firstType, secondType…|2>
];

/**
 * Split a {@param "aTuple"} into two tuples.
 *
 * @method "split_before_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥]→boolean"
 *        A function that accepts each element of the tuple. It must answer
 *        {@method "true"} when the pivot position has been reached. The 
 *        function will not be applied again after it has answered {@param 
 *        "true"}.
 * @returns "<tuple…|2>"
 *          A 2-tuple. The first tuple contains the elements of {@param 
 *          "aTuple"} to which {@param "predicate"} was applied without a 
 *          {@method "true"} result. The second tuple contains the element for 
 *          which a {@method "true"} result was obtained along with the 
 *          remaining, untested, elements of {@param "aTuple"}.
 * @category "Tuples" "Transformers"
 */
Method "split_before_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	firstIndex ::= first index of aTuple where predicate;
	splitIndex ::=
		if firstIndex = 0
		then [ |aTuple| ]
		else [ cast firstIndex - 1 into [ t : whole number | t ] ];
	split aTuple after splitIndex
] : <tuple…|2>;

/**
 * Construct the strongest possible 2-tuple type for the given arguments. The
 * first element type is a tuple type whose elements are drawn from the original
 * tuple type. The second element type is a tuple type whose element type are
 * smears (i.e., type unions) of the trailing element types of the original
 * tuple type. The cardinality of each tuple varies from 0 to the upper bound of
 * {@param "tupleType"}'s cardinality range.
 * 
 * @method "split_before_"
 * @restricts "tuple meta"
 * @restricts "[⊥]→boolean's type"
 */
Semantic restriction "split_before_" is
[
	tupleType : tuple meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts tupleType (check indices);
	returnType ::= predicate's return type;
	if ⎡tupleType⎤ = 0 then
	[
		<<>, <>>'s type
	]
	else
	[
		sizes ::= ||tupleType||;
		upper ::= [0..⎡sizes⎤ + 1);
		firstType ::=
			<tupleType's leading types, tupleType's default type…|upper>;
		secondType ::=
			tuple type of tupleType[[1..⎡sizes⎤ + 1)..upper];
		<firstType, secondType…|2>
	]
];

/**
 * Compute and answer the specified stripe of {@param "aTuple"}.
 * 
 * @method "stripe_at_"
 * @param "aTuple" "<<any…|1..>…|>"
 *        A tuple of non-empty tuples.
 * @param "index" "natural number"
 *        The stripe index.
 * @returns "tuple"
 *          A tuple comprising the {@param "index"}-th elements of each element 
 *          of {@param "aTuple"}.
 * @category "Tuples" "Transformers"
 */
Public stable method "stripe_at_" is
[
	aTuple : <<any…|1..>…|>,
	index : natural number
|
	map aTuple through [ inner : <any…|1..> | inner[index] ]
] : tuple;

/**
 * Reject the parse if the stripe index could never be valid.
 * 
 * @method "stripe_at_"
 * @restricts "<<any…|1..>…|>'s type"
 * @restricts "natural number's type"
 */
Semantic restriction "stripe_at_" is
[
	tupleType : <<any…|1..>…|>'s type,
	index : natural number's type
|
	uncertainty ::= cast ⎡index⎤ - ⎣index⎦
		into [ t : [0..∞] | t ];
	stripeTypes : <any meta…|> := <>;
	From 1 to |tupleType's leading types| + 1 do
	[
		typeIndex : natural number
	|
		innerType ::= tupleType[typeIndex];
		If ⎣index⎦ > ⎡innerType⎤ then
		[
			Reject parse, expected:
				"a subscript ("
				++ “⎣index⎦”
				++ " ≤ theSubscript ≤ "
				++ “⎡index⎤”
				++ ") that could ever be valid ("
				++ “⎣innerType⎦”
				++ " ≤ |theTuple| ≤ "
				++ “⎡innerType⎤”
				++ ")"
		];
		union : any meta := ⊥;
		limit ::= uncertainty min (|innerType's leading types| + 1);
		From 0 to limit do
		[
			delta : whole number
		|
			innerIndex ::= ⎣index⎦ + delta;
			union := eject ↑union ∪ innerType[innerIndex];
		];
		stripeTypes := eject ↑stripeTypes ++ <union>;
	];
	nonemptyTypes ::= cast stripeTypes into [ t : <any meta…|1..> | t ];
	<nonemptyTypes[1..|nonemptyTypes| - 1], nonemptyTypes[|nonemptyTypes|]…
		| ||tupleType||>
];

/**
 * Answer a tuple containing the first {@param "count"} elements of {@param 
 * "aTuple"}.
 * 
 * @method "take_from_"
 * @param "count" "whole number"
 *        The size of the requested tuple.
 * @param "aTuple" "tuple"
 *        The source tuple.
 * @returns "tuple"
 *          A tuple containing the first {@param "count"} elements of {@param 
 *          "aTuple"}, preserving the original order.
 * @category "Tuples" "Transformers"
 */
Public stable method "take_from_" is
[
	count : whole number,
	aTuple : tuple
|
	aTuple[1..count]
] : tuple;

/**
 * @method "take_from_"
 * @restricts "whole number's type"
 * @restricts "tuple's type"
 */
Semantic restriction "take_from_" is
[
	count : whole number's type,
	tupleType : tuple's type
|
	tuple type of tupleType[1's type..count]
];

/**
 * Answer a tuple containing the prefix of {@param "aTuple"} that answered 
 * {@method "true"} to {@param "predicate"}.
 *
 * @method "take from_while_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥]→boolean"
 *        A function that can accept each element of the specified tuple. It
 *        should answer {@method "true"} to keep the element (and continue 
 *        scanning) or {@method "false"} to abort.
 * @returns "tuple"
 *          A tuple containing the prefix of {@param "aTuple"} that satisfied 
 *          {@param "predicate"}.
 * @category "Tuples" "Transformers"
 */
Public method "take from_while_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	firstIndex ::= first index of aTuple where
		[value : any | ¬predicate(value)];
	splitIndex ::=
		if firstIndex = 0
		then [ |aTuple| ]
		else [ cast firstIndex - 1 into [ t : whole number | t ] ];
	aTuple[1..splitIndex]
] : tuple;

/**
 * Answer a semantic restriction suitable for use by the predicated-based
 * take/drop methods.
 *
 * @method "take|drop-while|until semantic restriction"
 * @param "tupleType" "tuple meta"
 * @param "predicate" "[⊥]→boolean's type"
 * Returns:
 *    The requested function.
 */
Private method "take|drop-while|until semantic restriction" is
[
	[
		tupleType : tuple meta,
		predicate : [⊥]→boolean's type
	|
		Require: predicate accepts tupleType (check indices);
		<∪ tupleType[1..|tupleType's leading types| + 1]…|0..⎡tupleType⎤>
	]
];

/**
 * @method "take from_while_"
 * @restricts "tuple meta"
 * @restricts "[⊥]→boolean's type"
 */
Semantic restriction "take from_while_" is take-while semantic restriction;

/**
 * Answer a tuple containing the prefix of `aTuple` that answered `false` to
 * `predicate`.
 *
 * @method "take from_until_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥]→boolean"
 *        A function that can accept each element of the specified tuple. It 
 *        should answer {@method "false"} to keep the element (and continue 
 *        scanning) or {@method "true"} to abort.
 * @returns "tuple"
 *          A tuple containing the prefix of {@param "aTuple"} that satisfied
 *          {@param "predicate"}.
 * @category "Tuples" "Transformers"
 */
Public method "take from_until_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	firstIndex ::= first index of aTuple where predicate;
	splitIndex ::=
		if firstIndex = 0
		then [ |aTuple| ]
		else [ cast firstIndex - 1 into [ t : whole number | t ] ];
	aTuple[1..splitIndex]
] : tuple;

/**
 * @method "take from_until_"
 * @restricts "tuple meta"
 * @restricts "[⊥]→boolean's type"
 */
Semantic restriction "take from_until_" is take-until semantic restriction;

/**
 * Compute and answer the suffix of {@param "aTuple"} that begins with the 
 * element that answers {@method "false"} to {@param "predicate"}.
 * 
 * @method "drop from_while_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥]→boolean"
 *        A function that can accept each element of the specified tuple. It 
 *        should answer {@method "true"} to discard the element (and continue 
 *        scanning) or {@method "false"} to abort.
 * @returns "tuple"
 *          The requested suffix.
 * @category "Tuples" "Transformers"
 */
Public method "drop from_while_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	firstIndex ::= first index of aTuple where
		[value : any | ¬predicate(value)];
	splitIndex ::=
		if firstIndex = 0
		then [ |aTuple| + 1 ]
		else [ cast firstIndex into [ t : natural number | t ] ];
	aTuple[splitIndex..]
] : tuple;

/**
 * @method "drop from_while_"
 * @restricts "tuple meta"
 * @restricts "[⊥]→boolean's type"
 */
Semantic restriction "drop from_while_" is drop-while semantic restriction;

/**
 * Compute and answer the suffix of {@param "aTuple"} that begins with the 
 * element that answers {@method "true"} to {@param "predicate"}.
 * 
 * @method "drop from_until_"
 * @param "aTuple" "tuple"
 * @param "predicate" "[⊥]→boolean"
 *        A function that can accept each element of the specified tuple. It
 *        should answer {@method "false"} to discard the element (and continue 
 *        scanning) or {@method "true"} to abort.
 * @returns "tuple"
 *          The requested suffix.
 * @category "Tuples" "Transformers"
 */
Public method "drop from_until_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	firstIndex ::= first index of aTuple where predicate;
	splitIndex ::=
		if firstIndex = 0
		then [ |aTuple| + 1 ]
		else [ cast firstIndex into [ t : natural number | t ] ];
	aTuple[splitIndex..]
] : tuple;

/**
 * @method "drop from_until_"
 * @restricts "tuple meta"
 * @restricts "[⊥]→boolean's type"
 */
Semantic restriction "drop from_until_" is drop-until semantic restriction;

/**
 * Answer a tuple containing every element of {@param "aTuple"} except for the 
 * first {@param "count"} elements.
 * 
 * @method "drop_from_"
 * @param "count" "whole number"
 *        The size of the prefix of {@param "aTuple"} that should be omitted 
 *        from the result tuple.
 * @param "aTuple" "tuple"
 *        The source tuple.
 * @returns "tuple"
 *          A tuple containing every element but the first {@param "count"} 
 *          elements of {@param "aTuple"}, preserving the original order.
 * @category "Tuples" "Transformers"
 */
Public stable method "drop_from_" is
[
	count : whole number,
	aTuple : tuple
|
	aTuple[count + 1..]
] : tuple;

/**
 * @method "drop_from_"
 * @restricts "whole number's type"
 * @restricts "tuple's type"
 */
Semantic restriction "drop_from_" is
[
	count : whole number's type,
	tupleType : tuple's type
|
	startType ::= cast count + 1's type into [ t : [1..∞)'s type | t ];
	tuple type of tupleType[startType..||tupleType||]
];

Method "_[_]→_" is stable at [tuple, natural number, any]→tuple;

/**
 * Tuple element replacement affects only those elements whose subscripts are
 * instances of the index's type. If multiple subscripts could be affected, then
 * update the element types via type union with the result type. If only a 
 * single subscript could be affected, then simply replace the corresponding 
 * element type with the result type. Leverage instance types if possible.
 * 
 * @method "_[_]→_"
 * @restricts "tuple meta"
 * @restricts "natural number's type"
 * @restricts "any meta"
 */
Semantic restriction "_[_]→_" is
[
	tupleType : tuple meta,
	indexType : natural number's type,
	valueType : any meta
|
	indexLower ::= ⎣indexType⎦;
	If indexLower > ⎡tupleType⎤ then
	[
		Reject parse, expected:
			"a subscript ("
			++ “⎣indexType⎦”
			++ " ≤ theSubscript ≤ "
			++ “⎡indexType⎤”
			++ ") that could ever be valid ("
			++ “⎣tupleType⎦”
			++ " ≤ |theTuple| ≤ "
			++ “⎡tupleType⎤”
			++ ")"
	];
	indexUpper ::= ⎡indexType⎤;
	leadingTypes : <any meta…|> := tupleType's leading types;
	defaultType : any meta := tupleType's default type;
	/* Update any leading types possibly affected by `index`. */
	If indexLower ≤ |leadingTypes| then
	[
		limit ::= indexUpper min |leadingTypes|;
		From indexLower to limit do
		[
			leadingIndex : natural number
		|
			original ::= leadingTypes[leadingIndex];
			/* If only one possible element is affected (because the lower and
			 * upper bound of `index` are equal), then we can simply replace the
			 * element type with `valueType`. Otherwise we have to weaken the
			 * affected elements via type union with `valueType`.
			 */
			replacement ::= if |{indexLower, indexUpper}| = 1
				then [ valueType ]
				else [ original ∪ valueType ];
			newLeadingTypes ::= leadingTypes[leadingIndex]→replacement;
			leadingTypes := cast newLeadingTypes into [ t : <any meta…|> | t ];
		];
	];
	/* Extend the leading types. */
	If indexUpper > |leadingTypes| then
	[
		/* If the lower bound of `index` is greater than the number of leading
		 * types, i.e., the leading types are unaffected by this operation *and*
		 * there may be intervening element types between the last leading type
		 * and the first element type affected, then pad the leading types with
		 * the default type up to the lower bound (exclusive) of `index`.
		 */
		padCount ::= indexLower - |leadingTypes| - 1;
		If padCount > 0 then
		[
			count ::= cast padCount into [ t : natural number | t ];
			leadingTypes := eject ↑leadingTypes ++ count of defaultType;
		];
		/* If the upper bound of `index` is less than the maximum length of the
		 * tuple, then some elements of the result tuple may have the original
		 * default type. Extend the leading types to account for the new
		 * element.
		 */
		If indexUpper < ⎡tupleType⎤ then
		[
			newType ::= if |{indexLower, indexUpper}| = 1
				then [ valueType ]
				else [ defaultType ∪ valueType ];
			delta ::= if indexLower ≤ |leadingTypes| then [ 0 ] else [ 1 ];
			count ::= cast indexUpper - (|leadingTypes| max indexLower)
				into [ t : whole number | t + delta ];
			leadingTypes := eject ↑leadingTypes ++ count of newType;
		]
		/* The upper bound of `index` exceeds the minimum length of the tuple,
		 * so just update the default type.
		 */
		else
		[
			defaultType := eject ↑defaultType ∪ valueType;
		];
	];
	<leadingTypes, defaultType… | ||tupleType||>
];

/**
 * Compute and answer a tuple that is the result of replacing the specified
 * slice of {@param "aTuple"} with {@param "replacement"}.
 * 
 * @method "_[_.._]→_"
 * @param "aTuple" "tuple"
 * @param "sliceStart" "natural number"
 *        The subscript of the first element of the target slice.
 * @param "sliceEnd" "whole number"
 *        The subscript of the last element of the target slice.
 * @param "replacement" "tuple"
 *        The tuple that should be spliced into {@param "aTuple"} instead of the
 *        specified slice.
 * @returns "tuple"
 *          A variant of {@param "aTuple"} whose elements from {@param 
 *          "sliceStart"} (inclusive) to {@param "sliceEnd"} (inclusive) have 
 *          been replaced with those of {@param "replacement"}. Elements before 
 *          {@param "sliceStart"} and after {@param "sliceEnd"} will be present 
 *          in the answer.
 * @category "Tuples" "Transformers"
 */
Public stable method "_[_.._]→_" is
[
	aTuple : tuple,
	sliceStart : natural number,
	sliceEnd : whole number,
	replacement : tuple
|
	If sliceEnd < sliceStart - 1 then
	[
		early failure function(subscript-out-of-bounds code)
	];
	aTuple[..sliceStart - 1] ++ replacement ++ aTuple[sliceEnd + 1..]
] : tuple;

/**
 * Reject the parse if the target slice would never be valid.
 * 
 * @method "_[_.._]→_"
 * @restricts "tuple meta"
 * @restricts "natural number's type"
 * @restricts "whole number's type"
 * @restricts "tuple meta"
 */
Semantic restriction "_[_.._]→_" is
[
	aTuple : tuple meta,
	sliceStart : natural number's type,
	sliceEnd : whole number's type,
	replacement : tuple meta
|
	Require: aTuple[sliceStart..sliceEnd] is ever valid;
	prefixEnd ::= cast sliceStart - 1's type
		into [ t : whole number's type | t ];
	prefix ::= tuple type of aTuple[1's type..prefixEnd];
	suffixStart ::= cast sliceEnd + 1's type
		into [ t : natural number's type | t ];
	suffix ::= tuple type of aTuple[suffixStart..||aTuple||];
	prefix ++ replacement ++ suffix
];

/**
 * Compute and answer that is the result of swapping the elements of {@param
 * "aTuple"} at {@param "index1"} and {@param "index2"}.
 *
 * @method "_[_↔_]"
 * @param "aTuple" "tuple"
 *        A tuple.
 * @param "index1" "natural number"
 *        A subscript.
 * @param "index2" "natural number"
 *        A subscript.
 * @returns "tuple"
 *          A variant of {@param "aTuple"} whose elements at indices {@param
 *          "index1"} and {@param "index2"} have been exchanged. No other
 *          elements are affected.
 * @category "Tuples" "Transformers"
 */
Public stable method "_[_↔_]" is
[
	aTuple : tuple,
	index1 : natural number,
	index2 : natural number
|
	element2 ::= aTuple[index2];
	temp ::= aTuple[index2]→aTuple[index1];
	temp[index1]→element2
] : tuple;

/**
 * @method "_[_↔_]"
 * @restricts "tuple's type"
 * @restricts "natural number's type"
 * @restricts "natural number's type"
 */
Semantic restriction "_[_↔_]" is
[
	aTuple : tuple's type,
	index1 : natural number's type,
	index2 : natural number's type
|
	If ⎣index1⎦ > ⎡aTuple⎤ then
	[
		Reject parse, expected:
			"a subscript ("
			++ “⎣index1⎦”
			++ " ≤ theSubscript ≤ "
			++ “⎡index1⎤”
			++ ") that could ever be valid ("
			++ “⎣aTuple⎦”
			++ " ≤ |theTuple| ≤ "
			++ “⎡aTuple⎤”
			++ ")"
	];
	If ⎣index2⎦ > ⎡aTuple⎤ then
	[
		Reject parse, expected:
			"a subscript ("
			++ “⎣index2⎦”
			++ " ≤ theSubscript ≤ "
			++ “⎡index2⎤”
			++ ") that could ever be valid ("
			++ “⎣aTuple⎦”
			++ " ≤ |theTuple| ≤ "
			++ “⎡aTuple⎤”
			++ ")"
	];
	limit ::= ⎣index1⎦ min ⎣index2⎦;
	leadingTypes ::= aTuple[1..limit - 1];
	defaultType ::= ∪ aTuple[limit..|aTuple's leading types| + 1];
	<leadingTypes, defaultType… | ||aTuple||>
];

/**
 * Obtain the first element of the specified tuple.
 *
 * @method "_'s⁇head"
 * @param "aTuple" "<any…|1..>"
 * @returns "any"
 *          The first element of {@param "aTuple"}.
 * @category "Tuples" "Queries"
 */
Public stable method "_'s⁇head" is
[
	aTuple : <any…|1..>
|
	aTuple[1]
] : any;

/**
 * @method "_'s⁇head"
 * @restricts "<any…|1..>'s type"
 */
Semantic restriction "_'s⁇head" is
[
	aTupleType : <any…|1..>'s type
|
	aTupleType[1]
];

/**
 * Construct and answer a tuple slice that contains all but the first element of
 * the specified tuple. If the argument contains only one element, then answer
 * an empty tuple.
 *
 * @method "_'s⁇tail"
 * @param "aTuple" "<any…|1..>"
 *        A nonempty tuple.
 * @returns "tuple"
 *          The requested tuple slice.
 * @category "Tuples" "Queries"
 */
Public stable abstract method "_'s⁇tail" is [<any…|1..>]→tuple;

Method "_'s⁇tail" is
[
	aTuple : <any…|1>
|
	<>
] : <>'s type;

Method "_'s⁇tail" is
[
	aTuple : <any…|2..>
|
	aTuple[2..]
] : tuple;

/**
 * @method "_'s⁇tail"
 * @restricts "<any…|1..>'s type"
 */
Semantic restriction "_'s⁇tail" is
[
	aTupleType : <any…|1..>'s type
|
	leadingTypes ::= aTupleType's leading types;
	defaultType ::= aTupleType's default type;
	sizeLeadingTypes ::= |leadingTypes|;
	bound ::= ⎡aTupleType⎤;
	lower ::= ⎣aTupleType⎦ - 1;
	if sizeLeadingTypes > 1 then
	[
		<leadingTypes[2..sizeLeadingTypes], defaultType…|[lower..bound)>
	]
	else
	[
		<defaultType…|lower..bound-1>
	]
];

/**
 * Obtain the last element of the specified tuple.
 *
 * @method "_'s⁇last"
 * @param "aTuple" "<any…|1..>"
 * @returns "any"
 *          The last element of a {@param "aTuple"}.
 * @category "Tuples" "Queries"
 */
Public stable method "_'s⁇last" is
[
	aTuple : <any…|1..>
|
	aTuple[|aTuple|]
] : any;

/**
 * @method "_'s⁇last"
 * @restricts "<any…|1..>'s type"
 */
Semantic restriction "_'s⁇last" is
[
	aTupleType : <any…|1..>'s type
|
	upper ::= ⎡aTupleType⎤ min (|aTupleType's leading types| + 1);
	∪ aTupleType[⎣aTupleType⎦..upper]
];

/**
 * Sum the elements of the specified tuple of integers.
 *
 * @method "∑_"
 * @param "intTuple" "<extended integer…|1..∞>"
 *        A tuple of integers.
 * @returns "extended integer"
 *          An integer.
 * @category "Tuples" "Integers" "Mathematics"
 */
Public stable method "∑_" is
[
	intTuple : <extended integer…|1..∞>
|
	left fold intTuple through
		[i : extended integer, ri : extended integer | i + ri]
] : extended integer;

/**
 * Compute and answer the best bounds of the specified summation.
 *
 * @method "∑_"
 * @param "intTupleType" "<extended integer…|1..∞>'s type"
 *        A tuple type whose default type is {@type "extended integer"}.
 * @returns "extended integer's type"
 *          The strongest integer range that can be computed for the argument.
 * @category "Tuples" "Mathematics" "Types"
 */
Method "∑_" is
[
	intTupleType : <extended integer…|1..∞>'s type
|
	leading ::= intTupleType's leading types;
	defaultType ::= intTupleType's default type;
	leadingSize ::= |leading|;
	lowIndex ::= leadingSize min ⎣leading's type⎦;
	lowBound ::=
		if leadingSize > 0 then
		[
			t ::= cast leading[1..lowIndex]
				into [t : <extended integer meta…|1..> | t];
			(∑ map t through [i : extended integer meta | ⎣i⎦])
				+ ((⎣intTupleType⎦ - lowIndex) max 0)
				× ⎣defaultType⎦
		]
		else
		[
			⎣intTupleType⎦ × ⎣defaultType⎦
		];
	upBound ::=
		if leadingSize > 0 then 
		[
			t ::= cast leading[1..lowIndex]
				into [t : <extended integer meta…|1..> | t];
			(∑ map t through [i : extended integer meta | ⎡i⎤])
				+ ⎡intTupleType's default type⎤
				× (⎡intTupleType⎤ - leadingSize)
		]
		else
		[
			⎡intTupleType's default type⎤ × (⎡intTupleType⎤ - leadingSize)
		];
	[lowBound..upBound]
] : extended integer's type;

/**
 * Strengthen the return type
 *
 * @method "∑_"
 * @restricts "<extended integer…|1..∞>'s type"
 */
Semantic restriction "∑_" is
[
	intTupleType : <extended integer…|1..∞>'s type
|
	∑ intTupleType
];

/**
 * Take the product of the elements of a tuple of integers.
 *
 * @method "∏_"
 * @param "intTuple" "<extended integer…|1..∞>"
 *        A tuple of integers.
 * @returns "extended integer"
 *          An integer.
 * @category "Tuples" "Mathematics" "Integers"
 */
Public stable method "∏_" is
[
	intTuple : <extended integer…|1..∞>
|
	left fold intTuple through 
	[
		i : extended integer,
		ri : extended integer
	|
		i × ri
	]
] : extended integer;

/* TODO [RAA]
 * 
 * Strengthen the return type
 *
 * @method "∏_"
 * @restricts "<integer…|1..∞>'s type"
 *
Semantic restriction "∏_" is
[
	intTupleType : <integer…|1..∞>'s type
|
	leading ::= intTupleType's leading types;
	defaultType ::= intTupleType's default type;
	leadingSize ::= |leading|;
	lowIndex ::= leadingSize min ⎣leading's type⎦;
	lowBound ::= if leadingSize > 0 then 
	[
		m ::=  map leading[1..lowIndex] through
		[
			i : any's type
		|
			x::=cast i into [it : integer's type | it];
Print: "x=";
Print: “x”;
			y::= cast (⎣x⎦) into [n : integer | n]
		];
		∏ (cast x into [iTuple : <integer…|1..∞> | iTuple] )); 
Print: "y=";
Print: “y”;

		z::=y × (⎣defaultType⎦ ^ 
				((⎣intTupleType⎦ - lowIndex) max 0));
Print: "z=";
Print: “z”;
		z
			
	]
	else
	[
		⎣defaultType⎦ ^ 
				((⎣intTupleType⎦ - lowIndex) max 0)
	];
	upBound ::= if leadingSize > 0 then 
	[
		(∏ (cast (map leading[1..lowIndex] through
		[
			i : any's type
		|
			x ::= cast i into [it : integer's type | it];
			cast (⎡x⎤) into [n : integer | n]
		]) into [iTuple : <integer…|1..∞> | iTuple] )) × 
			((⎡intTupleType's default type⎤) ^
			(⎡intTupleType⎤ - leadingSize))
	]
	else
	[
		((⎡intTupleType's default type⎤) ^
			(⎡intTupleType⎤ - leadingSize))
	];
	[lowBound..upBound+1)
];*/

/**
 * An implementation of insertion sort that accepts a tuple to be sorted and
 * the predicate that defines how sorting occurs. This only used for sorting
 * small tuples.
 *
 * @method "insertion sort_with_"
 * @category "category"
 * @param "aTuple" "<any…|2..15>" 
 *        The tuple to be sorted.
 * @param "comparator" "[⊥, ⊥]→boolean"
 *        A comparison function that accepts two elements of {@param "aTuple"}
 *        and answers {@method "true"} if the first ≤ second and {@method
 *        "false"} otherwise.
 * @returns "<any|2..15>"
 *          The sorted tuple.
 * @category "Tuples" "Transformers"
 */
Private method "insertion sort_with_" is
[
	aTuple : <any…|2..10>,
	comparator : [⊥, ⊥]→boolean
|
	output : <any…|2..> := aTuple;
	From 2 to |aTuple| do
	[
		i : [2..10]
	|
		j : [1..9] := i-1;
		k : [2..10] := i;
		While [j > 1 ∧ [comparator(output[k],output[j])]]
		do
		[
			output := output[k↔j];
			↑k--;
			↑j--;
		];
		output := if j = 1 ∧ [comparator(output[k],output[j])] then 
			[output[k↔j]] else [output];
	];
	output
] : <any…|2..>;

/**
 * @method "insertion sort_with_"
 * @restricts "<any…|2..10>'s type"
 * @restricts "[⊥, ⊥]→boolean's type"
 */
Semantic restriction "insertion sort_with_" is
[
	tupleType : <any…|2..10>'s type,
	comparator : [⊥, ⊥]→boolean's type
|
	union ::= ∪ tupleType[1..|tupleType's leading types|+1];
	If comparator[1] ≠ ⊥ ∧ [¬union ⊆ comparator[1]] then
	[
		Reject parse, expected:
			"first parameter of comparison function to accept all elements ∈ "
			++ “union”
			++ " of the specified tuple (but it only accepts "
			++ “comparator[1]”
			++ ")"
	];
	If comparator[2] ≠ ⊥ ∧ [¬union ⊆ comparator[2]] then
	[
		Reject parse, expected:
			"second parameter of comparison function to accept all elements ∈ "
			++ “union”
			++ " of the specified tuple (but it only accepts "
			++ “comparator[2]”
			++ ")"
	];
	<union… | ⎣tupleType⎦..⎡tupleType⎤>
];

/**
 * Construct and answer a sorted variant of {@param "numbers"} using the
 * quicksort algorithm.
 *
 * When overriding {@method "quicksort_"}, only target tuple types that contain
 * at least two elements. Not only do the trivial cases of 0 and 1 elements have
 * a simple universal implementation, the 0-element (i.e., empty tuple) case
 * causes ambiguous resolution if multiple overrides exist that will accept it.
 *
 * @method "quicksort_"
 * @param "numbers" "<number…|>"
 *        A tuple of numbers.
 * @returns "<number…|>"
 *          A tuple of numbers in ascending order.
 */
Public abstract method "quicksort_" is [<number…|>]→<number…|>;

/** 
 * Give quicksort higher precedence than concatenation. 
 * 
 * @method "quicksort_"
 * @forbids "1" "«_‡++»"
 */
Grammatical restriction "quicksort_" is <{"«_‡++»"}>;

/**
 * @method "quicksort_"
 * @restricts "tuple meta"
 */
Semantic restriction "quicksort_" is
[
	tupleType : tuple meta
|
	union ::= ∪ tupleType[1..|tupleType's leading types|+1];
	<<>, union… | ||tupleType||>
];

/**
 * An empty tuple is already sorted.
 * 
 * @method "quicksort_"
 * @param "trivial" "<⊥…|0>"
 * @returns "<number…|0>"
 */
Method "quicksort_" is
[
	trivial : <⊥…|0>
|
	trivial
] : <number…|0>;

/**
 * A tuple with one element is already sorted.
 * 
 * @method "quicksort_"
 * @param "trivial" "<number…|1>"
 * @returns "<number…|1>"
 */
Method "quicksort_" is
[
	trivial : <number…|1>
|
	trivial
] : <number…|1>;

Seal method "quicksort_" at <<any…|0..1>>;

/**
 * @method "quicksort_"
 * @param "numbers" "<number…|2..>"
 */
Method "quicksort_" is
[
	numbers : <number…|2..>
|
	/* Choose the median of the first, middle, and last elements as the
	 * pivot.
	 */
	size ::= |numbers|;
	halfSize ::= |numbers| ÷ 2;
	pivotIndex : natural number :=
		if numbers[1] > numbers[size]
		then [1]
		else [size];
	pivotIndex :=
		if numbers[pivotIndex] < numbers[halfSize]
		then [pivotIndex]
		else [
			nonpivotBoundaryIndex : natural number :=
				cast size + 1 - pivotIndex into [t : natural number | t];
			if numbers[nonpivotBoundaryIndex] < numbers[halfSize]
			then [halfSize]
			else [nonpivotBoundaryIndex]];
	pivot ::= numbers[pivotIndex];
	withoutPivot ::= numbers[..pivotIndex-1] ++ numbers[pivotIndex+1..];
	lesser ::= filter withoutPivot by [n : number | n ≤ pivot];
	greater ::= filter withoutPivot by [n : number | n > pivot];
	quicksort lesser ++ <pivot> ++ quicksort greater
];

/**
 * Construct and answer a sorted variant of {@param "aTuple"} using the
 * quicksort algorithm and specified comparison function.
 *
 * @method "quicksort_with_"
 * @param "aTuple" "tuple"
 *        A tuple.
 * @param "comparator" "[⊥, ⊥]→boolean"
 *        A comparison function that accepts two elements of {@param "aTuple"}
 *        and answers {@method "true"} if the first ≤ second and {@method 
 *        "false"} otherwise.
 * @returns "tuple"
 *          A sorted variant of {@param "aTuple"}.
 */
Public abstract method "quicksort_with_" is [tuple, [⊥, ⊥]→boolean]→tuple;

/**
 * @method "quicksort_with_"
 * @restricts "tuple meta"
 * @restricts "[⊥, ⊥]→boolean's type"
 */
Semantic restriction "quicksort_with_" is
[
	tupleType : tuple meta,
	comparator : [⊥, ⊥]→boolean's type
|
	union ::= ∪ tupleType[1..|tupleType's leading types|+1];
	If comparator[1] ≠ ⊥ ∧ [¬union ⊆ comparator[1]] then
	[
		Reject parse, expected:
			"first parameter of comparison function to accept all elements ∈ "
			++ “union”
			++ " of the specified tuple (but it only accepts "
			++ “comparator[1]”
			++ ")"
	];
	If comparator[2] ≠ ⊥ ∧ [¬union ⊆ comparator[2]] then
	[
		Reject parse, expected:
			"second parameter of comparison function to accept all elements ∈ "
			++ “union”
			++ " of the specified tuple (but it only accepts "
			++ “comparator[2]”
			++ ")"
	];
	<<>, union… | ||tupleType||>
];

/**
 * A tuple with no or one element is already sorted.
 * 
 * @method "quicksort_with_"
 * @param "trivial" "<any…|0..1>"
 * @param "comparator" "[⊥, ⊥]→boolean"
 * @returns "<any…|0..1>"
 */
Method "quicksort_with_" is
[
	trivial : <any…|0..1>,
	comparator : [⊥, ⊥]→boolean
|
	trivial
] : <any…|0..1>;

/**
 * @method "quicksort_with_"
 * @param "aTuple" "<any…|2..10>"
 * @param "comparator" "[⊥, ⊥]→boolean"
 */
Method "quicksort_with_" is
[
	aTuple : <any…|2..10>,
	comparator : [⊥, ⊥]→boolean
 |
	insertion sort aTuple with comparator
];

/**
 * @method "quicksort_with_"
 * @param "aTuple" "<any…|11..>"
 * @param "comparator" "[⊥, ⊥]→boolean"
 */
Method "quicksort_with_" is
[
	aTuple : <any…|11..>,
	comparator : [⊥, ⊥]→boolean
|
	/* Choose the median of the first, middle, and last elements as the
	 * pivot.
	 */
	size ::= |aTuple|;
	halfSize ::= |aTuple| ÷ 2;
	pivotIndex : natural number :=
		if comparator(aTuple[1], aTuple[size])
		then [1]
		else [size];
	pivotIndex :=
		if ¬comparator(aTuple[pivotIndex], aTuple[halfSize])
		then [pivotIndex]
		else [halfSize];
	pivot ::= aTuple[pivotIndex];
	withoutPivot ::= aTuple[..pivotIndex-1] ++ aTuple[pivotIndex+1..];
	lesser ::= filter withoutPivot by
		[a : any | comparator(a, pivot)];
	greater ::= filter withoutPivot by
		[a : any | ¬comparator(a, pivot)];
	quicksort lesser with comparator
		++ <pivot>
		++ quicksort greater with comparator
];

Seal method "quicksort_with_" at <tuple, [⊥, ⊥]→boolean>;

/**
 * Take two sorted tuples and merge them into one sorted tuple based upon the
 * criteria provided in the comparison function.
 *
 * @method "merge_with_"
 * @category "Tuples"
 * @param "splitInput" "<tuple…|2>>" 
 *        The two ordered tuples to merge.
 * @param "comparator" "[⊥, ⊥]→boolean"
 *        A comparison function that accepts two elements of {@param "aTuple"}
 *        and answers {@method "true"} if the first ≤ second and {@method 
 *        "false"} otherwise.
 * @returns "tuple"
 *          The merged tuple.
 * @author "Richard Arriaga"
 */
Private method "merge_with_" is
[
	splitInput : <tuple…|2>,
	comparator : [⊥, ⊥]→boolean
 |
	i : natural number := 1;
	j : natural number := 1;
	k : natural number := 1;

	input1 : tuple := splitInput[1];
	input2 : tuple := splitInput[2];
	output : tuple := input1 ++ input2;

	While [i ≤ |input1| ∧  [j ≤ |input2|]]
	do
	[
		If comparator(input1[i], input2[j]) then
		[
			output := output[k]→input1[i];
			↑i++;
		]
		else
		[
			output := output[k]→input2[j];
			↑j++;
		];
		↑k++;
	];
	if i < |input1| then [output[..k-1] ++ input1[i..]]
	else [output[..k-1] ++ input2[j..]]
]: tuple;

/**
 * Construct and answer a sorted variant of {@param "aTuple"} using the
 * merge sort algorithm and specified comparison function.
 *
 * @method "merge sort_with_"
 * @category "Tuples"
 * @param "aTuple" "tuple" 
 *        The tuple to sort.
 * @param "comparator" "[⊥, ⊥]→boolean"
 *        A comparison function that accepts two elements of {@param "aTuple"}
 *        and answers {@method "true"} if the first ≤ second and {@method 
 *        "false"} otherwise.
 * @returns "tuple"
 *          The sorted tuple.
 * @author "Richard Arriaga"
 * @category "Tuples" "Transformations"
 */
Public abstract method "merge sort_with_" is [tuple, [⊥, ⊥]→boolean]→tuple;

/**
 * @method "merge sort_with_"
 * @restricts "tuple meta"
 * @restricts "[⊥, ⊥]→boolean's type"
 */
Semantic restriction "merge sort_with_" is
[
	tupleType : tuple meta,
	comparator : [⊥, ⊥]→boolean's type
|
	union ::= ∪ tupleType[1..|tupleType's leading types|+1];
	If comparator[1] ≠ ⊥ ∧ [¬union ⊆ comparator[1]] then
	[
		Reject parse, expected:
			"first parameter of comparison function to accept all elements ∈ "
			++ “union”
			++ " of the specified tuple (but it only accepts "
			++ “comparator[1]”
			++ ")"
	];
	If comparator[2] ≠ ⊥ ∧ [¬union ⊆ comparator[2]] then
	[
		Reject parse, expected:
			"second parameter of comparison function to accept all elements ∈ "
			++ “union”
			++ " of the specified tuple (but it only accepts "
			++ “comparator[2]”
			++ ")"
	];
	<union… | ⎣tupleType⎦..⎡tupleType⎤>
];

Method "merge sort_with_" is
[
	trivial : <any…|0..1>,
	comparator : [⊥, ⊥]→boolean
|
	trivial
] : <any…|0..1>;

Method "merge sort_with_" is
[
	aTuple : <any…|2..10>,
	comparator : [⊥, ⊥]→boolean
 |
	insertion sort aTuple with comparator
]: tuple;

Public method "merge sort_with_" is
[
	aTuple : <any…|11..>,
	comparator : [⊥, ⊥]→boolean
 |
		left : tuple := merge sort aTuple[..|aTuple| ÷ 2] with comparator;
		right: tuple := merge sort aTuple[|aTuple| ÷ 2 + 1..] with comparator;
		merge <left,right> with comparator
]: tuple;

/**
 * Construct and answer a sorted variant of {@param "aTuple"} of numbers using
 * the merge sort algorithm where n ≤ m.
 *
 * @method "merge sort_"
 * @category "Tuples"
 * @param "aTuple" "<number…|>" 
 *         A tuple.
 * @returns "<number…|>"
 *          The sorted tuple.
 * @author "Richard Arriaga"
 * @category "Tuples" "Transformations"
 */
Public abstract method "merge sort_" is [<number…|>]→<number…|>;

/**
 * Give quicksort higher precedence than concatenation.
 * 
 * @method "merge sort_"
 * @forbids "1" "«_‡++»"
 */
Grammatical restriction "merge sort_" is <{"«_‡++»"}>;

/**
 * @method "merge sort_"
 * @restricts "tuple meta"
 */
Semantic restriction "merge sort_" is
[
	tupleType : tuple meta
|
	union ::= ∪ tupleType[1..|tupleType's leading types|+1];
	<<>, union… | ||tupleType||>
];

/*
 * An empty tuple is already sorted.
 */
Method "merge sort_" is
[
	trivial : <⊥…|0>
|
	trivial
] : <number…|0>;

/*
 * A tuple with one element is already sorted.
 */
Method "merge sort_" is
[
	trivial : <number…|1>
|
	trivial
] : <number…|1>;

Method "merge sort_" is
[
	aTuple : <number…|2..>
 |
	merge sort aTuple with [n : number, m : number | n ≤ m]
];

/**
 * Construct and answer a tuple like {@param "aTuple"}, but with the leftmost
 * occurrence of {@param "doomed"} removed.
 *
 * @method "_-_"
 * @param "aTuple" "tuple"
 *        A tuple.
 * @param "doomed" "any"
 *        A value.
 * @returns "tuple"
 *          The requested tuple, which will be {@param "aTuple"} if there were
 *          no occurrences of {@param "doomed"}.
 * @category "Tuples" "Transformations"
 */
Method "_-_" is
[
	aTuple : tuple,
	doomed : any
|
	index ::= first index of aTuple where [a : any | a = doomed];
	cast index into [i : natural number | aTuple[..i-1] ++ aTuple[i+1..]]
	else [aTuple]
] : tuple;

/**
 * @method "_-_"
 * @restricts "tuple meta"
 * @restricts "any meta"
 */
Semantic restriction "_-_" is
[
	tupleType : tuple meta,
	element : any meta
|
	allDisjoint : boolean := true;
	From 1 to |tuple's leading types| + 1 do
	[
		index : natural number
	|
		If tupleType[index] ∩ element ≠ ⊥ then
		[
			allDisjoint := false;
		];
		allDisjoint
	];
	If allDisjoint then
	[
		tupleType
	]
	else
	[
		union ::= ∪ tupleType[1..|tupleType's leading types|+1];
		<union… | 0 max (⎣tupleType⎦-1).. ⎡tupleType⎤>
	]
];

/**
 * If {@param "start"} and {@param "end"} are valid subscripts representing a 
 * valid range for {@param "aTuple"}, then answer the corresponding subtuple. 
 * Otherwise, answer the result obtained by applying {@param "else"}.
 *
 * @method "_[_.._]else_"
 * @param "aTuple" "tuple"
 *        A {@type "tuple"}.
 * @param "start" "integer"
 *        An {@type "integer"}.
 * @param "end" "integer"
 *        An {@type "integer"}.
 * @param "else" "[]→any"
 *        The function to apply if {@param "start"} through {@param "end"} is not
 *        a valid range of {@param "aTuple"}.
 * @returns "any"
 *          The {@param "start"}-th throught the {@param "end"}-th elements of 
 *          {@param "aTuple"}, or the result of applying {@param "else"} 
 *          (if {@param "index"} is invalid).
 * @category "Tuples" "Queries"
 */
Public method "_[_.._]else_" is
[
	aTuple : tuple,
	start : integer,
	end : integer,
	else : function accepting <> and returning any
|
	if start ∈ [1..|aTuple| + 1] ∧ [end  ∈ [0..|aTuple|] ∧ [start - 1 ≤ end]]
	then [aTuple[cast start into [t : natural number | t]..
		cast end into [t : whole number | t]]]
	else else
] : any;

/**
 * @method "_[_.._]else_"
 * @restricts "tuple meta"
 * @restricts "integer's type"
 * @restricts "integer's type"
 * @restricts "(function accepting <> and returning any)'s type"
 */
Semantic restriction "_[_.._]else_" is
[
	tupleType : tuple meta,
	start : integer's type,
	end : integer's type,
	else : (function accepting <> and returning any)'s type
|
	if ⎣start⎦- 1 > ⎡tupleType⎤ ∨ [⎡start⎤ < 1 ∨ [⎣end⎦ > ⎡tupleType⎤ ∨ 
		[⎡end⎤ < 0 ∨ [⎣start⎦- 1 > ⎡end⎤]]]] then
	[
		else's return type
	]
	else
	[
		min ::= ⎣start⎦ max 1;
		max ::= cast ⎡end⎤ min (|tupleType's leading types| + 1)
			into [t : whole number | t];
		if min - 1 = max then [ <>'s type]
		else 
		[
			union ::= tuple type of tupleType[min's type..max's type];
			if [min..max] ⊆ [1..⎣tupleType⎦] then
			[
				union
			]
			else
			[
				union ∪ else's return type
			]
		]
	]
];

/**
 * If {@param "end"} is a valid subscript representing the end of a valid range
 * for {@param "aTuple"}, then answer the corresponding subtuple. Otherwise,
 * answer the result obtained by applying {@param "else"}.
 *
 * @method "_[.._]else_"
 * @param "aTuple" "tuple"
 *        A {@type "tuple"}.
 * @param "end" "integer"
 *        An {@type "integer"}.
 * @param "else" "[]→any"
 *        The function to apply if 1 through {@param "end"} is not
 *        a valid range of {@param "aTuple"}.
 * @returns "any"
 *          The first through the {@param "end"}-th element of 
 *          {@param "aTuple"}, or the result of applying {@param "else"} 
 *          (if {@param "index"} is invalid).
 * @category "Tuples" "Queries"
 */
Public method "_[.._]else_" is
[
	aTuple : tuple,
	end : integer,
	else : function accepting <> and returning any
|
	aTuple[1..end] else else
] : any;

/**
 * @method "_[.._]else_"
 * @restricts "tuple meta"
 * @restricts "integer's type"
 * @restricts "(function accepting <> and returning any)'s type"
 */
Semantic restriction "_[.._]else_" is
[
	tupleType : tuple meta,
	end : integer's type,
	else : (function accepting <> and returning any)'s type
|
	if ⎣end⎦ > ⎡tupleType⎤ ∨ [⎡end⎤ < 0 ] then
	[
		else's return type
	]
	else
	[
		max ::= cast ⎡end⎤ min (|tupleType's leading types| + 1)
			into [t : whole number | t];
		if max = 0 then [ <>'s type]
		else 
		[
			union ::= tuple type of tupleType[1's type..max's type];
			if [1..max] ⊆ [1..⎣tupleType⎦] then
			[
				union
			]
			else
			[
				union ∪ else's return type
			]
		]
	]
];

/**
 * If {@param "start"} is a valid subscript representing the start of a  
 * valid range for {@param "aTuple"}, then answer the corresponding subtuple. 
 * Otherwise, answer the result obtained by applying {@param "else"}.
 *
 * @method "_[_..]else_"
 * @param "aTuple" "tuple"
 *        A {@type "tuple"}.
 * @param "start" "integer"
 *        An {@type "integer"}.
 * @param "else" "[]→any"
 *        The function to apply if {@param "start"} through the end of aTuple 
 *        is not a valid range of {@param "aTuple"}.
 * @returns "any"
 *          The {@param "start"}-th through the last element of 
 *          {@param "aTuple"}, or the result of applying {@param "else"} 
 *          (if {@param "start"} is invalid).
 * @category "Tuples" "Queries"
 */
Public method "_[_..]else_" is
[
	aTuple : tuple,
	start : integer,
	else : function accepting <> and returning any
|
	aTuple[start..|aTuple|] else else
] : any;

/**
 * @method "_[_..]else_"
 * @restricts "tuple meta"
 * @restricts "integer's type"
 * @restricts "(function accepting <> and returning any)'s type"
 */
Semantic restriction "_[_..]else_" is
[
	tupleType : tuple meta,
	start : integer's type,
	else : (function accepting <> and returning any)'s type
|
	if ⎣start⎦ - 1 > ⎡tupleType⎤ ∨ [⎡start⎤ < 1 ] then
	[
		else's return type
	]
	else
	[
		min ::= ⎣start⎦ max 1;
		max ::= cast ⎡tupleType⎤
			into [t : whole number | t];
		if min - 1 = max then [ <>'s type]
		else 
		[
			union ::= tuple type of tupleType[min's type..max's type];
			if [min..max] ⊆ [1..⎣tupleType⎦] then
			[
				union
			]
			else
			[
				union ∪ else's return type
			]
		]
	]
];

/**
 * A method that calculates all instances of overlap that a tuple has with
 * itself. 
 *
 * @method "self overlap_"
 * @category "Tuples"
 * @param "aTuple" "tuple" 
 *        A tuple.
 * @returns "{tuple→natural number|}"
 *          A map keyed by the strict subtuples of the input tuple with values
 *          of the index on the full tuple that is one position beyond the 
 *          overlap.
 * @author "Richard Arriaga"
 */
Private method "self overlap_" is
[
	aTuple : <any…|1..>
 |
	overlap : {tuple→natural number|} := {};
	position : natural number := 2;
	current : natural number := 1;
	While
	[
		|aTuple| > position
	]
	do
	[
		/*create a map for each state of a tuple, what it would be mapped back
		 * to.  The key is a subtuple of the input tuple, the value is the 
		 * index in the tuple it returns to for the most recent overlap
		 */
		If aTuple[current] = aTuple[position] then
		[
		 	↑current++;
		] 
		else
		[
			current := 1;
		];
		overlap := overlap + aTuple[..position]→current;
		↑position++;
	];
	overlap
] : {tuple→natural number|};

/**
 * Obtain the location of the start of the first occuring subtuple in a 
 * tuple.
 *
 * @method "first index of_in_"
 * @category "Tuples"
 * @param "aTuple" "tuple" 
 *        The tuple within which to search for the subtuple.
 * @param "subtuple" "tuple"
 *        The subtuple to locate in aTuple.
 * @returns "whole number"
 *          The index of the start of the first subtuple, 0 if none.
 * @author "Richard Arriaga"
 * @category "Tuples" "Queries"
 */
Public stable abstract method "first index of_in_" is [tuple,tuple]→whole number;

Method "first index of_in_" is
[
	subtuple : <any…|0>,
	aTuple : <any…|0>
 |
	0
] : 0's type;

Method "first index of_in_" is
[
	subtuple : <any…|1..>,
	aTuple : <any…|0>
 |
	0
] : 0's type;

Method "first index of_in_" is
[
	subtuple : <any…|0>,
	aTuple : <any…|1..>
 |
	0
] : 0's type;

/*
 * Obtain the location of the start of the first occuring subtuple in a 
 * tuple (a substring of a string).  The
 * {@link "http://en.wikipedia.org/wiki/Knuth-Morris-Pratt_algorithm" 
 * Knuth-Moris-Pratt algorithm} is used for this implementation. 
 */
Method "first index of_in_" is
[
	subtuple : <any…|1..>,
	aTuple : <any…|1..>
 |

	if |subtuple| > |aTuple| then [0]
	else if [|subtuple| = 1] then
	[
		/* if the subtuple has only one element, no benefit from KMP, simply
		 * walk through aTuple searching for first element that matches the 
		 * single element of aSubtuple*/
		first index of aTuple where
		[
			a : any
		 |
			a = subtuple[1]
		]
	]
	else
	[
		found : boolean := false;
		subtupleStart : whole number := 0;
		tupleIndex : natural number := 1;
		subtupleIndex : natural number := 1;
		overlapTable : {tuple→natural number|} := self overlap subtuple;
		Until 
		[
			found ∨ [tupleIndex + |subtuple| - subtupleIndex > |aTuple|]
		]
		do
		[
			If aTuple[tupleIndex] = subtuple[subtupleIndex] then
			[
				If subtupleIndex = |subtuple| then 
				[
					found := true;
					subtupleStart := cast tupleIndex - subtupleIndex + 1 into 
						[w : whole number | w];
				]
				else [↑subtupleIndex++;];
			]
			else
			[
			 	subtupleIndex := overlapTable[subtuple[..subtupleIndex]] 
			 		else [1];
			];
			↑tupleIndex++;
		];
		subtupleStart
	]
] : whole number;

/**
 * Obtain the location of the start of every instance of subtuple occuring in a 
 * tuple.
 *
 * @method "all indices of_in_"
 * @category "Tuples"
 * @param "aTuple" "tuple" 
 *        The tuple to search for the subtuple.
 * @param "subtuple" "tuple"
 *        The subtuple to locate in aTuple.
 * @returns "<natural number…|>"
 *          A tuple of the indices of the start of every instance of subtuple,
 *          <> if none.
 * @author "Richard Arriaga"
 * @category "Tuples" "Queries"
 */
Public stable abstract method "all indices of_in_" is 
	[tuple,tuple]→<natural number…|>;

Method "all indices of_in_" is
[
	subtuple : <any…|0>,
	aTuple : <any…|0>
 |
	<>
] : <>'s type;

Method "all indices of_in_" is
[
	subtuple : <any…|1..>,
	aTuple : <any…|0>
 |
	<>
] : <>'s type;

Method "all indices of_in_" is
[
	subtuple : <any…|0>,
	aTuple : <any…|1..>
 |
	<>
] : <>'s type;

/*
 * Obtain the location of the start of every instance of subtuple occuring in a 
 * tuple (a substring of a string).  The 
 * {@link "http://en.wikipedia.org/wiki/Knuth-Morris-Pratt_algorithm" 
 * Knuth-Moris-Pratt algorithm} is used for this implementation. 
 */
Method "all indices of_in_" is
[
	subtuple : <any…|1..>,
	aTuple : <any…|1..>
 |
	if |subtuple| > |aTuple| then [<>]
	else if [|subtuple| = 1] then
	[
		/* if the subtuple has only one element, no benefit from KMP, simply
		 * walk through aTuple searching for first element that matches the 
		 * single element of aSubtuple*/
		all indices of aTuple where
		[
			a : any
		 |
			a = subtuple[1]
		]
	]
	else
	[
		index : natural number := 1;
		occurrences : <natural number…|> := <>;
		w : whole number := 0;
		While [
			index + |subtuple| ≤ |aTuple| 
		]
		do
		[
			w := first index of subtuple in aTuple[index..];
			if w > 0 then 
			[
				occurrences := occurrences ++ <cast w + index - 1 into 
					[n : natural number | n]>;
				index := index + w + |subtuple| - 1;
			]
			else [index := index + |aTuple|;];
		];
		occurrences
	]
] : <natural number…|>;

/**
 * Locate of the first instance of a nonempty subtuple occuring in a nonempty 
 * tuple and replace it with the supplied replacement tuple.
 *
 * @method "replace the first occurrence of_in_with_"
 * @category "Tuples"
 * @param "subtuple" "<any…|1..>"
 *        The subtuple to locate.
 * @param "aTuple" "tuple" 
 *        The tuple to be searched.
 * @param "replacementTuple" "tuple"
 *        The tuple to be swapped with the search tuple.
 * @returns "tuple"
 *        The new tuple with the first occurrence of the subtuple replaced with
 *        the replacement tuple.
 * @author "Richard Arriaga"
 * @category "Tuples" "Transformers"
 */
Public stable abstract method "replace the first occurrence of_in_with_" is 
	[<any…|1..>,tuple,tuple]→tuple;

Method "replace the first occurrence of_in_with_" is
[
	subtuple : <any…|1..>,
	aTuple : <any…|0>,
	replacementTuple : tuple
 |
 	<>
] : <>'s type;

Method "replace the first occurrence of_in_with_" is
[
	subtuple : <any…|1..>,
	aTuple : <any…|1..>,
	replacementTuple : tuple
 |

 	if |subtuple| > |aTuple| then [aTuple]
	else if [subtuple = aTuple] then [replacementTuple]
	else
	[
		subtupleStart : whole number := first index of subtuple in aTuple;
		if subtupleStart = 0 then [aTuple]
		else
		[
		 	index : natural number := cast subtupleStart - 1 into 
		 		[n : natural number | n];
		 	nextIndex : natural number := subtupleStart + |subtuple|; 
		 	aTuple[..index] ++ replacementTuple ++ aTuple[nextIndex..]
		]
	]
] : tuple;
	
Semantic restriction "replace the first occurrence of_in_with_" is
[
	subtuple : <any…|1..>'s type,
	aTuple : tuple's type,
	replacementTuple : tuple's type
 |
 	defaultType ::= ∪ aTuple[1..∞] ∪ ∪replacementTuple[1..∞];
	if ⎡aTuple⎤ = 0 then [<>'s type]
	else if [⎡aTuple⎤ < ⎣subtuple⎦] then [aTuple]
	else if [⎡replacementTuple⎤ < ⎣subtuple⎦] then
	[
	 	lower ::=  cast ⎡aTuple⎤ + ⎡replacementTuple⎤ - ⎣subtuple⎦
	 		into [w : [0..∞) | w];
	 	upper ::= ⎡aTuple⎤;
	 	<defaultType…|lower..upper>
	]
	else if [⎡subtuple⎤ < ⎣replacementTuple⎦] then
	[
	 	lower ::=  cast ⎡aTuple⎤ into [w : [0..∞) | w];
	 	upper ::= cast ⎡aTuple⎤ + ⎣replacementTuple⎦ - ⎡subtuple⎤
	 		into [w : [0..∞) | w];
	 	<defaultType…|lower..upper>
	]
	else if [⎡subtuple⎤ = ⎣replacementTuple⎦ ∧ 
		[⎡replacementTuple⎤ = ⎣subtuple⎦]] then
	[
	 	lower ::=  cast ⎡aTuple⎤ into [w : [0..∞) | w];
	 	upper ::= cast ⎡aTuple⎤ + ⎣replacementTuple⎦ - ⎡subtuple⎤
	 		into [w : [0..∞) | w];
	 	<defaultType…|lower..upper>
	]
	else
	[
	 	lower ::= min <⎣aTuple⎦,⎣replacementTuple⎦>;
	 	upper ::= if ⎡replacementTuple⎤ ≤ ⎡subtuple⎤ then [⎡aTuple⎤]
	 		else [∞];
	 	<defaultType…|lower..upper>
	]
];

/**
 * Replace every instance of a nonempty subtuple occuring in a nonempty tuple 
 * and with the supplied replacement tuple.
 *
 * @method "replace all occurrences of_in_with_"
 * @category "Tuples"
 * @param "subtuple" "<any…|1..>"
 *        The subtuple to be replaced.
 * @param "aTuple" "tuple" 
 *        The tuple to be searched.
 * @param "replacementTuple" "tuple"
 *        The replacement tuple.
 * @returns "tuple"
 *        The new tuple with the all occurrences of the subtuple replaced with
 *        the replacement tuple.
 * @author "Richard Arriaga"
 * @category "Tuples" "Transformers"
 */
Public stable abstract method "replace all occurrences of_in_with_" is 
	[<any…|1..>,tuple,tuple]→tuple;

Method "replace all occurrences of_in_with_" is
[
	subtuple : <any…|1..>,
	aTuple : <any…|0>,
	replacementTuple : tuple
 |
 	<>
] : <>'s type;

Method "replace all occurrences of_in_with_" is
[
	subtuple : <any…|1..>,
	aTuple : <any…|1..>,
	replacementTuple : tuple
 |
	if |subtuple| > |aTuple| then [aTuple]
	else if [subtuple = aTuple] then [replacementTuple]
	else if [|subtuple| = 1] then
	[
		newTuple : tuple := <>;
		index : natural number := 1;
		While [index ≤ |aTuple|] do
		[
			If <aTuple[index]> = subtuple then
			[
			 	newTuple := newTuple ++ replacementTuple;
			] else
			[
				newTuple := newTuple ++ <aTuple[index]>;
			];
			↑index++;
		];
		newTuple
	]
	else
	[
		index : natural number := 1;
		newTuple : tuple := <>;
		w : whole number := 0;
		While [
			index + |subtuple| ≤ |aTuple| 
		]
		do
		[
			w := first index of subtuple in aTuple[index..];
			If w > 0 then 
			[
			 	lastPreSubtupleIndex : natural number := cast w - 2 + index into 
			 		[n : natural number | n];
			 	newTuple := newTuple ++ aTuple[index..lastPreSubtupleIndex] ++
			 		replacementTuple;	
				index := index + w + |subtuple|-1;
			]
			else 
			[
			 	newTuple := newTuple ++ aTuple[index..];
			 	index := index + |aTuple|-1;
			];
		];
		newTuple
	]
] : tuple;
	
Semantic restriction "replace all occurrences of_in_with_" is
[
	subtuple : <any…|1..>'s type,
	aTuple : tuple's type,
	replacementTuple : tuple's type
 |
 	defaultType ::= ∪ aTuple[1..∞] ∪ ∪replacementTuple[1..∞];
	if ⎡aTuple⎤ = 0 then [<>'s type]
	else if [⎡aTuple⎤ < ⎣subtuple⎦] then [aTuple]
	else
	[
	 	lower ::= min <⎣aTuple⎦,⎣replacementTuple⎦>;
	 	upper ::= if ⎡replacementTuple⎤ ≤ ⎡subtuple⎤ then [⎡aTuple⎤]
	 		else [∞];
	 	<defaultType…|lower..upper>
	]
];
