/*
 * Concurrency.avail
 * Copyright © 1993-2015, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Concurrency"
Versions
	"1.0.0 DEV 2014-04-28"
Uses
	"Assertions",
	"Atoms",
	"Bootstrap",
	"Casts",
	"Collections",
	"Control Structures" =
	(
		-"Cast|cast_into_else_",
		-"Cast|cast_into_",
		-"Cast|cast_into«_‡,»«else_»",
		…
	),
	"Definers",
	"Early Conditionals",
	"Enumeration Support",
	"Exceptions",
	"Functions",
	"Literals",
	"Logic",
	"Macro Support",
	"Maps",
	"Math",
	"Objects",
	"Sets",
	"Synchronization",
	"Tuples",
	"Types",
	"Variables"
Names
	/* Fiber-local variable access. */
	"current fiber[_]else_",

	/* Simplified forking. */
	"Fork_",
	"fork_",
	"In_millisecond|milliseconds,⁇fork_",
	"in_millisecond|milliseconds,⁇fork_",

	/* Parallel constructs. */
	"For each of⁇_in parallel«_-way»do_",
	"For each…in|of_§in parallel«_-way»do_",
	"For each…,…in|of_§in parallel«_-way»do_",
	"For each…→…in|of_§in parallel«_-way»do_",
	"Store a runner of_work units into_,\
		\|⁇store a waiter into_,\
		\|⁇store an exception into_",
	"default maximum worker fibers",
	"filter_in parallel«_-way»by_",
	"injector from_to_by_doing_in parallel_-way",
	"map_in parallel«_-way»through_",
	"map each…in|of_§in parallel«_-way»through_",
	"map each…,…in|of_§in parallel«_-way»through_",
	"map each…→…in|of_§in parallel«_-way»through_",
	"map and filter_in parallel«_-way»by_",

	/* Futures. */
	"Cancel_",
	"future",
	"future of_",
	"the future of_",

	/* Exceptions. */
	"worker exception"
Body

/**
 * @method "_'s⁇result"
 * @restricts "filber's type"
 */
Semantic restriction "_'s⁇result" is
[
	fiberType : fiber's type
|
	fiberType's result type
];

/**
 * Require that the specified function type is applicable to the specified
 * argument types. If the function type is not sufficiently well known, then
 * no checks are possible. Otherwise, reject a parse if appropriate.
 *
 * @method "Require:_accepts_"
 * @param "functionType" "function's type"
 * @param "argumentsType" "tuple's type"
 * @returns "⊤"
 */
Private method "Require:forked_accepts_" is
[
	functionType : function's type,
	argumentsType : tuple's type
|
	parametersType ::= functionType's parameters' type;
	parametersSizes ::= ||parametersType||;
	/* If `parameterSizes` = ⊥, then `parametersType` = ⊥. In this case, we
	 * cannot statically ascertain anything interesting about the function and
	 * the arguments to apply.
	 */
	If parametersSizes ≠ ⊥ then
	[
		argumentsSizes ::= ||argumentsType||;
		validSizes ::= parametersSizes ∩ argumentsSizes;
		If validSizes = ⊥ then
		[
			Reject parse, expected:
				"size of argument tuple to be compatible with size of applied\
				\| function's parameter tuple"
		];
	];
];

/**
 * @method "Invoke_with_,⁇forked at priority_"
 * @restricts "function's type"
 * @restricts "tuple's type"
 * @restricts "[0..255]'s type"
 */
Semantic restriction "Invoke_with_,⁇forked at priority_" is
[
	functionType : function's type,
	argumentsType : tuple's type,
	priorityType : [0..255]'s type
|
	Require: forked functionType accepts argumentsType;
	⊤
];

/**
 * @method "invoke_with_,⁇forked at priority_"
 * @restricts "function's type"
 * @restricts "tuple's type"
 * @restricts "[0..255]'s type"
 */
Semantic restriction "invoke_with_,⁇forked at priority_" is
[
	functionType : function's type,
	argumentsType : tuple's type,
	priorityType : [0..255]'s type
|
	Require: forked functionType accepts argumentsType;
	fiber→(functionType's return type)
];

/**
 * @method "In_millisecond|milliseconds,⁇invoke_with_,⁇forked at priority_"
 * @restricts "[0..∞]'s type"
 * @restricts "function's type"
 * @restricts "tuple's type"
 * @restricts "[0..255]'s type"
 */
Semantic restriction
	"In_millisecond|milliseconds,⁇invoke_with_,⁇forked at priority_"
is
[
	delayType : [0..∞]'s type,
	functionType : function's type,
	argumentsType : tuple's type,
	priorityType : [0..255]'s type
|
	Require: forked functionType accepts argumentsType;
	⊤
];

/**
 * @method "in_millisecond|milliseconds,⁇invoke_with_,⁇forked at priority_"
 * @restricts "[0..∞]'s type"
 * @restricts "function's type"
 * @restricts "tuple's type"
 * @restricts "[0..255]'s type"
 */
Semantic restriction
	"in_millisecond|milliseconds,⁇invoke_with_,⁇forked at priority_"
is
[
	delayType : [0..∞]'s type,
	functionType : function's type,
	argumentsType : tuple's type,
	priorityType : [0..255]'s type
|
	Require: forked functionType accepts argumentsType;
	fiber→(functionType's return type)
];

/* Disambiguate fiber-local access and atom property access. They are already
 * disambiguated by types, so this is not strictly necessary.
 */

/**
 * @method "Remove_[_]"
 * @forbids 1 "current fiber"
 */
Grammatical restriction "Remove_[_]" is <{"current fiber"}, ∅>;

/**
 * @method "_[_]"
 * @forbids 1 "current fiber"
 */
Grammatical restriction "_[_]" is <{"current fiber"}, ∅>;

/**
 * @method "_[_]else_"
 * @forbids 1 "current fiber"
 */
Grammatical restriction "_[_]else_" is <{"current fiber"}, ∅, ∅>;

/**
 * @method "_[_]:=_"
 * @forbids 1 "current fiber"
 */
Grammatical restriction "_[_]:=_" is <{"current fiber"}, ∅, ∅>;

/**
 * @method "_∈_"
 * @forbids 2 "current fiber"
 */
Grammatical restriction "_∈_" is <∅, {"current fiber"}>;

/**
 * Answer the value associated with the property {@param "key"} of {@param
 * "aFiber"}. If no such property exists, then answer the result of applying
 * {@param "else"}.
 *
 * @method "current fiber[_]else_"
 * @param "aFiber" "fiber"
 *        A fiber.
 * @param "key" "atom"
 *        The property key.
 * @param "else" "[]→any"
 *        The function to apply if {@param "key"} is not a property of {@param
 *        "aFiber"}.
 * @returns "any" 
 * 		Either the requested property value or the result of applying 
 * 		{@param "else"}.
 * @category "Concurrency" "Queries"
 */
Method "current fiber[_]else_" is
[
	key : atom,
	else : []→any
|
	if key ∈ current fiber
	then [current fiber[key]]
	else else
] : any;

/**
 * Fork a new {@type "fiber"} to apply the specified arity-0 {@type "function"}.
 * The new fiber will run at the same {@method "_'s⁇priority" priority} as the
 * {@method "current fiber"}.
 *
 * @method "Fork_"
 * @param "aFunction" "[]→⊤"
 * @returns "⊤"
 * @category "Concurrency" "Control Structures"
 */
Public method "Fork_" is
[
	aFunction : []→⊤
|
	Invoke aFunction with <> forked at priority current fiber's priority;
] : ⊤;

/**
 * Fork a new {@type "fiber"} to apply the specified arity-0 {@type "function"}.
 * The new fiber will run at the same {@method "_'s⁇priority" priority} as the
 * {@method "current fiber"}.
 *
 * @method "fork_"
 * @param "aFunction" "[]→⊤"
 * @returns "fiber"
 *          The new fiber.
 * @category "Concurrency" "Control Structures"
 */
Public method "fork_" is
[
	aFunction : []→⊤
|
	invoke aFunction with <> forked at priority current fiber's priority
] : fiber;

/**
 * @method "fork_"
 * @restricts "[]→⊤'s type"
 */
Semantic restriction "fork_" is
[
	functionType : []→⊤'s type
|
	fiber→(functionType's return type)
];

/**
 * When at least the specified number of milliseconds have elapsed, fork a new
 * {@type "fiber"} at the {@method "current fiber"}'s priority. The new {@type
 * "fiber"} will invoke the given {@type "function"} with the supplied
 * arguments. A best effort will be made to start the {@type "fiber"} as soon as
 * the delay has expired, but no real-time guarantees are made.
 *
 * @category "Primitives" "Concurrency" "Time" "Control Structures"
 * @method "In_millisecond|milliseconds,⁇fork_"
 * @param "delayMillis" "nonnegative extended integer"
 *        The minimum number of milliseconds to delay the start of the new
 *        fiber.
 * @param "aFunction" "function"
 *        A function.
 * @returns "⊤"
 * @raises "incorrect-number-of-arguments exception"
 * @raises "incorrect-argument-type exception"
 */
Public method "In_millisecond|milliseconds,⁇fork_" is
[
	delay : [0..∞],
	aFunction : []→⊤
|
	In delay milliseconds,
		invoke aFunction with <>
		forked at priority current fiber's priority;
] : ⊤;

/**
 * When at least the specified number of milliseconds have elapsed, fork a new
 * {@type "fiber"} at the {@method "current fiber"}'s priority. The new {@type
 * "fiber"} will invoke the given {@type "function"} with the supplied
 * arguments. A best effort will be made to start the {@type "fiber"} as soon as
 * the delay has expired, but no real-time guarantees are made.
 *
 * @category "Primitives" "Concurrency" "Time" "Control Structures"
 * @method "In_millisecond|milliseconds,⁇fork_"
 * @param "delayMillis" "nonnegative extended integer"
 *        The minimum number of milliseconds to delay the start of the new
 *        fiber.
 * @param "aFunction" "function"
 *        A function.
 * @returns "fiber"
 *          The new fiber.
 * @raises "incorrect-number-of-arguments exception"
 * @raises "incorrect-argument-type exception"
 */
Public method "in_millisecond|milliseconds,⁇fork_" is
[
	delay : [0..∞],
	aFunction : []→⊤
|
	in delay milliseconds,
		invoke aFunction with <>
		forked at priority current fiber's priority
] : fiber;

/**
 * @method "in_millisecond|milliseconds,⁇fork_"
 * @restricts "[0..∞]'s type"
 * @restricts "[]→⊤'s type"
 */
Semantic restriction "in_millisecond|milliseconds,⁇fork_" is
[
	delayType : [0..∞]'s type,
	functionType : []→⊤'s type
|
	fiber→(functionType's return type)
];

/**
 * A worker exception indicates that a worker forked by a parallel construct
 * raised an exception.
 *
 * @type "worker exception"
 * @supertype "cascade exception"
 * @category "Concurrency" "Exceptions"
 */
Public explicit class "worker exception" extends cascade exception;

"expected type" is a new field atom;
"future monitor" is a new field atom;
"completeness" is a new field atom;
"worker fiber" is a new field atom;
"product" is a new field atom;
"killer" is a new field atom;

/**
 * A future is a proxy for an operation that may not have completed yet. If
 * asked for its value prematurely, then it will block the current fiber until
 * the value becomes available.
 *
 * @type "future"
 * @supertype "object"
 * @category "Concurrency"
 * @category "Data Abstractions" "Futures"
 */
Public class "future" extends object
	with fields
		expected type : any's type,
		future monitor : monitor,
		completeness : condition
	with mutable fields
		referable worker fiber : fiber,
		product : any,
		referable killer : exception;

/**
 * Construct and answer a future type that answers futures that produce values
 * of the specified type.
 *
 * @method "future of_"
 * @param "expectedType" "any's type"
 *        The type of value produced by futures of the answered type.
 * @returns "future's type"
 *          The requested future type.
 * @category "Concurrency"
 * @category "Data Abstractions" "Futures" "Types"
 */
Public method "future of_" is
[
	expectedType : any's type
|
	extend future with expected type : expectedType's type
] : future's type;

/**
 * Answer the {@type "future"} of applying the specified {@type "function"} in
 * a new {@type "fiber"}.
 *
 * @method "the future of_"
 * @param "aFunction" "[]→any"
 *        The future whose result is desired.
 * @returns "future"
 *          The requested future.
 * @category "Concurrency" "Control Structures"
 * @category "Data Abstractions" "Futures"
 */
Public method "the future of_" is
[
	aFunction : []→any
|
	result : any;
	ex : exception;
	worker : fiber;
	mutex ::= a monitor named "future monitor";
	cond ::= a condition of mutex 
		such that [ex is assigned ∨ result is assigned];
	worker :=
		fork
		[
			Honor a termination request;
			Lock mutex for
			[
				Guard [result := aFunction();]
				intercept [e : exception | ex := e;]
				ensure
				[
					/* Discard the fiber, to be nice to memory. */
					Clear worker;
					Signal cond;
				];
			];
		];
	a future with
		expected type ::= aFunction's type's return type,
		future monitor ::= mutex,
		completeness ::= cond,
		worker fiber ::= ↑worker,
		product ::= ↑result,
		killer ::= ↑ex
] : future;

/**
 * @method "the future of_"
 * @restricts "[]→any's type"
 */
Semantic restriction "the future of_" is
[
	functionType : []→any's type
|
	extend future with expected type : functionType's return type's type
];

/**
 * Obtain the value of the specified {@type "future"}, parking the current fiber
 * until a value is available if necessary. This method is idempotent, and never
 * parks on a subsequent send.
 *
 * @method "_'s⁇value"
 * @param "aFuture" "future"
 * @returns "any"
 *          The result produced by the future.
 * @raises "worker exception"
 *         If the {@type "fiber"} forked to evaluate the future raised an
 *         {@type "exception"}.
 * @category "Concurrency" "Control Structures"
 * @category "Data Abstractions" "Futures" "Queries"
 */
Method "_'s⁇value" is
[
	aFuture : future
|
	lock aFuture's future monitor for
	[
		Await aFuture's completeness;
		If ↑aFuture's killer is assigned then
		[
			Raise a worker exception with
				causal exception ::= aFuture's killer
		];
		aFuture's product
	]
] : any;

/**
 * @method "_'s⁇value"
 * @restricts "future's type"
 */
Semantic restriction "_'s⁇value" is
[
	futureType : future's type
|
	futureType's expected type's instance
];

/**
 * Cancel evaluation of the specified {@type "future"}. Cancellation is
 * best-effort only; the {@type "fiber"} responsible for evaluation of the
 * future is not obligated to honor a termination request. Cancellation of a
 * resolved future has no effect. Only the first cancellation attempt is
 * permitted to have an effect. Subsequent cancellation attempts are silently
 * ignored.
 *
 * @method "Cancel_"
 * @param "aFuture" "future"
 * @returns "⊤"
 * @category "Concurrency" "Control Structures"
 * @category "Data Abstractions" "Futures"
 */
Public method "Cancel_" is
[
	aFuture : future
|
	/* Opportunistically read the future's worker fiber. If the variable has
	 * become unassigned, then do nothing. Otherwise, clear the variable and
	 * request termination of the worker.
	 */
	Guard
	[
		worker ::= aFuture's worker fiber;
		Clear ↑aFuture's worker fiber;
		Request termination of worker;
	]
	intercept [e : cannot-read-unassigned-variable exception | /* Nothing. */];
] : ⊤;

/**
 * Construct and answer an injector {@type "fiber"} that spawns worker {@type
 * "fiber"}s to apply {@param "action"} to each of the {@type "integer"}s in the
 * implied range, running no more than {@param "limit"} worker {@type "fiber"}s
 * in parallel. The injector honors any {@method "termination request"}s.
 *
 * If possible, then the injector runs at a priority that is {@code "1"} less
 * than the {@method "current fiber"}'s. If possible, then each worker fiber
 * runs at a priority that is {@code "1"} less than than the injector's.
 *
 * While this method is very useful in its own right, it is primarily intended
 * as a building block for higher-level concurrent control structures.
 *
 * @method "injector from_to_by_doing_in parallel_-way"
 * @param "integer" "start"
 *        The start value, inclusive.
 * @param "end" "extended integer"
 *        The end value, inclusive.
 * @param "step" "integer"
 *        The amount by which to adjust the value after each iteration.
 * @param "action" "[⊥]→⊤"
 *        A function that accepts a value in the implied range.
 * @param "limit" "natural number"
 *        The maximum number of worker {@type "fiber"}s that are permitted to
 *        run concurrently.
 * @returns "fiber→⊤"
 * @category "Concurrency" "Control Structures"
 */
Public method "injector from_to_by_doing_in parallel_-way" is
[
	start : integer,
	end : extended integer,
	step : integer,
	action : [⊥]→⊤,
	limit : natural number
|
	sem ::= a semaphore named "injection semaphore" with limit permits;
	invoke
	[
		For each index from start to end by step do
		[
			Honor a termination request;
			Await sem;
			invoke [Guard [action(index);] ensure [Signal sem;];]
			with <>
			forked at priority 0 max current fiber's priority - 1
		];
	]
	with <>
	forked at priority 0 max current fiber's priority - 1
] : fiber→⊤;

Semantic restriction "injector from_to_by_doing_in parallel_-way" is
[
	start : integer's type,
	end : extended integer's type,
	step : integer's type,
	action : [⊥]→⊤'s type,
	limit : natural number's type
|
	Require: action accepts subscripts from start to end by step;
	⊤
];

/**
 * Answer the maximum number of worker {@type "fiber"}s that the standard
 * concurrent control structures will permit to run in parallel when no explicit
 * limit is supplied.
 *
 * @method "default maximum worker fibers"
 * @returns "natural number"
 *          {@code "100"}.
 * @category "Concurrency" "Constants"
 */
Public method "default maximum worker fibers" is [100];

/**
 * Store coordinated {@type "function"}s into the supplied {@type "variable"}s
 * that, in concert, implement a management system for a finite number of
 * work units running in parallel. Each work unit is supplied by the caller as
 * an arity-0 {@type "function"}.
 *
 * @method
 *    "Store a runner of_work units into_,\
 *    \|⁇store a waiter into_,\
 *    \|⁇store an exception into_"
 * @param "workUnitCount" "[0..∞]"
 *        The total number of work units.
 * @param "workUnitRunner" "↑[[]→⊤]→⊤"
 *        A variable into which to store the {@type "function" work unit
 *        runner}. This is a function that accepts a work unit, supplied by the
 *        caller, as an arbitrary {@type "[]→⊤"}. If a work unit raises an
 *        {@type "exception"}, then a {@type "fiber"} waiting for the {@param
 *        "synchronizer"} to complete will resume.
 * @param "synchronizer" "↑[]→⊤"
 *        A variable into which to store a {@type "function"} that the caller
 *        can use to wait for 1) {@param "workUnitCount" all} work units to
 *        complete or 2) an {@type "exception"} to terminate the parallel
 *        control structure.
 * @param "killer" "↑exception"
 *        A variable into which to store an {@type "exception"} that terminates
 *        any work unit.
 * @returns "⊤"
 */
Public method
	"Store a runner of_work units into_,\
	\|⁇store a waiter into_,\
	\|⁇store an exception into_"
is
[
	workUnitCount : [0..∞],
	workUnitRunner : ↑[[]→⊤]→⊤,
	synchronizer : ↑[]→⊤,
	killer : ↑exception
|
	workersFinished : whole number := 0;
	mutex ::= a monitor named "parallel for-each monitor";
	done ::= a condition of mutex
		such that [killer is assigned ∨ workersFinished = workUnitCount];
	/* Write back the worker management function. */
	workUnitRunner ?=
		[
			action : []→⊤
		|
			Guard
			[
				killed ::= lock mutex for [killer is assigned];
				If ¬killed then
				[
					Honor a termination request;
					action();
					Lock mutex for
					[
						workersFinished++;
						Assert: workersFinished ≤ workUnitCount;
						Signal done if satisfied;
					];
				];
			]
			intercept
			[
				e : exception
			|
				Lock mutex for
				[
					/* Only capture the first exception. */
					If killer is unassigned then
					[
						killer ?= e;
						Signal done;
					];
				];
			];
		];
	/* Write back the function that the caller will use to wait until all
	 * workers have finished or an exception is raised.
	 */
	synchronizer ?= [Lock mutex for [Await done;];];
] : ⊤;

/*The following methods, 
 * 	"return type(_,_,_,_)"
 * 	"index return type(_,_,_,_)"
 * evaluate the return types of methods given a tuple input to a block.*/
Private method "«indexed»?return type(_,_,_,_,_)" is
[
 	indexed : boolean,
	aTuple : expression phrase ⇒ tuple,
	optionalLimit : expression phrase ⇒ natural number?,
	action : block phrase ⇒ []→⊤,
	baseReturnType : type,
	anAtom : atom
|
	elementType ::= aTuple's strengthening function();
	aTupleType ::= aTuple's semantic type;
	optionalLimitType ::= optionalLimit's semantic type;
	blockType ::= if indexed then
	[
		indexingType ::= (0 .. ⎡aTupleType⎤+1);
		[elementType, indexingType]→(action's semantic type's return type)
	] else
	[
		[elementType]→(action's semantic type's return type)
	];

	strengthen baseReturnType for call of anAtom 
		using <aTupleType, optionalLimitType, blockType> 
]:type;

/**
 * Concurrently apply {@param "action"} to each consecutive element of {@param
 * "aTuple"}. Wait until all forked {@type "fiber"s} have completed before
 * returning control to the caller.
 * 
 * @method "For each of⁇_in parallel«_-way»do_"
 * @param "aTuple" "tuple"
 * @param "optionalLimit" "natural number?"
 *        If specified, then the maximum number of worker {@type "fiber"}s
 *        permitted to run in parallel. If not specified, then permit {@method
 *        "default maximum worker fibers"} worker {@type "fiber"}s to run in
 *        parallel.
 * @param "action" "[⊥, ⊥]→⊤"
 *        A function that accepts 1) an element of the tuple and 2) the index of
 *        that element.
 * @returns "⊤"
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @category "Concurrency" "Control Structures" "Loops"
 * @category "Collections" "Tuples"
 */
Public method "For each of⁇_in parallel«_-way»do_" is
[
	aTuple : tuple,
	optionalLimit : natural number?,
	action : [⊥, ⊥]→⊤
|
	workUnitRunner : [[]→⊤]→⊤;
	waiter : []→⊤;
	killer : exception;
	Store a runner of |aTuple| work units into ↑workUnitRunner,
		store a waiter into ↑waiter,
		store an exception into ↑killer;
	/* Fork a fiber for each element. */
	limit ::= optionalLimit[1] else [default maximum worker fibers];
	injector ::=
		injector from 1 to |aTuple| by 1 doing
		[
			index : natural number
		|
			current fiber's name := "parallel for-each fiber #" ++ “index”;
			workUnitRunner([action(aTuple[index], index);]);
		] in parallel limit-way;
	waiter();
	/* If there were any exceptions, then raise the one that was captured. */
	If killer is assigned then
	[
		Request termination of injector;
		Raise a worker exception with causal exception ::= killer
	];
] : ⊤;

/**
 * Concurrently apply {@param "action"} to each consecutive element of {@param
 * "aTuple"}. Wait until all forked fibers have completed before returning
 * control to the caller.
 * 
 * @method "For each of⁇_in parallel«_-way»do_"
 * @param "aTuple" "tuple"
 * @param "optionalLimit" "natural number?"
 *        If specified, then the maximum number of worker {@type "fiber"}s
 *        permitted to run in parallel. If not specified, then permit {@method
 *        "default maximum worker fibers"} worker {@type "fiber"}s to run in
 *        parallel.
 * @param "action" "[⊥]→⊤"
 *        A function that accepts the elements of the tuple.
 * @returns "⊤"
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @category "Concurrency" "Control Structures" "Loops"
 * @category "Collections" "Tuples"
 */
Public method "For each of⁇_in parallel«_-way»do_" is
[
	aTuple : tuple,
	optionalLimit : natural number?,
	action : [⊥]→⊤
|
	limit ::= optionalLimit[1] else [default maximum worker fibers];
	For each of aTuple in parallel limit-way do
	[
		element : any,
		ignoredIndex : natural number
	|
		action(element);
	];
] : ⊤;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * If the tuple is certainly nonempty and the function certainly does not
 * complete if applied, then answer ⊥.
 * 
 * @method "For each of⁇_in parallel«_-way»do_"
 * @restricts "tuple meta"
 * @restricts "natural number?'s type"
 * @restricts "function meta"
 */
Semantic restriction "For each of⁇_in parallel«_-way»do_" is
[
	tupleType : tuple meta,
	optionalLimit : natural number?'s type,
	action : function meta
|
	Require: action accepts tupleType (check indices);
	if ⎣tupleType⎦ > 0 ∧ action's return type = ⊥ then [⊥] else [⊤]
];

/*
 * Answer a function that computes a concurrent body function.
 * 
 * @method "concurrent tuple body function(_,_)"
 * @param "anAtom" "atom" the atom that represents the function that the
 * 		macro builds
 * @param "baseReturnType" "type" the base return type of the method
 * @returns "[literal phrase ⇒ token, expression phrase ⇒ tuple, 
 *   block phrase ⇒ []→ boolean]→send phrase ⇒ ⊤"
 *          The requested function.
 */
Private method "concurrent tuple body function(_,_)" is
[
 	anAtom : atom,
 	baseReturnType : type
|
	[
		elementPhrase : literal phrase ⇒ token,
		aTuple : expression phrase ⇒ tuple,
		optionalLimit : expression phrase ⇒ natural number?,
		action : block phrase ⇒ []→⊤
	|
		returnType ::= 
			return type(aTuple, optionalLimit, action, baseReturnType, anAtom);
		statements ::= action's statements;
		blockReturnType ::= cast statements
			into [t : phrase+ | t[|t|]'s semantic type]
			else [⊤];
		name ::= elementPhrase's token's lexeme;
		restricted send anAtom with
		<
			aTuple, 
			optionalLimit,
			«[
				<cast scope map[name] into [d : argument phrase | d]>
			 | 
				statements
			] : blockReturnType»
		> : returnType
	] : send phrase ⇒ ⊤
];

/*
 * Answer a function that computes a concurrent body function.
 * 
 * @method "concurrent two-input tuple body function(_,_)"
 * @param "anAtom" "atom" the atom that represents the function that the
 * 		macro builds
 * @param "baseReturnType" "type" the base return type of the method
 * @returns "[literal phrase ⇒ token, expression phrase ⇒ tuple, 
 *   block phrase ⇒ []→ boolean]→send phrase ⇒ ⊤"
 *          The requested function.
 */
Private method "concurrent two-input tuple body function(_,_)" is
[
 	anAtom : atom,
 	baseReturnType : type
|
	[
		elementPhrase : literal phrase ⇒ token,
		indexPhrase : literal phrase ⇒ token,
		aTuple : expression phrase ⇒ tuple,
		optionalLimit : expression phrase ⇒ natural number?,
		action : block phrase ⇒ []→⊤
	|
		returnType ::= 
			return type(aTuple, optionalLimit, action, baseReturnType, anAtom);
		statements ::= action's statements;
		blockReturnType ::= cast statements
			into [t : phrase+ | t[|t|]'s semantic type]
			else [⊤];
		elementName ::= elementPhrase's token's lexeme;
		indexName ::= indexPhrase's token's lexeme;
		
		castToPhrase ::= [s : nonempty string | 
			cast scope map[s] into [d : argument phrase | d]];
		restricted send anAtom with
		<
			aTuple, 
			optionalLimit,
			«[
				<castToPhrase(elementName), castToPhrase(indexName)>
			 | 
				statements
			] : blockReturnType»
		> : returnType
	] : send phrase ⇒ ⊤
];

/**
 * Concurrently apply {@param "action"} to each consecutive element of {@param
 * "aTuple"}. Wait until all forked fibers have completed before returning
 * control to the caller.
 * 
 * @method "For each…in|of_§in parallel«_-way»do_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aTuple"}.
 * @param "aTuple" "expression phrase ⇒ tuple"
 * @param "optionalLimit" "expression phrase ⇒ natural number?"
 *        If specified, then the maximum number of worker {@type "fiber"}s
 *        permitted to run in parallel. If not specified, then permit {@method
 *        "default maximum worker fibers"} worker {@type "fiber"}s to run in
 *        parallel.
 * @param "action" "block phrase ⇒ []→⊤"
 *        A function that includes the elements of the tuple.
 * @returns "⊤"
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @category "Concurrency" "Control Structures" "Loops"
 * @category "Collections" "Tuples"
 */
Public macro "For each…in|of_§in parallel«_-way»do_" is
	a tuple iteration prefix function,
	concurrent tuple body function($"For each of⁇_in parallel«_-way»do_", ⊤);

/**
 * Concurrently apply {@param "action"} to each consecutive element of {@param
 * "aTuple"}. Wait until all forked {@type "fiber"s} have completed before
 * returning control to the caller.
 * 
 * @method "For each…,…in|of_§in parallel«_-way»do_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aTuple"}.
 * @param "aTuple" "expression phrase ⇒ tuple"
 * @param "optionalLimit" "expression phrase ⇒ natural number?"
 *        If specified, then the maximum number of worker {@type "fiber"}s
 *        permitted to run in parallel. If not specified, then permit {@method
 *        "default maximum worker fibers"} worker {@type "fiber"}s to run in
 *        parallel.
 * @param "action" "block phrase ⇒ []→⊤"
 *        A function that includes 1) an element of the tuple and 2) the index
 *        of that element.
 * @returns "⊤"
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @category "Concurrency" "Control Structures" "Loops"
 * @category "Collections" "Tuples"
 */
Public macro "For each…,…in|of_§in parallel«_-way»do_" is
	a two-input tuple iteration prefix function,
	concurrent two-input tuple body function(
		$"For each of⁇_in parallel«_-way»do_", ⊤);

/*	Test code for building this set of macros
For each n,i of 1 to 10 in parallel do
[
	Print: "i + n=";
	Print: “i + n”;
	Print: "\n";
];*/

/*
 * Answer a function that computes a concurrent body function.
 * 
 * @method "concurrent set body function(_,_)"
 * @param "anAtom" "atom" the atom that represents the function that the
 * 		macro builds
 * @param "baseReturnType" "type" the base return type of the method
 * @returns "[literal phrase ⇒ token, expression phrase ⇒ set, 
 *   block phrase ⇒ []→ boolean]→send phrase ⇒ ⊤"
 *          The requested function.
 */
Private method "concurrent set body function(_,_)" is
[
 	anAtom : atom,
 	baseReturnType : type
|
	[
		elementPhrase : literal phrase ⇒ token,
		aSet : expression phrase ⇒ set,
		optionalLimit : expression phrase ⇒ natural number?,
		action : block phrase ⇒ []→⊤
	|
		name ::= elementPhrase's token's lexeme;
		aSetType ::= aSet's semantic type;
		optionalLimitType ::= optionalLimit's semantic type;
		elementType ::= aSetType's element type;
		blockType ::= 
			[elementType]→(action's semantic type's return type);

		returnType ::= strengthen baseReturnType for call of anAtom 
			using <aSetType, optionalLimitType, blockType>;
	
		statements ::= action's statements;
		blockReturnType ::= cast statements
			into [t : phrase+ | t[|t|]'s semantic type]
			else [⊤];
		restricted send anAtom with
		<
			aSet, 
			optionalLimit,
			«[
			  	<cast scope map[name] into [d : argument phrase | d]>
			 | 
			 	statements
			 ] : blockReturnType»
		> : returnType
	] : send phrase ⇒ ⊤
];

/**
 * Concurrently apply {@param "action"} to each element of {@param
 * "aSet"}. Wait until all forked fibers have completed before returning
 * control to the caller.
 * 
 * @method "For each of⁇_in parallel«_-way»do_"
 * @param "aSet" "set"
 * @param "optionalLimit" "natural number?"
 *        If specified, then the maximum number of worker {@type "fiber"}s
 *        permitted to run in parallel. If not specified, then permit {@method
 *        "default maximum worker fibers"} worker {@type "fiber"}s to run in
 *        parallel.
 * @param "action" "[⊥]→⊤"
 *        A function that accepts an arbitrary element of {@param "aSet"}.
 * @returns "⊤"
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @author "Richard Arriaga"
 * @category "Concurrency" "Control Structures" "Loops"
 * @category "Collections" "Sets"
 */
Public method "For each of⁇_in parallel«_-way»do_" is
[
	aSet : set,
	optionalLimit : natural number?,
	action : [⊥]→⊤
|
	limit ::= optionalLimit[1] else [default maximum worker fibers];
	For each of aSet→tuple in parallel limit-way do
	[
		element : any
	|
		action(element);
	];
] : ⊤;

/**
 * @method "For each of⁇_in parallel«_-way»do_"
 * @restricts "set meta"
 * @restricts "natural number?'s type"
 * @restricts "[⊥]→⊤'s type"
 */
Semantic restriction "For each of⁇_in parallel«_-way»do_" is
[
	setType : set meta,
	optionalLimit : natural number?'s type,
	action : [⊥]→⊤'s type
|
	Require: action accepts setType;
	if ⎣setType⎦ > 0 ∧ action's return type = ⊥ then [⊥] else [⊤]
];

/**
 * Concurrently apply {@param "action"} to each consecutive element of {@param
 * "aSet"}. Wait until all forked fibers have completed before returning
 * control to the caller.
 * 
 * @method "For each…in|of_§in parallel«_-way»do_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aSet"}.
 * @param "aSet" "expression phrase ⇒ set"
 * @param "optionalLimit" "expression phrase ⇒ natural number?"
 *        If specified, then the maximum number of worker {@type "fiber"}s
 *        permitted to run in parallel. If not specified, then permit {@method
 *        "default maximum worker fibers"} worker {@type "fiber"}s to run in
 *        parallel.
 * @param "action" "block phrase ⇒ []→⊤"
 *        A function that includes the elements of the tuple.
 * @returns "⊤"
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @category "Concurrency" "Control Structures" "Loops" "Sets"
 */
Macro "For each…in|of_§in parallel«_-way»do_" is
	a set iteration prefix function,
	concurrent set body function($"For each of⁇_in parallel«_-way»do_", ⊤);

/**
 * Concurrently apply {@param "action"} to each key-value pair of {@param
 * "aMap"}. Wait until all forked fibers have completed before returning
 * control to the caller.
 * 
 * @method "For each of⁇_in parallel«_-way»do_"
 * @param "aMap" "map"
 * @param "optionalLimit" "natural number?"
 *        If specified, then the maximum number of worker {@type "fiber"}s
 *        permitted to run in parallel. If not specified, then permit {@method
 *        "default maximum worker fibers"} worker {@type "fiber"}s to run in
 *        parallel.
 * @param "action" "[⊥, ⊥]→⊤"
 *        A function that accepts 1) a map key and 2) the value at that key
 * @returns "⊤"
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @author "Richard Arriaga"
 * @category "Concurrency" "Control Structures" "Loops"
 * @category "Collections" "Maps"
 */
Public method "For each of⁇_in parallel«_-way»do_" is
[
	aMap : map,
	optionalLimit : natural number?,
	action : [⊥, ⊥]→⊤
|
	limit ::= optionalLimit[1] else [default maximum worker fibers];
	For each of aMap's bindings in parallel limit-way do
	[
		binding : <any…|2>
	|
		action(binding[1],binding[2]);
	];
] : ⊤;

/**
 * @method "For each of⁇_in parallel«_-way»do_"
 * @restricts "map meta"
 * @restricts "natural number?'s type"
 * @restricts "[⊥, ⊥]→⊤'s type"
 */
Semantic restriction "For each of⁇_in parallel«_-way»do_" is
[
	mapType : map meta,
	optionalLimit : natural number?'s type,
	action : [⊥, ⊥]→⊤'s type
|
	Require: action accepts mapType;
	if ⎣mapType⎦ > 0 ∧ action's return type = ⊥ then [⊥] else [⊤]
];

/*
 * Answer a function that computes a body function.
 * 
 * @method "mabody function(_,_)"
 * @param "anAtom" "atom" the atom that represents the function that the
 * 		macro builds
 * @param "baseReturnType" "type" the base return type of the method
 * @returns "[literal phrase ⇒ token, expression phrase ⇒ map, 
 *   block phrase ⇒ []→ boolean]→send phrase ⇒ ⊤"
 *          The requested function.
 */
Private method "concurrent map body function(_,_)" is
[
 	anAtom : atom,
 	baseReturnType : type
|
	[
		keyPhrase : literal phrase ⇒ token,
		valuePhrase : literal phrase ⇒ token,
		aMap : expression phrase ⇒ map,
		optionalLimit : expression phrase ⇒ natural number?,
		action : block phrase ⇒ []→ ⊤
	| 
		keyName ::= keyPhrase's token's lexeme;
		valueName ::= valuePhrase's token's lexeme;
		aMapType ::= aMap's semantic type;
		keyType ::= aMapType's key type;
		optionalLimitType ::= optionalLimit's semantic type;
		
		valueType ::= aMapType's value type;
		blockType ::= 
			[keyType, valueType]→(action's semantic type's return type);

		returnType ::= strengthen baseReturnType for call of anAtom 
				using <aMapType, optionalLimitType, blockType>;

		statements ::= action's statements;
		blockReturnType ::= cast statements
			into [t : phrase+ | t's last's semantic type]
			else [⊤];

		castToPhrase ::= [s : nonempty string | 
			cast scope map[s] into [d : argument phrase | d]];
		restricted send anAtom with
		<
			aMap, 
			optionalLimit,
			«[
			  	<castToPhrase(keyName), castToPhrase(valueName)>
			 | 
			 	statements
			 ] : blockReturnType»
		> : returnType
	] : send phrase ⇒ ⊤
];

/**
 * Concurrently apply {@param "action"} to each consecutive element of {@param
 * "aMap"}. Wait until all forked {@type "fiber"s} have completed before
 * returning control to the caller.
 * 
 * @method "For each…→…in|of_§in parallel«_-way»do_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aMap"}.
 * @param "aMap" "expression phrase ⇒ map"
 * @param "optionalLimit" "expression phrase ⇒ natural number?"
 *        If specified, then the maximum number of worker {@type "fiber"}s
 *        permitted to run in parallel. If not specified, then permit {@method
 *        "default maximum worker fibers"} worker {@type "fiber"}s to run in
 *        parallel.
 * @param "action" "block phrase ⇒ []→⊤"
 *        A function that includes 1) an element of the tuple and 2) the index
 *        of that element.
 * @returns "⊤"
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @category "Concurrency" "Control Structures" "Loops" "Maps"
 */
Macro "For each…→…in|of_§in parallel«_-way»do_" is 
	a map iteration prefix function,
	concurrent map body function($"For each of⁇_in parallel«_-way»do_", ⊤);

"filler" is a new atom;
	
/**
 * Concurrently apply {@param "transformer"} to each consecutive element of
 * {@param "aTuple"}, collecting the results into a new tuple (and preserving
 * ordering of the transformed elements). Answer this tuple.
 *
 * @method "map_in parallel«_-way»through_"
 * @param "aTuple" "tuple"
 * @param "optionalLimit" "natural number?"
 *        If specified, then the maximum number of worker {@type "fiber"}s
 *        permitted to run in parallel. If not specified, then permit {@method
 *        "default maximum worker fibers"} worker {@type "fiber"}s to run in
 *        parallel.
 * @param "transformer" "[⊥, ⊥]→any"
 *        A function that accepts 1) an element of the tuple and 2) the index of
 *        that element.
 * @returns "tuple"
 *          A tuple of results of applications of {@param "transformer"} to the
 *          elements and indices of {@param "aTuple"}.
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @category "Concurrency" "Control Structures" "Loops"
 * @category "Collections" "Tuples" "Transformers"
 */
Public method "map_in parallel«_-way»through_" is
[
	aTuple : tuple,
	optionalLimit : natural number?,
	transformer : [⊥, ⊥]→any
|
	workUnitRunner : [[]→⊤]→⊤;
	waiter : []→⊤;
	killer : exception;
	Store a runner of |aTuple| work units into ↑workUnitRunner,
		store a waiter into ↑waiter,
		store an exception into ↑killer;
	/* Fork a fiber for each element. */
	limit ::= optionalLimit[1] else [default maximum worker fibers];
	lock ::= a non-reentrant mutex named "results mutex";
	results : tuple := |aTuple| of filler;
	injector ::=
		injector from 1 to |aTuple| by 1 doing
		[
			index : natural number
		|
			current fiber's name := "parallel map fiber #" ++ “index”;
			workUnitRunner(
				[
					result ::= transformer(aTuple[index], index);
					Lock lock for [results := eject results[index]→result;];
				]);
		] in parallel limit-way;
	waiter();
	/* If there were any exceptions, then raise the one that was captured. */
	If killer is assigned then
	[
		Request termination of injector;
		Raise a worker exception with causal exception ::= killer
	];
	results
];

/**
 * Concurrently apply {@param "transformer"} to each consecutive element of
 * {@param "aTuple"}, collecting the results into a new tuple (and preserving
 * ordering of the transformed elements). Answer this tuple.
 *
 * @method "map_in parallel«_-way»through_"
 * @param "aTuple" "tuple"
 * @param "transformer" "[⊥]→any"
 *        A function that accepts an element of the tuple.
 * @param "optionalLimit" "natural number?"
 *        If specified, then the maximum number of worker {@type "fiber"}s
 *        permitted to run in parallel. If not specified, then permit {@method
 *        "default maximum worker fibers"} worker {@type "fiber"}s to run in
 *        parallel.
 * @returns "tuple"
 *          A tuple of results of applications of {@param "transformer"} to the
 *          elements of {@param "aTuple"}.
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @category "Concurrency" "Control Structures" "Loops" "Collections" "Tuples" 
 * "Transformers"
 */
Public method "map_in parallel«_-way»through_" is
[
	aTuple : tuple,
	optionalLimit : natural number?,
	transformer : [⊥]→any
|
	limit ::= optionalLimit[1] else [default maximum worker fibers];
	map aTuple in parallel limit-way through
	[
		element : any,
		ignoredIndex : natural number
	|
		transformer(element)
	]
];

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * 
 * @method "map_in parallel«_-way»through_"
 * @restricts "tuple meta"
 * @restricts "natural number?"
 * @restricts "[…]→any's type"
 */
Semantic restriction "map_in parallel«_-way»through_" is
[
	tupleType : tuple meta,
	optionalLimit : natural number?'s type,
	transformer : […]→any's type
|
	Require: transformer accepts tupleType (check indices);
	If ⎣tupleType⎦ > 0 then
	[
		If transformer's return type = ⊥ then
		[
			Reject parse, expected:
				"repeatedly applied function to have a return type other than\
				\| ⊥"
		];
	];
	<<>, transformer's return type… | ||tupleType||>
];

/**
 * Concurrently apply {@param "transformer"} to each consecutive element of
 * {@param "aTuple"}, collecting the results into a new tuple (and preserving
 * ordering of the transformed elements). Answer this tuple.
 * 
 * @method "map each…in|of_§in parallel«_-way»through_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aTuple"}.
 * @param "aTuple" "expression phrase ⇒ tuple"
 * @param "optionalLimit" "expression phrase ⇒ natural number?"
 *        If specified, then the maximum number of worker {@type "fiber"}s
 *        permitted to run in parallel. If not specified, then permit {@method
 *        "default maximum worker fibers"} worker {@type "fiber"}s to run in
 *        parallel.
 * @param "action" "block phrase ⇒ []→⊤"
 *        A function that includes the elements of the tuple.
 * @returns "⊤"
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @category "Concurrency" "Control Structures" "Loops" "Collections" "Tuples"
 * 	"Transformers"
 */
Public macro "map each…in|of_§in parallel«_-way»through_" is
	a tuple iteration prefix function,
	concurrent tuple body function($"map_in parallel«_-way»through_", tuple);

/**
 * Concurrently apply {@param "transformer"} to each consecutive element of
 * {@param "aTuple"}, collecting the results into a new tuple (and preserving
 * ordering of the transformed elements). Answer this tuple.
 *
 * @method "map each…,…in|of_§in parallel«_-way»through_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aTuple"}.
 * @param "aTuple" "expression phrase ⇒ tuple"
 * @param "optionalLimit" "expression phrase ⇒ natural number?"
 *        If specified, then the maximum number of worker {@type "fiber"}s
 *        permitted to run in parallel. If not specified, then permit {@method
 *        "default maximum worker fibers"} worker {@type "fiber"}s to run in
 *        parallel.
 * @param "action" "block phrase ⇒ []→⊤"
 *        A function that includes 1) an element of the tuple and 2) the index
 *        of that element.
 * @returns "⊤"
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @category "Concurrency" "Control Structures" "Loops" "Collections" "Tuples"
 * 	"Transformers"
 */
Public macro "map each…,…in|of_§in parallel«_-way»through_" is
	a two-input tuple iteration prefix function,
	concurrent two-input tuple body function(
		$"map_in parallel«_-way»through_", tuple);

/**
 * Concurrently apply {@param "transformer"} to each element of a 
 * {@param "set"}, collecting the results into a new set.
 *
 * @method "map_in parallel«_-way»through_"
 * @param "aSet" "set"
 * @param "optionalLimit" "natural number?"
 *        If specified, then the maximum number of worker {@type "fiber"}s
 *        permitted to run in parallel. If not specified, then permit {@method
 *        "default maximum worker fibers"} worker {@type "fiber"}s to run in
 *        parallel.
 * @param "transformer" "[⊥]→any"
 *        A function that accepts an arbitrary element of {@param "aSet"}.
 * @returns "set"
 *          A set of results of applications of {@param "transformer"} to the
 *          elements of the original set.
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @category "Concurrency" "Control Structures" "Loops"
 * @category "Collections" "Sets" "Transformers"
 */
Public method "map_in parallel«_-way»through_" is
[
	aSet : set,
	optionalLimit : natural number?,
	transformer : [⊥]→any
|
	workUnitRunner : [[]→⊤]→⊤;
	waiter : []→⊤;
	killer : exception;
	Store a runner of |aSet| work units into ↑workUnitRunner,
		store a waiter into ↑waiter,
		store an exception into ↑killer;
	/* Fork a fiber for each element. */
	aTuple ::= aSet→tuple;
	limit ::= optionalLimit[1] else [default maximum worker fibers];
	lock ::= a non-reentrant mutex named "results mutex";
	results : set := ∅;
	injector ::=
		injector from 1 to |aSet| by 1 doing
		[
			index : natural number
		|
			current fiber's name := "parallel map fiber #" ++ “index”;
			workUnitRunner(
				[
					result ::= transformer(aTuple[index]);
					Lock lock for [results := eject results + result;];
				]);
		] in parallel limit-way;
	waiter();
	/* If there were any exceptions, then raise the one that was captured. */
	If killer is assigned then
	[
		Request termination of injector;
		Raise a worker exception with causal exception ::= killer
	];
	results
] : set;

/**
 * Ensure that the function will accept elements of the set. If the set is
 * certainly nonempty, then the function cannot answer ⊥.
 * 
 * @method "map_in parallel«_-way»through_"
 * @restricts "set meta"
 * @restricts "natural number?'s type"
 * @restricts "[⊥]→any's type"
 */
Semantic restriction "map_in parallel«_-way»through_" is
[
	setType : set meta,
	optionalLimit : natural number?'s type,
	transformer : [⊥]→any's type
|
	Require: transformer accepts setType;
	If ⎣setType⎦ > 0 then
	[
		If transformer's return type = ⊥ then
		[
			Reject parse, expected:
				"repeatedly applied function to have a return type other than\
				\| ⊥"
		];
	];
	{transformer's return type | 1..⎡setType⎤}
];

/**
 * Concurrently apply {@param "transformer"} to each element of a 
 * {@param "set"}, collecting the results into a new set.
 * 
 * @method "map each…in|of_§in parallel«_-way»through_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aSet"}.
 * @param "aSet" "expression phrase ⇒ set"
 * @param "optionalLimit" "expression phrase ⇒ natural number?"
 *        If specified, then the maximum number of worker {@type "fiber"}s
 *        permitted to run in parallel. If not specified, then permit {@method
 *        "default maximum worker fibers"} worker {@type "fiber"}s to run in
 *        parallel.
 * @param "action" "block phrase ⇒ []→⊤"
 *        A function that includes the elements of the set.
 * @returns "⊤"
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @category "Concurrency" "Control Structures" "Loops" "Collections" "Sets"
 * 	"Transformers"
 */
Public macro "map each…in|of_§in parallel«_-way»through_" is
	a set iteration prefix function,
	concurrent set body function($"map_in parallel«_-way»through_", set);

/**
 * Concurrently apply {@param "transformer"} to each binding of a map
 * {@param "map"}, collecting the results into a new map (and preserving
 * the original keys).
 *
 * @method "map_in parallel«_-way»through_"
 * @param "aMap" "map"
 * @param "optionalLimit" "natural number?"
 *        If specified, then the maximum number of worker {@type "fiber"}s
 *        permitted to run in parallel. If not specified, then permit {@method
 *        "default maximum worker fibers"} worker {@type "fiber"}s to run in
 *        parallel.
 * @param "transformer" "[⊥, ⊥]→any"
 *        A function that accepts 1) a key of the map and 2) the value
 *        associated with the key.
 * @returns "map"
 *          A map of results of applications of {@param "transformer"} to the
 *          bindings of {@param "aMap"}.
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @category "Concurrency" "Control Structures" "Loops"
 * @category "Collections" "Maps" "Transformers"
 */
Public method "map_in parallel«_-way»through_" is
[
	aMap : map,
	optionalLimit : natural number?,
	transformer : [⊥, ⊥]→any
|
	workUnitRunner : [[]→⊤]→⊤;
	waiter : []→⊤;
	killer : exception;
	Store a runner of |aMap| work units into ↑workUnitRunner,
		store a waiter into ↑waiter,
		store an exception into ↑killer;
	/* Fork a fiber for each element. */
	bindings ::= aMap's bindings;
	limit ::= optionalLimit[1] else [default maximum worker fibers];
	lock ::= a non-reentrant mutex named "results mutex";
	results : map := {};
	injector ::=
		injector from 1 to |aMap| by 1 doing
		[
			index : natural number
		|
			current fiber's name := "parallel map fiber #" ++ “index”;
			workUnitRunner(
				[
					binding ::= bindings[index];
					key ::= binding[1];
					result ::= transformer(key, binding[2]);
					Lock lock for [results := eject results + key→result;];
				]);
		] in parallel limit-way;
	waiter();
	/* If there were any exceptions, then raise the one that was captured. */
	If killer is assigned then
	[
		Request termination of injector;
		Raise a worker exception with causal exception ::= killer
	];
	results
] : map;

/**
 * Ensure that the function will accept all bindings of the tuple.
 *
 * @method "map_in parallel«_-way»through_"
 * @restricts "map meta"
 * @restricts "natural number?"
 * @restricts "[⊥, ⊥]→any's type"
 */
Semantic restriction "map_in parallel«_-way»through_" is
[
	mapType : map meta,
	optionalLimit : natural number?'s type,
	transformer : [⊥, ⊥]→any's type
|
	Require: transformer accepts mapType;
	If ⎣mapType⎦ > 0 then
	[
		If transformer's return type = ⊥ then
		[
			Reject parse, expected:
				"repeatedly applied function to have a return type other than\
				\| ⊥"
		];
	];
	{mapType's key type → transformer's return type | ||mapType||}
];

/**
 * Concurrently apply {@param "transformer"} to each consecutive element of
 * {@param "aMap"}, collecting the results into a new map (and preserving
 * ordering of the transformed elements). Answer this map.
 *
 * @method "map each…→…in|of_§in parallel«_-way»through_"
 * @param "elementPhrase" "literal phrase ⇒ token"
 *        A {@type "literal phrase"} holding a synthetic {@type "literal token"}
 *        whose value is the name of the loop variable. The generated loop
 *        variable is given the strongest possible type based on the type union
 *        of the leading types and default type of {@param "aMap"}.
 * @param "aMap" "expression phrase ⇒ map"
 * @param "optionalLimit" "expression phrase ⇒ natural number?"
 *        If specified, then the maximum number of worker {@type "fiber"}s
 *        permitted to run in parallel. If not specified, then permit {@method
 *        "default maximum worker fibers"} worker {@type "fiber"}s to run in
 *        parallel.
 * @param "action" "block phrase ⇒ []→⊤"
 *        A function that includes 1) an element of the map and 2) the index
 *        of that element.
 * @returns "⊤"
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @category "Concurrency" "Control Structures" "Loops" "Collections" "Maps"
 * 	"Transformers"
 */
Public macro "map each…→…in|of_§in parallel«_-way»through_" is
	a map iteration prefix function,
	concurrent map body function(
		$"map_in parallel«_-way»through_", map);

/**
 * Concurrently apply {@param "filter"} to each consecutive element of {@param
 * "aTuple"}, collecting elements for which {@param "filter"} answered {@method
 * "true"} into a new tuple (and preserving ordering of the transformed
 * elements). Answer this tuple.
 *
 * @method "filter_in parallel«_-way»by_"
 * @param "aTuple" "tuple"
 * @param "optionalLimit" "natural number?"
 *        If specified, then the maximum number of worker {@type "fiber"}s
 *        permitted to run in parallel. If not specified, then permit {@method
 *        "default maximum worker fibers"} worker {@type "fiber"}s to run in
 *        parallel.
 * @param "predicate" "[⊥, ⊥]→boolean"
 *        A function that accepts 1) an element of the tuple and 2) the index of
 *        that element and answers {@method "true"} if the element should be
 *        accumulated into the result.
 * @returns "tuple"
 *          A tuple of elements from {@param "aTuple"} for which {@param
 *          "filter"} answered {@method "true"}.
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @category "Concurrency" "Control Structures" "Loops"
 * @category "Collections" "Tuples" "Transformers"
 */
Public method "filter_in parallel«_-way»by_" is
[
	aTuple : tuple,
	optionalLimit : natural number?,
	predicate : [⊥, ⊥]→boolean
|
	workUnitRunner : [[]→⊤]→⊤;
	waiter : []→⊤;
	killer : exception;
	Store a runner of |aTuple| work units into ↑workUnitRunner,
		store a waiter into ↑waiter,
		store an exception into ↑killer;
	limit ::= optionalLimit[1] else [default maximum worker fibers];
	lock ::= a non-reentrant mutex named "results mutex";
	results : tuple := |aTuple| of filler;
	injector ::=
		injector from 1 to |aTuple| by 1 doing
		[
			index : natural number
		|
			current fiber's name := "parallel filter fiber #" ++ “index”;
			workUnitRunner(
				[
					element ::= aTuple[index];
					If predicate(element, index) then
					[
						Lock lock for
						[
							results := eject results[index]→element;
						];
					];
				]);
		] in parallel limit-way;
	waiter();
	/* If there were any exceptions, then raise the one that was captured. */
	If killer is assigned then
	[
		Request termination of injector;
		Raise a worker exception with causal exception ::= killer
	];
	select each a from results where [a ≠ filler]
];

/**
 * Concurrently apply {@param "filter"} to each consecutive element of {@param
 * "aTuple"}, collecting elements for which {@param "filter"} answered {@method
 * "true"} into a new tuple (and preserving ordering of the transformed
 * elements). Answer this tuple.
 *
 * @method "filter_in parallel«_-way»by_"
 * @param "aTuple" "tuple"
 * @param "optionalLimit" "natural number?"
 *        If specified, then the maximum number of worker {@type "fiber"}s
 *        permitted to run in parallel. If not specified, then permit {@method
 *        "default maximum worker fibers"} worker {@type "fiber"}s to run in
 *        parallel.
 * @param "predicate" "[⊥, ⊥]→boolean"
 *        A function that accepts an arbitrary element of the tuple and answers
 *        {@method "true"} if the element should be accumulated into the result.
 * @returns "tuple"
 *          A tuple of elements from {@param "aTuple"} for which {@param
 *          "filter"} answered {@method "true"}.
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @category "Concurrency" "Control Structures" "Loops"
 * @category "Collections" "Tuples" "Transformers"
 */
Public method "filter_in parallel«_-way»by_" is
[
	aTuple : tuple,
	optionalLimit : natural number?,
	predicate : [⊥]→boolean
|
	limit ::= optionalLimit[1] else [default maximum worker fibers];
	filter aTuple in parallel limit-way by
	[
		element : any,
		ignored : natural number
	|
		predicate(element)
	]
];

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * 
 * @method "filter_in parallel«_-way»by_"
 * @restricts "tuple meta"
 * @restricts "natural number?"
 * @restricts "[…]→boolean's type"
 */
Semantic restriction "filter_in parallel«_-way»by_" is
[
	tupleType : tuple meta,
	optionalLimit : natural number?'s type,
	predicate : […]→boolean's type
|
	Require: predicate accepts tupleType (check indices);
	if predicate's return type = true's type then [tupleType]
	else
	[
		union ::= ∪ tupleType[1..|tupleType's leading types| + 1];
		sizes ::=
			if predicate's return type = false's type then [0's type]
			else [[0..⎡tupleType⎤ + 1)];
		<<>, union…|sizes>
	]
];

/**
 * Concurrently apply {@param "filter"} to each element of {@param "aSet"},
 * collecting elements for which {@param "filter"} answered {@method "true"}
 * into a new {@type "set"}. Answer this set.
 *
 * @method "filter_in parallel«_-way»by_"
 * @param "aSet" "set"
 * @param "optionalLimit" "natural number?"
 *        If specified, then the maximum number of worker {@type "fiber"}s
 *        permitted to run in parallel. If not specified, then permit {@method
 *        "default maximum worker fibers"} worker {@type "fiber"}s to run in
 *        parallel.
 * @param "predicate" "[⊥]→boolean"
 *        A function that accepts an arbitrary element of the set and answers
 *        {@method "true"} if the element should be accumulated into the result.
 * @returns "set"
 *          The {@type "set" subset} of elements from {@param "aSet"} for which
 *          {@param "filter"} answered {@method "true"}.
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @category "Concurrency" "Control Structures" "Loops"
 * @category "Collections" "Sets" "Transformers"
 */
Public method "filter_in parallel«_-way»by_" is
[
	aSet : set,
	optionalLimit : natural number?,
	predicate : [⊥]→boolean
|
	workUnitRunner : [[]→⊤]→⊤;
	waiter : []→⊤;
	killer : exception;
	Store a runner of |aSet| work units into ↑workUnitRunner,
		store a waiter into ↑waiter,
		store an exception into ↑killer;
	aTuple ::= aSet→tuple;
	limit ::= optionalLimit[1] else [default maximum worker fibers];
	lock ::= a non-reentrant mutex named "results mutex";
	results : set := ∅;
	injector ::=
		injector from 1 to |aTuple| by 1 doing
		[
			index : natural number
		|
			current fiber's name := "parallel filter fiber #" ++ “index”;
			workUnitRunner(
				[
					element ::= aTuple[index];
					If predicate(element) then
					[
						Lock lock for [results := eject results + element;];
					];
				]);
		] in parallel limit-way;
	waiter();
	/* If there were any exceptions, then raise the one that was captured. */
	If killer is assigned then
	[
		Request termination of injector;
		Raise a worker exception with causal exception ::= killer
	];
	results
];

/**
 * Ensure that the function will accept all elements of the set.
 * 
 * @method "filter_in parallel«_-way»by_"
 * @restricts "set meta"
 * @restricts "natural number?"
 * @restricts "[…]→boolean's type"
 */
Semantic restriction "filter_in parallel«_-way»by_" is
[
	setType : set meta,
	optionalLimit : natural number?'s type,
	predicate : […]→boolean's type
|
	Require: predicate accepts setType;
	if predicate's return type = true's type then [setType]
	else if predicate's return type = false's type then [∅'s type]
	else [{setType's element type|[0..⎡setType⎤ + 1)}]
];

/**
 * Concurrently apply {@param "filter"} to each binding of {@param "aMap"},
 * collecting bindings for which {@param "filter"} answered {@method "true"}
 * into a new {@type "map"}. Answer this {@type "map"}.
 *
 * @method "filter_in parallel«_-way»by_"
 * @param "aMap" "map"
 * @param "optionalLimit" "natural number?"
 *        If specified, then the maximum number of worker {@type "fiber"}s
 *        permitted to run in parallel. If not specified, then permit {@method
 *        "default maximum worker fibers"} worker {@type "fiber"}s to run in
 *        parallel.
 * @param "predicate" "[⊥, ⊥]→boolean"
 *        A function that accepts an arbitrary binding of the map and answers
 *        {@method "true"} if the binding should be accumulated into the result.
 * @returns "map"
 *          The {@type "set" submap} of bindings from {@param "aMap"} for which
 *          {@param "filter"} answered {@method "true"}.
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @category "Concurrency" "Control Structures" "Loops"
 * @category "Collections" "Sets" "Transformers"
 */
Public method "filter_in parallel«_-way»by_" is
[
	aMap : map,
	optionalLimit : natural number?,
	predicate : [⊥, ⊥]→boolean
|
	workUnitRunner : [[]→⊤]→⊤;
	waiter : []→⊤;
	killer : exception;
	Store a runner of |aMap| work units into ↑workUnitRunner,
		store a waiter into ↑waiter,
		store an exception into ↑killer;
	aTuple ::= aMap's bindings;
	limit ::= optionalLimit[1] else [default maximum worker fibers];
	lock ::= a non-reentrant mutex named "results mutex";
	results : map := {};
	injector ::=
		injector from 1 to |aTuple| by 1 doing
		[
			index : natural number
		|
			current fiber's name := "parallel filter fiber #" ++ “index”;
			workUnitRunner(
				[
					key, value ::= aTuple[index];
					If predicate(key, value) then
					[
						Lock lock for [results := eject results + key→value;];
					];
				]);
		] in parallel limit-way;
	waiter();
	/* If there were any exceptions, then raise the one that was captured. */
	If killer is assigned then
	[
		Request termination of injector;
		Raise a worker exception with causal exception ::= killer
	];
	results
];

/**
 * Ensure that the function will accept all bindings of the map.
 * 
 * @method "filter_in parallel«_-way»by_"
 * @restricts "map meta"
 * @restricts "natural number?"
 * @restricts "[…]→boolean's type"
 */
Semantic restriction "filter_in parallel«_-way»by_" is
[
	mapType : map meta,
	optionalLimit : natural number?'s type,
	predicate : […]→boolean's type
|
	Require: predicate accepts mapType;
	if predicate's return type = true's type then [mapType]
	else if predicate's return type = false's type then [{}'s type]
	else [{mapType's key type → mapType's value type|[0..⎡mapType⎤ + 1)}]
];

/**
 * Concurrently apply {@param "accumulator"} to each element of {@param
 * "aTuple"} in order to transform and filter its elements into a new tuple,
 * preserving the original ordering. When {@param "accumulator"} is invoked, it
 * is passed a "keeper" function. The keeper function may be invoked to "save" a
 * particular value, i.e, a value that will be copied into the output tuple. The
 * keeper function will save at most one value per element of {@param "aTuple"},
 * i.e. each time that {@param "accumulator"} is invoked, it may invoke the
 * keeper function at most one time. Answer the new tuple.
 *
 * @method "map and filter_in parallel«_-way»by_"
 * @param "aTuple" "tuple"
 * @param "optionalLimit" "natural number?"
 *        If specified, then the maximum number of worker {@type "fiber"}s
 *        permitted to run in parallel. If not specified, then permit {@method
 *        "default maximum worker fibers"} worker {@type "fiber"}s to run in
 *        parallel.
 * @param "accumulator" "[⊥, ⊥, ⊥]→⊤"
 *        A function that accepts 1) an element from {@param "aTuple"}, 2) the 
 *        index of that element, and 3) a keeper function. The keeper function 
 *        accepts an argument of the type that should be saved.
 * @returns "tuple"
 *          A tuple whose elements are those saved by the {@param
 *          "accumulator"}.
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @category "Concurrency" "Control Structures" "Loops"
 * @category "Collections" "Tuples" "Transformers"
 */
Public method "map and filter_in parallel«_-way»by_" is
[
	aTuple : tuple,
	optionalLimit : natural number?,
	accumulator : [⊥, ⊥, ⊥]→⊤
|
	workUnitRunner : [[]→⊤]→⊤;
	waiter : []→⊤;
	killer : exception;
	Store a runner of |aTuple| work units into ↑workUnitRunner,
		store a waiter into ↑waiter,
		store an exception into ↑killer;
	limit ::= optionalLimit[1] else [default maximum worker fibers];
	lock ::= a non-reentrant mutex named "results mutex";
	results : tuple := |aTuple| of filler;
	injector ::=
		injector from 1 to |aTuple| by 1 doing
		[
			index : natural number
		|
			current fiber's name :=
				"parallel map and filter fiber #" ++ “index”;
			workUnitRunner(
				[
					hasAlreadyKept : boolean := false;
					accumulator(
						aTuple[index],
						index,
						[
							saved : any
						|
							If ¬hasAlreadyKept then
							[
								Lock lock for
								[
									results := eject results[index]→saved;
									hasAlreadyKept := true;
								];
							];
						]);
				]);
		] in parallel limit-way;
	waiter();
	/* If there were any exceptions, then raise the one that was captured. */
	If killer is assigned then
	[
		Request termination of injector;
		Raise a worker exception with causal exception ::= killer
	];
	select each a from results where [a ≠ filler]
];

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * Ensure that it does not produce a value.
 * 
 * @method "map and filter_in parallel«_-way»by_"
 * @restricts "tuple meta"
 * @restricts "natural number?"
 * @restricts "[⊥, ⊥, ⊥]→⊤'s type"
 */
Semantic restriction "map and filter_in parallel«_-way»by_" is
[
	tupleType : tuple meta,
	optionalLimit : natural number?'s type,
	accumulator : [⊥, ⊥, ⊥]→⊤'s type
|
	Require: accumulator accepts tupleType (check indices);
	Require: accumulator's keeper is valid;
	If accumulator's return type ≠ ⊤ then
	[
		Reject parse, expected:
			"repeatedly applied function to have return type ⊤"
	];
	paramsType ::= accumulator's parameters' type;
	<
		<>,
		cast accumulator[⎣paramsType⎦] into [t : function meta | t[1]]…
	|
		[0..⎡tupleType⎤ + 1)
	>
];

/**
 * Concurrently apply {@param "accumulator"} to each element of {@param
 * "aTuple"} in order to transform and filter its elements into a new tuple,
 * preserving the original ordering. When {@param "accumulator"} is invoked, it
 * is passed a "keeper" function. The keeper function may be invoked to "save" a
 * particular value, i.e, a value that will be copied into the output tuple. The
 * keeper function will save at most one value per element of {@param "aTuple"},
 * i.e. each time that {@param "accumulator"} is invoked, it may invoke the
 * keeper function at most one time. Answer the new tuple.
 *
 * @method "map and filter_in parallel«_-way»by_"
 * @param "aTuple" "tuple"
 * @param "optionalLimit" "natural number?"
 *        If specified, then the maximum number of worker {@type "fiber"}s
 *        permitted to run in parallel. If not specified, then permit {@method
 *        "default maximum worker fibers"} worker {@type "fiber"}s to run in
 *        parallel.
 * @param "accumulator" "[⊥, ⊥]→⊤"
 *        A function that accepts 1) an element from {@param "aTuple"} and 2) a
 *        keeper function. The keeper function accepts an argument of the type
 *        that should be saved.
 * @returns "tuple"
 *          A tuple whose elements are those saved by the {@param
 *          "accumulator"}.
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @category "Concurrency" "Control Structures" "Loops"
 * @category "Collections" "Tuples" "Transformers"
 */
Public method "map and filter_in parallel«_-way»by_" is
[
	aTuple : tuple,
	optionalLimit : natural number?,
	accumulator : [⊥, ⊥]→⊤
|
	workUnitRunner : [[]→⊤]→⊤;
	waiter : []→⊤;
	killer : exception;
	Store a runner of |aTuple| work units into ↑workUnitRunner,
		store a waiter into ↑waiter,
		store an exception into ↑killer;
	limit ::= optionalLimit[1] else [default maximum worker fibers];
	lock ::= a non-reentrant mutex named "results mutex";
	results : tuple := |aTuple| of filler;
	injector ::=
		injector from 1 to |aTuple| by 1 doing
		[
			index : natural number
		|
			current fiber's name :=
				"parallel map and filter fiber #" ++ “index”;
			workUnitRunner(
				[
					hasAlreadyKept : boolean := false;
					accumulator(
						aTuple[index],
						[
							saved : any
						|
							If ¬hasAlreadyKept then
							[
								Lock lock for
								[
									results := eject results[index]→saved;
									hasAlreadyKept := true;
								];
							];
						]);
				]);
		] in parallel limit-way;
	waiter();
	/* If there were any exceptions, then raise the one that was captured. */
	If killer is assigned then
	[
		Request termination of injector;
		Raise a worker exception with causal exception ::= killer
	];
	select each a from results where [a ≠ filler]
];

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * Ensure that it does not produce a value.
 * 
 * @method "map and filter_in parallel«_-way»by_"
 * @restricts "tuple meta"
 * @restricts "natural number?"
 * @restricts "[⊥, ⊥, ⊥]→⊤'s type"
 */
Semantic restriction "map and filter_in parallel«_-way»by_" is
[
	tupleType : tuple meta,
	optionalLimit : natural number?'s type,
	accumulator : [⊥, ⊥]→⊤'s type
|
	Require: accumulator accepts tupleType;
	Require: accumulator's keeper is valid;
	If accumulator's return type ≠ ⊤ then
	[
		Reject parse, expected:
			"repeatedly applied function to have return type ⊤"
	];
	paramsType ::= accumulator's parameters' type;
	<
		<>,
		cast accumulator[⎣paramsType⎦] into [t : function meta | t[1]]…
	|
		[0..⎡tupleType⎤ + 1)
	>
];

/**
 * Concurrently apply {@param "accumulator"} to each element of {@param
 * "aSet"} in order to transform and filter its elements into a new set. When
 * {@param "accumulator"} is invoked, it is passed a "keeper" function. The
 * keeper function may be invoked to "save" a particular value, i.e, a value
 * that will be copied into the output set. The keeper function will save at
 * most one value per element of {@param "aSet"}, i.e. each time that {@param
 * "accumulator"} is invoked, it may invoke the keeper function at most one
 * time. Answer the new set.
 *
 * @method "map and filter_in parallel«_-way»by_"
 * @param "aSet" "set"
 * @param "optionalLimit" "natural number?"
 *        If specified, then the maximum number of worker {@type "fiber"}s
 *        permitted to run in parallel. If not specified, then permit {@method
 *        "default maximum worker fibers"} worker {@type "fiber"}s to run in
 *        parallel.
 * @param "accumulator" "[⊥, ⊥]→⊤"
 *        A function that accepts 1) an element from {@param "aSet"} and 2) a
 *        keeper function. The keeper function accepts an argument of the type
 *        that should be saved.
 * @returns "set"
 *          A set whose elements are those saved by the {@param "accumulator"}.
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @category "Concurrency" "Control Structures" "Loops"
 * @category "Collections" "Sets" "Transformers"
 */
Public method "map and filter_in parallel«_-way»by_" is
[
	aSet : set,
	optionalLimit : natural number?,
	accumulator : [⊥, ⊥]→⊤
|
	workUnitRunner : [[]→⊤]→⊤;
	waiter : []→⊤;
	killer : exception;
	Store a runner of |aSet| work units into ↑workUnitRunner,
		store a waiter into ↑waiter,
		store an exception into ↑killer;
	limit ::= optionalLimit[1] else [default maximum worker fibers];
	lock ::= a non-reentrant mutex named "results mutex";
	results : set := ∅;
	aTuple ::= aSet→tuple;
	injector ::=
		injector from 1 to |aSet| by 1 doing
		[
			index : natural number
		|
			current fiber's name :=
				"parallel map and filter fiber #" ++ “index”;
			workUnitRunner(
				[
					hasAlreadyKept : boolean := false;
					accumulator(
						aTuple[index],
						[
							saved : any
						|
							If ¬hasAlreadyKept then
							[
								Lock lock for
								[
									results := eject results + saved;
									hasAlreadyKept := true;
								];
							];
						]);
				]);
		] in parallel limit-way;
	waiter();
	/* If there were any exceptions, then raise the one that was captured. */
	If killer is assigned then
	[
		Request termination of injector;
		Raise a worker exception with causal exception ::= killer
	];
	results
];

/**
 * Ensure that the function will accept all elements of the set. Ensure that it
 * does not produce a value.
 * 
 * @method "map and filter_in parallel«_-way»by_"
 * @restricts "set meta"
 * @restricts "natural number?"
 * @restricts "[⊥, ⊥]→⊤'s type"
 */
Semantic restriction "map and filter_in parallel«_-way»by_" is
[
	setType : set meta,
	optionalLimit : natural number?'s type,
	accumulator : [⊥, ⊥]→⊤'s type
|
	Require: accumulator accepts setType;
	Require: accumulator's keeper is valid;
	If accumulator's return type ≠ ⊤ then
	[
		Reject parse, expected:
			"repeatedly applied function to have return type ⊤"
	];
	{
		cast accumulator[2] into [t : function meta | t[1]]
	|
		[0..⎡setType⎤ + 1)
	}
];

/**
 * Concurrently apply {@param "accumulator"} to each binding of {@param "aMap"}
 * in order to transform and filter its elements into a new map. When {@param
 * "accumulator"} is invoked, it is passed a "keeper" function. The keeper
 * function may be invoked to "save" a particular value, i.e, a value that will
 * be copied into the output set. The keeper function will save at most one
 * value per element of {@param "aMap"}, i.e. each time that {@param
 * "accumulator"} is invoked, it may invoke the keeper function at most one
 * time. Answer the new map.
 *
 * @method "map and filter_in parallel«_-way»by_"
 * @param "aMap" "map"
 * @param "optionalLimit" "natural number?"
 *        If specified, then the maximum number of worker {@type "fiber"}s
 *        permitted to run in parallel. If not specified, then permit {@method
 *        "default maximum worker fibers"} worker {@type "fiber"}s to run in
 *        parallel.
 * @param "accumulator" "[⊥, ⊥, ⊥]→⊤"
 *        A function that accepts 1) a key from {@param "aMap"}, 2) the value
 *        associated with that key, and 3) a keeper function. The keeper
 *        function accepts an argument of the (value) type that should be saved.
 * @returns "map"
 *          A map whose bindings are those saved by the {@param "accumulator"}.
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @category "Concurrency" "Control Structures" "Loops"
 * @category "Collections" "Maps" "Transformers"
 */
Public method "map and filter_in parallel«_-way»by_" is
[
	aMap : map,
	optionalLimit : natural number?,
	accumulator : [⊥, ⊥, ⊥]→⊤
|
	workUnitRunner : [[]→⊤]→⊤;
	waiter : []→⊤;
	killer : exception;
	Store a runner of |aMap| work units into ↑workUnitRunner,
		store a waiter into ↑waiter,
		store an exception into ↑killer;
	limit ::= optionalLimit[1] else [default maximum worker fibers];
	lock ::= a non-reentrant mutex named "results mutex";
	results : map := {};
	bindings ::= aMap's bindings;
	injector ::=
		injector from 1 to |aMap| by 1 doing
		[
			index : natural number
		|
			current fiber's name :=
				"parallel map and filter fiber #" ++ “index”;
			workUnitRunner(
				[
					hasAlreadyKept : boolean := false;
					key, value ::= bindings[index];
					accumulator(
						key,
						value,
						[
							saved : any
						|
							If ¬hasAlreadyKept then
							[
								Lock lock for
								[
									results := eject results + key→saved;
									hasAlreadyKept := true;
								];
							];
						]);
				]);
		] in parallel limit-way;
	waiter();
	/* If there were any exceptions, then raise the one that was captured. */
	If killer is assigned then
	[
		Request termination of injector;
		Raise a worker exception with causal exception ::= killer
	];
	results
];

/**
 * Ensure that the function will accept all bindings of the map. Ensure that it
 * does not produce a value.
 * 
 * @method "map and filter_in parallel«_-way»by_"
 * @restricts "map meta"
 * @restricts "natural number?"
 * @restricts "[⊥, ⊥, ⊥]→⊤'s type"
 */
Semantic restriction "map and filter_in parallel«_-way»by_" is
[
	mapType : map meta,
	optionalLimit : natural number?'s type,
	accumulator : [⊥, ⊥, ⊥]→⊤'s type
|
	Require: accumulator accepts mapType;
	Require: accumulator's keeper is valid;
	If accumulator's return type ≠ ⊤ then
	[
		Reject parse, expected:
			"repeatedly applied function to have return type ⊤"
	];
	valueType ::= cast accumulator[3] into [t : function meta | t[1]];
	{mapType's key type → valueType | [0..⎡mapType⎤ + 1)}
];

/**
 * @method "a|an_«with«_«:»?:=_‡,»»"
 * @forbids 1 "future"
 */
Grammatical restriction "a|an_«with«_«:»?:=_‡,»»" is <{"future"}, ∅, ∅>;
