/*
 * Early Tuples.avail
 * Copyright © 1993-2014, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Early Tuples"
Versions
	"1.0.0 DEV 2014-04-28"
Extends
Uses
	"Bootstrap",
	"Collections" = ("_[_]else_"),
	"Definers",
	"Early Conditionals",
	"Early Control Structures",
	"Early Logic",
	"Early Math",
	"Enumeration Support",
	"Literals",
	"Variables"
Names
	"relevant`|_`|",
	"«_‡++»",
	"_[_..]",
	"_[.._]",
	"_*",
	"_+",
	"_`?",

	"UUID",
	"a UUID",

	"serialize_",
	"deserialize_from_",

	/* Exported for use by Tuples. */
	"Require:_[_.._]is ever valid",
	"tuple type of_[_.._]"
Body

/**
 * @method "_'s⁇default type"
 * @restricts "tuple meta's type"
 */
Semantic restriction "_'s⁇default type" is
[
	meta : tuple meta's type
|
	t ::= meta's instance;
	(∪ t[1 max ⎣t⎦..⎡t⎤])'s type
];

/**
 * Strengthen concatenation of tuple types. This is the most specific type whose
 * instance encompasses all possible concatenations of the two types.
 * 
 * @method "_++_"
 * @restricts "tuple meta's type"
 * @restricts "tuple meta's type"
 */
Semantic restriction "_++_" is
[
	metaA : tuple meta's type,
	metaB : tuple meta's type
|
	typeA ::= metaA's instance;
	typeB ::= metaB's instance;
	(typeA ++ typeB)'s type
];

/**
 * Make tuple type concatenation left-associative.
 * 
 * @method "_++_"
 * @forbids 2 "_++_"
 */
Grammatical restriction {"_++_"} is <∅, {"_++_"}>;

/**
 * Concatenate the lexically specified tuples. Answer the result.
 * 
 * @method "«_‡++»"
 * @param "tuples" "<tuple…|2..>"
 *        Some tuples.
 * @returns "tuple"
 *          The result of concatenating the lexically specified tuples
 *          left-to-right.
 * @category "Tuples" "Strings" "Transformers"
 */
Public method "«_‡++»" is
[
	tuples : <<>, tuple…|[2..∞)>
|
	Primitive 136;
] : tuple;

/**
 * Don't parse {@method "«_‡++»"} recursively.
 * 
 * @method "«_‡++»"
 * @forbids 1 "«_‡++»"
 */
Grammatical restriction "«_‡++»" is <{"«_‡++»"}>;

/**
 * Strengthen the lexical tuple concatenation operation.
 * 
 * @method "«_‡++»"
 * @restricts "<tuple…|2..>'s type"
 */
Semantic restriction "«_‡++»" is
[
	tuplesType : <<>, tuple…|[2..∞)>'s type
|
	result : tuple meta := tuplesType[1];
	From 2 to ⎡tuplesType⎤ do
	[
		index : natural number
	|
		result := eject result ++ tuplesType[index];
		true
	];
	result
];

/**
 * Compute and answer the minimum size of {@param "tupleType"} for efficient
 * traversal of its relevant element types.
 * 
 * @method "relevant`|_`|"
 * @param "tupleType" "tuple meta"
 * @returns "whole number"
 *    The smaller of the lower bound of the argument's cardinality and one more
 *    than the size of its leading types.
 * @category "Tuples" "Types" "Queries"
 */
Public method "relevant`|_`|" is
[
	tupleType : tuple meta
|
	lower ::= ⎣tupleType⎦ max 0;
	count ::= |tupleType's leading types| + 1;
	cast lower min count into [ t : whole number | t ]
] : whole number;

/**
 * There are no relevant element types when the tuple type is ⊥.
 * 
 * @method "relevant`|_`|"
 * @param "tupleType" "⊥"
 * @returns "0's type".
 */
Public method "relevant`|_`|" is
[
	tupleType : ⊥'s type
|
	0
] : 0's type;

/**
 * Check that the tuple type and start and end subscript ranges could ever be
 * statically valid. Reject the current parse if they are never valid together.
 * 
 * @method "Require:_[_.._]is ever valid"
 * @param "aTuple" "tuple meta"
 *        A tuple type.
 * @param "sliceStart" "natural number's type"
 *        The integral range of the start subscript.
 * @param "sliceEnd" "whole number's type"
 *        The integral range of the end subscript.
 * @returns "⊤"
 * @category "Assertions" "Tuples" "Types"
 */
Public method "Require:_[_.._]is ever valid" is
[
	aTuple : tuple meta,
	sliceStart : natural number's type,
	sliceEnd : whole number's type
|
	If ⎣sliceStart⎦ > ⎡aTuple⎤+1 then
	[
		Reject parse, expected:
			"a subscript ("
			++ “⎣sliceStart⎦”
			++ " ≤ sliceStart ≤ "
			++ “⎡sliceStart⎤”
			++ ") that could ever be valid ("
			++ “⎣aTuple⎦”
			++ " ≤ |theTuple| ≤ "
			++ “⎡aTuple⎤”
			++ ")"
	];
	If ⎣sliceEnd⎦ > ⎡aTuple⎤ then
	[
		Reject parse, expected:
			"a subscript ("
			++ “⎣sliceEnd⎦”
			++ " ≤ sliceEnd ≤ "
			++ “⎡sliceEnd⎤”
			++ ") that could ever be valid ("
			++ “⎣aTuple⎦”
			++ " ≤ |theTuple| ≤ "
			++ “⎡aTuple⎤”
			++ ")"
	];
	If ⎡sliceEnd⎤ < ⎣sliceStart⎦ - 1 then
	[
		Reject parse, expected:
			"a slice end subscript ("
			++ “⎣sliceEnd⎦”
			++ " ≤ theEndSubscript ≤ "
			++ “⎡sliceEnd⎤”
			++ ") not guaranteed more than one less than the start\
			\| subscript ("
			++ “⎣sliceStart⎦”
			++ " ≤ theStartSubscript ≤ "
			++ “⎡sliceStart⎤”
			++ ")"
	];
] : ⊤;

/**
 * Construct and answer the tuple type that represents the specified tuple
 * slice.
 * 
 * @method "tuple type of_[_.._]"
 * @param "aTupleType" "tuple meta"
 *        A tuple type.
 * @param "sliceStart" "natural number's type"
 *        The type of the slice start subscript.
 * @param "sliceEnd" "whole number's type"
 *        The type of the slice end subscript.
 * @returns "tuple meta"
 *          The strongest tuple type that can be constructed from the argument
 *          types.
 * @category "Assertions" "Tuples" "Types"
 */
Public method "tuple type of_[_.._]" is
[
	aTupleType : tuple meta,
	sliceStart : natural number's type,
	sliceEnd : whole number's type
|
	Require: aTupleType[sliceStart..sliceEnd] is ever valid;
	minStart ::= 1 max ⎣sliceStart⎦;
	maxStart ::= 1 max ⎡sliceStart⎤;
	minEnd ::= 0 max ⎣sliceEnd⎦;
	maxEnd ::= 0 max ⎡sliceEnd⎤;
	tupleEnd ::= ⎡aTupleType⎤;
	tupleDefaultTypeIndex ::= cast |aTupleType's leading types| + 1
		into [ t : natural number | t ];
	limit ::= maxEnd min tupleEnd min tupleDefaultTypeIndex;
	minLoopStart ::= (minStart min limit) max 1;
	maxLoopStart ::= (maxStart min limit) max 1;
	smearDelta ::= cast maxLoopStart - minLoopStart
		into [ t : whole number | t ];
	/* Build a tuple that represents the leading and default types of the
	 * resultant tuple type. Each element is the type union of the smear of
	 * element types within `smearDelta` of the traversal subscript.
	 */
	types : tuple of any meta := <>;
	From minLoopStart to limit do
	[
		i : natural number
	|
		union : type := ⊥;
		smearEnd ::= cast (i + smearDelta) min limit
			into [ t : natural number | t ];
		From i to smearEnd do
		[
			j : natural number
		|
			union := eject union ∪ aTupleType[j];
			true
		];
		types := cast concatenate <types, <union>>
			into [ t : tuple of any meta | t ];
		true
	];
	/* Unless `types` is empty, the last element is the default type. */
	defaultType ::= cast |types|
		into [ n : natural number | types[n] ]
		else [ ⊥ ];
	resultMinEnd ::= minEnd min tupleEnd;
	resultMaxEnd ::= maxEnd min tupleEnd;
	resultStart ::= cast (resultMinEnd - maxStart + 1) max 0
		into [ t : whole number | t ];
	resultEnd ::= cast ((resultMaxEnd - minStart + 1) max 0) + 1
		into [ t : [1..∞] | t ];
	resultSizes ::= [resultStart..resultEnd);
	result ::= <types, defaultType…|resultSizes>;
	result
] : tuple meta;

Method "_[_.._]" is stable at
	function accepting <tuple, natural number, whole number>
	and returning tuple;

/**
 * @method "_[_.._]"
 * @restricts "tuple meta"
 * @restricts "natural number's type"
 * @restricts "whole number's type"
 */
Semantic restriction "_[_.._]" is
[
	aTupleType : tuple meta,
	sliceStart : natural number's type,
	sliceEnd : whole number's type
|
	tuple type of aTupleType[sliceStart..sliceEnd]
];

/* Helper for restriction of "_[_.._]" on a tuple type. */

/**
 * @method "tuple meta of_[_.._]"
 * @param "aTupleMeta" "tuple meta's type"
 *        A tuple type.
 * @param "sliceStart" "natural number's type"
 *        The type of the slice start subscript.
 * @param "sliceEnd" "whole number's type"
 *        The type of the slice end subscript.
 * @returns "tuple meta"
 */
Private method "tuple meta of_[_.._]" is
[
	aTupleMeta : tuple meta's type,
	sliceStart : natural number's type,
	sliceEnd : whole number's type
|
	aTupleType ::= aTupleMeta's instance;
	Require: aTupleType[sliceStart..sliceEnd] is ever valid;
	minStart ::= 1 max ⎣sliceStart⎦;
	maxStart ::= 1 max ⎡sliceStart⎤;
	minEnd ::= 0 max ⎣sliceEnd⎦;
	maxEnd ::= 0 max ⎡sliceEnd⎤;
	tupleEnd ::= ⎡aTupleType⎤;
	tupleDefaultTypeIndex ::= cast |aTupleType's leading types| + 1
		into [ t : natural number | t ];
	limit ::= maxEnd min tupleEnd min tupleDefaultTypeIndex;
	minLoopStart ::= (minStart min limit) max 1;
	maxLoopStart ::= (maxStart min limit) max 1;
	smearDelta ::= cast maxLoopStart - minLoopStart
		into [ t : whole number | t ];
	/* Build a tuple that represents the leading and default types of the
	 * resultant tuple type. Each element is the type union of the smear of
	 * element types within `smearDelta` of the traversal subscript.
	 */
	types : <<>, any meta's type…|whole number> := <>;
	From minLoopStart to limit do
	[
		i : natural number
	|
		union : type := ⊥;
		smearEnd ::= cast (i + smearDelta) min limit
			into [ t : natural number | t ];
		From i to smearEnd do
		[
			j : natural number
		|
			union := eject union ∪ (aTupleType[j]'s type);
			true
		];
		types := cast concatenate <types, <union>>
			into [ t : <<>, any meta's type…|whole number> | t ];
		true
	];
	/* Unless `types` is empty, the last element is the default type. */
	defaultType ::= cast |types|
		into [ n : natural number | types[n] ]
		else [ ⊥ ];
	resultMinEnd ::= minEnd min tupleEnd;
	resultMaxEnd ::= maxEnd min tupleEnd;
	resultStart ::= cast (resultMinEnd - maxStart + 1) max 0
		into [ t : whole number | t ];
	resultEnd ::= cast ((resultMaxEnd - minStart + 1) max 0) + 1
		into [ t : [1..∞] | t ];
	resultSizes ::= [resultStart..resultEnd);
	result ::= <types, defaultType…|resultSizes>;
	result
] : tuple meta;

/**
 * @method "_[_.._]"
 * @restricts "tuple meta"
 * @restricts "natural number's type"
 * @restricts "whole number's type"
 */
Semantic restriction "_[_.._]" is
[
	aTupleType : tuple meta's type,
	sliceStart : natural number's type,
	sliceEnd : whole number's type
|
	tuple meta of aTupleType[sliceStart..sliceEnd]
];

/**
 * Construct and answer a slice (i.e., tuple type) that begins at subscript
 * {@param "sliceStart"} and continues to the end of the tuple type.
 * 
 * @method "_[_..]"
 * @param "aTupleType" "tuple meta"
 *        A tuple type.
 * @param "sliceStart" "natural number"
 *        The one-based start index (inclusive) of the desired slice.
 * @returns "tuple of any meta"
 *          The requested tuple.
 * @category "Tuples" "Types" "Queries"
 */
Public method "_[_..]" is
[
	aTupleType : tuple meta,
	sliceStart : natural number
|
	aTupleType[sliceStart..relevant |aTupleType|]
] : tuple of any meta;

/**
 * Construct and answer a slice (i.e., subtuple) that begins at subscript
 * {@param "sliceStart"} and continues to the end of the tuple.
 * 
 * @method "_[_..]"
 * @param "aTuple" "tuple"
 *        A tuple.
 * @param "sliceStart" "natural number"
 *        The one-based start index (inclusive) of the desired slice.
 * @returns "tuple"
 *          The requested tuple.
 * @category "Tuples" "Types" "Queries"
 */
Public stable method "_[_..]" is
[
	aTuple : tuple,
	sliceStart : natural number
|
	aTuple[sliceStart..|aTuple|]
] : tuple;

/**
 * Strengthen the tuple type produced by {@param "_[_..]"} to the strongest
 * possible given the argument types.
 *
 * @method "_[_..]"
 * @restricts "aTupleType" "tuple meta"
 * @restricts "sliceStart" "natural number's type"
 */
Semantic restriction "_[_..]" is
[
	aTupleType : tuple meta,
	sliceStart : natural number's type
|
	tuple type of aTupleType[sliceStart..||aTupleType||]
];

/**
 * Construct and answer a slice (i.e., tuple type) that begins at the start of
 * the tuple type and continues to subscript {@param "sliceEnd"}.
 * 
 * @method "_[.._]"
 * @param "aTupleType" "tuple meta"
 *        A tuple type.
 * @param "sliceEnd" "whole number"
 *        The one-based end index (inclusive) of the desired slice.
 * @returns "tuple of any meta"
 *          The requested tuple.
 * @category "Tuples" "Types" "Queries"
 */
Public method "_[.._]" is
[
	aTupleType : tuple meta,
	sliceEnd : whole number
|
	aTupleType[1..sliceEnd]
] : tuple of any meta;

/**
 * Construct and answer a slice (i.e., subtuple) that begins at the start of the
 * tuple and continues to subscript {@param "sliceEnd"}.
 * 
 * @method "_[.._]"
 * @param "aTuple" "tuple"
 *        A tuple.
 * @param "sliceEnd" "whole number"
 *        The one-based end index (inclusive) of the desired slice.
 * @returns "tuple"
 *           The requested tuple.
 * @category "Tuples" "Types" "Queries"
 */
Public stable method "_[.._]" is
[
	aTuple : tuple,
	sliceEnd : whole number
|
	aTuple[1..sliceEnd]
] : tuple;

/**
 * Strengthen the tuple type produced by {@param "_[.._]"} to the strongest
 * possible given the argument types.
 *
 * @method "_[.._]"
 * @restricts "aTupleType" "tuple meta"
 * @restricts "sliceEnd" "whole number's type"
 */
Semantic restriction "_[.._]" is
[
	aTupleType : tuple meta,
	sliceEnd : whole number's type
|
	tuple type of aTupleType[1's type..sliceEnd]
];

/**
 * Bind subscripting and slicing tighter than concatenation.
 * 
 * @method "_[_]"
 * @forbids 1 "«_‡++»"
 */

/**
 * Bind subscripting and slicing tighter than concatenation.
 * 
 * @method "_[_..]"
 * @forbids 1 "«_‡++»"
 */

/**
 * Bind subscripting and slicing tighter than concatenation.
 * 
 * @method "_[.._]"
 * @forbids 1 "«_‡++»"
 */
Grammatical restriction {"_[_]", "_[_..]", "_[.._]"} is <{"«_‡++»"}, ∅>;

/**
 * Bind subscripting and slicing tighter than concatenation.
 * 
 * @method "_[_.._]"
 * @forbids 1 "«_‡++»"
 */
Grammatical restriction "_[_.._]" is <{"«_‡++»"}, ∅, ∅>;

Method "concatenate_" is stable at
	function accepting <tuple of tuple> and returning tuple;

/**
 * @method "concatenate_"
 * @restricts "tuple of tuple's type"
 */
Semantic restriction "concatenate_" is
[
	tupleType : tuple of tuple's type
|
	sizes ::= ||tupleType||;
	limit ::=
		if ⎡sizes⎤ is infinite then
		[
			⎣sizes⎦ max (cast |tupleType's leading types| + 1
				into [t : natural number | t])
		]
		else [⎡sizes⎤];
	result : tuple meta := <>'s type;
	From 1 to limit do
	[
		index : natural number
	|
		result := eject result ++ tupleType[index];
		true
	];
	If ⎡sizes⎤ is infinite then
	[
		slice ::= result[1 .. cast limit into [t : whole number | t]];
		default ::= tupleType's default type;
		union ::= ∪ default[1 ..
			cast |default's leading types| + 1 into [ t : whole number | t ]];
		result := <slice, union… | [⎣result⎦..∞)>;
	];
	result
];

Method "_→set" is stable at function accepting <tuple> and returning set;

/**
 * It's extremely hard to provide a strong bound for set conversion without
 * chromatic polynomials, and even then it's still expensive. Provide a simple
 * strengthening: the resulting element type is the type union of all tuple
 * element types.
 * 
 * @method "_→set"
 * @restricts "tuple meta"
 */
Semantic restriction "_→set" is
[
	tupleType : tuple meta
|
	typeLimit ::= cast |tupleType's leading types| + 1
		into [ t : natural number | t ];
	union ::= ∪ tupleType[1..typeLimit];
	if ⎣tupleType⎦ = ⎡tupleType⎤
		∧ [ |union| = ⎣tupleType⎦
		∧ [ ¬union ⊆ type ] ]
	then
	[
		/* If the size of the tuple is known, and the type union of its element
		 * types is an enumeration type which is not itself a metatype, then
		 * answer a type strong enough to build a statically well known
		 * enumeration.  HOWEVER, we must make sure that there were no
		 * duplicate singular enumerations by ensuring there were no
		 * compensating >1 valued enumerations.
		 */
		allSingularEnumerations : boolean := true;
		From 1 to ⎣tupleType⎦ do
		[
			index : natural number
		|
			If |tupleType[index]| ≠ 1 then
			[
				allSingularEnumerations := false;
			];
			allSingularEnumerations
		];
		if allSingularEnumerations then
		[
			{union | ||tupleType||}
		]
		else
		[
			lower ::= ⎣tupleType⎦ min 1;
			{union | [lower..⎡tupleType⎤ + 1)}
		]
	]
	else
	[
		/* If the tuple could be empty, then so could the set. Otherwise, the
		 * set must contain at least one element.
		 */
		lower ::= ⎣tupleType⎦ min 1;
		{union | [lower..⎡tupleType⎤ + 1)}
	]
];

Method "_→map" is stable at
	function accepting <key-value tuple> and returning map;

/**
 * @method "_→map"
 * @restricts "key-value tuple's type"
 */
Semantic restriction "_→map" is
[
	tupleType : key-value tuple's type
|
	/* If the tuple could be empty, then so could the map. Otherwise, the
	 * map must contain at least one element.
	 */
	lower ::= ⎣tupleType⎦ min 1;
	typeLimit ::= cast |tupleType's leading types| + 1
		into [ t : natural number | t ];
	keyType : any meta := ⊥;
	valueType : any meta := ⊥;
	From 1 to typeLimit do
	[
		index : natural number
	|
		bindingType ::= /*cast*/ tupleType[index]
			/*into [ t : <<>, any…|[2..2]>'s type | t ]*/;
		keyType := cast eject keyType ∪ bindingType[1]
			into [ t : any meta | t ];
		valueType := cast eject valueType ∪ bindingType[2]
			into [ t : any meta | t ];
		true
	];
	{keyType→valueType | [lower..⎡tupleType⎤ + 1)}
];

/** 
 * Disambiguate {@method "_→_"} and {@method "_→tuple"}. 
 * 
 * @method "_→_"
 * @forbids 2 "tuple"
 */
Grammatical restriction "_→_" is <∅, {"tuple"}>;

/**
 * If {@param "index"} is a valid subscript for {@param "aTuple"}, then answer
 * the corresponding element. Otherwise, answer the result obtained by applying
 * {@param "else"}.
 *
 * @method "_[_]else_"
 * @param "aTuple" "tuple"
 *        A {@type "tuple"}.
 * @param "index" "integer"
 *        An {@type "integer"}.
 * @param "else" "[]→any"
 *        The function to apply if {@param "index"} is not a valid subscript
 *        into {@param "aTuple"}.
 * @returns "any"
 *          The {@param "index"}-th element of {@param "aTuple"}, or the result
 *          of applying {@param "else"} (if {@param "index"} is invalid).
 * @category "Tuples" "Queries"
 */
Method "_[_]else_" is
[
	aTuple : tuple,
	index : integer,
	else : function accepting <> and returning any
|
	if index ∈ [1..|aTuple|]
	then [aTuple[cast index into [t : natural number | t]]]
	else else
] : any;

/**
 * @method "_[_]else_"
 * @restricts "tuple meta"
 * @restricts "integer's type"
 * @restricts "(function accepting <> and returning any)'s type"
 */
Semantic restriction "_[_]else_" is
[
	tupleType : tuple meta,
	index : integer's type,
	else : (function accepting <> and returning any)'s type
|
	if ⎣index⎦ > ⎡tupleType⎤ ∨ [⎡index⎤ < 1] then
	[
		else's return type
	]
	else
	[
		min ::= ⎣index⎦ max 1;
		max ::= cast ⎡index⎤ min (|tupleType's leading types| + 1)
			into [t : whole number | t];
		union ::= ∪ tupleType[min..max];
		if index ⊆ [1..⎣tupleType⎦] then
		[
			union
		]
		else
		[
			union ∪ else's return type
		]
	]
];

/**
 * Create an optional type from some (non-top) type.  The optional type based on
 * type X is simply the tuple type of zero or one X's.
 * 
 * @method "_`?"
 * @param "t" "type"
 *        The type to be made optional.
 * @returns "any?'s type"
 *          A zero-or-one element tuple type whose sole element, if present, has
 *          type t.
 */
Public method "_`?" is
[
	t : any's type
|
	<<>, t…|[0..1]>
];

/**
 * Strengthen the optional type derived from the given non-top type.
 * 
 * @method "_`?"
 * @restricts "t" "type's type"
 *            The type of type being made optional at a call site.
 */
Semantic restriction "_`?" is
[
	m : any's type's type
|
	<<>, m's instance…|[0..1]>'s type
];

/**
 * Create a one-or-more type from some (non-top) type.  The one-or-more type
 * based on type X is simply the tuple type of one or more X's.
 * 
 * @method "_+"
 * @param "t" "type"
 *        The type to be made one-or-more.
 * @returns "<any…|1..∞>'s type"
 *          A one or more element tuple type whose elements have type t.
 */
Public method "_+" is
[
	t : any's type
|
	<<>, t…|[1..∞)>
];

/**
 * Strengthen the one-or-more type derived from the given type.
 * 
 * @method "_+"
 * @restricts "t" "type's type"
 *            The type of type being made one-or-more at a call site.
 */
Semantic restriction "_+" is
[
	m : any's type's type
|
	<<>, m's instance…|[1..∞)>'s type
];

/**
 * Create a zero-or-more type from some (non-top) type.  The zero-or-more type
 * based on type X is simply the tuple type of zero or more X's.
 * 
 * @method "_*"
 * @param "t" "type"
 *        The type to be made zero-or-more.
 * @returns "<any…|0..∞>'s type"
 *          A zero or more element tuple type whose elements have type t.
 */
Public method "_*" is
[
	t : any's type
|
	<<>, t…|[0..∞)>
];

/**
 * Strengthen the zero-or-more type derived from the given type.
 * 
 * @method "_*"
 * @restricts "t" "type's type"
 *            The type of type being made zero-or-more at a call site.
 */
Semantic restriction "_*" is
[
	m : any's type's type
|
	<<>, m's instance…|[0..∞)>'s type
];

/**
 * A {@type "UUID"} is a universally unique identifier.
 *
 * @type "UUID"
 * @supertype "<byte…|16>"
 */
Public method "UUID" is [<<>, byte…|16's type>];

/**
 * Generate and answer a cryptographically strong pseudo-random universally
 * unique identifier (UUID) as a 16-byte {@type "tuple"}.
 *
 * @category "Primitives"
 * @method "a UUID"
 * @returns "<byte…|16>"
 *          The requested UUID.
 */
Public method "a UUID" is
[
	Primitive 134;
] : <<>, byte…|16's type>;

/**
 * Convert the specified {@type "any" value} to a {@type "tuple"} of {@type
 * "byte"}s. This {@type "tuple"} can be {@method "deserialize_" deserialized}
 * later to reconstitute the argument.
 *
 * @method "serialize_"
 * @param "value" "any"
 * @returns "byte+"
 *          A serialization of {@param "value"}.
 */
Public method "serialize_" is
[
	value : any
|
	Primitive 270 (failureCode : serialization-failed code's type);
	Invoke early failure function with <failureCode>
] : byte+;

/**
 * Convert the specified {@type "tuple" tuple} of {@type "byte"}s into a {@type
 * "tuple"} of {@type "any" values}.
 *
 * @method "deserialize_from_"
 * @param "serializedBytes" "byte+"
 *        A {@method "serialize_" serialization} of arbitrary values.
 * @param "context" "module"
 *        The {@type "module"} that should be consulted to resolve {@type
 *        "atom"}s.
 * @returns "any+"
 *          The deserialized values.
 */
Public method "deserialize_from_" is
[
	serializedBytes : byte+,
	context : module
|
	Primitive 271 (failureCode : deserialization-failed code's type);
	Invoke early failure function with <failureCode>
] : any+;
