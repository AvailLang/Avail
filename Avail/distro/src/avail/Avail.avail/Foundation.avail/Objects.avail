/*
 * Objects.avail
 * Copyright © 1993-2014, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Objects"
Versions
	"dev"
Uses
	"Atoms",
	"Bootstrap",
	"Control Structures",
	"Definers",
	"Early Assertions",
	"Early Functions",
	"Enumeration Support",
	"Error Codes",
	"Literals",
	"Logic",
	"Maps",
	"Math",
	"Phrases",
	"Sets",
	"Tuples",
	"Types",
	"Variables"
Names
	"a|an_«with«_«:»?:=_‡,»»",
	"extend_with«_:_‡,»",
	"«Public»?«Explicit|explicit»?\
		\|Class|class_extends_\
		\|«with immutable⁇field|fields««public»?«reconstructible»?_:_‡,»»\
		\|«with mutable field|fields««public»?«shared»?«referable»?«read-only»?_:_‡,»»\
		\|«with reconstructor|reconstructors««public»?(«_‡,»)‡,»»",
	"_as_«with«_::=_‡,»»"
Body

Method "_→object type" is stable at [field type map]→object meta;

/**
 * @method "_→object type"
 * @restricts "field type map's type"
 */
Semantic restriction "_→object type" is
[
	mapType : field type map's type
|
	/* If the enumeration of keys is known and equals the cardinality of the
	 * map, then answer the nearest object type supertype with these keys.
	 */
	if ⎣mapType⎦ = ⎡mapType⎤
		∧ [ |mapType's key type| = ⎣mapType⎦ ] then
	[
		atoms ::= mapType's key type's instances;
		defs ::= atoms→tuple zip |atoms| of mapType's value type's instance;
		(defs→object type)'s type
	]
	/* Can't strengthen. */
	else
	[
		⊤
	]
];

Method "_→object type" is stable at [field type tuple]→object meta;

/**
 * @method "_→object type"
 * @restricts "field type tuple's type"
 */
Semantic restriction "_→object type" is
[
	tupleType : field type tuple's type
|
	limit ::= |tupleType's leading types| + 1;
	/* `defs` are the guaranteed field definitions. A field definition is
	 * only certain when the field atom is certain.
	 */
	defs : field type map := {};
	/* `constraints` are augmented when a particular definition tuple's
	 * field atom is not statically known. This map is used to weaken `defs`
	 * after all definition tuples have been processed.
	 */
	constraints : field type map := {};
	/* `universal` is the type union of all field types for which the
	 * corresponding field is merely `atom`, i.e., the actual fields are not
	 * statically known. It is used to weaken `defs` after all definition
	 * tuples have been processed.
	 */
	universal : any meta := ⊥;
	From 1 to limit do
	[
		index : natural number
	|
		defTuple ::= tupleType[index];
		atomType ::= defTuple[1];
		defType ::= defTuple[2]'s instance;
		/* The field atom is known exactly. Therefore, we can confidently
		 * say that the resulting object type must contain this field.
		 */
		if |atomType| = 1 then
		[
			fieldAtom ::= atomType's instance;
			fieldType ::= defs[fieldAtom] else [ ⊥ ] ∪ defType;
			defs := eject ↑defs + fieldAtom→fieldType;
		]
		/* We know one or more fields with which this type is associated, so
		 * record this knowledge into `constraints`.
		 */
		else if [ |atomType| ≠ ∞ ] then
		[
			atoms ::= atomType's instances;
			For each atoms do
			[
				fieldAtom : atom
			|
				fieldType ::= constraints[fieldAtom] else [ ⊥ ] ∪ defType;
				constraints := eject ↑constraints + fieldAtom→fieldType;
			];
		]
		/* We don't know anything about the field. Treat the field type as a
		 * universal constraint.
		 */
		else
		[
			Assert: atomType = atom;
			universal := eject ↑universal ∪ defType;
		];
	];
	/* Weaken each value of `defs` by all applicable constraints. */
	defs := map eject ↑defs through
		[
			fieldAtom : atom,
			fieldType : any meta
		|
			fieldType ∪ constraints[fieldAtom] else [ ⊥ ] ∪ universal
		];
	(defs→object type)'s type
];

Method "_→object" is stable at [field map]→object;

/**
 * @method "_→object"
 * @restricts "field map's type"
 */
Semantic restriction "_→object" is
[
	mapType : field map's type
|
	/* If the enumeration of keys is known and equals the cardinality of the
	 * map, then answer the nearest object type supertype with these keys.
	 */
	if ⎣mapType⎦ = ⎡mapType⎤
		∧ [ |mapType's key type| = ⎣mapType⎦ ] then
	[
		atoms ::= mapType's key type's instances;
		fieldAssignments ::= atoms→tuple zip |atoms| of mapType's value type;
		(fieldAssignments→object)'s type
	]
	/* Can't strengthen. */
	else
	[
		⊤
	]
];

Method "_→object" is stable at [field tuple]→object;

/**
 * @method "_→object"
 * @restricts "field tuple's type"
 */
Semantic restriction "_→object" is
[
	tupleType : field tuple's type
|
	limit ::= |tupleType's leading types| + 1;
	/* `defs` are the guaranteed field definitions. A field definition is
	 * only certain when the field atom is certain.
	 */
	defs : field type map := {};
	/* `constraints` are augmented when a particular definition tuple's
	 * field atom is not statically known. This map is used to weaken `defs`
	 * after all definition tuples have been processed.
	 */
	constraints : field type map := {};
	/* `universal` is the type union of all field types for which the
	 * corresponding field is merely `atom`, i.e., the actual fields are not
	 * statically known. It is used to weaken `defs` after all definition
	 * tuples have been processed.
	 */
	universal : any meta := ⊥;
	From 1 to limit do
	[
		index : natural number
	|
		defTuple ::= tupleType[index];
		atomType ::= defTuple[1];
		defType ::= defTuple[2];
		/* The field atom is known exactly. Therefore, we can confidently
		 * say that the resulting object type must contain this field.
		 */
		if |atomType| = 1 then
		[
			fieldAtom ::= atomType's instance;
			fieldType ::= defs[fieldAtom] else [ ⊥ ] ∪ defType;
			defs := eject ↑defs + fieldAtom→fieldType;
		]
		/* We know one or more fields with which this type is associated, so
		 * record this knowledge into `constraints`.
		 */
		else if [ |atomType| ≠ ∞ ] then
		[
			atoms ::= atomType's instances;
			For each atoms do
			[
				fieldAtom : atom
			|
				fieldType ::= constraints[fieldAtom] else [ ⊥ ] ∪ defType;
				constraints := eject ↑constraints + fieldAtom→fieldType;
			];
		]
		/* We don't know anything about the field. Treat the field type as a
		 * universal constraint.
		 */
		else
		[
			Assert: atomType = atom;
			universal := eject ↑universal ∪ defType;
		];
	];
	/* Weaken each value of `defs` by all applicable constraints. */
	defs := map eject ↑defs through
		[
			fieldAtom : atom,
			fieldType : any meta
		|
			fieldType ∪ constraints[fieldAtom] else [ ⊥ ] ∪ universal
		];
	defs→object type
];

Method "_→map" is stable at [object]→map;

/**
 * @method "_→map"
 * @restricts "object meta"
 */
Semantic restriction "_→map" is
[
	anObjectType : object meta
|
	objectMap ::= anObjectType→map;
	/* Because we can't know what keys and types the subtypes of the
	 * argument will contain, this is as good as it gets.
	 */
	{atom→any | |objectMap|..}
];

/**
 * @method "_→tuple"
 * @restricts "object meta"
 */
Semantic restriction "_→tuple" is
[
	anObjectType : object meta
|
	objectMap ::= anObjectType→map;
	/* Note that we can't exploit instance types here, because coversion of an
	 * object type to a tuple is an unstable operation. Because we can't know
	 * what keys and types the subtypes of the argument will contain, this is as
	 * good as it gets.
	 */
	<<atom, any…|2>…| |objectMap|..>
];

/**
 * Construct and answer an object type which is a subtype of {@param
 * "supertype"} augmented by the specified tuple of field definitions.
 *
 * @method "extend_with«_:_‡,»"
 * @param "supertype" "object's type"
 *        An object type that must be a supertype of the answer.
 * @param "newDefinitions" "<<atom, any meta…|2>…|1..>"
 *        A tuple of 2-tuples. Each 2-tuple consists of 1) an atom that uniquely
 *        identifies the field and 2) the field type, i.e., the type of value
 *        that instances of the answer may store in the field. If the field atom
 *        is defined by {@param "supertype"}, then the new field type must be a
 *        subtype of the field type as defined in {@param "supertype"}, i.e., it
 *        must be covariantly specialized.
 * @returns "object's type"
 *          The requested object type.
 * @category "Objects" "Types" "Constructors"
 */
Public method "extend_with«_:_‡,»" is
[
	supertype : object meta,
	newDefinitions : <<atom, any meta…|2>…|1..>
|
	fieldAtoms ::= stripe newDefinitions at 1;
	If |fieldAtoms→set| ≠ |fieldAtoms| then
	[
		early failure function(object-type-extension-contains-duplicates code)
	];
	subtype ::= (supertype→tuple ++ newDefinitions)→object type;
	If ¬subtype ⊆ supertype then
	[
		early failure function(
			object-type-extension-did-not-produce-subtype code)
	];
	subtype
] : object meta;

/**
 * Object type extension statically requires that:
 *
 * - Every field atom of the extension is known.
 * - Each field atom of the extension appears only once during extension.
 * - Each field atom of the extension is either 1) not present in the supertype
 *   or 2) specifies a type which covaries with the field type expressed in the
 *   supertype.
 *
 * @method "extend_with«_:_‡,»"
 * @restricts "object's type's type"
 * @restricts "<<atom, any meta…|2>…|1..>'s type"
 */
Semantic restriction "extend_with«_:_‡,»" is
[
	meta : object meta's type,
	newDefinitionTypes : <<atom, any meta…|2>…|1..>'s type
|
	supertype ::= meta's instance;
	oldDefinitions ::= supertype→map;
	newDefinitions : field type map := {};
	From 1 to |newDefinitionTypes' leading types| + 1 do
	[
		index : natural number
	|
		def ::= newDefinitionTypes[index];
		atomType ::= def[1];
		newType ::= def[2]'s instance;
		If |atomType| ≠ 1 then
		[
			Reject parse, expected: "all field atoms to be known statically"
		];
		fieldAtom ::= atomType's instance;
		If fieldAtom ∈ newDefinitions then
		[
			Reject parse, expected:
				fieldAtom's name
				++ " to appear only once during extension (but it already\
				\| appeared with type = "
				++ “newDefinitions[fieldAtom]”
				++ ")"
		];
		oldType ::= oldDefinitions[fieldAtom] else [ any ];
		If ¬newType ⊆ oldType then
		[
			Reject parse, expected:
				"covariant specialization of "
				++ fieldAtom's name
				++ " (but new field type "
				++ “newType”
				++ " is not a subtype of "
				++ “oldType”
				++ ")"
		];
		newDefinitions := eject ↑newDefinitions + fieldAtom→newType;
	];
	((supertype→tuple ++ newDefinitions' bindings)→object type)'s type
];

/**
 * Compute and answer the accessor name for the specified field atom.
 *
 * @method "accessor name for_"
 * @param "fieldAtom" "atom"
 *        A field atom.
 * @returns "string"
 *          The name of the accessor.
 */
Private method "accessor name for_" is
[
	fieldAtom : atom
|
	"_'s⁇" ++ fieldAtom's name
];

/* These methods are needed for reconstructor synthesis. */
toMapAtom ::= $"_→map";
mapAtAtom ::= $"_[_]";
objectAtFieldAtom ::= $"_[_]";
objectTypeAtFieldAtom ::= $"_[_]";
toObjectAtom ::= $"_→object";
toObjectTypeAtom ::= $"_→object type";
ejectAtom ::= $"eject_";
addBindingAtom ::= $"_+_→_";
getAtom ::= $"↓_";
readTypeAtom ::= $"_'s⁇read type";
putAtom ::= $"↓_`?=_";

/**
 * Generate the field accessor method for the specified field declaration.
 *
 * @method "generate_field accessor for_:_(mutable=_)"
 * @param "objectType" "object's type"
 * @param "fieldAtom" "atom"
 * @param "fieldType" "any's type"
 * @param "mutable" "boolean"
 *        {@method "true"} if the field is mutable, {@method "false"} otherwise.
 * @returns "method"
 * 		a field accessor method
 */
Private method "generate_field accessor for_:_(mutable=_)" is
[
	objectType : object meta,
	fieldAtom : atom,
	fieldType : any meta,
	mutable : boolean
|
	args ::= <arg «`"x"` : objectType»>;
/*	toMapMSend ::= send toMapAtom with «<«↓args[1]»>» : field map;*/
	objectPhrase ::= «↓args[1]»;
	getFieldSend ::= send objectAtFieldAtom
		with «<objectPhrase, ‘`fieldAtom`’>» : fieldType;
	resultType ::=
		unless mutable then [fieldType]
		else
		[
			varType ::= cast fieldType into [t : variable's type | t];
			varType's read type
		];
	last ::=
		unless mutable then [getFieldSend]
		else
		[
			send getAtom with «<getFieldSend>» : resultType
		];
	newBlock ::= «[args | <last>] : resultType»;
	newBlock→function
];

/**
 * Generate the field accessor semantic restriction for the specified field
 * declaration.
 *
 * @method "generate field accessor restriction for_:_(mutable=_)"
 * @param "objectType" "object's type"
 * @param "fieldAtom" "atom"
 * @param "fieldType" "any's type"
 * @param "mutable" "boolean"
 *        {@method "true"} if the field is mutable, {@method "false"} otherwise.
 * @returns "semantic restriction"
 * 		the field accessor semantic restriction
 */
Private method "generate_field accessor restriction for_:_(mutable=_)" is
[
	objectType : object meta,
	fieldAtom : atom,
	fieldType : any meta,
	mutable : boolean
|
	args ::= <arg «`"x"` : objectType's type»>;
	objectTypePhrase ::= «↓args[1]»;
	getFieldTypeSend ::= send objectTypeAtFieldAtom
		with «<objectTypePhrase, ‘`fieldAtom`’>» : fieldType's type;
	resultType ::=
		unless mutable then [fieldType's type]
		else
		[
			varType ::= cast fieldType into [t : variable meta | t];
			varType's read type's type
		];
	last ::=
		unless mutable then [getFieldTypeSend]
		else [send readTypeAtom with «<getFieldTypeSend>» : resultType];
	newBlock ::= «[args | <last>] : resultType»;
	newBlock→function
];

/**
 * Generate and install field type and field value accessors for the specified
 * object type and field atom. Generate and install a semantic restriction for
 * the field value accessor.
 *
 * @method "Generate and install_accessor for_"
 * @param "objectType" "object's type"
 *        An object type.
 * @param "isMutable" "boolean"
 *        {@method "true"} if the field is mutable, {@method "false"} otherwise.
 * @param "fieldAtom" "atom"
 *        A field atom.
 * @returns "⊤"
 */
Private method "Generate and install_accessor for«mutable»?_" is
[
	objectType : object meta,
	isMutable : boolean,
	fieldAtom : atom
|
	objectMap ::= objectType→map;
	methodName ::= accessor name for fieldAtom;
	methodAtom ::= atom for methodName;
	fieldType ::= objectMap[fieldAtom];
	defineClassAccessor : boolean := false;
	defineInstanceAccessor : boolean := false;
	/* If the method doesn't exist at all, then define it and install
	 * accessors.
	 */
	If ¬method exists named methodAtom then
	[
		defineClassAccessor := true;
		defineInstanceAccessor := true;
	]
	/* If the method does already exist, then install accessors for the object
	 * type iff they are not already present.
	 */
	else
	[
		defineClassAccessor :=
			¬methodAtom has definition for <objectType's type>;
		defineInstanceAccessor :=
			¬methodAtom has definition for <objectType>;
	];
	If defineClassAccessor then
	[
		Method methodName is
			new [objectType's type]→(fieldType's type)
			applying [x : object meta | x[fieldAtom]];
		/* Install a semantic restriction if one does not already exist for this
		 * signature.
		 */
		theMethod ::= method for methodAtom;
		restrictions ::= semantic restrictions for theMethod
			given <objectType's type's type>;
		needToRestrict ::= ¬any of restrictions satisfies
			[r : […]→type | r's type[1] = (objectType's type's type)];
		If needToRestrict then
		[
			Semantic restriction methodName is
				new [objectType's type's type]→(any meta's type)
				applying
				[
					x : object meta's type
				|
					(x's instance[fieldAtom])'s type
				];
		];
	];
	If defineInstanceAccessor then
	[
		impl ::= generate objectType field accessor
			for fieldAtom : fieldType (mutable = isMutable);
		Method methodName is impl;
		/* Install a semantic restriction if one does not already exist for this
		 * signature.
		 */
		theMethod ::= method for methodAtom;
		restrictions ::=
			semantic restrictions for theMethod given <objectType's type>;
		needToRestrict ::= ¬any of restrictions satisfies
			[r : […]→type | r's type[1] = (objectType's type)];
		If needToRestrict then
		[
			sem ::= generate objectType field accessor restriction
				for fieldAtom : fieldType (mutable = isMutable);
			Semantic restriction methodName is sem;
		];
	];
] : ⊤;

/**
 * Compute and answer the referer name for the specified field atom.
 *
 * @method "referer name for_"
 * @param "fieldAtom" "atom"
 *        A field atom.
 * @returns "string"
 *          The name of the accessor.
 */
Private method "referer name for_" is
[
	fieldAtom : atom
|
	"↑" ++ accessor name for fieldAtom
];

/**
 * Generate and install the field referer for the specified object type and
 * mutable field atom.
 *
 * @method "Generate and install_referer for_"
 * @param "objectType" "object's type"
 * @param "fieldAtom" "atom"
 * @returns "⊤"
 */
Private method "Generate and install_referer for mutable_" is
[
	objectType : object meta,
	fieldAtom : atom
|
	objectMap ::= objectType→map;
	methodName ::= referer name for fieldAtom;
	methodAtom ::= atom for methodName;
	fieldType ::= objectMap[fieldAtom];
	defineReferer : boolean :=
		if ¬method exists named methodAtom then
		[
			/* If the method doesn't exist at all, then define it and install a
			 * referer.
			 */
			true
		]
		else
		[
			/* If the method does already exist, then install a referer for the
			 * object type iff one is not already present.
			 */
			¬methodAtom has definition for <objectType>
		];
	If defineReferer then
	[
		impl ::= generate objectType field accessor
			for fieldAtom : fieldType (mutable = false);
		Method methodName is impl;
	];
] : ⊤;

/**
 * Compute and answer the mutator name for the specified field atom.
 *
 * @method "mutator name for_"
 * @param "fieldAtom" "atom"
 *        A field atom.
 * @returns "string"
 *          The name of the mutator.
 */
Private method "mutator name for_" is
[
	fieldAtom : atom
|
	"_'s⁇" ++ fieldAtom's name ++ ":=_"
];

/**
 * Generate and install the mutator for the specified object type and mutable
 * field atom.
 *
 * @method "Generate and install_mutator for_"
 * @param "objectType" "object's type"
 * @param "fieldAtom" "atom"
 * @returns "⊤"
 */
Private method "Generate and install_mutator for mutable_" is
[
	objectType : object meta,
	fieldAtom : atom
|
	objectMap ::= objectType→map;
	methodName ::= mutator name for fieldAtom;
	methodAtom ::= atom for methodName;
	fieldType ::= objectMap[fieldAtom];
	defineMutator : boolean :=
		if ¬method exists named methodAtom then
		[
			/* If the method doesn't exist at all, then define it and install a
			 * referer.
			 */
			true
		]
		else
		[
			/* If the method does already exist, then install a referer for the
			 * object type iff one is not already present.
			 */
			varType ::= cast fieldType into [t : variable's type | t];
			readType ::= cast varType's read type into [t : any's type | t];
			¬methodAtom has definition for <objectType, readType>
		];
	If defineMutator then
	[
		varType ::= cast fieldType into [t : variable's type | t];
		readType ::= cast varType's read type into [t : any's type | t];
		args ::= <arg «`"x"` : objectType», arg «`"v"` : readType»>;
		objectPhrase ::= «↓args[1]»;
		getFieldSend ::= send objectAtFieldAtom
			with «<objectPhrase, ‘`fieldAtom`’>» : varType;
		putSend ::= send putAtom with «<getFieldSend, «↓args[2]»>» : ⊤;
		newBlock ::= «[args | <putSend>] : ⊤»;
		impl ::= newBlock→function;
		Method methodName is impl;
	];
] : ⊤;

/**
 * Construct and answer the name of the object reconstructor method from the
 * specified tuple of field atoms.
 * 
 * @method "reconstructor name for_"
 * @param "fieldAtoms" "<atom…|1..>"
 *        The atoms of the fields migrated by the reconstructor.
 * @returns "string"
 *          The appropriate method name.
 */
Private method "reconstructor name for_" is
[
	fieldAtoms : <atom…|1..>
|
	methodName : <character…|8..> := accessor name for fieldAtoms[1] ++ "::=_";
	For each fieldAtoms' tail do
	[
		fieldAtom : atom
	|
		methodName := eject ↑methodName ++ "," ++ fieldAtom's name ++ "::=_";
	];
	methodName
];

/**
 * Construct and answer a tuple of argument declarations for an object
 * reconstructor method (or its semantic restriction).
 *
 * @method "_reconstructor arguments for_«(for semantic restriction)»?"
 * @param "objectType" "object's type"
 *        The object type.
 * @param "fieldAtoms" "<atom…|1..>"
 *        The atoms of the fields migrated by the reconstructor.
 * @param "forSemanticRestriction" "boolean"
 *        {@method "true"} if the argument declarations should be generated for
 *        the semantic restriction, {@method "false"} if they should be
 *        generated for the method.
 * @returns "<argument phrase…|2..>"
 *          The requested argument declarations. The first declaration is for
 *          the object type (or metatype) and the remaining correspond to the
 *          field atoms.
 */
Private method "_reconstructor arguments for_«(for semantic restriction)»?" is
[
	objectType : object meta,
	fieldAtoms : <atom…|1..>,
	forRestriction : boolean
|
	meta ::= if forRestriction then [objectType's type] else [objectType];
	objectMap ::= objectType→map;
	<arg «`"target"` : meta»> ++ map fieldAtoms through
	[
		fieldAtom : atom,
		index : natural number
	|
		desc ::= “index”;
		argType ::= if forRestriction
			then [objectMap[fieldAtom]'s type]
			else [objectMap[fieldAtom]];
		arg «`"arg" ++ desc` : argType»
	]
] : <argument phrase…|2..>;

/* This atom marks field atoms as sharable across reconstructions. */
"shared" is a new atom;

/**
 * Generate and install a reconstructor for the specified object type and tuple
 * of field atoms.
 *
 * @method "Generate and install_reconstructor for_"
 * @param "objectType" "object's type"
 * @param "fieldAtoms" "<atom…|1..>"
 * @returns "⊤"
 */
Private method "Generate and install_reconstructor for_" is
[
	objectType : object meta,
	fieldAtoms : <atom…|1..>
|
	methodName ::= reconstructor name for fieldAtoms;
	args ::= objectType reconstructor arguments for fieldAtoms;
	/* Emit code to convert the object to a map. */
	toMapMSend ::= send toMapAtom with «<«↓args[1]»>» : field map;
	mapDecl ::= «`"objectMap"` : field map := toMapMSend»;
	/* Emit code to migrate the target fields to their new values. */
	assignments ::= map fieldAtoms through
		[
			fieldAtom : atom,
			index : natural number
		|
			ejectSend ::= send ejectAtom with «<«↑«↓mapDecl»»>» : field map;
			addBindingSend ::= send addBindingAtom
				with «<ejectSend, ‘`fieldAtom`’, «↓args[index + 1]»>»
				: field map;
			««↓mapDecl» := addBindingSend»
		];
	/* Emit code to clone any mutable fields that are not explicitly being
	 * shared.
	 */
	cloning : <phrase…|> := <>;
	For each objectType→map do
	[
		fieldAtom : atom,
		fieldType : any meta
	|
		If ¬shared ∈ fieldAtom ∧ [fieldType ⊆ variable] then
		[
			varType ::= cast fieldType into [t : variable meta | t];
			readType ::= cast varType's read type into [t : any meta | t];
			mapAtSend ::= send mapAtAtom
				with «<«↓mapDecl», ‘`fieldAtom`’>» : varType;
			getSend ::= send getAtom with «<mapAtSend>» : readType;
			decl ::= «`fieldAtom's name` : readType := getSend»;
			ejectSend ::= send ejectAtom with «<«↑«↓mapDecl»»>» : field map;
			addBindingSend ::= send addBindingAtom
				with «<ejectSend, ‘`fieldAtom`’, «↑«↓decl»»>»
				: field map;
			assignment ::= ««↓mapDecl» := addBindingSend»;
			cloning := eject ↑cloning ++ <decl, assignment>;
		];
	];
	/* Convert the map back to an object. */
	last ::= send toObjectAtom with «<«↓mapDecl»>» : objectType;
	/* Build and install the implementation. */
	statements ::= <mapDecl> ++ assignments ++ cloning ++ <last>;
	newBlock ::= «[ args | statements ] : objectType»;
	reconstructorFunction ::= newBlock→function;
	Method methodName is reconstructorFunction;
] : ⊤;

/**
 * Generate and install a semantic restriction for the reconstructor for the
 * specified object type and tuple of field atoms.
 *
 * @method "Generate and install_reconstructor's semantic restriction for_"
 * @param "objectType" "object's type"
 *        An object type.
 * @param "fieldAtoms" "<atom…|1..>"
 *        A field atoms.
 * @returns "⊤"
 */
Private method
	"Generate and install_reconstructor's semantic restriction for_"
is
[
	objectType : object meta,
	fieldAtoms : <atom…|1..>
|
	methodName ::= reconstructor name for fieldAtoms;
	args ::= objectType reconstructor arguments for fieldAtoms
		(for semantic restriction);
	/* Construct the body of the semantic restriction method. */
	toMapMSend ::= send toMapAtom with «<«↓args[1]»>» : field type map;
	mapDecl ::= «`"objectMap"` : field type map := toMapMSend»;
	assignments ::= map fieldAtoms through
		[
			fieldAtom : atom,
			index : natural number
		|
			ejectSend ::= send ejectAtom with «<«↑«↓mapDecl»»>» : field type map;
			addBindingSend ::= send addBindingAtom
				with «<ejectSend, ‘`fieldAtom`’, «↓args[index + 1]»>»
				: field type map;
			««↓mapDecl» := addBindingSend»
		];
	last ::= send toObjectTypeAtom with «<«↓mapDecl»>» : objectType's type;
	statements ::= <mapDecl> ++ assignments ++ <last>;
	newBlock ::= «[ args | statements ] : type»;
	Semantic restriction methodName is newBlock→function;
];

/**
 * Define a class. In Avail, a class is simply a named object type supported by
 * 1) a generated method that reliably reproduces the object type, 2) generated
 * methods that provide access to the field definitions, and 3) generated
 * methods that provide access to instance field values. A class is essentially
 * only a lexical construct, and is analogous to the distinction between blocks
 * (lexical) and functions (semantic).
 *
 * @method "«Public»?«Explicit|explicit»?\
 *   \|Class|class_extends_\
 *   \|«with immutable⁇field|fields««public»?«reconstructible»?_:_‡,»»\
 *   \|«with mutable field|fields««public»?«shared»?«referable»?«read-only»?_:_‡,»»\
 *   \|«with reconstructor|reconstructors««public»?(«_‡,»)‡,»»"
 * @param "public" "boolean"
 *        {@method "true"} if the class should be exported by the defining
 *        module, {@method "false"} otherwise.
 * @param "explicit" "boolean"
 *        {@method "true"} if the class should have an artificial identity
 *        introduced (in order to ensure intentional provenance of subtypes),
 *        {@method "false"} otherwise.
 * @param "className" "nonempty string"
 *        The name of the class. A method will be generated with this name. This
 *        method will answer the object type. The object type will also be
 *        christened with this name.
 * @param "supertype" "object's type"
 *        The supertype of the class. Type intersection may be used here to
 *        facilitate inheritance from multiple sources.
 * @param "optionalImmutable" 
 *        "<<<boolean, boolean, atom, any meta…|4>…|1..>…|0..1>"
 *        The extension fields of this class. An accessor will be generated for
 *        each field. A reconstructor will be generated for each field tagged as
 *        {@code reconstructible}. Each field tagged as {@code public} must be
 *        exported by the defining module.
 * @param "optionalMutable"
 *        "<<<boolean, boolean, boolean, boolean, atom, any meta…|6>…|1..>…|0..1>"
 *        The mutable fields of this class. An accessor will be generated for
 *        each field. A referer will be generated for each field tagged as 
 *        {@code referable}. A mutator will be generated for each field not
 *        tagged as {@code read-only}. Each field tagged as {@code public} must
 *        have its accessor, referer, and mutator exported by the defining
 *        module. Each field tagged as {@code shared} will not be cloned (using
 *        a new variable) during reconstruction.
 * @param "optionalReconstructors"
 *        "<<<boolean, <atom…|1..>…|2>…|1..>…|0..1>"
 *        The reconstructors of this class. A reconstructor will be generated
 *        for each specification tuple. Each reconstructor tagged as {@code
 *        public} must be exported by the defining module.
 * @returns "⊤"
 * @category "Objects" "Types" "Declarations"
 */
Public method
	"«Public»?«Explicit|explicit»?\
	\|Class|class_extends_\
	\|«with immutable⁇field|fields««public»?«reconstructible»?_:_‡,»»\
	\|«with mutable field|fields««public»?«shared»?«referable»?«read-only»?_:_‡,»»\
	\|«with reconstructor|reconstructors««public»?(«_‡,»)‡,»»"
is
[
	public : boolean,
	explicit : boolean,
	className : nonempty string,
	supertype : object meta,
	optionalImmutable : <<<boolean, boolean, atom, any meta…|4>…|1..>…|0..1>,
	optionalMutable :
		<<<boolean, boolean, boolean, boolean, atom, any meta…|6>…|1..>…|0..1>,
	optionalReconstructors : <<<boolean, <atom…|1..>…|2>…|1..>…|0..1>
|
	newDefinitions : <<atom, any meta…|2>…|> := <>;
	/* Extract the immutable extensions. */
	immutable : <<boolean, boolean, atom, any meta…|4>…|> := <>;
	immutableAtoms : <atom…|> := <>;
	Unless optionalImmutable is empty then
	[
		immutable := optionalImmutable[1];
		newDefinitions := map immutable through
			[
				fieldTuple : <boolean, boolean, atom, any meta…|4>
			|
				fieldAtom ::= fieldTuple[3];
				immutableAtoms := eject ↑immutableAtoms ++ <fieldAtom>;
				<fieldAtom, fieldTuple[4]>
			];
	];
	/* Extract the mutable fields. */
	mutable : <<boolean, boolean, boolean, boolean, atom, any meta…|6>…|> := <>;
	mutableAtoms : <atom…|> := <>;
	Unless optionalMutable is empty then
	[
		mutable := optionalMutable[1];
		newDefinitions := eject ↑newDefinitions ++ map mutable through
			[
				fieldTuple :
					<boolean, boolean, boolean, boolean, atom, any meta…|6>
			|
				fieldAtom ::= fieldTuple[5];
				mutableAtoms := eject ↑mutableAtoms ++ <fieldAtom>;
				<fieldAtom, ↑fieldTuple[6]>
			];
	];
	/* Verify the uniqueness of the field atoms. */
	fieldAtoms ::= stripe newDefinitions at 1;
	If |fieldAtoms→set| ≠ |fieldAtoms| then
	[
		early failure function(object-type-extension-contains-duplicates code)
	];
	/* If necessary, then generate a field definition that guarantees
	 * uniqueness among object types.
	 */
	explicitDef : <<atom, any meta…|2>…|0..1> := <>;
	If explicit then
	[
		explicitAtom ::= atom for "explicit-" ++ className;
		explicitDef := <<explicitAtom, explicitAtom's type>>;
	];
	/* Construct and verify the subtype. */
	subtype ::= (supertype→tuple ++ newDefinitions ++ explicitDef)→object type;
	If ¬subtype ⊆ supertype then
	[
		early failure function(
			object-type-extension-did-not-produce-subtype code)
	];
	/* Define the class: give the object type a name, define a method that
	 * answers the object type, and define methods that access the field
	 * definitions and values.
	 */
	subtype's name := className;
	Method className is new []→(subtype's type) applying [subtype];
	For each immutableAtoms do
	[
		fieldAtom : atom
	|
		Generate and install subtype accessor for fieldAtom;
	];
	For each mutable do
	[
		fieldTuple : <boolean, boolean, boolean, boolean, atom, any meta…|6>
	|
		isShared ::= fieldTuple[2];
		referable ::= fieldTuple[3];
		readOnly ::= fieldTuple[4];
		fieldAtom ::= fieldTuple[5];
		/* The shared flag must be set on the field atom *before* any
		 * reconstructors are generated!
		 */
		If isShared then [fieldAtom[shared] := true;];
		Generate and install subtype accessor for mutable fieldAtom;
		If referable then
		[
			Generate and install subtype referer for mutable fieldAtom;
		];
		Unless readOnly then
		[
			Generate and install subtype mutator for mutable fieldAtom;
		];
	];
	/* Determine which reconstructors to create. */
	reconstructors : <<atom…|1..>…|> := map and filter immutable by
		[
			triple : <boolean, boolean, atom, any meta…|4>,
			accept : [<atom…|1..>]→⊤
		|
			If triple[2] then
			[
				accept(<triple[3]>);
			];
		];
	Unless optionalReconstructors is empty then
	[
		specs ::= optionalReconstructors[1];
		reconstructors := eject ↑reconstructors ++ map specs through
			[
				spec : <boolean, <atom…|1..>…|2>
			|
				spec[2]
			];
	];
	/* Generate the reconstructors. */
	For each reconstructors do
	[
		atoms : <atom…|1..>
	|
		Generate and install subtype reconstructor for atoms;
		Generate and install subtype reconstructor's semantic restriction
			for atoms;
	];
] : ⊤;

/**
 * Class definition statically requires that:
 *
 * - Every field atom of the extension is known.
 * - Each field atom of the extension appears only once during extension.
 * - Each field atom of the extension is either 1) not present in the supertype
 *   or 2) specifies a type which covaries with the field type expressed in the
 *   supertype.
 *
 * @method "«Public»?«Explicit|explicit»?\
 *   \|Class|class_extends_\
 *   \|«with immutable⁇field|fields««public»?«reconstructible»?_:_‡,»»\
 *   \|«with mutable field|fields««public»?«shared»?«referable»?«read-only»?_:_‡,»»\
 *   \|«with reconstructor|reconstructors««public»?(«_‡,»)‡,»»"
 * @restricts "boolean's type"
 * @restricts "boolean's type"
 * @restricts "nonempty string's type"
 * @restricts "object's type"
 * @restricts "<<<boolean, boolean, atom, any meta…|4>…|1..>…|0..1>'s type"
 * @restricts
 *    "<<<boolean, boolean, boolean, boolean, atom, any meta…|6>…|1..>…|0..1>'s type"
 * @restricts "<<<boolean, <atom…|1..>…|2>…|1..>…|0..1>'s type"
 */
Semantic restriction
	"«Public»?«Explicit|explicit»?\
	\|Class|class_extends_\
	\|«with immutable⁇field|fields««public»?«reconstructible»?_:_‡,»»\
	\|«with mutable field|fields««public»?«shared»?«referable»?«read-only»?_:_‡,»»\
	\|«with reconstructor|reconstructors««public»?(«_‡,»)‡,»»"
is
[
	publicType : boolean's type,
	explicit : boolean's type,
	classNameType : nonempty string's type,
	meta : object meta's type,
	optionalImmutable :
		<<<boolean, boolean, atom, any meta…|4>…|1..>…|0..1>'s type,
	optionalMutable :
		<<<boolean, boolean, boolean, boolean, atom, any meta…|6>…|1..>…|0..1>'s type,
	optionalReconstructors : <<<boolean, <atom…|1..>…|2>…|1..>…|0..1>'s type
|
	public ::= publicType's instance;
	publicNames ::= current module's public names;
	If public ∧ [ |classNameType| ≠ 1 ] then
	[
		Reject parse, expected:
			"public class modifier to be provided only when the class name \
			\|is statically known"
	];
	If |classNameType| = 1 then
	[
		className ::= classNameType's instance;
		If public ∧ [ ¬className ∈ publicNames ] then
		[
			Reject parse, expected:
				"\""
				++ className
				++ "\" to be included in the module's \"Names\" section"
		];
	];
	supertype ::= meta's instance;
	oldDefinitions ::= supertype→map;
	newDefinitions : field type map := {};
	From 1 to relevant |optionalImmutable[1]| do
	[
		index : natural number
	|
		def ::= optionalImmutable[1][index];
		publicField ::= def[1]'s instance;
		reconstructible ::= def[2]'s instance;
		atomType ::= def[3];
		newType ::= def[4]'s instance;
		If |atomType| ≠ 1 then
		[
			Reject parse, expected:
				"all field atoms to be known statically"
		];
		fieldAtom ::= atomType's instance;
		accessorName ::= accessor name for fieldAtom;
		If publicField then
		[
			If ¬public then
			[
				Reject parse, expected:
					"\""
					++ accessorName
					++ "\" to be private (because the class is private)"
			];
			If ¬accessorName ∈ publicNames then
			[
				Reject parse, expected:
					"\""
					++ accessorName
					++ "\" to be included in the module's \"Names\" section\
					\| (because it is public)"
			];
			If reconstructible then
			[
				reconstructorName ::= reconstructor name for <fieldAtom>;
				If ¬reconstructorName ∈ publicNames then
				[
					Reject parse, expected:
						"\""
						++ reconstructorName
						++ "\" to be included in the module's \"Names\"\
							\| section (because it is public)"
				];
			];
		];
		If fieldAtom ∈ newDefinitions then
		[
			Reject parse, expected:
				fieldAtom's name
				++ " to appear only once during extension (but it already\
				\| appeared with type = "
				++ “newDefinitions[fieldAtom]”
				++ ")"
		];
		oldType ::= oldDefinitions[fieldAtom] else [any];
		If ¬newType ⊆ oldType then
		[
			Reject parse, expected:
				"covariant specialization of "
				++ fieldAtom's name
				++ " (but new field type "
				++ “newType”
				++ " is not a subtype of "
				++ “oldType”
				++ ")"
		];
		newDefinitions := eject ↑newDefinitions + fieldAtom→newType;
	];
	From 1 to relevant |optionalMutable[1]| do
	[
		index : natural number
	|
		def ::= optionalMutable[1][index];
		publicField ::= def[1]'s instance;
		referable ::= def[3]'s instance;
		readOnly ::= def[4]'s instance;
		atomType ::= def[5];
		newType ::= def[6]'s instance;
		If |atomType| ≠ 1 then
		[
			Reject parse, expected:
				"all field atoms to be known statically"
		];
		fieldAtom ::= atomType's instance;
		accessorName ::= accessor name for fieldAtom;
		If publicField then
		[
			If ¬public then
			[
				Reject parse, expected:
					"\""
					++ accessorName
					++ "\" to be private (because the class is private)"
			];
			If ¬accessorName ∈ publicNames then
			[
				Reject parse, expected:
					"\""
					++ accessorName
					++ "\" to be included in the module's \"Names\" section\
					\| (because it is public)"
			];
			If referable then
			[
				refererName ::= referer name for fieldAtom;
				If ¬refererName ∈ publicNames then
				[
					Reject parse, expected:
						"\""
						++ refererName
						++ "\" to be included in the module's \"Names\"\
							\| section (because it is public)"
				];
			];
			Unless readOnly then
			[
				mutatorName ::= mutator name for fieldAtom;
				If ¬mutatorName ∈ publicNames then
				[
					Reject parse, expected:
						"\""
						++ mutatorName
						++ "\" to be included in the module's \"Names\"\
							\| section (because it is public)"
				];
			];
		];
		If fieldAtom ∈ newDefinitions then
		[
			Reject parse, expected:
				fieldAtom's name
				++ " to appear only once during extension (but it already\
				\| appeared with type = "
				++ “newDefinitions[fieldAtom]”
				++ ")"
		];
		oldType ::= oldDefinitions[fieldAtom] else [newType];
		Unless newType = oldType then
		[
			Reject parse, expected:
				"equivalent specification of "
				++ fieldAtom's name
				++ " (but new field type "
				++ “newType”
				++ " is not equivalent to "
				++ “oldType”
				++ ")"
		];
		newDefinitions := eject ↑newDefinitions + fieldAtom→newType;
	];
	From 1 to relevant |optionalReconstructors[1]| do
	[
		index : natural number
	|
		spec ::= optionalReconstructors[1][index];
		publicSpec ::= spec[1]'s instance;
		atomsType ::= spec[2];
		fieldAtoms : <atom…|> := <>;
		From 1 to relevant |atomsType| do
		[
			atomTypeIndex : natural number
		|
			atomType ::= atomsType[atomTypeIndex];
			If |atomType| ≠ 1 then
			[
				Reject parse, expected:
					"all reconstructor field atoms to be known statically"
			];
			fieldAtoms := eject ↑fieldAtoms ++ <atomType's instance>;
		];
		nonemptyFieldAtoms ::= cast fieldAtoms into [ t : <atom…|1..> | t ];
		reconstructorName ::= reconstructor name for nonemptyFieldAtoms;
		If publicSpec then
		[
			If ¬public then
			[
				Reject parse, expected:
					"\""
					++ reconstructorName
					++ "\" to be private (because the class is private)"
			];
			If ¬reconstructorName ∈ publicNames then
			[
				Reject parse, expected:
					"\""
					++ reconstructorName
					++ "\" to be included in the module's \"Names\" section\
					\| (because it is public)"
			];
		];
	];
	⊤
];

/**
 * Construct and answer an object which is an instance of {@param "objectType"}
 * and whose field values are determined by {@param "optional"}.
 *
 * @method "a|an_«with«_::=_‡,»»"
 * @param "objectType" "object's type"
 *        An object type that must be a supertype of the answer.
 * @param "optional" "<<<atom, boolean, any…|3>…|1..>…|0..1>"
 *        A tuple of field assignments. The outermost tuple may be empty (but
 *        only to support the case that {@code objectType = object}), but
 *        usually contains a single tuple of field assignments. A field
 *        assignment is a 3-tuple that consists of 1) an atom that uniquely
 *        identifies the field, 2) a boolean that is {@method "true"} if the
 *        field is mutable and a variable should be created and initialized, and
 *        3) the field value.
 * @returns "object"
 *          The requested object type.
 * @category "Objects" "Constructors"
 */
Public method "a|an_«with«_«:»?:=_‡,»»" is
[
	objectType : object meta,
	optional : <<<atom, boolean, any…|3>…|1..>…|0..1>
|
	objectMap ::= objectType→map;
	defs ::= optional[1] else [<>];
	fieldAtoms : {atom|} := ∅;
	/* Process each field definition, ensuring its uniqueness. Create
	 * appropriately typed variables whenever assignment forms are encountered.
	 */
	assignments ::=
		map defs through
		[
			def : <atom, boolean, any…|3>
		|
			fieldAtom ::= def[1];
			If fieldAtom ∈ fieldAtoms then
			[
				early failure function(
					object-instantiation-contains-duplicates code)
			];
			fieldAtoms := eject ↑fieldAtoms + fieldAtom;
			/* If the assignment form (:=) was used, then create a new variable
			 * and initialize it with the specified value.
			 */
			value ::= def[3];
			/* Construct the field assignment. */
			<fieldAtom,
				if ¬def[2] then
				[
					/* The semantic restriction ensures that this will not fail
					 * at runtime.
					 */
					cast objectMap[fieldAtom] into
					[
						varType : variable meta
					|
						readType ::= cast varType's read type
							into [t : any meta | t];
						var ::= new ↑readType;
						↓var ?= value;
						var
					]
				]
				else
				[
					value
				]>
		];
	/* Synthesize assignments whenever appropriate and necessary, taking care
	 * not to override any user assignments.
	 */
	syntheticAssignments : field tuple := <>;
	For each objectMap do
	[
		fieldAtom : atom,
		fieldType : any meta
	|
		/* Don't override the user's assignments. */
		If ¬fieldAtom ∈ fieldAtoms then
		[
			/* Any field whose type is an instance type on a nontype may have
			 * its value synthesized.
			 */
			If |fieldType| = 1 ∧ [fieldType ⊆ nontype] then
			[
				syntheticAssignments := eject ↑syntheticAssignments
					++ <<fieldAtom, fieldType's instance>>;
			]
			else
			[
				/* Create any variables not explicitly assigned by the user. */
				Cast fieldType into
				[
					varType : variable meta
				|
					readType ::= cast varType's read type
						into [t : any meta | t];
					var ::= new ↑readType;
					syntheticAssignments := eject ↑syntheticAssignments
						++ <<fieldAtom, var>>;
				]
				else
				[
					/* Do nothing. */
				];
			];
		];
	];
	/* Instantiate the object and certify its type. */
	newObject ::= (assignments ++ syntheticAssignments)→object;
	If ¬newObject ∈ objectType then
	[
		early failure function(
			object-instantiation-did-not-produce-instance code)
	];
	newObject
] : object;

/**
 * Object instantiation statically requires that:
 *
 * - Every field atom of the instantiation tuple is known.
 * - Each field atom of the instantiation tuple appears only once during
 *   instantiation.
 * - An assigned value conforms to the field type.
 * - An assignment occurs for every field of the object type except those for
 *   which the exact types are known; these will be supplied automatically.
 *
 * @method "a|an_«with«_::=_‡,»»"
 * @restricts "object's type's type"
 * @restricts "<<<atom, boolean, any…|3>…|1..>…|0..1>'s type"
 */
Semantic restriction "a|an_«with«_«:»?:=_‡,»»" is
[
	meta : object meta's type,
	optional : <<<atom, boolean, any…|3>…|1..>…|0..1>'s type
|
	objectType ::= meta's instance;
	definitions ::= objectType→map;
	assignments : field type map := {};
	From 1 to relevant |optional[1]| do
	[
		index : natural number
	|
		def ::= optional[1][index];
		atomType ::= def[1];
		assign ::= ¬def[2]'s instance;
		valueType ::= def[3];
		If |atomType| ≠ 1 then
		[
			Reject parse, expected: "all field atoms to be known statically"
		];
		fieldAtom ::= atomType's instance;
		If fieldAtom ∈ assignments then
		[
			Reject parse, expected:
				fieldAtom's name
				++ " to appear only once during instantiation (but it already\
				\| appeared with type = "
				++ “assignments[fieldAtom]”
				++ ")"
		];
		requiredType ::=
			if assign then
			[
				fieldType ::= definitions[fieldAtom] else
					[
						Reject parse, expected:
							"mutable field assignment not to introduce \
							\|target field "
							++ fieldAtom's name
							++ " (but it is not present in the object type)"
					];
				cast fieldType into
				[
					varType : variable meta
				|
					cast varType's read type into [t : any meta | t]
				]
				else
				[
					Reject parse, expected:
						"mutable field assignment to target a mutable field \
						\|(but "
						++ fieldAtom's name
						++ " is not a mutable field)"
				]
			]
			else
			[
				definitions[fieldAtom] else [any]
			];
		If ¬valueType ⊆ requiredType then
		[
			Reject parse, expected:
				"valid assignment to "
				++ fieldAtom's name
				++ " (but "
				++ “valueType”
				++ " is not a subtype of "
				++ “requiredType”
				++ ")"
		];
		assignments := eject ↑assignments + fieldAtom→valueType;
	];
	For each definitions do
	[
		fieldAtom : atom,
		fieldType : any meta
	|
		If |fieldType| = 1 ∧ [¬fieldType ⊆ type] then
		[
			assignments := eject ↑assignments + fieldAtom→fieldType;
		]
		else if [fieldType ⊆ variable] then
		[
			assignments := eject ↑assignments + fieldAtom→fieldType;
		];
	];
	missing ::= filter definitions' keys by [a : atom | ¬a ∈ assignments];
	If |missing| ≠ 0 then
	[
		Reject parse, expected:
			"assignments for all immutable fields of "
			++ “objectType”
			++ " (but assignments are missing for "
			++ “missing”
			++ ")"
	];
	assignments→object type
];

/**
 * Given an object and a target object type, answer an object that retains the
 * field assignments of the original object but which 1) is also an instance of
 * the new object type and 2) reflects the new (optional) field assignments.
 *
 * @method "_as_«with«_::=_‡,»»"
 * @param "instance" "object"
 *        An object.
 * @param "objectType" "object's type"
 *        An object type that must be a supertype of the answer.
 * @param "optional" "<<<atom, any…|2>…|1..>…|0..1>"
 *        An optional tuple of field assignments. A field assignment is a
 *        2-tuple that consists of 1) an atom that uniquely identifies the field
 *        and 2) the field value.
 * @returns "object"
 *          The requested object type.
 * @category "Objects" "Constructors"
 */
Public method "_as_«with«_::=_‡,»»" is
[
	instance : object,
	objectType : object meta,
	optional : <<<atom, any…|2>…|1..>…|0..1>
|
	assignments ::= optional[1] else [<>];
	fieldAtoms ::= stripe assignments at 1;
	If |fieldAtoms→set| ≠ |fieldAtoms| then
	[
		early failure function(object-instantiation-contains-duplicates code)
	];
	objectMap ::= objectType→map;
	identityAssignments : <<atom, any…|2>…|> := <>;
	For each objectMap do
	[
		fieldAtom : atom,
		fieldType : any meta
	|
		If |fieldType| = 1 ∧ [¬fieldType ⊆ type] then
		[
			identityAssignments := eject ↑identityAssignments
				++ <<fieldAtom, fieldType's instance>>;
		];
	];
	newObject ::=
		(instance→map's bindings ++ assignments ++ identityAssignments)→object;
	If ¬newObject ∈ objectType then
	[
		early failure function(
			object-instantiation-did-not-produce-instance code)
	];
	newObject
] : object;

/**
 * Object adoption statically requires that:
 *
 * - Every field atom of the instantiation tuple is known.
 * - Each field atom of the instantiation tuple appears only once during
 *   instantiation.
 * - An assigned value conforms to the field type.
 * - An assignment occurs for every field of the object type except those for
 *   which the exact types are known; these will be supplied automatically.
 *
 * @method "_as_«with«_::=_‡,»»"
 * @restricts "object's type"
 * @restricts "object's type's type"
 * @restricts "<<<atom, any…|2>…|1..>…|0..1>'s type"
 */
Semantic restriction "_as_«with«_::=_‡,»»" is
[
	instance : object meta,
	meta : object meta's type,
	optional : <<<atom, any…|2>…|1..>…|0..1>'s type
|
	objectType ::= meta's instance;
	definitions ::= objectType→map;
	assignments : field type map := instance→map;
	From 1 to relevant |optional[1]| do
	[
		index : natural number
	|
		def ::= optional[1][index];
		atomType ::= def[1];
		valueType ::= def[2];
		If |atomType| ≠ 1 then
		[
			Reject parse, expected: "all field atoms to be known statically"
		];
		fieldAtom ::= atomType's instance;
		If fieldAtom ∈ assignments then
		[
			Reject parse, expected:
				fieldAtom's name
				++ " to appear only once during instantiation (but it already\
				\| appeared with type = "
				++ “assignments[fieldAtom]”
				++ ")"
		];
		requiredType ::= definitions[fieldAtom] else [ any ];
		If ¬valueType ⊆ requiredType then
		[
			Reject parse, expected:
				"valid assignment to "
				++ fieldAtom's name
				++ " (but "
				++ “valueType”
				++ " is not a subtype of "
				++ “requiredType”
				++ ")"
		];
		assignments := eject ↑assignments + fieldAtom→valueType;
	];
	For each definitions do
	[
		fieldAtom : atom,
		fieldType : any meta
	|
		If |fieldType| = 1 ∧ [ ¬fieldType ⊆ type ] then
		[
			assignments := eject ↑assignments + fieldAtom→fieldType;
		];
	];
	missing ::= filter definitions' keys by [ a : atom | ¬a ∈ assignments ];
	If |missing| ≠ 0 then
	[
		Reject parse, expected:
			"assignments for all fields of "
			++ “objectType”
			++ " (but assignments are missing for "
			++ “missing”
			++ ")"
	];
	assignments→object type
];
