/*
 * Late Math.avail
 * Copyright © 1993-2014, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Late Math"
Versions
	"1.0.0 DEV 2014-04-28"
Extends
	"Math"
Uses
	"Bootstrap",
	"Control Structures",
	"Definers",
	"Early Assertions",
	"Early Functions",
	"Early Logic",
	"Early Sets",
	"Early Tuples",
	"Enumeration Support",
	"Exceptions",
	"Literals",
	"Objects",
	"Sets",
	"Tuples",
	"Types",
	"Variables"
Names
	/* Compound assignment. */
	"_↑+=_",
	"_+=_",
	"_↑-=_",
	"_-=_"
Body

cannotRaiseZeroToZero ::= "either base or exponent not to be 0";
cannotRaiseInfinityToZero ::= "base not to be ±∞ or exponent not to be 0";
cannotRaiseNegativeToInfinity ::=
	"base not to be negative or exponent not to be ±∞";

/* The definitions of `_^_` are recursive, so forward declare them here. */
Abstract method "_^_" is [extended integer, [0..∞]]→extended integer;
Forward method "_^_" is [extended integer, whole number]→extended integer;
Forward method "_^_" is [extended integer, [∞..∞]]→{0, ∞}ᵀ;
Forward method "_^_" is [float, whole number]→float;
Forward method "_^_" is [double, whole number]→double;

/**
 * Compute and answer the result of exponentiating {@param "base"} by {@param
 * "exponent"}.
 * 
 * @method "_^_"
 * @param "base" "number"
 * @param "exponent" "number"
 * @returns "number"
 *          The result of raising {@param "base"} to the {@param "exponent"}
 *          power.
 * @category "Mathematics" "Numbers"
 */
Method "_^_" is
[
	base : number,
	exponent : number
|
	/* Uses the identity: a^b = exp(ln(a^b)) = exp(b*ln(a)). */
	Euler's number ^ (exponent × ln (base→double))
] : number;

/**
 * Construct and answer a function that affects type promotions for the various
 * numeric types. This function is intended for use by semantic restrictions
 * of exponentiation.
 *
 * @method "exponentiation type promotion function for_"
 * @param "operator" "[number, number]→number"
 *        A function that performs exponentiation and answers the result.
 * @returns "[number's type, number's type]→number's type"
 *          A function that handles type promotions for exponentiation.
 */
Private method "exponentiation type promotion function for_" is
[
	operator : [number, number]→number
|
	[
		a : number's type,
		b : number's type
	|
		if |a| = 1 ∧ [|b| = 1] then
		[
			/* The exact values are known statically. Calculate it exactly. */
			(invoke operator with <a's instance, b's instance>)'s type
		]
		else
		[
			if a ⊆ double ∨ [b ⊆ double] then
			[
				/* At least one is known to be double, which forces the result
				 * to be a double.
				 */
				double
			]
			else
			[
				if a = number ∨ [b = number] then
				[
					/* Neither is known to be a double, and at least one is as
					 * weak as a number.  The weak one might be a double at run
					 * time, so we can't limit the output type any more.
					 */
					number
				]
				else
				[
					/* Neither one is as weak as number. */
					if a ⊆ float ∨ [b ⊆ float] then
					[
						/* Either {float,float} or {float,int}, which each
						 * produce a float.
						 */
						float
					]
					else
					[
						if a ⊆ extended integer ∧ [b ⊆ [0..∞]]
						then [extended integer]
						else [number]
					]
				]
			]
		]
	]
];

/**
 * Establish type promotion rules for exponentiation. Also handle instance
 * types.
 * 
 * @method "_^_"
 * @restricts "number"
 * @restricts "number"
 */
Semantic restriction "_^_" is exponentiation type promotion function for
[
	a : number,
	b : number
|
	If b = 0 then
	[
		If a = 0 then
		[
			Reject parse, expected: cannotRaiseZeroToZero
		];
		If a ∈ {-∞, ∞} then
		[
			Reject parse, expected: cannotRaiseInfinityToZero
		];
	];
	If a ∈ extended integer then
	[
		If a < 0 ∧ [ b ∈ {-∞, ∞} ] then
		[
			Reject parse, expected: cannotRaiseNegativeToInfinity
		];
	];
	a ^ b
];

Method "_^_" is
[
	base : extended integer,
	exponent : [∞..∞]
|
	/* Forbid [-∞..-1]^∞ and 1^∞.  For all other n, n^∞=∞. */
	If base < 0 ∨ [ base = 1 ] then
	[
		Raise an arithmetic exception
	];
	if base = 0 then [0] else [∞]
] : {0, ∞}ᵀ;

Forward method "_recursive^_"
	is [extended integer, whole number]→extended integer;

Method "_^_" is
[
	base : extended integer,
	exponent : whole number
|
	/* Forbid -∞^0, and ∞^0.  Use 0^0=1, since this identity is *practical*,
	 * especially when the exponent is expected to be an integer, such as in
	 * power series.
	 *
	 * Use the identities: b^(2x) = (b^2)^x; and: b^(2x+1) = (b^2)^x*b.
	 */
	if exponent = 0 then
	[
		If base ∈ {∞, -∞} then
		[
			Raise an arithmetic exception
		];
		1
	]
	else
	[
		intermediate ::= (base × base) recursive^ (exponent ÷ 2);
		if exponent is odd then [ intermediate × base ] else [ intermediate ]
	]
] : extended integer;

/**
 * Compute and answer the result of exponentiating {@param "base"} by {@param
 * "exponent"}. Do not complain about indeterminate values, under the assumption
 * that those are dealt with by the actual {@param "_^_"} method.
 *
 * @method "_recursive^_"
 * @param "base" "extended integer"
 * @param "exponent" "whole number"
 * @returns "extended integer"
 *          The result of raising {@param "base"} to the {@param "exponent"}
 *          power.
 */
Private method "_recursive^_" is
[
	base : extended integer,
	exponent : whole number
|
	if exponent = 0 then
	[
		1
	]
	else
	[
		intermediate ::= (base × base) recursive^ (exponent ÷ 2);
		if exponent is odd then [ intermediate × base ] else [ intermediate ]
	]
] : extended integer;

Method "_^_" is
[
	base : float,
	exponent : whole number
|
	/*  Uses the identities: b^(2x) = (b^2)^x; and: b^(2x+1) = (b^2)^x*b. */
	if exponent = 0 then
	[
		1.0→float
	]
	else
	[
		intermediate ::= (base × base) ^ (exponent ÷ 2);
		if exponent is odd then [ intermediate × base ] else [ intermediate ]
	]
] : float;

Method "_^_" is
[
	base : double,
	exponent : whole number
|
	/*  Uses the identities: b^(2x) = (b^2)^x; and: b^(2x+1) = (b^2)^x*b. */
	if exponent = 0 then
	[
		1.0
	]
	else
	[
		intermediate ::= (base × base) ^ (exponent ÷ 2);
		if exponent is odd then [ intermediate × base ] else [ intermediate ]
	]
] : double;

/**
 * Support exponentiation of ranges of integral arguments.  This could be useful
 * for semantic restrictions in clients that compose things with exponentiation.
 *
 * @method "_^_"
 * @param "base" "extended integer's type"
 * @param "power" "whole number's type"
 * @returns "extended integer's type"
 */
Method "_^_" is
[
	base : extended integer's type,
	power : whole number's type
|
	interestingBases ::= {
		⎣base⎦,
		⎣base⎦ + 1,
		-2,
		-1,
		0,
		1,
		2,
		⎡base⎤ - 1,
		⎡base⎤
	} → tuple;
	interestingPowers ::= {
		⎣power⎦,
		⎣power⎦ + 1,
		2,
		3,
		⎡power⎤ - 1 max 0,
		⎡power⎤
	} → tuple;
	augmentedBase ::= [⎣base⎦ .. ⎡base⎤];
	augmentedPower ::= [⎣power⎦ .. ⎡power⎤];
	range : extended integer's type := ⊥;
	openLimits : extended integer's type := ⊥;
	For each interestingBases do
	[
		interestingBase : extended integer
	|
		If interestingBase ∈ augmentedBase then
		[
			baseInclusive ::= interestingBase ∈ base;
			For each interestingPowers do
			[
				interestingPower : [0..∞]
			|
				If interestingPower ∈ augmentedPower then
				[
					Guard
					[
						value : extended integer :=
							interestingBase ^ interestingPower;
						If baseInclusive ∧ [interestingPower ∈ power] then
						[
							range := range ∪ [value..value];
						]
						else
						[
							openLimits := openLimits ∪ [value..value];
						];
					]
					intercept
					[
						suppressed : exception
					|
						/* This particular combination would fail at runtime
						 * anyhow, so it doesn't contribute to the type.
						 */
					];
				];
			];
		];
	];
	if range = ⊥ then
	[
		(⎣openLimits⎦..⎡openLimits⎤)
	]
	else if [ -∞ ∈ openLimits ∧ [ ∞ ∈ openLimits ] ] then
	[
		range ∪ integer
	]
	else if [ -∞ ∈ openLimits ] then
	[
		range ∪ (-∞..⎡range⎤)
	]
	else if [ ∞ ∈ openLimits ] then
	[
		range ∪ (⎣range⎦..∞)
	]
	else
	[
		range
	]
] : extended integer's type;


/**
 * Restrict integral exponentiation, in particular when the power is a whole
 * number.
 *
 * @method "_^_"
 * @restricts "extended integer's type"
 * @restricts "whole number's type"
 */
Semantic restriction "_^_" is
[
	base : extended integer's type,
	power : whole number's type
|
	base ^ power
];

/**
 * Calculate the logarithm of the specified number to the specified base, using
 * {@type "double"}s for intermediate values.
 * 
 * @method "log_of_"
 * @param "b" "integer"
 *        The logarithm base to use.
 * @param "n" "integer"
 *        The number whose logarithm should be computed.
 * @returns "double"
 *          The logarithm of {@param "n"} to base {@param "b"}.
 * @category "Mathematics" "Numbers"
 */
Stable method "log_of_" is
[
	b : natural number,
	n : extended integer
|
	log b→double of n→double
] : double;

Stable method "log_of_" is
[
	b : natural number,
	n : ∞'s type
|
	∞→double
] : double;

Stable method "log_of_" is
[
	b : natural number,
	n : nonpositive integer
|
	Raise a cannot-compute-logarithm-of-nonpositive-number exception
] : ⊥;

Private method "compound addition function" is
[
	[
		var : read number/write ⊥,
		delta : number
	|
		var ?= eject var + delta;
	] : ⊤
];

/**
 * Increment the variable by {@param "delta"}.
 *
 * @method "_↑+=_"
 * @category "Variables" "Mathematics" "Integers"
 * @param "var" "variable"
 *        A numeric variable.
 * @param "delta" "number"
 *        The amount by which to increment {@param "var"}.
 * @returns "⊤"
 * @raises "cannot-add-unlike-infinities exception"
 * @raises "cannot-store-incorrectly-typed-value exception"
 */
Public method "_↑+=_" is compound addition function;

/**
 * Increment the variable by {@param "delta"}.
 *
 * @method "_↑+=_"
 * @category "Variables" "Mathematics" "Integers"
 * @param "var" "variable"
 *        A numeric variable.
 * @param "delta" "number"
 *        The amount by which to increment {@param "var"}.
 * @returns "⊤"
 * @raises "cannot-add-unlike-infinities exception"
 * @raises "cannot-store-incorrectly-typed-value exception"
 */
Public method "_+=_" is compound addition function;

Private method "compound subtraction function" is
[
	[
		var : read number/write ⊥,
		delta : number
	|
		var ?= eject var - delta;
	] : ⊤
];

/**
 * Decrement the variable by {@param "delta"}.
 *
 * @method "_↑-=_"
 * @category "Variables" "Mathematics" "Integers"
 * @param "var" "variable"
 *        A numeric variable.
 * @param "delta" "number"
 *        The amount by which to decrement {@param "var"}.
 * @returns "⊤"
 * @raises "cannot-subtract-like-infinities exception"
 * @raises "cannot-store-incorrectly-typed-value exception"
 */
Public method "_↑-=_" is compound subtraction function;

/**
 * Increment the variable by {@param "delta"}.
 *
 * @method "_↑-=_"
 * @category "Variables" "Mathematics" "Integers"
 * @param "var" "variable"
 *        A numeric variable.
 * @param "delta" "number"
 *        The amount by which to decrement {@param "var"}.
 * @returns "⊤"
 * @raises "cannot-subtract-like-infinities exception"
 * @raises "cannot-store-incorrectly-typed-value exception"
 */
Public method "_-=_" is compound subtraction function;

Private method "compound arithmetic semantic restriction" is
[
	[
		var : (read number/write ⊥)'s type,
		delta : number's type
	|
		If ¬var's write type ⊆ number then
		[
			Reject parse, expected: "variable to accept and yield numbers"
		];
		⊤
	]
];

Semantic restriction "_↑+=_" is compound arithmetic semantic restriction;
Semantic restriction "_+=_" is compound arithmetic semantic restriction;
Semantic restriction "_↑-=_" is compound arithmetic semantic restriction;
Semantic restriction "_-=_" is compound arithmetic semantic restriction;

Grammatical restriction
{
	"_↑+=_", "_+=_",
	"_↑+=_", "_+=_"
} is <{"`↑_↑"}, ∅>;
