/*
 * Types.avail
 * Copyright © 1993-2014, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Types"
Versions
	"1.0.0 DEV 2014-04-28"
Extends
Uses
	"Bootstrap",
	"Collections" = ("_[_]else_"),
	"Early Assertions",
	"Early Conditionals",
	"Early Control Structures",
	"Early Definers",
	"Early Logic",
	"Early Math",
	"Early Tuples",
	"Enumeration Support",
	"Literals",
	"Variables"
Names
	/* Function type constructor. */
	"[«_‡,»]→_",
	/* Tuple type constructors. */
	"<«_‡,»`…`|_.._>",
	"<«_‡,»`…`|_..>",
	"<«_‡,»`…`|.._>",
	"<«_‡,»`…`|_>",
	"<«_‡,»`…`|>",
	/* Set type constructors. */
	"set«_»of_",
	"{_`|_.._}",
	"{_`|_..}",
	"{_`|.._}",
	"{_`|}",
	/* Map type constructors. */
	"{_→_`|_.._}",
	"{_→_`|_..}",
	"{_→_`|.._}",
	"{_→_`|}",
	/* Conversion utilities. */
	"“_”(cardinality restriction)",
	/* Shorthand. */
	"_⊈_"
Body

/**
 * Construct and answer a function type from the lexically specified argument
 * types and return type.
 * 
 * @method "[«_‡,»]→_"
 * @param "argTypes" "tuple of any meta"
 * 	The lexically specified argument types.
 * @param "returnType" "type"
 * 	The return type.
 * @returns "function meta"
 *  The requested function type.
 */
Public method "[«_‡,»]→_" is
[
	argTypes : tuple of any meta,
	returnType : type
|
	function accepting argTypes and returning returnType
] : function meta;

Grammatical restriction {"_`?", "_+", "_*"} is <{"[«_‡,»]→_", "[`…]→_"}>;
Grammatical restriction "[«_‡,»]→_" is <∅, {"_'s⁇type"}>;
Grammatical restriction "[`…]→_" is <{"_'s⁇type"}>;

/**
 * Tuple type constructor's semantic restriction.
 *
 * @method "<_,_`…`|_>"
 * @restricts "tuple of any meta's type"
 * @restricts "any meta's type"
 * @restricts "whole number meta's type"
 */
Semantic restriction "<_,_`…`|_>" is
[
	leadingTypesTypes : tuple of any meta's type,
	defaultTypeType : any meta's type,
	cardinalityTypeType : whole number meta's type
|
	leadingTupleLeadingAndDefaultTypes :: = 
		leadingTypesTypes' leading types ++ <leadingTypesTypes' default type>;
	leadingTypesTypesSize ::= |leadingTupleLeadingAndDefaultTypes|;
	typesTypesInstanceTuple : tuple := <>;

	From 1 to leadingTypesTypesSize do
	[
		index : natural number
	|
		typesTypesInstanceTuple := 
			if |leadingTupleLeadingAndDefaultTypes[index]| ≠ 1 then
			[
				Assert: leadingTupleLeadingAndDefaultTypes[index] ∈ {type,⊥}
					("tuple leading type at index: " 
						++ “index”
						++ " has size ≠ 1 and is "
						++  “leadingTupleLeadingAndDefaultTypes[index]”
						++ ", however only type or ⊥ is acceptable"
						++ " in this case.");
				if leadingTupleLeadingAndDefaultTypes[index] = type then
				[
					eject typesTypesInstanceTuple ++ <type>
				]
				else
				[
					eject typesTypesInstanceTuple
				]
			]
			else
			[
				eject typesTypesInstanceTuple ++ 
					<leadingTupleLeadingAndDefaultTypes[index]'s instance>
			];
		true
	];

	finalDefaultType ::=
		if |defaultTypeType| ≠ 1 then
		[
			Assert: defaultTypeType ∈ {type}
				("tuple default type is "
					++ “defaultTypeType” 
					++ " and has size ≠ 1, however only type is acceptable"
					++ " in this case.");
			type
		]
		else
		[
			defaultTypeType's instance
		];

	cardinalityTypeTypeInstance :: = cardinalityTypeType's instance;
	bound ::= cast ⎡cardinalityTypeTypeInstance⎤ + 
		1 into [ t : [0..∞] | t ];
	lower ::= ⎣cardinalityTypeTypeInstance⎦;
	allTypesToUse ::= cast typesTypesInstanceTuple into 
		[t: <<>,any's type…|[0..∞)> | t];

	<allTypesToUse,finalDefaultType…|[lower..bound)>'s type
];

/**
 * Tuple type constructor.
 * @method "<«_‡,»`…`|_.._>"
 * @param "leadingAndDefaultTypes" "<<>, any's type…|natural number>" 
 *		a tuple of the types in the tuple
 * @param "minimumSize" "whole number" 
 *		minimum cardinality
 * @param "maximumSize" "[0..∞]"
 *		maximum cardinality
 * @returns "tuple meta"
 *    The requested tuple's type.
 */
Public method "<«_‡,»`…`|_.._>" is
[
	leadingAndDefaultTypes : <<>, any's type…|natural number>,
	minimumSize : whole number,
	maximumSize : [0..∞]
|
	typesSize ::= |leadingAndDefaultTypes|;
	lastLeadingTypeIndex ::= cast typesSize - 1 into [ t : whole number | t ];
	leadingTypes ::= leadingAndDefaultTypes[..lastLeadingTypeIndex];
	defaultType ::= leadingAndDefaultTypes[typesSize];
	bound ::= cast maximumSize + 1 into [ t : [0..∞] | t ];
	<leadingTypes, defaultType…|[minimumSize..bound)>
] : tuple meta;

/**
 * @method "<«_‡,»`…`|_.._>"
 * @restricts "<<>, any's type…|natural number>'s type"
 * @restricts "whole number's type"
 * @restricts "[0..∞]'s type"
 */ 
Semantic restriction "<«_‡,»`…`|_.._>" is
[
	leadingAndDefaultTypesTypes : <<>, any's type…|natural number>'s type,
	minimumSizeType : whole number's type,
	maximumSizeType : [0..∞]'s type
|
	leadingTypesTypes ::= 
		leadingAndDefaultTypesTypes' leading types;
	leadingTypesTypesSize ::= |leadingTypesTypes|;
	typesTypesInstanceTuple : tuple := <>;

	From 1 to leadingTypesTypesSize do
	[
		index : natural number
	|
		typesTypesInstanceTuple := 
			if |leadingTypesTypes[index]| ≠ 1 then
			[
				Assert: leadingTypesTypes[index] = type 
					("tuple leading type at index: "
						++ “index”
						++ " has size ≠ 1 and is "
						++ “leadingTypesTypes[index]”
						++ ", however only type is acceptable"
						++ " in this case.");
				eject typesTypesInstanceTuple ++ <type>
			]
			else
			[
				eject typesTypesInstanceTuple ++ 
					<leadingTypesTypes[index]'s instance>
			];
		true
	];

	defaultTypeType ::= leadingAndDefaultTypesTypes' default type;
	defaultTypeTypeInstance ::=
		if |defaultTypeType| ≠ 1 then
		[
			Assert: defaultTypeType = type 
				("tuple default type is "
					++ “defaultTypeType”
					++ " and has size ≠ 1, however only type is acceptable"
					++ " in this case.");
			type
		]
		else
		[
			defaultTypeType's instance
		];

	bound ::= cast ⎡maximumSizeType⎤ + 1 into [ t : [0..∞] | t ];
	lower ::= ⎣minimumSizeType⎦;
	allTypesToUse ::= cast typesTypesInstanceTuple into 
		[t: any's type* | t];

	<allTypesToUse,defaultTypeTypeInstance…|[lower..bound)>'s type
];

/**
 * Tuple type constructor with max cardinality of ∞.
 *
 * @method "<«_‡,»`…`|_..>"
 * @param "leadingAndDefaultTypes" "<<>, any's type…|natural number>" 
 *		a tuple of the types in the tuple
 * @param "minimumSize" "whole number" 
 *		minimum cardinality
 * @returns "tuple meta"
 *    The requested tuple's type.
 */
Public method "<«_‡,»`…`|_..>" is
[
	leadingAndDefaultTypes : <<>, any's type…|natural number>,
	minimumSize : whole number
|
	typesSize ::= |leadingAndDefaultTypes|;
	lastLeadingTypeIndex ::= cast typesSize - 1 into [ t : whole number | t ];
	leadingTypes ::= leadingAndDefaultTypes[..lastLeadingTypeIndex];
	defaultType ::= leadingAndDefaultTypes[typesSize];
	<leadingTypes, defaultType…|[minimumSize..∞)>
] : tuple meta;

/**
 * @method "<«_‡,»`…`|_..>"
 * @restricts "<<>, any's type…|natural number>'s type"
 * @restricts "whole number's type"
 */ 
Semantic restriction "<«_‡,»`…`|_..>" is
[
	leadingAndDefaultTypesTypes : <<>, any's type…|natural number>'s type,
	minimumSizeType : whole number's type
|
	leadingTypesTypes ::= 
	leadingAndDefaultTypesTypes' leading types;
	leadingTypesTypesSize ::= |leadingTypesTypes|;
	typesTypesInstanceTuple : tuple := <>;

	From 1 to leadingTypesTypesSize do
	[
		index : natural number
	|
		typesTypesInstanceTuple := 
			if |leadingTypesTypes[index]| ≠ 1 then
			[
				Assert: leadingTypesTypes[index] = type 
					("tuple leading type at index: "
						++ “index”
						++ " has size ≠ 1 and is "
						++ “leadingTypesTypes[index]”
						++ ", however only type is acceptable in this case.");
				eject typesTypesInstanceTuple ++ <type>
			]
			else
			[
				eject typesTypesInstanceTuple ++ 
					<leadingTypesTypes[index]'s instance>
			];
		true
	];

	defaultTypeType ::= leadingAndDefaultTypesTypes' default type;
	defaultTypeTypeInstance ::=
		if |defaultTypeType| ≠ 1 then
		[
			Assert: defaultTypeType = type 
				("tuple default type is "
					++ “defaultTypeType”
					++ " and has size ≠ 1, however only type is acceptable "
					++ "in this case.");
			type
		]
		else
		[
			defaultTypeType's instance
		];

	lower ::= ⎣minimumSizeType⎦;
	allTypesToUse ::= cast typesTypesInstanceTuple into 
		[t: any's type* | t];

	<allTypesToUse,defaultTypeTypeInstance…|[lower..∞)>'s type
];

/**
 * Tuple type constructor with minimum cardinality of 0.
 *
 * @method "<«_‡,»`…`|.._>"
 * @param "leadingAndDefaultTypes" "<<>, any's type…|natural number>" 
 *		a tuple of the types in the tuple 
 * @param "maximumSize" "[0..∞]"
 *		maximum cardinality
 * @returns "tuple meta"
 *    The requested tuple's type.
 */
Public method "<«_‡,»`…`|.._>" is
[
	leadingAndDefaultTypes : <<>, any's type…|natural number>,
	maximumSize : [0..∞]
|
	typesSize ::= |leadingAndDefaultTypes|;
	lastLeadingTypeIndex ::= cast typesSize - 1 into [ t : whole number | t ];
	leadingTypes ::= leadingAndDefaultTypes[..lastLeadingTypeIndex];
	defaultType ::= leadingAndDefaultTypes[typesSize];
	bound ::= cast maximumSize + 1 into [ t : [0..∞] | t ];
	<leadingTypes, defaultType…|[0..bound)>
] : tuple meta;

/**
 * @method "<«_‡,»`…`|.._>"
 * @restricts "<<>, any's type…|natural number>'s type"
 * @restricts "[0..∞]'s type"
 */ 
Semantic restriction "<«_‡,»`…`|.._>" is
[
	leadingAndDefaultTypesTypes : <<>, any's type…|natural number>'s type,
	maximumSizeType : [0..∞]'s type
|
	leadingTypesTypes ::= 
	leadingAndDefaultTypesTypes' leading types;
	leadingTypesTypesSize ::= |leadingTypesTypes|;
	typesTypesInstanceTuple : tuple := <>;

	From 1 to leadingTypesTypesSize do
	[
		index : natural number
	|
		typesTypesInstanceTuple := 
			if |leadingTypesTypes[index]| ≠ 1 then
			[
				Assert: leadingTypesTypes[index] = type 
					("tuple leading type at index: "
						++ “index”
						++ " has size ≠ 1 and is "
						++ “leadingTypesTypes[index]”
						++ ", however only type is acceptable in this case.");
				eject typesTypesInstanceTuple ++ <type>
			]
			else
			[
				eject typesTypesInstanceTuple ++ 
					<leadingTypesTypes[index]'s instance>
			];
		true
	];

	defaultTypeType ::= leadingAndDefaultTypesTypes' default type;
	defaultTypeTypeInstance ::=
		if |defaultTypeType| ≠ 1 then
		[
			Assert: defaultTypeType = type 
				("tuple default type is "
					++ “defaultTypeType”
					++ " and has size ≠ 1, however only type is acceptable"
					++ " in this case.");
			type
		]
		else
		[
			defaultTypeType's instance
		];

	bound ::= cast ⎡maximumSizeType⎤ + 1 into [ t : [0..∞] | t ];
	allTypesToUse ::= cast typesTypesInstanceTuple into 
		[t: any's type* | t];

	<allTypesToUse,defaultTypeTypeInstance…|[0..bound)>'s type
];

/**
 * Tuple type constructor with exact tuple size for cardinality.
 *
 * @method "<«_‡,»`…`|_>"
 * @param "leadingAndDefaultTypes" "<<>, any's type…|natural number>" 
 *		a tuple of the types in the tuple
 * @param "exactSize" "whole number" 
 *		the minimum and maximum cardinality
 * @returns "tuple meta"
 *    The requested tuple's type's type.
 */
Public method "<«_‡,»`…`|_>" is
[
	leadingAndDefaultTypes : <<>, any's type…|natural number>,
	exactSize : whole number
|
	typesSize ::= |leadingAndDefaultTypes|;
	lastLeadingTypeIndex ::= cast typesSize - 1 into [ t : whole number | t ];
	leadingTypes ::= leadingAndDefaultTypes[..lastLeadingTypeIndex];
	defaultType ::= leadingAndDefaultTypes[typesSize];
	bound ::= cast exactSize + 1 into [ t : [0..∞] | t ];
	<leadingTypes, defaultType…|[exactSize..bound)>
] : tuple meta;

/**
 * @method "<«_‡,»`…`|_>"
 * @restricts "<<>, any's type…|natural number>'s type"
 * @restricts "whole number's type"
 */ 
Semantic restriction "<«_‡,»`…`|_>" is
[
	leadingAndDefaultTypesTypes : <<>, any's type…|natural number>'s type,
	exactSizeType : whole number's type
|
	leadingTypesTypes ::= 
	leadingAndDefaultTypesTypes' leading types;
	leadingTypesTypesSize ::= |leadingTypesTypes|;
	typesTypesInstanceTuple : tuple := <>;

	From 1 to leadingTypesTypesSize do [ 
		index : natural number
	|
		typesTypesInstanceTuple := 
			if |leadingTypesTypes[index]| ≠ 1 then
			[
				Assert: leadingTypesTypes[index] = type 
					("tuple leading type at index: "
						++ “index”
						++ " has size ≠ 1 and is "
						++ “leadingTypesTypes[index]”
						++ ", however only type is acceptable "
						++ "in this case.");
				eject typesTypesInstanceTuple ++ <type>
			]
			else
			[
				eject typesTypesInstanceTuple ++ 
					<leadingTypesTypes[index]'s instance>
			];
		true
	];

	defaultTypeType ::= leadingAndDefaultTypesTypes' default type;
	defaultTypeTypeInstance ::=
		if |defaultTypeType| ≠ 1 then
		[
			Assert: defaultTypeType = type 
				("tuple default type is "
					++ “defaultTypeType”
					++ " and has size ≠ 1, however only type is acceptable "
					++ "in this case.");
			type
		]
		else
		[
			defaultTypeType's instance
		];

	lower ::= ⎣exactSizeType⎦;
	upper ::= cast ⎡exactSizeType⎤ + 1 into [ t : [0..∞] | t ];
	allTypesToUse ::= cast typesTypesInstanceTuple into 
		[t: any's type* | t];

	<allTypesToUse,defaultTypeTypeInstance…|[lower..upper)>'s type
];

/**
 * Tuple type constructor with cardinality [0..∞).
 *
 * @method "<«_‡,»`…`|>"
 * @param "leadingAndDefaultTypes" "<<>, any's type…|natural number>" 
 *		a tuple of the types in the tuple
 * @returns "tuple meta"
 *    The requested tuple's type's type.
 */
Public method "<«_‡,»`…`|>" is
[
	leadingAndDefaultTypes : <<>, any's type…|natural number>
|
	typesSize ::= |leadingAndDefaultTypes|;
	lastLeadingTypeIndex ::= cast typesSize - 1 into [ t : whole number | t ];
	leadingTypes ::= leadingAndDefaultTypes[..lastLeadingTypeIndex];
	defaultType ::= leadingAndDefaultTypes[typesSize];
	<leadingTypes, defaultType…|whole number>
] : tuple meta;

/**
 * @method "<«_‡,»`…`|>"
 * @restricts "<<>, any's type…|natural number>'s type"
 */ 
Semantic restriction "<«_‡,»`…`|>" is
[
	leadingAndDefaultTypesTypes : <<>, any's type…|natural number>'s type
|
	leadingTypesTypes ::= 
	leadingAndDefaultTypesTypes' leading types;
	leadingTypesTypesSize ::= |leadingTypesTypes|;
	typesTypesInstanceTuple : tuple := <>;

	From 1 to leadingTypesTypesSize do
	[
		index : natural number
	|
		typesTypesInstanceTuple := 
			if |leadingTypesTypes[index]| ≠ 1 then [
				Assert: leadingTypesTypes[index] = type 
					("tuple leading type at index: "
						++ “index”
						++ " has size ≠ 1 and is "
						++ “leadingTypesTypes[index]” 
						++ ", however only type is acceptable in this case.");
				eject typesTypesInstanceTuple ++ <type>
			]
			else
			[
				eject typesTypesInstanceTuple ++ 
					<leadingTypesTypes[index]'s instance>
			];
		true
	];

	defaultTypeType ::= leadingAndDefaultTypesTypes' default type;
	defaultTypeTypeInstance ::=
		if |defaultTypeType| ≠ 1 then
		[
			Assert: defaultTypeType = type 
				("tuple default type is "
					++ “defaultTypeType” 
					++ " and has size ≠ 1, however only type is acceptable"
					++ " in this case.");
			type
		]
		else
		[
			defaultTypeType's instance
		];

	allTypesToUse ::= cast typesTypesInstanceTuple into 
		[t: any's type* | t];

	<allTypesToUse,defaultTypeTypeInstance…|[0..∞)>'s type
];

/**
 * @method "{_`|_}"
 * @restricts "any meta's type"
 * @restricts "whole number meta's type"
 */
Semantic restriction "{_`|_}" is
[
	elementTypeType : any meta's type,
	cardinalityTypeType : whole number meta's type
|
	cardinalityTypeTypeInstance :: = cardinalityTypeType's instance;
	bound ::= cast ⎡cardinalityTypeTypeInstance⎤ + 
		1 into [ t : [0..∞] | t ];
	lower ::= ⎣cardinalityTypeTypeInstance⎦;
	{elementTypeType's instance|[lower..bound)}'s type
];

/**
 * Construct and answer a set type with the specified element type and the 
 * specified minimum value and maximum value of the cardinalities.
 * 
 * @method "{_`|_.._}"
 * @param "elementType" "any's type" 
 *		The element type.
 * @param "minimumSize" "whole number" 
 * 		The minimum cardinality of the set.
 * @param "maximumSize" "[0..∞]"
 *		The maximum cardinality of the set.
 * @returns "set meta"
 *    The requested set type. Instances have elements that conform to
 *    `elementType` and cardinalities, using the supplied minimum and maximum 
 *    provided values, that conform to `cardinalityType`.
 */
Public method "{_`|_.._}" is
[
	elementType : any's type,
	minimumSize : whole number,
	maximumSize : [0..∞]
|
	/* If `elementType` is an enumeration and `exactSize` is the cardinality of
	 * that enumeration's membership, then build an instance type.
	 */
	if |elementType| = minimumSize ∧ [ minimumSize = maximumSize ] then
	[
		elementType's instances' type
	]
	/* Otherwise just build an ordinary set type. */
	else
	[
		bound ::= cast maximumSize + 1 into [ t : [0..∞] | t ];
		{elementType|[minimumSize..bound)}
	]
] : set meta;

/**
 * @method "{_`|_.._}"
 * @restricts "any's type's type"
 * @restricts "whole number's type"
 * @restricts "[0..∞]'s type"
 */
Semantic restriction "{_`|_.._}" is
[
	elementMeta : any's type's type,
	minimumSize : whole number's type,
	maximumSize : [0..∞]'s type
|
	elementType ::= elementMeta's instance;
	if |elementType| = ⎣minimumSize⎦
		∧ [ ⎣minimumSize⎦ = ⎡minimumSize⎤
		∧ [ ⎣maximumSize⎦ = ⎡maximumSize⎤
		∧ [ ⎣minimumSize⎦ = ⎣maximumSize⎦ ] ] ]
	then
	[
		elementType's instances' type's type
	]
	else
	[
		lower ::= ⎣minimumSize⎦;
		upper ::= cast ⎡maximumSize⎤ + 1 into [ t : [0..∞] | t ];
		{elementType|[lower..upper)}'s type
	]
];

/**
 * Construct and answer a set type with the specified element type and the 
 * specified minimum value of the cardinality. The maximum value of the 
 * cardinality is automatically set to ∞.
 *
 * @method "{_`|_..}"
 * @param "elementType" "any's type" 
 *		The element type.
 * @param "minimumSize" "whole number" 
 * 		The minimum cardinality of the set.
 * @returns "set meta"
 *    The requested set type. Instances have elements that conform to
 *    `elementType` and cardinalities, using the supplied minimum value and 
 *    infinity as the maximum value, that conform to `cardinalityType`.
 */
Public method "{_`|_..}" is
[
	elementType : any's type,
	minimumSize : whole number
|
	{elementType|[minimumSize..∞)}
] : set meta;

/**
 * @method "{_`|_..}"
 * @restricts "ant's type's type"
 * @restricts "whole number's type"
 */
Semantic restriction "{_`|_..}" is
[
	elementTypeType : any's type's type,
	minimumSizeType : whole number's type
|
	lower ::= ⎣minimumSizeType⎦;
	{elementTypeType's instance|[lower..∞)}'s type
];

/**
 * Construct and answer a set type with the specified element type and the 
 * specified minimum value of the cardinality. The maximum value of the 
 * cardinality is automatically set to ∞.
 *
 * @method "{_`|.._}"
 * @param "elementType" "any's type" 
 *		The element type.
 * @param "maximumSize" "[0..∞]"
 *		The maximum cardinality of the set.
 * @returns "set meta"
 *    The requested set type. Instances have elements that conform to
 *    `elementType` and cardinalities, using the supplied maximum value and 
 *    0 as the minimum value, that conform to `cardinalityType`.
 */
Public method "{_`|.._}" is
[
	elementType : any's type,
	maximumSize : [0..∞]
|
	bound ::= cast maximumSize + 1 into [ t : [0..∞] | t ];
	{elementType|[0..bound)}
] : set meta;

/**
 * @method "{_`|.._}"
 * @restricts "any's type's type"
 * @restricts "[0..∞]'s type"
 */
Semantic restriction "{_`|.._}" is
[
	elementTypeType : any's type's type,
	maximumSizeType : [0..∞]'s type
|
	upper ::= cast ⎡maximumSizeType⎤ + 1 into [ t : [0..∞] | t ];
	{elementTypeType's instance|[0..upper)}'s type
];

/**
 * Construct and answer a set type with the specified element type and exact
 * cardinality.
 * 
 * @method "{_`|_}"
 * @restricts "any's type"
 * @restricts "whole number"
 */
Method "{_`|_}" is
[
	elementType : any's type,
	exactSize : whole number
|
	/* If `elementType` is an enumeration and `exactSize` is the cardinality of
	 * that enumeration's membership, then build an instance type.
	 */
	if |elementType| = exactSize then
	[
		elementType's instances' type
	]
	/* Otherwise just build an ordinary set type. */
	else
	[
		bound ::= cast exactSize + 1 into [ t : whole number | t ];
		{elementType|[exactSize..bound)}
	]
] : set meta;

/**
 * @method "{_`|_}"
 * @restricts "any's type's type"
 * @restricts "whole number's type"
 */
Semantic restriction "{_`|_}" is
[
	elementMeta : any's type's type,
	exactSize : whole number's type
|
	elementType ::= elementMeta's instance;
	if |elementType| = ⎣exactSize⎦
		∧ [ ⎣exactSize⎦ = ⎡exactSize⎤ ]
	then
	[
		elementType's instances' type's type
	]
	else
	[
		bound ::= cast ⎡exactSize⎤ + 1 into [ t : [0..∞] | t ];
		{elementType|[⎣exactSize⎦ .. bound)}'s type
	]
];

/**
 * Construct and answer a set type with the specified element type and the 
 * specified minimum value of the cardinality. The maximum value of the 
 * cardinality is automatically set to ∞.
 * 
 * @method "{_`|}"
 * @param "elementType" "any's type" 
 *		The element type.
 * @returns "set meta"
 *    The requested set type. Instances have elements that conform to
 *    `elementType` and cardinalities, using the supplied maximum value and 
 *    0 as the minimum value, that conform to `cardinalityType`.
 */
Public method "{_`|}" is
[
	elementType : any's type
|
	{elementType|whole number}
] : set meta;

/**
 * @method "{_`|}"
 * @restricts "any's type's type"
 */
Semantic restriction "{_`|}" is
[
	elementTypeType : any's type's type
|
	{elementTypeType's instance|[0..∞)}'s type
];

/**
 * Construct and answer a set type with the specified element type and range of
 * cardinalities.
 *
 * @method "set«_»of_"
 * @param "optionalSizes" "whole number meta?"
 *	If specified, then the range of allowed cardinalities. Defaults to whole 
 *  number.
 * @param "elementType" "any meta"
 *	The element type.
 * @returns "set meta"
 *    The requested set type. Instances have elements that conform to
 *    `elementType` and cardinalities that conform to `optionalSizes`, if
 *    specified, or `whole number`, if unspecified.
 */
Public method "set«_»of_" is
[
	optionalSizes : whole number meta?,
	elementType : any meta
|
	{elementType | optionalSizes[1] else [whole number]}
] : set meta;

/**
 * @method "set«_»of_"
 * @restricts "whole number meta?'s type"
 * @restricts "any meta's type"
 */
Semantic restriction "set«_»of_" is
[
	optionalSizes : whole number meta?'s type,
	elementType : any meta's type
|
	sizes ::= if ⎡optionalSizes⎤ = 0
		then [whole number]
		else [optionalSizes[1]'s instance];
	bound ::= cast ⎡sizes⎤ + 1 into [t : [0..∞] | t];
	lower ::= ⎣sizes⎦;
	{elementType's instance|[lower..bound)}'s type
];

/**
 * @method "{_→_`|_}"
 * @restricts "any meta's type"
 * @restricts "any meta's type"
 * @restricts "whole number meta's type"
 */
Semantic restriction "{_→_`|_}" is
[
	keyTypeType : any meta's type,
	valueTypeType : any meta's type,
	cardinalityTypeType : whole number meta's type
|
	cardinalityTypeTypeInstance :: = cardinalityTypeType's instance;
	bound ::= cast ⎡cardinalityTypeTypeInstance⎤ + 
	1 into [ t : [0..∞] | t ];
	lower ::= ⎣cardinalityTypeTypeInstance⎦;
	{keyTypeType's instance→valueTypeType's instance|[lower..bound)}'s type
];

/**
 * Construct and answer a map type with the specified key type, value type, and
 * uses all whole numbers as the value of the cardinality.
 *
 * @method "{_→_`|_.._}"
 * @param "keyType" "any meta"
 * 	A type to which all keys of instances must conform.
 * @param "valueType" "any meta"
 *  A type to which all values of instances must conform.
 * @param "minimumSize" "whole number"
 *  The minimum cardinality of the set.
 * @param "maximumSize" "[0..∞]"
 *  The maximum cardinality of the set.
 * @returns "map meta"
 *    The requested map type.
 */
Public method "{_→_`|_.._}" is
[
	keyType : any meta,
	valueType : any meta,
	minimumSize : whole number,
	maximumSize : [0..∞]
|
	bound ::= cast maximumSize + 1 into [ t : [0..∞] | t ];
	{keyType→valueType|[minimumSize..bound)}
] : map meta;

/**
 * @method "{_→_`|_.._}"
 * @restricts "any's type's type"
 * @restricts "any's type's type"
 * @restricts "whole number's type"
 * @restricts "[0..∞]'s type"
 */
Semantic restriction "{_→_`|_.._}" is
[
	keyTypeType : any's type's type,
	valueTypeType : any's type's type,
	minimumSizeType : whole number's type,
	maximumSizeType : [0..∞]'s type
|
	bound ::= cast ⎡maximumSizeType⎤ + 1 into [ t : [0..∞] | t ];
	lower ::= ⎣minimumSizeType⎦;
	{keyTypeType's instance→valueTypeType's instance|[lower..bound)}'s type
];

/**
 * Construct and answer a map type with the specified key type, value type, and
 * the specified minimum value of the cardinality and ∞ as the maximum value of 
 * the cardinality.
 * 
 * @method "{_→_`|_..}"
 * @param "keyType" "any meta"
 * 	A type to which all keys of instances must conform.
 * @param "valueType" "any meta"
 *  A type to which all values of instances must conform.
 * @param "minimumSize" "whole number"
 *  The minimum cardinality of the set.
 * @returns "map meta"
 *    The requested map type.
 */
Public method "{_→_`|_..}" is
[
	keyType : any meta,
	valueType : any meta,
	minimumSize : whole number
|
	{keyType→valueType|[minimumSize..∞)}
] : map meta;

/**
 * @method "{_→_`|_..}"
 * @restricts "any's type's type"
 * @restricts "any's type's type"
 * @restricts "whole number's type"
 */
Semantic restriction "{_→_`|_..}" is
[
	keyTypeType : any's type's type,
	valueTypeType : any's type's type,
	minimumSizeType : whole number's type
|
	lower ::= ⎣minimumSizeType⎦;
	{keyTypeType's instance→valueTypeType's instance|[lower..∞)}'s type
];
	
/**
 * Construct and answer a map type with the specified key type, value type, and
 * the specified maximum value of the cardinality and 0 as the minimum value of 
 * the cardinality.
 *
 * @method "{_→_`|.._}"
 * @param "keyType" "any meta"
 * 	A type to which all keys of instances must conform.
 * @param "valueType" "any meta"
 *  A type to which all values of instances must conform.
 * @param "maximumSize" "[0..∞]"
 *  The maximum cardinality of the set.
 * @returns "map meta"
 *    The requested map type.
 */
Public method "{_→_`|.._}" is
[
	keyType : any meta,
	valueType : any meta,
	maximumSize : [0..∞]
|
	bound ::= cast maximumSize + 1 into [ t : [0..∞] | t ];
	{keyType→valueType|[0..bound)}
] : map meta;

/**
 * @method "{_→_`|.._}"
 * @restricts "any's type's type"
 * @restricts "any's type's type"
 * @restricts "[0..∞]'s type"
 */
Semantic restriction "{_→_`|.._}" is
[
	keyTypeType : any's type's type,
	valueTypeType : any's type's type,
	maximumSizeType : [0..∞]'s type
|
	bound ::= cast ⎡maximumSizeType⎤ + 1 into [ t : [0..∞] | t ];
	{keyTypeType's instance→valueTypeType's instance|[0..bound)}'s type
];

/**
 * Construct and answer a map type with the specified key type, value type, and
 * the exact size of the cardinality.
 * 
 * @method "{_→_`|_}"
 * @param "keyType" "any meta"
 * 	A type to which all keys of instances must conform.
 * @param "valueType" "any meta"
 *  A type to which all values of instances must conform.
 * @param "exact size" "whole number"
 *  The minimum and maximum cardinality.
 * @returns "map meta"
 *    The requested map type.
 */
Method "{_→_`|_}" is
[
	keyType : any meta,
	valueType : any meta,
	exactSize : whole number
|
	bound ::= cast exactSize + 1 into [ t : whole number | t ];
	{keyType→valueType|[exactSize..bound)}
]:map meta;

/**
 * @method "{_→_`|_}"
 * @restricts "any meta's type"
 * @restricts "any meta's type"
 * @restricts "whole number's type"
 */
Semantic restriction "{_→_`|_}" is
[
	keyTypeType : any meta's type,
	valueTypeType : any meta's type,
	exactSizeType : whole number's type
|
	bound ::= exactSizeType's instance;
	{keyTypeType's instance→valueTypeType's instance|bound..bound}'s type
];

/**
 * Construct and answer a map type with the specified key type, value type, and
 * uses all whole numbers as the value of the cardinality.
 * 
 * @method "{_→_`|}"
 * @param "keyType" "any meta"
 * 	A type to which all keys of instances must conform.
 * @param "valueType" "any meta"
 *  A type to which all values of instances must conform.
 * @returns "map meta"
 *    The requested map type.
 */
Public method "{_→_`|}" is
[
	keyType : any meta,
	valueType : any meta
|
	{keyType→valueType|[0..∞)}
] : map meta;

/**
 * @method "{_→_`|}"
 * @restricts "any meta's type"
 * @restricts "any meta's type"
 */
Semantic restriction "{_→_`|}" is
[
	keyTypeType : any meta's type,
	valueTypeType : any meta's type
|
	{keyTypeType's instance→valueTypeType's instance|0..∞}'s type
];

/**
 * @method "_∪_"
 * @restricts "type's type"
 * @restricts "type's type"
 */
Semantic restriction "_∪_" is
[
	metaA : type's type,
	metaB : type's type
|
	metaA ∪ metaB
];

/**
 * @method "_∩_"
 * @restricts "type's type"
 * @restricts "type's type"
 */
Semantic restriction "_∩_" is
[
	metaA : type's type,
	metaB : type's type
|
	metaA ∩ metaB
];

/**
 * @method "`|`|_`|`|"
 * @restricts "tuple meta's type"
 */
Semantic restriction "`|`|_`|`|" is
[
	tupleMeta : tuple meta's type
|
	||tupleMeta's instance||'s type
];

/**
 * @method "`|`|_`|`|"
 * @restricts "set meta's type"
 */
Semantic restriction "`|`|_`|`|" is
[
	setMeta : set meta's type
|
	||setMeta's instance||'s type
];

/**
 * @method "`|`|_`|`|"
 * @restricts "map meta's type"
 */
Semantic restriction "`|`|_`|`|" is
[
	mapMeta : map meta's type
|
	||mapMeta's instance||'s type
];

/**
 * @method "`|`|_`|`|"
 * @restricts "⊥'s type's type"
 */
Semantic restriction "`|`|_`|`|" is
[
	bottomMeta : ⊥'s type's type
|
	⊥'s type
];

/**
 * Function type construction can at least statically ensure the correct number
 * of arguments and the return type.
 * 
 * @method "[«_‡,»]→_"
 * @restricts "tuple of any meta's type"
 * @restricts "type's type"
 */
Semantic restriction "[«_‡,»]→_" is
[
	argTypes : tuple of any meta's type,
	returnType : type's type
|
	bottoms : <⊥'s type…|> := <>;
	From 1 to ⎣argTypes⎦ do
	[
		index : natural number
	|
		bottoms := eject bottoms ++ <⊥>;
		true
	];
	return ::= if |returnType| = 1
		then [returnType's instance]
		else [⊤];
	(function accepting bottoms and returning return)'s type
];

/**
 * Produce a {@type "string"} representation of the specified integer range type
 * that is suitable for use as the cardinality restriction of a {@type
 * "tuple meta" tuple type}, {@type "set meta" "set type"}, {@type "map meta"
 * map type}, etc.
 *
 * @method "“_”(cardinality restriction)"
 * @param "range" "extended integer meta"
 * @returns "string"
 */
Public method "“_”(cardinality restriction)" is
[
	range : extended integer meta
|
	lower ::= ⎣range⎦;
	upper ::= ⎡range⎤;
	if upper = ∞ then
	[
		if lower = 0 then [""]
		else [“lower” ++ ".."]
	]
	else
	[
		if lower = upper then [“lower”]
		else [“lower” ++ ".." ++ “upper”]
	]
] : string;

/**
 * Statically strengthen the unary union ("∪_") operation.
 *
 * @method "∪_"
 * @restricts "tupleOfTypesType" "(tuple of type)'s type"
 * @returns type
 */
Semantic restriction "∪_" is
[
	tupleOfTypesType : (tuple of type)'s type
|
	union : type := ⊥;
	typeLimit ::= cast |tupleOfTypesType's leading types| + 1
		into [n : natural number | n];
	From 1 to typeLimit do
	[
		index : natural number
	|
		union := union ∪ tupleOfTypesType[index]'s instance;
		true
	];
	union's type
] : type's type;

/**
 * Is {@param "a"} not a subtype of {@param "b"}?
 *
 * @method "_⊈_"
 * @param "a" "type"
 * @param "b" "type"
 * @returns "boolean"
 *          {@method "true"} if {@param "a"} is not a subtype of {@param "b"},
 *          {@method "false"} otherwise.
 */
Public method "_⊈_" is
[
	a : type,
	b : type
|
	¬ a ⊆ b
];

/**
 * @method "_⊈_"
 * @restricts "metaA" "type's type"
 * @restricts "metaB" "type's type"
 */
Semantic restriction "_⊈_" is
[
	typeA : type's type,
	typeB : type's type
|
	/* The basic rule is this: If the type intersection of typeA's instance and
	 * typeB's instance is ⊥, then the result must be true. Otherwise all bets
	 * are off.
	 */
	if typeA ∩ typeB ⊆ ⊥'s type
		then [true's type]
		else [boolean]
];
