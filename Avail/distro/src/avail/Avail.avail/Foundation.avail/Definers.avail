/*
 * Definers.avail
 * Copyright © 1993-2015, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Definers"
Versions
	"1.0.0 DEV 2014-04-28"
Extends
	"Early Definers"
Uses
	"Bootstrap",
	"Early Conditionals",
	"Early Control Structures",
	"Early Enumeration Support",
	"Early Literals",
	"Early Variables",
	"Phrases"
Names
	"Method_is stable at_",
	"Private stable abstract method_is_",
	"Private stable forward method_is_",
	"Private stable method_is_",
	"Public stable abstract method_is_",
	"Public stable forward method_is_",
	"Public stable method_is_",
	"Public read-only variable_is_",
	"Public variable_is_",
	"Stable abstract method_is_",
	"Stable forward method_is_",
	"Stable method_is_",

	/* These are bootstrap methods. They are exported for use by Exceptions, and
	 * should not escape Foundation.
	 */
	"stability failure function",
	"Set stability failure function to_"
Body

Private method "stable invoker" is
	[function accepting <> and returning literal phrase];
Private method "recovery invoker" is
	[function accepting <> and returning send phrase⇒any];
Private method "stable guard" is
[
	function
		accepting <stable invoker, recovery invoker>
		and returning expression phrase⇒any
];

/**
 * This is the {@type "function"} that wraps invocations of stable methods in
 * generated macros produced by {@method "Method_is stable at_"}. The first
 * argument is a {@type "function"} that attempts to perform the stable method
 * with the correct arguments and, on success, produces a {@type
 * "literal phrase"} that wraps the result. In the event of failure, the second
 * argument is invoked to produce a {@type "send phrase"} that will try the
 * operation at runtime.
 *
 * @global "failureFunction"
 *         "[[]→literal phrase, []→send phrase⇒any]→expression phrase⇒any"
 */
failureFunction : stable guard :=
	[f : stable invoker, r : recovery invoker | invoke f with <>];

Method "stability failure function" is [failureFunction];

/**
 * Set the {@global "failureFunction"} that wraps invocations of stable methods
 * in macros produced by {@method "Method_is stable at_"}. This is a bootstap
 * method, and should not escape "Foundation".
 *
 * @method "Set stability failure function to_"
 * @param "f" "[[]→type]→type"
 *        The new wrapper {@type "function"}.
 * @returns "⊤"
 */
Method "Set stability failure function to_"
	is [f : stable guard | failureFunction := f;];

/**
 * Utility method for {@method "Method_is stable at_"}.  Test whether the
 * given expression is singularly typed, meaning there is only one possible
 * value it could produce. Even though ⊥'s type is technically a metatype rather
 * than a pure enumeration, it only has one instance (⊥).
 */
Private method "_is singular expression" is
[
	anExpression : expression phrase
|
	$method : boolean;
	expressionType ::= anExpression's semantic type;
	If (|expressionType| = 1) = false then [Exit method with false];
	if (expressionType's instance ∈ type) = false then [true]
	else [expressionType = ⊥'s type's type]
] : boolean;

/**
 * Literal phrases are always foldable, even if they produce a type.  Normally
 * yielding a type means a subtype could be returned instead, but that's not the
 * case for a literal phrase.
 */
Private method "_is singular expression" is
[
	anExpression : literal phrase
|
	true
];

/**
 * Override to reject folding in the presence of a super cast phrase.
 */
Private method "_is singular expression" is
[
	anExpression : super cast phrase
|
	false
];

/**
 * Override to scan list phrases for super cast phrases, which will then be
 * rejected from folding.
 */
Private method "_is singular expression" is
[
	anExpression : list phrase
|
	$method : boolean;
	expressions ::= anExpression's expressions;
	From 1 to |expressions| do
	[
		index : natural number
	|
		element ::= cast expressions[index] into [t : expression phrase | t];
		if element is singular expression then [true]
		else [Exit method with false]
	];
	true
];

/**
 * Utility method for {@method "Method_is stable at_"}.  Test whether the
 * elements of the tuple of expressions all have types that have exactly one
 * instance each. Even though ⊥'s type is technically a metatype rather than a
 * pure enumeration, it only has one instance (⊥).
 */
Private method "«_‡,»are all singular expressions" is
[
	argExpressions : <<>, expression phrase…|whole number>
|
	$method : boolean;
	From 1 to |argExpressions| do
	[
		index : natural number
	|
		arg ::= cast argExpressions[index] into [t : expression phrase | t];
		if arg is singular expression then [true]
		else [Exit method with false]
	];
	true
];

/*
 * Given an expression that answered true to "_is singular expression", extract
 * the singular value that would be produced by the phrase.
 */
Private method "extract singular value from_" is
[
	anExpression : expression phrase
|
	t ::= anExpression's semantic type;
	Assert: |t| = 1
		("The expression produced a type, which is not stable \
		\|due to metacovariance.");
	t's instance
] : any;

/*
 * Overridden to extract each list element's value, assembling them into a
 * tuple.  This is to agree with the list phrase's implementation of
 * "_is singular expression".
 */
Private method "extract singular value from_" is
[
	anExpression : list phrase
|
	valueTuple : tuple := <>;
	expressions ::= anExpression's expressions;
	From 1 to |expressions| do
	[
		i : natural number
	|
		elementExpression ::= cast expressions[i]
			into [e : expression phrase | e];
		value ::= extract singular value from elementExpression;
		valueTuple := concatenate <eject valueTuple, <value>>;
		true
	];
	valueTuple
] : any;

/*
 * Overridden to extract the token's value.  This allows constant expressions
 * to be folded, even if they result in a type (which would normally be blocked
 * from folding because metacovariance causes subtypes to also comply with that
 * type's type).
 */
Private method "extract singular value from_" is
[
	anExpression : literal phrase
|
	anExpression's token's value
] : any;


/* These methods are needed for autogeneration of stable method restrictions. */
ifThenElseAtom ::= atom for "If|if_then_else_";
areAllSingularAtom ::= atom for "«_‡,»are all singular expressions";
invokeAtom ::= atom for "Invoke|invoke_with_";
readVarAtom ::= atom for "↓_";
extractValueAtom ::= atom for "extract singular value from_";
tokenAtom ::= atom for "``_``";
literalAtom ::= atom for "‘_’";
restrictedSendAtom ::= atom for "restricted send_with_:_";


/**
 * Declare that the {@type "method"} referenced by {@param "methodName"} is
 * stable for the given signature. A stable method produces the same value for
 * the same arguments on every call. Automatically generate and install a macro
 * that will fold the call site away, replacing it with a precisely known value
 * when all arguments types are themselves precisely known.
 *
 * @method "Method_is stable at_"
 * @param "methodAtom" "atom"
 *        The name of the stable method.
 * @param "functionType" "function meta"
 *        The signature of the method that is being declared stable.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Method_is stable at_" is
[
	methodName : atom,
	functionType : function meta
|
	/* The goal is to take an invocation like:
	 *
	 *    Method "_[_]→_" is stable at [tuple, natural number, any]→tuple;
	 *
	 * And automatically generate something like this:
	 *
	 *    Macro "_[_]→_" is
	 *    [
	 *        arg1 : expression phrase ⇒ tuple,
	 *        arg2 : expression phrase ⇒ natural number,
	 *        arg3 : expression phrase ⇒ any
	 *    |
	 *        if <arg1, arg2, arg3> are all singular expressions then
	 *        [
	 *            invoke failureFunction with
	 *            <
	 *                [
	 *                    ‘`(extract singular value from arg1
	 *                        [extract singular value from arg2]
	 *                        →extract singular value from arg3)`’
	 *                ],
	 *                [
	 *                    restricted send "_[_]→_"
	 *                        with <arg1, arg2, arg3> : any
	 *                ]
	 *            >
	 *        ]
	 *        else
	 *        [
	 *            restricted send "_[_]→_"
	 *                with <arg1, arg2, arg3> : any
	 *        ]
	 *    ];
	 *
	 * The code below generalizes the above to any method name and set of
	 * parameter types. Note that we do not actually have to synthesize an
	 * invocation of "<«_‡,»>".
	 */
	resultType ::= cast functionType's return type into [t : any meta | t];
	argDecls : <<>, argument phrase…|whole number> := <>;
	argUses : <<>, variable use phrase…|whole number> := <>;
	instances : <<>, send phrase⇒any…|whole number> := <>;
	/* Construct the tuples of argument declarations, argument uses, expressions
	 * to extract semantic types, and expressions to extract the singular
	 * instances.
	 */
	From 1 to |message methodName's name's parameters| do
	[
		index : natural number
	|
		argName ::= cast concatenate <"arg", “index”> into [t : string | t];
		argType ::= functionType[index];
		argToken ::= `argName`;
		argDecl ::= arg «argToken : expression phrase ⇒ argType»;
		argDecls := cast concatenate <eject argDecls, <argDecl>>
			into [t : <<>, argument phrase…|whole number> | t];
		argUse ::= «↓argDecl»;
		argUses := cast concatenate <eject argUses, <argUse>>
			into [t : <<>, variable use phrase…|whole number> | t];
		instance ::= send extractValueAtom with «<argUse>» : argType;
		instances := cast concatenate <eject instances, <instance>>
			into [t : <<>, send phrase⇒any…|whole number> | t];
		true
	];
	/* Construct the predicate. */
	check ::=
		send areAllSingularAtom with «<argUses → list phrase>» : boolean;
	/* Construct the false block, i.e., the one that doesn't fold. */
	sendPhrase ::=
		send restrictedSendAtom with
		«<
			‘`methodName`’,
			argUses → list phrase,
			‘`resultType`’
		>» : (send phrase ⇒ any);
	falseBlock ::= «[<sendPhrase>] : send phrase ⇒ any»;
	/* Construct the true block, i.e., the one that folds. */
	answer ::= send methodName with instances → list phrase : resultType;
	answerToken ::=
		send tokenAtom with «<answer>» : (literal token ⇒ resultType);
	answerPhrase ::=
		send literalAtom with «<answerToken>» : (literal phrase ⇒ resultType);
	answerBlock ::= «[<answerPhrase>] : (literal phrase ⇒ resultType)»;
	read ::= send readVarAtom with «<‘`↑failureFunction`’>» : function;
	invoke ::=
		send invokeAtom
		with «<read, «<answerBlock, falseBlock>»>»
		: (expression phrase ⇒ resultType);
	trueBlock ::= «[<invoke>] : expression phrase ⇒ resultType»;
	/* Construct the branch. */
	branch ::=
		send ifThenElseAtom
		with «<check, trueBlock, falseBlock>» : expression phrase ⇒ any;
	/* Construct the function. */
	macroBody ::= «[argDecls | <branch>] : expression phrase ⇒ any»;
	macroFunction ::= macroBody→function;
	/* Install the macro. */
	Macro methodName is macroFunction;
] : ⊤;

/**
 * Declare that the method referenced by {@param "methodName"} is stable for the
 * given signature. A stable method produces the same value for the same 
 * arguments on every call. Automatically generate and install a semantic 
 * restriction that will statically strengthen the answer produced at a call 
 * site to a precisely known value when all arguments are themselves precisely 
 * known.
 * 
 * @method "Method_is stable at_"
 * @param "methodName" "string"
 *        The name of the stable.
 * @param "functionType" "function meta"
 *        The signature of the method that is being declared stable.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Method_is stable at_" is
[
	methodName : string,
	functionType : function meta
|
	methodAtom ::= atom for methodName;
	Method methodAtom is stable at functionType;
] : ⊤;

/**
 * Declare a new abstract stable method with the specified name and signature. A
 * concrete implementation is one whose parameter types and return type are
 * strictly more specific than the corresponding types of the abstract
 * signature. A stable method produces the same value for the same arguments on
 * every call. Automatically generate and install a semantic restriction that
 * will statically strengthen the answer produced at a call site to a precisely
 * known value when all arguments are themselves precisely known.
 *
 * @method "Stable abstract method_is_"
 * @param "methodName" "string"
 *        The name of the abstract method to declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Stable abstract method_is_" is
[
	methodName : string,
	aFunctionType : function meta
|
	Abstract method methodName is aFunctionType;
	Method methodName is stable at aFunctionType;
] : ⊤;

/**
 * Declare a new abstract stable method with the specified name and signature. A
 * concrete implementation is one whose parameter types and return type are
 * strictly more specific than the corresponding types of the abstract
 * signature. A stable method produces the same value for the same arguments on
 * every call. Automatically generate and install a semantic restriction that
 * will statically strengthen the answer produced at a call site to a precisely
 * known value when all arguments are themselves precisely known.
 *
 * @method "Stable abstract method_is_"
 * @param "methodAtom" "atam"
 *        The atom representing the abstract method to declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Stable abstract method_is_" is
[
	methodAtom : atom,
	functionType : function meta
|
	methodName ::= methodAtom's name;
	Stable abstract method methodName is functionType;
] : ⊤;

/**
 * Declare the intention to locally define a method with the specified name and
 * signature. If no such method is defined before compilation of the containing
 * module completes, then the compiler will emit an appropriate error message.
 *
 * Recursive methods must be forward declared. Mutually recursive methods must
 * forward declare all but the lexically first participant in the recursion.
 * 
 * Also declare that the method is stable A stable method produces the same
 * value for the same arguments on every call. Automatically generate and
 * install a semantic restriction that will statically strengthen the answer
 * produced at a call site to a precisely known value when all arguments are
 * themselves precisely known.
 *
 * @method "Stable forward method_is_"
 * @param "methodName" "string"
 *        The name of the method to forward declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Stable forward method_is_" is
[
	methodName : string,
	aFunctionType : function meta
|
	Forward method methodName is aFunctionType;
	Method methodName is stable at aFunctionType;
] : ⊤;

/**
 * Declare the intention to locally define a method with the specified name and
 * signature. If no such method is defined before compilation of the containing
 * module completes, then the compiler will emit an appropriate error message.
 *
 * Recursive methods must be forward declared. Mutually recursive methods must
 * forward declare all but the lexically first participant in the recursion.
 * 
 * Also declare that the method is stable A stable method produces the same
 * value for the same arguments on every call. Automatically generate and
 * install a semantic restriction that will statically strengthen the answer
 * produced at a call site to a precisely known value when all arguments are
 * themselves precisely known.
 *
 * @method "Stable forward method_is_"
 * @param "methodAtom" "atom"
 *        The atom representing the method to forward declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Stable forward method_is_" is
[
	methodAtom : atom,
	aFunctionType : function meta
|
	methodName ::= methodAtom's name;
	Stable forward method methodName is aFunctionType;
] : ⊤;

/**
 * Define a new stable method. A stable method produces the same value for the
 * same arguments on every call. Automatically generate and install a semantic
 * restriction that will statically strengthen the answer produced at a call
 * site to a precisely known value when all arguments are themselves precisely
 * known.
 * 
 * @method "Stable method_is_"
 * @param "methodName" "string"
 *        The name of the new method.
 * @param "implementation" "function"
 *        An implementation of the method.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Stable method_is_" is
[
	methodName : string,
	implementation : function
|
	Method methodName is implementation;
	Method methodName is stable at implementation's type;
];

/**
 * Define a new stable method. A stable method produces the same value for the
 * same arguments on every call. Automatically generate and install a semantic
 * restriction that will statically strengthen the answer produced at a call
 * site to a precisely known value when all arguments are themselves precisely
 * known.
 * 
 * @method "Stable method_is_"
 * @param "methodAtom" "atom"
 *        The atom representing the new method.
 * @param "implementation" "function"
 *        An implementation of the method.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Stable method_is_" is
[
	methodAtom : atom,
	implementation : function
|
	methodName ::= methodAtom's name;
	Stable method methodName is implementation;
];

/**
 * Declare a new public abstract stable method with the specified name and
 * signature. A concrete implementation is one whose parameter types and return
 * type are strictly more specific than the corresponding types of the abstract
 * signature. A stable method produces the same value for the same arguments on
 * every call. Automatically generate and install a semantic restriction that
 * will statically strengthen the answer produced at a call site to a precisely
 * known value when all arguments are themselves precisely known. The semantic
 * restriction ensures that the method is named in the current module's "Names"
 * section. This should not be used to extend existing methods.
 *
 * @method "Public stable abstract method_is_"
 * @param "methodName" "string"
 *        The name of the abstract method to declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Public stable abstract method_is_" is
[
	methodName : string,
	aFunctionType : function meta
|
	Abstract method methodName is aFunctionType;
	Method methodName is stable at aFunctionType;
] : ⊤;

/**
 * Ensure that the new method is introduced by the module's "Names" section.
 * 
 * @method "Public stable abstract method_is_"
 * @restricts "string's type"
 * @restricts "function meta's type"
 */
Semantic restriction "Public stable abstract method_is_" is
[
	nameType : string's type,
	functionMeta : function meta's type
|
	Require: nameType is public;
	⊤
];

/**
 * Declare a new public abstract stable method with the specified name and
 * signature. A concrete implementation is one whose parameter types and return
 * type are strictly more specific than the corresponding types of the abstract
 * signature. A stable method produces the same value for the same arguments on
 * every call. Automatically generate and install a semantic restriction that
 * will statically strengthen the answer produced at a call site to a precisely
 * known value when all arguments are themselves precisely known. The semantic
 * restriction ensures that the method is named in the current module's "Names"
 * section. This should not be used to extend existing methods.
 *
 * @method "Public stable abstract method_is_"
 * @param "methodAtom" "atom"
 *        The atom representing the abstract method to declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Public stable abstract method_is_" is
[
	methodAtom : atom,
	aFunctionType : function meta
|
	methodName ::= methodAtom's name;
	Public stable abstract method methodName is aFunctionType;
] : ⊤;

/**
 * Declare the intention to locally define a public method with the specified
 * name and signature. If no such method is defined before compilation of the
 * containing module completes, then the compiler will emit an appropriate error
 * message.
 *
 * Recursive methods must be forward declared. Mutually recursive methods must
 * forward declare all but the lexically first participant in the recursion.
 * 
 * Also declare that the method is stable A stable method produces the same
 * value for the same arguments on every call. Automatically generate and
 * install a semantic restriction that will statically strengthen the answer
 * produced at a call site to a precisely known value when all arguments are
 * themselves precisely known.
 *
 * The semantic restriction ensures that the method is named in the current
 * module's "Names" section.
 * 
 * This should not be used to extend existing methods.
 *
 * @method "Public stable forward method_is_"
 * @param "methodName" "string"
 *        The name of the method to forward declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Public stable forward method_is_" is
[
	methodName : string,
	aFunctionType : function meta
|
	Forward method methodName is aFunctionType;
	Method methodName is stable at aFunctionType;
] : ⊤;

/**
 * Ensure that the new method is introduced by the module's "Names" section.
 * 
 * @method "Public stable forward method_is_"
 * @restricts "string's type"
 * @restricts "function meta's type"
 */
Semantic restriction "Public stable forward method_is_" is
[
	nameType : string's type,
	functionMeta : function meta's type
|
	Require: nameType is public;
	⊤
];

/**
 * Declare the intention to locally define a public method with the specified
 * name and signature. If no such method is defined before compilation of the
 * containing module completes, then the compiler will emit an appropriate error
 * message.
 *
 * Recursive methods must be forward declared. Mutually recursive methods must
 * forward declare all but the lexically first participant in the recursion.
 * 
 * Also declare that the method is stable A stable method produces the same
 * value for the same arguments on every call. Automatically generate and
 * install a semantic restriction that will statically strengthen the answer
 * produced at a call site to a precisely known value when all arguments are
 * themselves precisely known.
 *
 * The semantic restriction ensures that the method is named in the current
 * module's "Names" section.
 * 
 * This should not be used to extend existing methods.
 *
 * @method "Public stable forward method_is_"
 * @param "methodAtom" "atom"
 *        The atom representing the method to forward declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Public stable forward method_is_" is
[
	methodAtom : atom,
	aFunctionType : function meta
|
	methodName ::= methodAtom's name;
	Public stable forward method methodName is aFunctionType;
] : ⊤;

/**
 * Define a new public stable method. A stable method produces the same value
 * for the same arguments on every call. Automatically generate and install a
 * semantic restriction that will statically strengthen the answer produced at a
 * call site to a precisely known value when all arguments are themselves
 * precisely known. The semantic restriction ensures that the method is named in
 * the current module's "Names" section. This should not be used to extend
 * existing methods.
 * 
 * @method "Public stable method_is_"
 * @param "methodName" "string"
 *        The name of the new method.
 * @param "implementation" "function"
 *        The original implementation of the method.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Public stable method_is_" is
[
	methodName : string,
	implementation : function
|
	Method methodName is implementation;
	Method methodName is stable at implementation's type;
];

/**
 * Ensure that the new method is introduced by the module's "Names" section.
 * 
 * @method "Public stable method_is_"
 * @restricts "string's type"
 * @restricts "function meta"
 */
Semantic restriction "Public stable method_is_" is
[
	nameType : string's type,
	functionType : function meta
|
	Require: nameType is public;
	⊤
];

/**
 * Define a new public stable method. A stable method produces the same value
 * for the same arguments on every call. Automatically generate and install a
 * semantic restriction that will statically strengthen the answer produced at a
 * call site to a precisely known value when all arguments are themselves
 * precisely known. The semantic restriction ensures that the method is named in
 * the current module's "Names" section. This should not be used to extend
 * existing methods.
 * 
 * @method "Public stable method_is_"
 * @param "methodAtom" "atom"
 *        The atom representing the new method.
 * @param "implementation" "function"
 *        The original implementation of the method.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Public stable method_is_" is
[
	methodAtom : atom,
	implementation : function
|
	methodName ::= methodAtom's name;
	Public stable method methodName is implementation;
];

/**
 * Declare a new private abstract stable method with the specified name and
 * signature. A concrete implementation is one whose parameter types and return
 * type are strictly more specific than the corresponding types of the abstract
 * signature. A stable method produces the same value for the same arguments on
 * every call. Automatically generate and install a semantic restriction that
 * will statically strengthen the answer produced at a call site to a precisely
 * known value when all arguments are themselves precisely known. The semantic
 * restriction ensures that the method is not named in the current module's
 * "Names" section. This should not be used to extend existing methods.
 *
 * @method "Private stable abstract method_is_"
 * @param "methodName" "string"
 *        The name of the abstract method to declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Private stable abstract method_is_" is
[
	methodName : string,
	aFunctionType : function meta
|
	Abstract method methodName is aFunctionType;
	Method methodName is stable at aFunctionType;
] : ⊤;

/**
 * Ensure that the new method is not introduced by the module's "Names" section.
 * 
 * @method "Private stable abstract method_is_"
 * @restricts "string's type"
 * @restricts "function meta's type"
 */
Semantic restriction "Private stable abstract method_is_" is
[
	nameType : string's type,
	functionMeta : function meta's type
|
	Require: nameType is private;
	⊤
];

/**
 * Declare a new private abstract stable method with the specified name and
 * signature. A concrete implementation is one whose parameter types and return
 * type are strictly more specific than the corresponding types of the abstract
 * signature. A stable method produces the same value for the same arguments on
 * every call. Automatically generate and install a semantic restriction that
 * will statically strengthen the answer produced at a call site to a precisely
 * known value when all arguments are themselves precisely known. The semantic
 * restriction ensures that the method is not named in the current module's
 * "Names" section. This should not be used to extend existing methods.
 *
 * @method "Private stable abstract method_is_"
 * @param "methodAtom" "atom"
 *        The atom representing the abstract method to declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Private stable abstract method_is_" is
[
	methodAtom : atom,
	aFunctionType : function meta
|
	methodName ::= methodAtom's name;
	Private stable abstract method methodName is aFunctionType;
] : ⊤;

/**
 * Declare the intention to locally define a private method with the specified
 * name and signature. If no such method is defined before compilation of the
 * containing module completes, then the compiler will emit an appropriate error
 * message.
 *
 * Recursive methods must be forward declared. Mutually recursive methods must
 * forward declare all but the lexically first participant in the recursion.
 * 
 * Also declare that the method is stable A stable method produces the same
 * value for the same arguments on every call. Automatically generate and
 * install a semantic restriction that will statically strengthen the answer
 * produced at a call site to a precisely known value when all arguments are
 * themselves precisely known.
 * 
 * The semantic restriction ensures that the method is not named in the current
 * module's "Names" section.
 * 
 * This should not be used to extend existing methods.
 *
 * @method "Private stable forward method_is_"
 * @param "methodName" "string"
 *        The name of the method to forward declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Private stable forward method_is_" is
[
	methodName : string,
	aFunctionType : function meta
|
	Forward method methodName is aFunctionType;
	Method methodName is stable at aFunctionType;
] : ⊤;

/**
 * Ensure that the new method is not introduced by the module's "Names" section.
 * 
 * @method "Private stable forward method_is_"
 * @restricts "string's type"
 * @restricts "function meta's type"
 */
Semantic restriction "Private stable forward method_is_" is
[
	nameType : string's type,
	functionMeta : function meta's type
|
	Require: nameType is private;
	⊤
];

/**
 * Declare the intention to locally define a private method with the specified
 * name and signature. If no such method is defined before compilation of the
 * containing module completes, then the compiler will emit an appropriate error
 * message.
 *
 * Recursive methods must be forward declared. Mutually recursive methods must
 * forward declare all but the lexically first participant in the recursion.
 * 
 * Also declare that the method is stable A stable method produces the same
 * value for the same arguments on every call. Automatically generate and
 * install a semantic restriction that will statically strengthen the answer
 * produced at a call site to a precisely known value when all arguments are
 * themselves precisely known.
 * 
 * The semantic restriction ensures that the method is not named in the current
 * module's "Names" section.
 * 
 * This should not be used to extend existing methods.
 *
 * @method "Private stable forward method_is_"
 * @param "methodAtom" "atom"
 *        The atom representing the method to forward declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Private stable forward method_is_" is
[
	methodAtom : atom,
	aFunctionType : function meta
|
	methodName ::= methodAtom's name;
	Private stable forward method methodName is aFunctionType;
] : ⊤;

/**
 * Define a new private stable method. A stable method produces the same value
 * for the same arguments on every call. Automatically generate and install a
 * semantic restriction that will statically strengthen the answer produced at a
 * call site to a precisely known value when all arguments are themselves
 * precisely known. The semantic restriction ensures that the method is not
 * named in the current module's "Names" section. This should not be used to
 * extend existing methods.
 * 
 * @method "Private stable method_is_"
 * @param "methodName" "string"
 *        The name of the new method.
 * @param "implementation" "function"
 *        The original implementation of the method.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Private stable method_is_" is
[
	methodName : string,
	implementation : function
|
	Method methodName is implementation;
	Method methodName is stable at implementation's type;
];

/**
 * Ensure that the new method is not introduced by the module's "Names" section.
 * 
 * @method "Private stable method_is_"
 * @restricts "string's type"
 * @restricts "function meta"
 */
Semantic restriction "Private stable method_is_" is
[
	nameType : string's type,
	functionType : function meta
|
	Require: nameType is private;
	⊤
];

/**
 * Define a new private stable method. A stable method produces the same value
 * for the same arguments on every call. Automatically generate and install a
 * semantic restriction that will statically strengthen the answer produced at a
 * call site to a precisely known value when all arguments are themselves
 * precisely known. The semantic restriction ensures that the method is not
 * named in the current module's "Names" section. This should not be used to
 * extend existing methods.
 * 
 * @method "Private stable method_is_"
 * @param "methodAtom" "atom"
 *        The atom representing the new method.
 * @param "implementation" "function"
 *        The original implementation of the method.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Private stable method_is_" is
[
	methodAtom : atom,
	implementation : function
|
	methodName ::= methodAtom's name;
	Private stable method methodName is implementation;
];

/**
 * Define a new public variable. Automatically generate an accessor and a
 * mutator. The semantic restriction ensures that these methods are named in the
 * current module's "Names" section.
 *
 * @method "Public variable_is_"
 * @param "var" "variable"
 *        The variable for which an accessor and a mutator should be generated.
 * @param "accessorName" "string"
 *        The name of the accessor. The name of the mutator will be 
 *        {@param "accessorName"} ++ ":=_".
 * @returns "⊤"
 * @category "Declarations" "Variables"
 */
Public method "Public variable_is_" is
[
	var : variable,
	accessorName : string
|
	readType ::= cast var's type's read type into [t : any's type | t];
	writeType ::= cast var's type's write type into [t : any's type | t];
	decl ::= «module variable var (this token: SomeModuleVariable)»;
	readerBlock ::= «[<>| <«↓decl»>] : readType»;
	Method accessorName is readerBlock → function;
	Method cast concatenate <accessorName, ":=_"> into [t : string | t] is
		new function accepting <writeType> and returning ⊤
		applying [t : any | var ?= t;];
] : ⊤;

/**
 * Ensure that the new methods are introduced by the module's "Names" section.
 * 
 * @method "Public variable_is_"
 * @restricts "variable meta"
 * @restricts "string's type"
 */
Semantic restriction "Public variable_is_" is
[
	var : variable meta,
	nameType : string's type
|
	Require: nameType is public;
	If |nameType| = 1 then
	[
		accessorName ::= cast nameType's instance into [t : string | t];
		mutatorName ::= cast concatenate <accessorName, ":=_">
			into [t : string | t];
		Require: mutatorName's type is public;
	];
	⊤
];

/**
 * Define a new public variable. Automatically generate an accessor. The
 * semantic restriction ensures that these methods are named in the current
 * module's "Names" section.
 *
 * @method "Public read-only variable_is_"
 * @param "var" "variable"
 *        The variable for which an accessor should be generated.
 * @param "accessorName" "string"
 *        The name of the accessor.
 * @returns "⊤"
 * @category "Declarations" "Variables"
 */
Public method "Public read-only variable_is_" is
[
	var : variable,
	accessorName : string
|
	readType ::= cast var's type's read type into [t : any's type | t];
	Method accessorName is
		new function accepting <> and returning readType
		applying [ ↓var ];
] : ⊤;

/**
 * Ensure that the new methods are introduced by the module's "Names" section.
 * 
 * @method "Public read-only variable_is_"
 * @restricts "variable meta"
 * @restricts "string's type"
 */
Semantic restriction "Public read-only variable_is_" is
[
	var : variable meta,
	nameType : string's type
|
	Require: nameType is public;
	⊤
];
