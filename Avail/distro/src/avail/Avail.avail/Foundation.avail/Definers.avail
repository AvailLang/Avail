/*
 * Definers.avail
 * Copyright © 1993-2014, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Definers"
Versions
	"1.0.0 DEV 2014-04-28"
Extends
	"Early Definers"
Uses
	"Bootstrap",
	"Early Control Structures",
	"Early Enumeration Support",
	"Early Literals",
	"Early Variables",
	"Phrases"
Names
	"Method_is stable at_",
	"Private stable abstract method_is_",
	"Private stable forward method_is_",
	"Private stable method_is_",
	"Public stable abstract method_is_",
	"Public stable forward method_is_",
	"Public stable method_is_",
	"Public read-only variable_is_",
	"Public variable_is_",
	"Stable abstract method_is_",
	"Stable forward method_is_",
	"Stable method_is_",

	/* These are bootstrap methods. They are exported for use by Exceptions, and
	 * should not escape Foundation.
	 */
	"stability failure function",
	"Set stability failure function to_"
Body

Private method "stable invoker"
	is [function accepting <> and returning type];
Private method "stable guard"
	is [function accepting <stable invoker> and returning type];

/**
 * This is the {@type "function"} that wraps invocations of stable methods in
 * generated semantic restrictions produced by {@method "Method_is stable at_"}.
 * The boostrap version simply applies the argument, but once {@type
 * "exception"}s are live, then another function is substituted that suppresses
 * exceptions raised by stable methods at singularities. It's bad practice, in
 * general, to swallow exceptions, but this is the least cumbersome approach to
 * this particular issue.
 *
 * @global "failureFunction" "[[]→type]→type"
 */
failureFunction : stable guard :=
	[f : function accepting <> and returning type | invoke f with <>];

Method "stability failure function" is [failureFunction];

/**
 * Set the {@global "failureFunction"} that wraps invocations of stable methods
 * in semantic restrictions produced by {@method "Method_is stable at_"}. This
 * is a bootstap method, and should not escape "Foundation".
 *
 * @method "Set stability failure function to_"
 * @param "f" "[[]→type]→type"
 *        The new wrapper {@type "function"}.
 * @returns "⊤"
 */
Method "Set stability failure function to_"
	is [f : stable guard | failureFunction := f; ];

/**
 * Utility method for "Method_is stable at_".  Test whether the tuple of types
 * have exactly one instance each.  Even though ⊥'s type is technically a
 * metatype rather than a pure enumeration, it only has one instance (⊥).
 * 
 * @method "«_‡,»are all singular"
 * @returns "boolean"
 */
Private method "«_‡,»are all singular" is
[
	argTypes : <<>, type…|whole number>
|
	$method : boolean;
	From 1 to |argTypes| do
	[
		index : natural number
	|
		argType ::= cast argTypes[index] into [t : type | t];
		If (|argType| = 1) = false then
		[
			Exit method with false
		];
		if (argType's instance ∈ type) = false then
		[
			true
		]
		else
		[
			if argType = ⊥'s type's type then
			[
				true
			]
			else
			[
				Exit method with false
			]
		]
	];
	true
] : boolean;

/* These methods are needed for autogeneration of stable method restrictions. */
ifThenElseAtom ::= atom for "If|if_then_else_";
instanceAtom ::= atom for "_'s⁇instance";
typeAtom ::= atom for "_'s⁇type";
areAllSingularAtom ::= atom for "«_‡,»are all singular";
invokeAtom ::= atom for "Invoke|invoke_with_";
readVarAtom ::= atom for "↓_";

/**
 * Declare that the method referenced by {@param "methodName"} is stable for the 
 * given signature. A stable method produces the same value for the same
 * arguments on every call. Automatically generate and install a semantic 
 * restriction that will statically strengthen the answer produced at a call 
 * site to a precisely known value when all arguments are themselves precisely 
 * known.
 * 
 * @method "Method_is stable at_"
 * @param "methodAtom" "atom"
 *        The name of the stable method.
 * @param "functionType" "function meta"
 *        The signature of the method that is being declared stable.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Method_is stable at_" is
[
	methodName : atom,
	functionType : function meta
|
	/* The goal is to take an invocation like:
	 *
	 *    Method "_[_]→_" is stable at [tuple, natural number, any]→tuple;
	 *
	 * And automatically generate something like this:
	 *
	 *    Semantic restriction "_[_]→_" is
	 *    [
	 *        arg1 : tuple's type,
	 *        arg2 : natural number's type,
	 *        arg3 : any's type
	 *    |
	 *        if <arg1, arg2, arg3> are all singular
	 *        [
	 *            invoke failureFunction with <[
	 *                (arg1's instance[arg2's instance]→arg3's instance)'s type
	 *            ]>
	 *        ]
	 *        else
	 *        [
	 *            ⊤
	 *        ]
	 *    ] : type;
	 *
	 * The code below generalizes the above to any method name and set of
	 * parameter types. Note that we do not actually have to synthesize an
	 * invocation of "(_)" or "<«_‡,»>".
	 */
	resultType ::= functionType's return type's type;
	argDecls : <<>, argument phrase…|whole number> := <>;
	argUses : <<>, variable use phrase…|whole number> := <>;
	instances : <<>, send phrase⇒any…|whole number> := <>;
	/* Construct the tuples of argument declarations, argument uses, and
	 * expressions to extract the singular instances.
	 */
	From 1 to |message methodName's name's parameters| do
	[
		index : natural number
	|
		argName ::= cast concatenate <"arg", “index”> into [t : string | t];
		argType ::= functionType[index];
		argToken ::= `argName`;
		argDecl ::= arg «argToken : argType's type»;
		argDecls := cast concatenate <eject ↑argDecls, <argDecl>>
			into [t : <<>, argument phrase…|whole number> | t];
		argUse ::= «↓argDecl»(`argToken`);
		argUses := cast concatenate <eject ↑argUses, <argUse>>
			into [t : <<>, variable use phrase…|whole number> | t];
		instance ::= send instanceAtom with «<argUse>» : argType;
		instances := cast concatenate <eject ↑instances, <instance>>
			into [t : <<>, send phrase⇒any…|whole number> | t];
		true
	];
	/* Construct the predicate. */
	instanceCheck ::=
		send areAllSingularAtom
		with «<argUses → list phrase>»
		: boolean;
	/* Construct the true block, i.e., the one that strengthens. */
	answer ::= send methodName with instances → list phrase : any;
	answerType ::= send typeAtom with «<answer>» : resultType;
	answerBlock ::= «[<answerType>] : resultType»;
	read ::= send readVarAtom with «<‘`↑failureFunction`’>» : function;
	invoke ::= send invokeAtom with «<read, «<answerBlock>»>» : type;
	answerTypeBlock ::= «[<invoke>] : type»;
	/* Construct the false block, i.e., the one that doesn't strengthen. */
	cantStrengthenBlock ::= «[<‘`⊤`’>] : ⊤'s type»;
	/* Construct the branch. */
	branch ::= send ifThenElseAtom
		with «<instanceCheck, answerTypeBlock, cantStrengthenBlock>» : type;
	/* Construct the function. */
	restrictionBlock ::= «[argDecls | <branch>] : type»;
	restrictionFunction ::= restrictionBlock→function;
	/* Install the semantic restriction. */
	Semantic restriction methodName is restrictionFunction;
] : ⊤;

/**
 * Declare that the method referenced by {@param "methodName"} is stable for the
 * given signature. A stable method produces the same value for the same 
 * arguments on every call. Automatically generate and install a semantic 
 * restriction that will statically strengthen the answer produced at a call 
 * site to a precisely known value when all arguments are themselves precisely 
 * known.
 * 
 * @method "Method_is stable at_"
 * @param "methodName" "string"
 *        The name of the stable.
 * @param "functionType" "function meta"
 *        The signature of the method that is being declared stable.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Method_is stable at_" is
[
	methodName : string,
	functionType : function meta
|
	methodAtom ::= atom for methodName;
	Method methodAtom is stable at functionType;
] : ⊤;

/**
 * Reject the current parse if the specified message specifies any lexical
 * groups. Take no action if the actual message is not available.
 * 
 * @method "Require:message_does not specify lexical groups"
 * @param "nameType" "string's type"
 *        The type of the method name.
 * @returns "⊤"
 */
Private method "Require:message_does not specify lexical groups" is
[
	nameType : string's type
|
	If |nameType| = 1 then
	[
		methodName ::= cast nameType's instance into [ t : string | t ];
		If message methodName contains groups then
		[
			messageTuple ::= concatenate <
				"message name (",
				“methodName”,
				") must not specify lexical groups">;
			Invoke
			[
				messageString : string
			|
				Reject parse, expected: messageString
			]
			with <messageTuple>
		];
	];
] : ⊤;

/**
 * Reject the current parse if any of the argument's parameter types are
 * metatypes, i.e., the actual argument is a type, or function types. Take no
 * action if the argument's parameter types are not available.
 * 
 * @method "Require:_'s⁇parameters are not metatypes or function types"
 * @param "functionType" "function meta"
 *        A function type.
 * @returns "⊤"
 */
Private method "Require:_'s⁇parameters are not metatypes or function types" is
[
	functionType : function meta
|
	parametersType ::= functionType's parameters' type;
	cast ||parametersType||'s genuine upper bound into
	[
		limit : whole number
	|
		From 1 to limit do
		[
			index : natural number
		|
			parameterType ::= parametersType[index];
			If parameterType = ⊥ then
			[
				/* Can't tell anything about this argument. */
			]
			else
			[
				If parameterType ⊆ type then
				[
					messageTuple ::= concatenate <
						"parameter type (",
						“parameterType”,
						") not to be a metatype; metacovariance will allow \
						\|subtypes of this type, causing the operation not to \
						\|be stable">;
					Invoke
					[
						messageString : string
					|
						Reject parse, expected: messageString
					]
					with <messageTuple>
				];
				If parameterType ⊆ function then
				[
					messageTuple ::= concatenate <
						"parameter type (",
						“parameterType”,
						") not to be a function type">;
					Invoke
					[
						messageString : string
					|
						Reject parse, expected: messageString
					]
					with <messageTuple>
				];
			];
			true
		];
	]
	else
	[
		/* Can't check the parameter types. */
	];
] : ⊤;

/**
 * If possible, then ensure that the parameters are not types; because of
 * metacovariance, the operation would not actually be stable.
 * 
 * @method "Method_is stable at_"
 * @restricts "string's type"
 * @restricts "function meta"
 */
Semantic restriction "Method_is stable at_" is
[
	nameType : string's type,
	functionType : function meta
|
	Require: message nameType does not specify lexical groups;
	Require: functionType's parameters are not metatypes or function types;
	⊤
];

/**
 * Declare a new abstract stable method with the specified name and signature. A
 * concrete implementation is one whose parameter types and return type are
 * strictly more specific than the corresponding types of the abstract
 * signature. A stable method produces the same value for the same arguments on
 * every call. Automatically generate and install a semantic restriction that
 * will statically strengthen the answer produced at a call site to a precisely
 * known value when all arguments are themselves precisely known.
 *
 * @method "Stable abstract method_is_"
 * @param "methodName" "string"
 *        The name of the abstract method to declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Stable abstract method_is_" is
[
	methodName : string,
	aFunctionType : function meta
|
	Abstract method methodName is aFunctionType;
	Method methodName is stable at aFunctionType;
] : ⊤;

/**
 * @method "Stable abstract method_is_"
 * @restricts "string's type"
 * @restricts "function meta's type"
 */
Semantic restriction "Stable abstract method_is_" is
[
	nameType : string's type,
	functionMeta : function meta's type
|
	Require: message nameType does not specify lexical groups;
	If |functionMeta| = 1 then
	[
		functionType ::= cast functionMeta's instances→tuple[1] into
			[ t : function meta | t ];
		Require: functionType's parameters are not metatypes or function types;
	];
	⊤
];

/**
 * Declare a new abstract stable method with the specified name and signature. A
 * concrete implementation is one whose parameter types and return type are
 * strictly more specific than the corresponding types of the abstract
 * signature. A stable method produces the same value for the same arguments on
 * every call. Automatically generate and install a semantic restriction that
 * will statically strengthen the answer produced at a call site to a precisely
 * known value when all arguments are themselves precisely known.
 *
 * @method "Stable abstract method_is_"
 * @param "methodAtom" "atam"
 *        The atom representing the abstract method to declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Stable abstract method_is_" is
[
	methodAtom : atom,
	functionType : function meta
|
	methodName ::= methodAtom's name;
	Stable abstract method methodName is functionType;
] : ⊤;

/**
 * Declare the intention to locally define a method with the specified name and
 * signature. If no such method is defined before compilation of the containing
 * module completes, then the compiler will emit an appropriate error message.
 *
 * Recursive methods must be forward declared. Mutually recursive methods must
 * forward declare all but the lexically first participant in the recursion.
 * 
 * Also declare that the method is stable A stable method produces the same
 * value for the same arguments on every call. Automatically generate and
 * install a semantic restriction that will statically strengthen the answer
 * produced at a call site to a precisely known value when all arguments are
 * themselves precisely known.
 *
 * @method "Stable forward method_is_"
 * @param "methodName" "string"
 *        The name of the method to forward declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Stable forward method_is_" is
[
	methodName : string,
	aFunctionType : function meta
|
	Forward method methodName is aFunctionType;
	Method methodName is stable at aFunctionType;
] : ⊤;

/**
 * 
 * @method "Stable forward method_is_"
 * @restricts "string's type"
 * @restricts "function meta's type"
 */
Semantic restriction "Stable forward method_is_" is
[
	nameType : string's type,
	functionMeta : function meta's type
|
	Require: message nameType does not specify lexical groups;
	If |functionMeta| = 1 then
	[
		functionType ::= cast functionMeta's instances→tuple[1] into
			[ t : function meta | t ];
		Require: functionType's parameters are not metatypes or function types;
	];
	⊤
];

/**
 * Declare the intention to locally define a method with the specified name and
 * signature. If no such method is defined before compilation of the containing
 * module completes, then the compiler will emit an appropriate error message.
 *
 * Recursive methods must be forward declared. Mutually recursive methods must
 * forward declare all but the lexically first participant in the recursion.
 * 
 * Also declare that the method is stable A stable method produces the same
 * value for the same arguments on every call. Automatically generate and
 * install a semantic restriction that will statically strengthen the answer
 * produced at a call site to a precisely known value when all arguments are
 * themselves precisely known.
 *
 * @method "Stable forward method_is_"
 * @param "methodAtom" "atom"
 *        The atom representing the method to forward declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Stable forward method_is_" is
[
	methodAtom : atom,
	aFunctionType : function meta
|
	methodName ::= methodAtom's name;
	Stable forward method methodName is aFunctionType;
] : ⊤;

/**
 * Define a new stable method. A stable method produces the same value for the
 * same arguments on every call. Automatically generate and install a semantic
 * restriction that will statically strengthen the answer produced at a call
 * site to a precisely known value when all arguments are themselves precisely
 * known.
 * 
 * @method "Stable method_is_"
 * @param "methodName" "string"
 *        The name of the new method.
 * @param "implementation" "function"
 *        An implementation of the method.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Stable method_is_" is
[
	methodName : string,
	implementation : function
|
	Method methodName is implementation;
	Method methodName is stable at implementation's type;
];

/**
 * @method "Stable method_is_"
 * @restricts "string's type"
 * @restricts "function meta"
 */
Semantic restriction "Stable method_is_" is
[
	nameType : string's type,
	functionType : function meta
|
	Require: message nameType does not specify lexical groups;
	Require: functionType's parameters are not metatypes or function types;
	⊤
];

/**
 * Define a new stable method. A stable method produces the same value for the
 * same arguments on every call. Automatically generate and install a semantic
 * restriction that will statically strengthen the answer produced at a call
 * site to a precisely known value when all arguments are themselves precisely
 * known.
 * 
 * @method "Stable method_is_"
 * @param "methodAtom" "atom"
 *        The atom representing the new method.
 * @param "implementation" "function"
 *        An implementation of the method.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Stable method_is_" is
[
	methodAtom : atom,
	implementation : function
|
	methodName ::= methodAtom's name;
	Stable method methodName is implementation;
];

/**
 * Declare a new public abstract stable method with the specified name and
 * signature. A concrete implementation is one whose parameter types and return
 * type are strictly more specific than the corresponding types of the abstract
 * signature. A stable method produces the same value for the same arguments on
 * every call. Automatically generate and install a semantic restriction that
 * will statically strengthen the answer produced at a call site to a precisely
 * known value when all arguments are themselves precisely known. The semantic
 * restriction ensures that the method is named in the current module's "Names"
 * section. This should not be used to extend existing methods.
 *
 * @method "Public stable abstract method_is_"
 * @param "methodName" "string"
 *        The name of the abstract method to declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Public stable abstract method_is_" is
[
	methodName : string,
	aFunctionType : function meta
|
	Abstract method methodName is aFunctionType;
	Method methodName is stable at aFunctionType;
] : ⊤;

/**
 * Ensure that the new method is introduced by the module's "Names" section.
 * 
 * @method "Public stable abstract method_is_"
 * @restricts "string's type"
 * @restricts "function meta's type"
 */
Semantic restriction "Public stable abstract method_is_" is
[
	nameType : string's type,
	functionMeta : function meta's type
|
	Require: nameType is public;
	Require: message nameType does not specify lexical groups;
	If |functionMeta| = 1 then
	[
		functionType ::= cast functionMeta's instances→tuple[1] into
			[ t : function meta | t ];
		Require: functionType's parameters are not metatypes or function types;
	];
	⊤
];

/**
 * Declare a new public abstract stable method with the specified name and
 * signature. A concrete implementation is one whose parameter types and return
 * type are strictly more specific than the corresponding types of the abstract
 * signature. A stable method produces the same value for the same arguments on
 * every call. Automatically generate and install a semantic restriction that
 * will statically strengthen the answer produced at a call site to a precisely
 * known value when all arguments are themselves precisely known. The semantic
 * restriction ensures that the method is named in the current module's "Names"
 * section. This should not be used to extend existing methods.
 *
 * @method "Public stable abstract method_is_"
 * @param "methodAtom" "atom"
 *        The atom representing the abstract method to declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Public stable abstract method_is_" is
[
	methodAtom : atom,
	aFunctionType : function meta
|
	methodName ::= methodAtom's name;
	Public stable abstract method methodName is aFunctionType;
] : ⊤;

/**
 * Declare the intention to locally define a public method with the specified
 * name and signature. If no such method is defined before compilation of the
 * containing module completes, then the compiler will emit an appropriate error
 * message.
 *
 * Recursive methods must be forward declared. Mutually recursive methods must
 * forward declare all but the lexically first participant in the recursion.
 * 
 * Also declare that the method is stable A stable method produces the same
 * value for the same arguments on every call. Automatically generate and
 * install a semantic restriction that will statically strengthen the answer
 * produced at a call site to a precisely known value when all arguments are
 * themselves precisely known.
 *
 * The semantic restriction ensures that the method is named in the current
 * module's "Names" section.
 * 
 * This should not be used to extend existing methods.
 *
 * @method "Public stable forward method_is_"
 * @param "methodName" "string"
 *        The name of the method to forward declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Public stable forward method_is_" is
[
	methodName : string,
	aFunctionType : function meta
|
	Forward method methodName is aFunctionType;
	Method methodName is stable at aFunctionType;
] : ⊤;

/**
 * Ensure that the new method is introduced by the module's "Names" section.
 * 
 * @method "Public stable forward method_is_"
 * @restricts "string's type"
 * @restricts "function meta's type"
 */
Semantic restriction "Public stable forward method_is_" is
[
	nameType : string's type,
	functionMeta : function meta's type
|
	Require: nameType is public;
	Require: message nameType does not specify lexical groups;
	If |functionMeta| = 1 then
	[
		functionType ::= cast functionMeta's instances→tuple[1] into
			[ t : function meta | t ];
		Require: functionType's parameters are not metatypes or function types;
	];
	⊤
];

/**
 * Declare the intention to locally define a public method with the specified
 * name and signature. If no such method is defined before compilation of the
 * containing module completes, then the compiler will emit an appropriate error
 * message.
 *
 * Recursive methods must be forward declared. Mutually recursive methods must
 * forward declare all but the lexically first participant in the recursion.
 * 
 * Also declare that the method is stable A stable method produces the same
 * value for the same arguments on every call. Automatically generate and
 * install a semantic restriction that will statically strengthen the answer
 * produced at a call site to a precisely known value when all arguments are
 * themselves precisely known.
 *
 * The semantic restriction ensures that the method is named in the current
 * module's "Names" section.
 * 
 * This should not be used to extend existing methods.
 *
 * @method "Public stable forward method_is_"
 * @param "methodAtom" "atom"
 *        The atom representing the method to forward declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Public stable forward method_is_" is
[
	methodAtom : atom,
	aFunctionType : function meta
|
	methodName ::= methodAtom's name;
	Public stable forward method methodName is aFunctionType;
] : ⊤;

/**
 * Define a new public stable method. A stable method produces the same value
 * for the same arguments on every call. Automatically generate and install a
 * semantic restriction that will statically strengthen the answer produced at a
 * call site to a precisely known value when all arguments are themselves
 * precisely known. The semantic restriction ensures that the method is named in
 * the current module's "Names" section. This should not be used to extend
 * existing methods.
 * 
 * @method "Public stable method_is_"
 * @param "methodName" "string"
 *        The name of the new method.
 * @param "implementation" "function"
 *        The original implementation of the method.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Public stable method_is_" is
[
	methodName : string,
	implementation : function
|
	Method methodName is implementation;
	Method methodName is stable at implementation's type;
];

/**
 * Ensure that the new method is introduced by the module's "Names" section.
 * 
 * @method "Public stable method_is_"
 * @restricts "string's type"
 * @restricts "function meta"
 */
Semantic restriction "Public stable method_is_" is
[
	nameType : string's type,
	functionType : function meta
|
	Require: nameType is public;
	Require: message nameType does not specify lexical groups;
	Require: functionType's parameters are not metatypes or function types;
	⊤
];

/**
 * Define a new public stable method. A stable method produces the same value
 * for the same arguments on every call. Automatically generate and install a
 * semantic restriction that will statically strengthen the answer produced at a
 * call site to a precisely known value when all arguments are themselves
 * precisely known. The semantic restriction ensures that the method is named in
 * the current module's "Names" section. This should not be used to extend
 * existing methods.
 * 
 * @method "Public stable method_is_"
 * @param "methodAtom" "atom"
 *        The atom representing the new method.
 * @param "implementation" "function"
 *        The original implementation of the method.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Public stable method_is_" is
[
	methodAtom : atom,
	implementation : function
|
	methodName ::= methodAtom's name;
	Public stable method methodName is implementation;
];

/**
 * Declare a new private abstract stable method with the specified name and
 * signature. A concrete implementation is one whose parameter types and return
 * type are strictly more specific than the corresponding types of the abstract
 * signature. A stable method produces the same value for the same arguments on
 * every call. Automatically generate and install a semantic restriction that
 * will statically strengthen the answer produced at a call site to a precisely
 * known value when all arguments are themselves precisely known. The semantic
 * restriction ensures that the method is not named in the current module's
 * "Names" section. This should not be used to extend existing methods.
 *
 * @method "Private stable abstract method_is_"
 * @param "methodName" "string"
 *        The name of the abstract method to declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Private stable abstract method_is_" is
[
	methodName : string,
	aFunctionType : function meta
|
	Abstract method methodName is aFunctionType;
	Method methodName is stable at aFunctionType;
] : ⊤;

/**
 * Ensure that the new method is not introduced by the module's "Names" section.
 * 
 * @method "Private stable abstract method_is_"
 * @restricts "string's type"
 * @restricts "function meta's type"
 */
Semantic restriction "Private stable abstract method_is_" is
[
	nameType : string's type,
	functionMeta : function meta's type
|
	Require: nameType is private;
	Require: message nameType does not specify lexical groups;
	If |functionMeta| = 1 then
	[
		functionType ::= cast functionMeta's instances→tuple[1] into
			[ t : function meta | t ];
		Require: functionType's parameters are not metatypes or function types;
	];
	⊤
];

/**
 * Declare a new private abstract stable method with the specified name and
 * signature. A concrete implementation is one whose parameter types and return
 * type are strictly more specific than the corresponding types of the abstract
 * signature. A stable method produces the same value for the same arguments on
 * every call. Automatically generate and install a semantic restriction that
 * will statically strengthen the answer produced at a call site to a precisely
 * known value when all arguments are themselves precisely known. The semantic
 * restriction ensures that the method is not named in the current module's
 * "Names" section. This should not be used to extend existing methods.
 *
 * @method "Private stable abstract method_is_"
 * @param "methodAtom" "atom"
 *        The atom representing the abstract method to declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Private stable abstract method_is_" is
[
	methodAtom : atom,
	aFunctionType : function meta
|
	methodName ::= methodAtom's name;
	Private stable abstract method methodName is aFunctionType;
] : ⊤;

/**
 * Declare the intention to locally define a private method with the specified
 * name and signature. If no such method is defined before compilation of the
 * containing module completes, then the compiler will emit an appropriate error
 * message.
 *
 * Recursive methods must be forward declared. Mutually recursive methods must
 * forward declare all but the lexically first participant in the recursion.
 * 
 * Also declare that the method is stable A stable method produces the same
 * value for the same arguments on every call. Automatically generate and
 * install a semantic restriction that will statically strengthen the answer
 * produced at a call site to a precisely known value when all arguments are
 * themselves precisely known.
 * 
 * The semantic restriction ensures that the method is not named in the current
 * module's "Names" section.
 * 
 * This should not be used to extend existing methods.
 *
 * @method "Private stable forward method_is_"
 * @param "methodName" "string"
 *        The name of the method to forward declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Private stable forward method_is_" is
[
	methodName : string,
	aFunctionType : function meta
|
	Forward method methodName is aFunctionType;
	Method methodName is stable at aFunctionType;
] : ⊤;

/**
 * Ensure that the new method is not introduced by the module's "Names" section.
 * 
 * @method "Private stable forward method_is_"
 * @restricts "string's type"
 * @restricts "function meta's type"
 */
Semantic restriction "Private stable forward method_is_" is
[
	nameType : string's type,
	functionMeta : function meta's type
|
	Require: nameType is private;
	Require: message nameType does not specify lexical groups;
	If |functionMeta| = 1 then
	[
		functionType ::= cast functionMeta's instances→tuple[1] into
			[ t : function meta | t ];
		Require: functionType's parameters are not metatypes or function types;
	];
	⊤
];

/**
 * Declare the intention to locally define a private method with the specified
 * name and signature. If no such method is defined before compilation of the
 * containing module completes, then the compiler will emit an appropriate error
 * message.
 *
 * Recursive methods must be forward declared. Mutually recursive methods must
 * forward declare all but the lexically first participant in the recursion.
 * 
 * Also declare that the method is stable A stable method produces the same
 * value for the same arguments on every call. Automatically generate and
 * install a semantic restriction that will statically strengthen the answer
 * produced at a call site to a precisely known value when all arguments are
 * themselves precisely known.
 * 
 * The semantic restriction ensures that the method is not named in the current
 * module's "Names" section.
 * 
 * This should not be used to extend existing methods.
 *
 * @method "Private stable forward method_is_"
 * @param "methodAtom" "atom"
 *        The atom representing the method to forward declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Private stable forward method_is_" is
[
	methodAtom : atom,
	aFunctionType : function meta
|
	methodName ::= methodAtom's name;
	Private stable forward method methodName is aFunctionType;
] : ⊤;

/**
 * Define a new private stable method. A stable method produces the same value
 * for the same arguments on every call. Automatically generate and install a
 * semantic restriction that will statically strengthen the answer produced at a
 * call site to a precisely known value when all arguments are themselves
 * precisely known. The semantic restriction ensures that the method is not
 * named in the current module's "Names" section. This should not be used to
 * extend existing methods.
 * 
 * @method "Private stable method_is_"
 * @param "methodName" "string"
 *        The name of the new method.
 * @param "implementation" "function"
 *        The original implementation of the method.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Private stable method_is_" is
[
	methodName : string,
	implementation : function
|
	Method methodName is implementation;
	Method methodName is stable at implementation's type;
];

/**
 * Ensure that the new method is not introduced by the module's "Names" section.
 * 
 * @method "Private stable method_is_"
 * @restricts "string's type"
 * @restricts "function meta"
 */
Semantic restriction "Private stable method_is_" is
[
	nameType : string's type,
	functionType : function meta
|
	Require: nameType is private;
	Require: message nameType does not specify lexical groups;
	Require: functionType's parameters are not metatypes or function types;
	⊤
];

/**
 * Define a new private stable method. A stable method produces the same value
 * for the same arguments on every call. Automatically generate and install a
 * semantic restriction that will statically strengthen the answer produced at a
 * call site to a precisely known value when all arguments are themselves
 * precisely known. The semantic restriction ensures that the method is not
 * named in the current module's "Names" section. This should not be used to
 * extend existing methods.
 * 
 * @method "Private stable method_is_"
 * @param "methodAtom" "atom"
 *        The atom representing the new method.
 * @param "implementation" "function"
 *        The original implementation of the method.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Private stable method_is_" is
[
	methodAtom : atom,
	implementation : function
|
	methodName ::= methodAtom's name;
	Private stable method methodName is implementation;
];

/**
 * Define a new public variable. Automatically generate an accessor and a
 * mutator. The semantic restriction ensures that these methods are named in the
 * current module's "Names" section.
 *
 * @method "Public variable_is_"
 * @param "var" "variable"
 *        The variable for which an accessor and a mutator should be generated.
 * @param "accessorName" "string"
 *        The name of the accessor. The name of the mutator will be 
 *        {@param "accessorName"} ++ ":=_".
 * @returns "⊤"
 * @category "Declarations" "Variables"
 */
Public method "Public variable_is_" is
[
	var : variable,
	accessorName : string
|
	readType ::= cast var's type's read type into [t : any's type | t];
	writeType ::= cast var's type's write type into [t : any's type | t];
	Method accessorName is
		new function accepting <> and returning readType
		applying [ ↓var ];
	Method cast concatenate <accessorName, ":=_"> into [t : string | t] is
		new function accepting <writeType> and returning ⊤
		applying [t : any | var ?= t;];
] : ⊤;

/**
 * Ensure that the new methods are introduced by the module's "Names" section.
 * 
 * @method "Public variable_is_"
 * @restricts "variable meta"
 * @restricts "string's type"
 */
Semantic restriction "Public variable_is_" is
[
	var : variable meta,
	nameType : string's type
|
	Require: nameType is public;
	If |nameType| = 1 then
	[
		accessorName ::= cast nameType's instance into [t : string | t];
		mutatorName ::= cast concatenate <accessorName, ":=_">
			into [t : string | t];
		Require: mutatorName's type is public;
	];
	⊤
];

/**
 * Define a new public variable. Automatically generate an accessor. The
 * semantic restriction ensures that these methods are named in the current
 * module's "Names" section.
 *
 * @method "Public read-only variable_is_"
 * @param "var" "variable"
 *        The variable for which an accessor should be generated.
 * @param "accessorName" "string"
 *        The name of the accessor.
 * @returns "⊤"
 * @category "Declarations" "Variables"
 */
Public method "Public read-only variable_is_" is
[
	var : variable,
	accessorName : string
|
	readType ::= cast var's type's read type into [t : any's type | t];
	Method accessorName is
		new function accepting <> and returning readType
		applying [ ↓var ];
] : ⊤;

/**
 * Ensure that the new methods are introduced by the module's "Names" section.
 * 
 * @method "Public variable_is_"
 * @restricts "variable meta"
 * @restricts "string's type"
 */
Semantic restriction "Public read-only variable_is_" is
[
	var : variable meta,
	nameType : string's type
|
	Require: nameType is public;
	⊤
];
