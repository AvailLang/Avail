/*
 * Primitives.avail
 * Copyright © 1993-2014, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Primitives"
Versions
	"1.0.0 DEV 2014-04-28"
Extends
	"Data Abstractions" = ("_'s⁇position", "_'s⁇position:=_")
Uses
	"Common",
	"File Access Rights",
	"File Names",
	"File Open Options" = (
		"read" → "read option",
		"write" → "write option"
		…),
	"Foundation",
	"Unit Testing"
Names
	/* File types. */
	"file",
	"readable file",
	"readable,⁇writable file",
	"writable file",

	/* File constructors. */
	"_opened«with alignment_»with options_«with file access rights_»",

	/* File attributes. */
	"_'s⁇name",
	"_is open",
	"_is closed",
	"_'s⁇size",

	/* File I/O. */
	"a fiber reading_byte|bytes at_from_,⁇\
		\|on success doing_,⁇\
		\|on failure doing_,⁇\
		\|«forked at priority_»",
	"a fiber writing_at_to_,⁇\
		\|on success doing_,⁇\
		\|on failure doing_,⁇\
		\|«forked at priority_»",
	"a fiber synchronizing_with file system,then_else_priority_",
	"a fiber truncating_to_bytes⁇then_else_priority_",

	/* File cleanup. */
	"Using|using_,⁇do_",

	/* File exceptions. */
	"file-closed exception",

	/* Unit testing. */
	"file primitives test suite"
Body

"name" is a new field atom;
"handle" is a new field atom;
"readable" is a new field atom;
"writable" is a new field atom;
"open state" is a new field atom;

/**
 * A file represents an open node within a file system.
 *
 * @type "file"
 * @supertype "object"
 */
Public class "file" extends object
	with fields
		handle : atom,
		public name : file name,
		readable : boolean,
		writable : boolean
	with mutable field
		open state : boolean;

/**
 * A readable file has been opened for reading.
 *
 * @type "readable file"
 * @supertype "file"
 */
Public class "readable file" extends file
	with field
		readable : true's type;

/**
 * A writable file has been opened for writing.
 *
 * @type "writable file"
 * @supertype "file"
 */
Public class "writable file" extends file
	with field
		writable : true's type;

/**
 * A readable, writable file has been opened for reading and writing.
 *
 * @type "readable,⁇writable file"
 * @supertype "readable file"
 * @supertype "writable file"
 */
Public class "readable,⁇writable file" extends readable file ∩ writable file;

/* Open a raw file handle. */
Private method
	"raw handle for file named_alignment_options_file access rights_" is
[
	name : string,
	alignment : whole number,
	options : {[0..9]|0..10},
	rights : {[1..9]|0..9}
|
	Primitive 160 (e : {
		invalid-path code,
		illegal-option code,
		operation-not-supported code,
		permission-denied code,
		I/O-error code,
		exceeds-vm-limit code}ᵀ);
	Raise an exception for e
] : atom;

_default_access_rights ::= "rw-r--r--" → file access rights;

/**
 * Answer an abstraction of the file named {@param "n"} that is open for
 * reading. The file position is initially zero ({@code 0}).
 *
 * @method "_opened with options_«with file access rights_»"
 * @param "fileName" "file name"
 * @param "optionSet" "{open option|}"
 * @param "accessRights" "<{file access right|}…|0..1>"
 * @returns "file"
 * @raises "permission-denied exception"
 *         If permission is denied to use the specified {@type "file name"}.
 * @raises "I/O exception"
 *         If an I/O error occurs for any reason.
 */
Public method
	"_opened«with alignment_»with options_«with file access rights_»" is
[
	fileName : file name,
	optionalAlignment : <natural number…|0..1>,
	optionSet : {open option|1..9},
	optionalAccessRights : <{file access right|0..9}…|0..1>
|
	optionNumbers ::=
		map optionSet through [opt : open option | opt → numeric code];
	accessRights ::= optionalAccessRights [1] else [_default_access_rights];
	accessRightNumbers ::= map accessRights
		through [r : file access right | r → numeric code];
	fileHandle ::= raw handle for file named fileName's name
		alignment optionalAlignment[1] else [0]
		options optionNumbers
		file access rights accessRightNumbers;
	a file with
		handle ::= fileHandle,
		name ::= fileName,
		readable ::= read option ∈ optionSet,
		writable ::= write option ∈ optionSet,
		open state := true
] : file;

/**
 * Strengthen the type with the file name and whether {@code "read"} and/or
 * {@code "write"} are specified.
 * 
 * @method "_opened with options_«with file access rights_»"
 * @restricts "file name's type"
 * @restricts "{open option|}'s type"
 * @restricts "{file access right|}'s type"
 */
Semantic restriction
	"_opened«with alignment_»with options_«with file access rights_»" is
[
	fileName : file name's type,
	optionalAlignment : <natural number…|0..1>'s type,
	optionSet : {open option|1..9}'s type,
	accessRights : <{file access right|0..9}…|0..1>'s type
|
	readableType : boolean's type := ⊥;
	writableType : boolean's type := ⊥;
	If |optionSet| ≠ ∞ then
	[
		/* Check each possibility, typically just one. */
		For each of optionSet's instances do
		[
			possibleSet : {open option|}
		|
			readableType :=
				readableType ∪ ((read option ∈ possibleSet)'s type);
			writableType :=
				writableType ∪ ((write option ∈ possibleSet)'s type);
		];
	]
	else
	[
		readableType := if read option ∈ optionSet's element type
			then [boolean]
			else [false's type];
		writableType := if write option ∈ optionSet's element type
			then [boolean]
			else [false's type];
	];
	If (readableType = false's type) ∧ [writableType = false's type] then
	[
		Reject parse, expected: "file open to specify read or write or both"
	];
	extend file with
		name : fileName,
		readable : readableType,
		writable : writableType
];

Method "_is readable" is [f : file | false] : boolean;
Method "_is readable" is [f : readable file | true];
Method "_is writable" is [f : file | false] : boolean;
Method "_is writable" is [f : writable file | true];
Public method "_is open" is [f : file | f's open state];
Public method "_is closed" is [f : file | ¬f's open state];

/**
 * @method "“_”"
 * @param "f" "file"
 * @returns "string"
 */
Stable method "“_”" is
[
	f : file
|
	s : string := if f is open then ["open"] else ["closed"];
	s := eject s ++ " file named " ++ “file's name”;
	If f is open then
	[
		s := eject s ++ " " ++
			if f is readable then
			[
				if f is writable then ["(readable, writable)"]
				else ["(readable)"]
			]
			else ["(writable)"];
	];
	s
];

/**
 * A file-closed exception is raised when a file operation is performed on a
 * closed file.
 *
 * @type "file-closed exception"
 * @supertype "I/O exception"
 */
Public explicit class "file-closed exception" extends I/O exception;

/**
 * Close the specified {@type "file"}.
 *
 * @method "Close_"
 * @param "f" "file"
 * @raises "file-closed exception"
 *         If {@param "f"} has already been closed.
 */
Method "Close_" is
[
	f : file
|
	If f is closed then [Raise a file-closed exception];
	[
		h : atom
	|
		Primitive 161 (e : invalid-handle code's type);
		Raise an exception for e
	] : ⊤ (f's handle);
	f's open state := false;
] : ⊤;

/**
 * Answer the current size of the specified {@type "file"}.
 *
 * @method "_'s⁇size"
 * @param "f" "file"
 * @returns "whole number"
 * @raises "I/O exception"
 *         If an I/O error occurs for any reason.
 * @raises "file-closed exception"
 *         If {@param "f"} has already been closed.
 */
Public method "_'s⁇size" is
[
	f : file
|
	[
		h : atom
	|
		Primitive 166 (e : {invalid-handle code, I/O-error code}ᵀ);
		Raise an exception for e
	] : whole number (f's handle)
] : whole number;

/* Truncate a file. */
Private method "private truncate_to_then_else_priority_" is
[
	fileHandle : atom,
	newSize : whole number,
	then : []→⊤,
	else : [{I/O-error code}ᵀ]→⊤,
	priority : byte
|
	Primitive 176 (e : {
		invalid-handle code,
		special-atom code,
		not-open-for-write code}ᵀ);
	Raise an exception for e
] : fiber;


/**
 * Set the size of the specified {@type "writable file"} to {@param "newSize"},
 * if {@param "newSize"} is less than the current size of {@param "f"},
 * otherwise do nothing.  Any data beyond the new size will be destroyed.
 *
 * @method "a fiber truncating_to_bytes⁇then_else_priority_"
 * @param "f" "writable file"
 * @param "newSize" "whole number"
 * @param "success" "[]→⊤"
 * @param "failure" "[{I/O-error code}ᵀ]→⊤"
 * @param "priority" "byte"
 * @returns "fiber"
 * @raises "invalid handle"
 *         If an I/O error occurs for any reason.
 * @raises "file-closed exception"
 *         If {@param "f"} has already been closed.
 * @raises "invalid handle"
 *         If {@param "f"} is not a file handle.
 * @raises "special atom"
 *         If {@param "f"} is a special atom.
 * @raises "not open for write"
 *         If {@param "f"} is a valid file handle, but not opened for write.
 */
Public method "a fiber truncating_to_bytes⁇then_else_priority_" is
[
	f : writable file,
	newSize : whole number,
	success : []→⊤,
	failure : [{I/O-error code}ᵀ]→⊤,
	priority : byte
|
	private truncate f's handle
		to newSize
		then success
		else failure
		priority priority
] : fiber;

Private method
	"private starting at_read_byte|bytes from_into_else_priority_" is
[
	start : natural number,
	bytesToRead : [1..∞],
	fileHandle : atom,
	into : [<byte…|0..∞>]→⊤,
	else : [{I/O-error code}ᵀ]→⊤,
	priority : byte
|
	Primitive 164 (e : {
		invalid-handle code,
		special-atom code,
		not-open-for-read code,
		exceeds-vm-limit code}ᵀ);
	Raise an exception for e
] : fiber;

Public method
	"a fiber reading_byte|bytes at_from_,⁇\
		\|on success doing_,⁇\
		\|on failure doing_,⁇\
		\|«forked at priority_»" is
[
	bytesToRead : [1..∞],
	start : natural number,
	f : readable file,
	success : [<byte…|0..∞>]→⊤,
	failure : [{I/O-error code}ᵀ]→⊤,
	optionalPriority : <byte…|0..1>
|
	private starting at start
		read bytesToRead bytes
		from f's handle
		into success
		else failure
		priority optionalPriority[1] else [current fiber's priority]
] : fiber;

Private method "private starting at_write_to_then_else_priority_" is
[
	start : natural number,
	bytesToWrite : <byte…|1..∞>,
	fileHandle : atom,
	then : []→⊤,
	else : [{I/O-error code}ᵀ]→⊤,
	priority : byte
|
	Primitive 165 (e : {
		invalid-handle code,
		special-atom code,
		not-open-for-write code,
		exceeds-vm-limit code}ᵀ);
	Raise an exception for e
] : fiber;

Public method
	"a fiber writing_at_to_,⁇\
		\|on success doing_,⁇\
		\|on failure doing_,⁇\
		\|«forked at priority_»" is
[
	bytesToWrite : <byte…|1..∞>,
	start : natural number,
	f : writable file,
	success : []→⊤,
	failure : [{I/O-error code}ᵀ]→⊤,
	optionalPriority : <byte…|0..1>
|
	private starting at start
		write bytesToWrite
		to f's handle
		then success
		else failure
		priority optionalPriority[1] else [current fiber's priority]
] : fiber;

/**
 * Block the current fiber until all writes buffered for the specified {@type
 * "file"} have been committed to the file system.  Unfortunately Avail's Java
 * substrate – and its sub-substrates in the OS – think it's ok to block a
 * thread just to wait for previously handed-off buffered write operations to
 * physically complete, defeating half of the purpose of asynchronous writes.
 * Sigh.
 * 
 * Fortunately, we have the "fileExecutor" pool of threads in the VM for just
 * that purpose – synchronous I/O operations.  We accomodate opening files,
 * renaming files and directories, and other similarly synchronous operations by
 * using the same dedicated pool.
 *
 * @method "Synchronize_with file system"
 * @param "f" "writable file"
 * @raises "I/O exception"
 *         If an I/O error occurs for any reason.
 * @raises "file-closed exception"
 *         If {@param "f"} has already been closed.
 */
Public method "a fiber synchronizing_with file system,then_else_priority_" is
[
	f : writable file,
	succeed : []→⊤,
	fail : [{I/O-error code}ᵀ]→⊤,
	priority : byte
|
	[
		handle : atom,
		succeed2 : []→⊤,
		fail2 : [{I/O-error code}ᵀ]→⊤,
		priority2 : byte
	|
		Primitive 169 (e : {
			invalid-handle code,
			special-atom code,
			not-open-for-write code}ᵀ);
		Raise an exception for e
	] : fiber (f's handle, succeed, fail, priority)
] : fiber;

/**
 * Perform the specified {@type "function" action}, passing {@param "f"} as the
 * argument. Whether the action completes normally or raises an exception,
 * {@method "Close_" close} {@param "f"}.
 *
 * @method "Using|using_,⁇do_"
 * @param "f" "file"
 *        A file, typically opened very near the send of this method. The
 *        argument position works especially well.
 * @param "action" "[⊥]→⊤"
 *        A function to apply to {@param "f"}.
 * @returns "⊤"
 *          The answer produced by applying {@param "action"} to {@param "f"}.
 */
Public method "Using|using_,⁇do_" is
[
	f : file,
	action : [⊥]→⊤
|
	Guard [action(f);]
	ensure [Close f;];
] : ⊤;

/**
 * @method "Using|using_,⁇do_"
 * @restricts "file's type"
 * @restricts "[⊥]→⊤'s type"
 */
Semantic restriction "Using|using_,⁇do_" is
[
	f : file's type,
	action : [⊥]→⊤'s type
|
	If ¬f ⊆ action[1] then
	[
		Reject parse, expected:
			format
				"function to accept the specified file \
				\|(but “①” is not a subtype of “②”)"
			with f, action[1]
	];
	action's return type
];

/**
 * Disallow the general object constructor for file-related types.
 * 
 * @method "a|an_«with«_«:»?:=_‡,»»"
 * @forbids "1" "file name" "file" "readable file" "writable file"
 *          "readable,⁇writable file"
 */
Grammatical restriction "a|an_«with«_«:»?:=_‡,»»" is
	<{
		"file name",
		"file",
		"readable file",
		"writable file",
		"readable,⁇writable file"},
	∅,
	∅>;
