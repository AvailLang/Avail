/*
 * Primitives.avail
 * Copyright © 1993-2014, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Primitives"
Versions
	"dev"
Extends
	"Data Abstractions" = ("_'s⁇position", "_'s⁇position:=_")
Uses
	"Common",
	"File Names",
	"Foundation",
	"Unit Testing"
Names
	/* File open modes. */
	"file open mode",
	"read mode",
	"write mode",

	/* File types. */
	"file",
	"readable file",
	"readable,⁇writable file",
	"writable file",

	/* File constructors. */
	"a file named_with flags_",
/*	"a file named_(mode=_)",
	"a readable file named_",
	"a readable,⁇writable file named_",
	"a writable file named_",
*/
	/* File attributes. */
	"_'s⁇name",
	"_is open",
	"_is closed",
	"_'s⁇size",
	"_'s⁇size:=_",

	/* File I/O. */
	"next_byte|bytes from_",
	"next_byte|bytes from_starting at_",
	"Write_to_",
	"Synchronize_with file system",

	/* File cleanup. */
	"Using|using_,⁇do_",

	/* File exceptions. */
	"file-closed exception",

	/* Unit testing. */
	"file primitives test suite"
Body

/**
 * The atom that represents the readability of a file.
 */
Public "read mode" is a new atom;

/**
 * The atom that represents the writability of a file.
 */
Public "write mode" is a new atom;

/**
 * Answer the enumeration of file open modes.
 */
_mode ::= {read mode, write mode}ᵀ;
Public method "file open mode" is [_mode];

"name" is a new field atom;
"handle" is a new field atom;
"readable" is a new field atom;
"writable" is a new field atom;
"open state" is a new field atom;

/**
 * A file represents an open node within a file system.
 *
 * @type "file"
 * @supertype "object"
 */
Public class "file" extends object
	with fields
		handle : atom,
		public name : file name,
		readable : boolean,
		writable : boolean
	with mutable field
		open state : boolean;

/**
 * A readable file has been opened for reading.
 *
 * @type "readable file"
 * @supertype "file"
 */
Public class "readable file" extends file
	with field
		readable : true's type;

/**
 * A writable file has been opened for writing.
 *
 * @type "writable file"
 * @supertype "file"
 */
Public class "writable file" extends file
	with field
		writable : true's type;

/**
 * A readable, writable file has been opened for reading and writing.
 *
 * @type "readable,⁇writable file"
 * @supertype "readable file"
 * @supertype "writable file"
 */
Public class "readable,⁇writable file" extends readable file ∩ writable file;

/* Open a raw file handle. */
Private method "a raw handle for file named_options_permissions_" is
[
	name : nonempty string,
	options : {[1..10]|0..10},
	permissions : {[1..9]|0..9}
|
	Primitive 160 (e : {
		invalid-path code,
		illegal-option code,
		operation-not-supported code,
		permission-denied code,
		I/O-error code}ᵀ);
	Raise an exception for e
] : atom;

/**
 * Answer an abstraction of the file named {@param "n"} that is open for
 * reading. The file position is initially zero ({@code 0}).
 *
 * @method "a readable file named_"
 * @param "n" "file name"
 * @returns "readable file"
 * @raises "permission-denied exception"
 *         If permission is denied to use the specified {@type "file name"}.
 * @raises "I/O exception"
 *         If an I/O error occurs for any reason.
 */
Public method "a readable file named_" is
[
	n : file name
|
	newHandle ::=
	[
		s : nonempty string
	|
		Primitive 160 (e : {
			invalid-path code,
			illegal-option code,
			operation-not-supported code,
			permission-denied code,
			I/O-error code}ᵀ);
		Raise an exception for e
	] : atom (n's name),
	a readable file with
		name ::= n,
		writable ::= false,
		open state := true
] : readable file;

/**
 * @method "a readable file named_"
 * @restricts "file name's type"
 */
Semantic restriction "a readable file named_" is
[
	n : file name's type
|
	extend readable file with name : n
];

/**
 * Answer an abstraction of the file named {@param "n"} that is open for
 * writing. The file position is initially zero ({@code 0}).
 *
 * @method "a truncated,⁇writable file named_"
 * @param "n" "file name"
 * @returns "writable file"
 * @raises "permission-denied exception"
 *         If permission is denied to use the specified {@type "file name"}.
 * @raises "I/O exception"
 *         If an I/O error occurs for any reason.
 */
Public method "a writable file named_" is
[
	n : file name
|
	a writable file with
		handle ::=
			[
				s : nonempty string
			|
				Primitive 161 (e : {I/O-error code, permission-denied code}ᵀ);
				Raise an exception for e
			] : atom (n's name),
		name ::= n,
		readable ::= false,
		open state := true
] : writable file;

/**
 * @method "a writable file named_"
 * @restricts "file name's type"
 */
Semantic restriction "a writable file named_" is
[
	n : file name's type
|
	extend writable file with name : n
];

/**
 * Answer an abstraction of the file named {@param "n"} that is open for
 * reading and writing. The file position is initially zero ({@code 0}).
 *
 * @method "a readable,⁇writable file named_"
 * @param "n" "file name"
 * @returns "readable,⁇writable file"
 * @raises "permission-denied exception"
 *         If permission is denied to use the specified {@type "file name"}.
 * @raises "I/O exception"
 *         If an I/O error occurs for any reason.
 */
Public method "a readable,⁇writable file named_" is
[
	n : file name
|
	a readable, writable file with
		handle ::=
			[
				s : nonempty string
			|
				Primitive 162 (e : {I/O-error code, permission-denied code}ᵀ);
				Raise an exception for e
			] : atom (n's name),
		name ::= n,
		open state := true
] : readable, writable file;

/**
 * @method "a readable,⁇writable file named_"
 * @restricts "file name's type"
 */
Semantic restriction "a readable,⁇writable file named_" is
[
	n : file name's type
|
	extend readable, writable file with name : n
];

/**
 * Answer an abstraction of the file named {@param "n"} using the specified
 * {@type "file open mode"}s. The file position is initially zero ({@code 0}).
 *
 * @method "a file named_(mode=_)"
 * @param "n" "file name"
 * @param "modes" "{file open mode|1..2}"
 *        A set containing {@method "read mode"}, {@method "write mode"}, or
 *        both.
 * @returns "file"
 *          A file open for reading, writing, or both, as specified by {@param
 *          "modes"}.
 * @raises "permission-denied exception"
 *         If permission is denied to use the specified {@type "file name"}.
 * @raises "I/O exception"
 *         If an I/O error occurs for any reason.
 */
Public method "a file named_(mode=_)" is
[
	n : file name,
	modes : {file open mode|1..2}
|
	if read mode ∈ modes then
	[
		if write mode ∈ modes then [a readable, writable file named n]
		else [a readable file named n]
	]
	else [a writable file named n]
] : file;

/**
 * @method "a file named_(mode=_)"
 * @restricts "file name's type"
 * @restricts "{file open mode|1..2}'s type"
 */
Semantic restriction "a file named_(mode=_)" is
[
	n : file name's type,
	modesType : {file open mode|1..2}'s type
|
	fileType ::=
		if |modesType| = 1 then
		[
			modes ::= modesType's instance;
			t : file's type := file;
			If read mode ∈ modes then [t := eject ↑t ∩ readable file;];
			If write mode ∈ modes then [t := eject ↑t ∩ writable file;];
			t
		]
		else [file];
	extend fileType with name : n
];

Stable method "_is readable" is [f : file | false] : boolean;
Stable method "_is readable" is [f : readable file | true];
Stable method "_is writable" is [f : file | false] : boolean;
Stable method "_is writable" is [f : writable file | true];
Public method "_is open" is [f : file | f's open state];
Public method "_is closed" is [f : file | ¬f's open state];

/**
 * @method "“_”"
 * @param "f" "file"
 * @returns "string"
 */
Stable method "“_”" is
[
	f : file
|
	s : string := if f is open then ["open"] else ["closed"];
	s := eject ↑s ++ " file named " ++ “file's name”;
	If f is open then
	[
		s := eject ↑s ++ " " ++
			if f is readable then
			[
				if f is writable then ["(readable, writable)"]
				else ["(readable)"]
			]
			else ["(writable)"];
	];
	s
];

/**
 * A file-closed exception is raised when a file operation is performed on a
 * closed file.
 *
 * @type "file-closed exception"
 * @supertype "I/O exception"
 */
Public explicit class "file-closed exception" extends I/O exception;

/**
 * Close the specified {@type "file"}.
 *
 * @method "Close_"
 * @param "f" "file"
 * @raises "file-closed exception"
 *         If {@param "f"} has already been closed.
 */
Method "Close_" is
[
	f : file
|
	[
		h : atom
	|
		Primitive 163 (e : invalid-handle code's type);
		Raise an exception for e
	] : ⊤ (f's handle);
	f's open state := false;
] : ⊤;

/**
 * Answer the current size of the specified {@type "file"}.
 *
 * @method "_'s⁇size"
 * @param "f" "file"
 * @returns "whole number"
 * @raises "I/O exception"
 *         If an I/O error occurs for any reason.
 * @raises "file-closed exception"
 *         If {@param "f"} has already been closed.
 */
Public method "_'s⁇size" is
[
	f : file
|
	[
		h : atom
	|
		Primitive 166 (e : {invalid-handle code, I/O-error code}ᵀ);
		Raise an exception for e
	] : whole number (f's handle)
] : whole number;

/**
 * Set the size of the specified {@type "file"} to {@param "newSize"}. If
 * {@param "newSize"} is less than the current size of {@param "f"}, then
 * truncate the file, preserving the prefix of the contents. If {@param
 * "newSize"} is greater than the current size of {@param "f"}, then extend the
 * file; the contents of the extension are undefined.
 *
 * @method "_'s⁇size:=_"
 * @param "f" "writable file"
 * @param "newSize" "whole number"
 * @returns "whole number"
 * @raises "I/O exception"
 *         If an I/O error occurs for any reason.
 * @raises "file-closed exception"
 *         If {@param "f"} has already been closed.
 */
Public method "_'s⁇size:=_" is
[
	f : writable file,
	newSize : whole number
|
	[
		h : atom,
		v : whole number
	|
		Primitive 176 (e : {invalid-handle code, I/O-error code}ᵀ);
		Raise an exception for e
	] : ⊤ (f's handle, newSize);
] : ⊤;

/**
 * Answer the current file position for the specified {@type "file"}.
 *
 * @method "_'s⁇position"
 * @param "f" "file"
 * @returns "natural number"
 *          The current one-based file position. This is the subscript of the
 *          next byte that will be read or written.
 * @raises "I/O exception"
 *         If an I/O error occurs for any reason.
 * @raises "file-closed exception"
 *         If {@param "f"} has already been closed.
 */
Method "_'s⁇position" is
[
	f : file
|
	[
		h : atom
	|ww
		Primitive 167 (e : {invalid-handle code, I/O-error code}ᵀ);
		Raise an exception for e
	] : natural number (f's handle)
] : natural number;

/**
 * Set the file position of the specified {@type "file"} to {@param
 * "newPosition"}. {@param "newPosition"} may exceed the {@method "_'s⁇size"
 * current size} of {@param "f"}. This will not cause extension of {@param "f"}
 * unless and until a write occurs.
 *
 * @method "_'s⁇position:=_"
 * @param "f" "file"
 * @param "newPosition" "natural number"
 *        The new one-based file position. This is the subscript of the next
 *        byte that will be read or written.
 * @raises "subscript-out-of-bounds exception"
 *         If {@param "newPosition"} exceeds the maximum representation of a
 *         file position for the given file system.
 * @raises "I/O exception"
 *         If an I/O error occurs for any reason.
 * @raises "file-closed exception"
 *         If {@param "f"} has already been closed.
 */
Method "_'s⁇position:=_" is
[
	f : file,
	newPosition : natural number
|
	[
		h : atom,
		v : natural number
	|
		Primitive 168 (e : {
			subscript-out-of-bounds code,
			invalid-handle code,
			I/O-error code}ᵀ);
		Raise an exception for e
	] : ⊤ (f's handle, newPosition);
] : ⊤;

/**
 * Read data from the specified {@type "file"}, starting at the {@method
 * "_'s⁇position" current file position}. Advance the file position by the
 * number of bytes actually read.
 *
 * @method "next_byte|bytes from_"
 * @param "bytesToRead" "[0..∞]"
 *        The number of bytes to attempt to read from {@param "f"}. If infinite,
 *        then return the smaller of 1) all remaining bytes or 2) a huge tuple
 *        whose exact size is unspecified.
 * @param "f" "readable file"
 * @returns "<[0..255]…|>"
 *          Up to {@param "bytesToRead"} bytes from {@param "f"}. Fewer bytes
 *          will be returned if fewer bytes are available.
 * @raises "I/O exception"
 *         If an I/O error occurs for any reason.
 * @raises "file-closed exception"
 *         If {@param "f"} has already been closed.
 */
Public method "next_byte|bytes from_" is
[
	bytesToRead : [0..∞],
	f : readable file
|
	[
		h : atom,
		v : [0..∞]
	|
		Primitive 164 (e : {invalid-handle code, I/O-error code}ᵀ);
		Raise an exception for e
	] : <[0..255]…|> (f's handle, bytesToRead)
] : <[0..255]…|>;

final A_Number positionObject = args.get(0);
final A_Number sizeObject = args.get(1);
final A_Atom handle = args.get(2);
final A_Function succeed = args.get(3);
final A_Function fail = args.get(4);
final A_Number priority = args.get(5);


Private method "private next_byte|bytes starting at_from_priority_into_else_" is
[
	bytesToRead : [1..∞],
	start : natural number,
	f : readable file,
	priority : byte,
	into : [<byte…|>]→⊤,
	else : [io error code]→⊤
|
	Primitive 164 (e : {
		invalid-handle code,
		special-atom code,
		not-open-for-read code,
		exceeds-vm-limit code})
	Raise an exception for e
] : <byte…|1..∞>

/**
 * @method "next_byte|bytes from_"
 * @restricts "[0..∞]'s type"
 * @restricts "readable file's type"
 */
Semantic restriction "next_byte|bytes from_" is
[
	bytesToRead : [0..∞]'s type,
	f : readable file's type
|
	<[0..255]…|0..⎡bytesToRead⎤>
];

/**
 * Write data to the specified {@type "file"}, starting at the {@method
 * "_'s⁇position" current file position}. Advance the file position by the
 * number of bytes actually written.
 *
 * @method "Write_to_"
 * @param "bytesToWrite" "whole number"
 *        The bytes to write to {@param "f"}.
 * @param "f" "writable file"
 * @raises "I/O exception"
 *         If an I/O error occurs for any reason.
 * @raises "file-closed exception"
 *         If {@param "f"} has already been closed.
 */
Public method "Write_to_" is
[
	bytesToWrite : <[0..255]…|>,
	f : writable file
|
	[
		h : atom,
		b : <[0..255]…|>
	|
		Primitive 165 (e : {invalid-handle code, I/O-error code}ᵀ);
		Raise an exception for e
	] : ⊤ (f's handle, bytesToWrite);
] : ⊤;

/**
 * Block the current fiber until all writes buffered for the specified {@type
 * "file"} have been committed to the file system.
 *
 * @method "Synchronize_with file system"
 * @param "f" "writable file"
 * @raises "I/O exception"
 *         If an I/O error occurs for any reason.
 * @raises "file-closed exception"
 *         If {@param "f"} has already been closed.
 */
Public method "Synchronize_with file system" is
[
	f : writable file
|
	[
		h : atom
	|
		Primitive 169 (e : {invalid-handle code, I/O-error code}ᵀ);
		Raise an exception for e
	] : ⊤ (f's handle);
] : ⊤;

/**
 * Perform the specified {@type "function" action}, passing {@param "f"} as the
 * argument. Whether the action completes normally or raises an exception,
 * {@method "Close_" close} {@param "f"}.
 *
 * @method "Using|using_,⁇do_"
 * @param "f" "file"
 *        A file, typically opened very near the send of this method. The
 *        argument position works especially well.
 * @param "action" "[⊥]→⊤"
 *        A function to apply to {@param "f"}.
 * @returns "⊤"
 *          The answer produced by applying {@param "action"} to {@param "f"}.
 */
Public method "Using|using_,⁇do_" is
[
	f : file,
	action : [⊥]→⊤
|
	Guard [action(f);]
	ensure [Close f;];
] : ⊤;

/**
 * @method "Using|using_,⁇do_"
 * @restricts "file's type"
 * @restricts "[⊥]→⊤'s type"
 */
Semantic restriction "Using|using_,⁇do_" is
[
	f : file's type,
	action : [⊥]→⊤'s type
|
	If ¬f ⊆ action[1] then
	[
		Reject parse, expected:
			format
				"function to accept the specified file \
				\|(but “①” is not a subtype of “②”)"
			with f, action[1]
	];
	action's return type
];

/**
 * Disallow the general object constructor for file-related types.
 * 
 * @method "a|an_«with«_«:»?:=_‡,»»"
 * @forbids "1" "file name" "file" "readable file" "writable file"
 *          "readable,⁇writable file"
 */
Grammatical restriction "a|an_«with«_«:»?:=_‡,»»" is
	<{
		"file name",
		"file",
		"readable file",
		"writable file",
		"readable,⁇writable file"},
	∅,
	∅>;
