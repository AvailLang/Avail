/*
 * File Iterators.avail
 * Copyright © 1993-2014, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "File Iterators"
Versions
	"1.0.0 DEV 2014-04-28"
Extends
	"Data Abstractions" =
	(
		"_'s⁇position",
		"_'s⁇position:=_"
	),
	"Primitives" =
	(
		"Using|using_,⁇do_",
		"_is closed",
		"_is open"
	)
Uses
	"Common",
	"Data Abstractions",
	"File Names",
	"File Open Options",
	"Foundation",
	"Primitives",
	"Unit Testing"
Names
	/* Types. */
	"file iterator",
	"file reader",
	"file writer",
	"file reader/writer",

	/* Constructors. */
	"a_for_«aligning buffers to_bytes»",

	/* Coherence. */
	"Synchronize_",

	/* Tests. */
	"file iterator test suite"
Body

"file position" is a new field atom;
"alignment" is a new field atom;
"buffer is dirty" is a new field atom;
"element source" is a new field atom;

/*
TODO [MvG] - document properly.
NOTES:
	Explicitly taking N bytes should use a large buffer, big enough to
	be aligned but include the entire desired range.  Round down the start to
	the alignment and round up the end to the alignment.

	-Positioning before the current buffer or *beyond* the byte just *after* the
	 current buffer should flush the current buffer if necessary, then
	 invalidate it by replacing it with the empty tuple.  If the next operation
	 is a read, it will read the (aligned) buffer.  On the other hand, if the
	 next operation is a write, the buffer will not need to be fetched.  If a
	 full bufferful of data is written, no read will have to happen, but if a
	 buffer flush is forced before a full buffer is available, only the buffered
	 bytes need to be written.
	-Writes are not aligned, since that forces an early read.
	-Writes into a buffer that's aligned due to a read will be re-written
	 starting at the alignment.  When the write starts, the buffer is
	 immediately truncated to the nearest aligned location before the write
	 position.
 
	-The read buffer is always aligned.  A request to read more than a single
	 aligned buffer will figure out which region(s) of data are not in the
	 current buffer, then do zero, one, or two reads to populate a larger
	 buffer that's aligned to the nearest alignments that provide the needed
	 data.  The buffers are concatenated to form a contiguous region if possible
	 (even if the read merely abuts the previous buffer boundary).  The buffer
	 is then truncated to conform to the file's read buffer cache limit (always
	 a multiple of the alignment).
	-Contiguous writes are accumulated up to the file's write buffer cache limit
	 before being flushed (updating the overlapping portion of the read buffer).
	 However, they need not be aligned.  A non-contiguous write within the same
	 alignment area should perform a read if necessary to populate the write
	 buffer

	 VM support:
	 	-ACTION ITEM: File open primitive needs to capture buffer alignment into
	 	 a new property.
	 	-AvailRuntime has added an LRUCache of buffers, each of which is
	 	 associated with a particular file and starting position.  If the buffer
	 	 is present, it will always be aligned.  Even though the Avail code can
	 	 request ranges that are unaligned, these ranges are silently extended
	 	 to the nearest alignment boundaries (floor for start, ceiling for end)
	 	 before the operating system is consulted, and the read result is sliced
	 	 into individual aligned pages (via SubrangeTupleDescriptor) which are
	 	 placed in the cache.  Then a potentially unaligned subtuple is returned
	 	 from the read primitive, corresponding to the exact requested range.
	 	-If the requested pages are all present, then the operation system read
	 	 is skipped, and the pages are spliced together as needed, and a
	 	 suitable subtuple is returned.
	 	-The write operation doesn't need to be aligned.  However, for each
	 	 page partially overwritten by the write, any existing cached buffer is
	 	 updated prior to the OS write.  Any complete pages are completely
	 	 replaced with the appropriate subrange of the provided buffer.
	 Representation of read/write file iterators:
		-one buffer
		-buffer dirty flag
		-current position in file
		-alignment
		-buffers are LRU-cached by the VM to speed up reads.  An explicit
		 "refresh" is needed to remove the buffer, allowing the next read to
		 replace it.
	 Invariants:
		-empty buffer implies buffer dirty flag is clear.
		-if buffer is dirty then current position in file is between buffer
		 start and buffer end + 1.
		-buffer never crosses page boundary.
	 Sample situations:
		-empty buffer, read -> fetch ONE aligned page.
		-empty buffer, write -> accrete buffer as data is appended to it,
		 flushing when buffer crosses alignment.  If a single large tuple of
		 bytes is written, multiple alignment boundaries may be crossed.  In
		 that case, all data up to the last-crossed alignment boundary is
		 written, and the remaining portion of the buffer, if any, remains as a
		 dirty buffer.
		-buffer not dirty, seek adjusts current position and clears the buffer
		 if the new position is off the buffer.
		-dirty buffer, seek far -> flush buffer, empties it, set current
		 position.
		-dirty buffer, seek on same alignment page but outside buffer -> read
		 a page from file, overwrite with dirty parts, keep dirty flag set, and
		 adjust buffer start in file to start of page (i.e., treat whole buffer
		 as dirty).
		-support "refresh" operation which flushes if dirty, but empties the
		 buffer in either case.  It also discards all existing VM-cached buffers
		 for that file.
		-support "flush" operation which flushes if the buffer is dirty.
		-support "commit" operation which flushes and then waits for all
		 outstanding writes to complete.
*/

/**
 * A file iterator provides streaming access to a backing {@type "file"}.  Its
 * subtypes {@type "file reader"}, {@type "file writer"}, and
 * {@type "file reader/writer"} are specializations that support reading
 * writing, or both, respectively.
 *
 * @type "file iterator"
 * @supertype "positionable buffered iterator"
 */
Public class "file iterator" extends random access buffered iterator
	with fields
		alignment : whole number,
		element type : byte's type,
		element source : file;

/**
 * A file reader buffers bytes obtained from a backing {@type "readable file"}.
 *
 * @type "file reader"
 * @supertype "file iterator"
 */
Public explicit class "file reader" extends file iterator ∩ buffered reader
	with field
		element source : readable file;

/**
 * A file writer buffers bytes obtained from a backing {@type "writable file"}.
 *
 * @type "file writer"
 * @supertype "file iterator"
 */
Public class "file writer" extends file iterator
	with field
		element source : writable file
	with mutable fields
		buffer is dirty : boolean;

/**
 * A file iterator buffers bytes obtained from a backing {@type
 * "readable,⁇writable file"}.
 *
 * @type "file reader/writer"
 * @supertype "file reader"
 * @supertype "file writer"
 */
Public class "file reader/writer"
	extends file reader ∩ file writer;


_privateReadBuffer ::=
[
	fileReader : file reader
|
	buffer : <byte…|>;
	readComplete ::= a semaphore named "read is complete" with 0 permits;
	readFiber ::= a fiber reading fileReader's maximum buffer size bytes
		at fileReader's position
		from fileReader's element source
		on success doing
			[
				theBytes : <byte…|>
			|
				buffer := theBytes;
				Signal readComplete;
			]
		on failure doing
			[
				error : {I/O-error code}ᵀ
			|
				/* All we know is that I/O failed. */
				Signal readComplete;
			];
	Await readComplete;
	If buffer is unassigned then [Raise an I/O exception];
	buffer
] : <byte…|>;

file reader's fetch current buffer method is _privateReadBuffer;

file reader/writer's fetch current buffer method is
[
	aFileReaderWriter : file reader/writer
|
	Assert: ¬ aFileReaderWriter's buffer is dirty;
	_privateReadBuffer(aFileReaderWriter)
];

_privateWriteBuffer ::=
[
	fileWriter : file writer
|
	success : boolean := false;
	If fileWriter's buffer is dirty then
	[
		Assert: |fileWriter's buffer| > 0;
		writeComplete ::= a semaphore named "write is complete" with 0 permits;
		buffer ::= fileWriter's buffer ?→ <byte…|1..>;
		writeFiber ::= a fiber writing buffer
			at fileWriter's buffer start
			to fileWriter's element source
			on success doing
				[
					success := true;
					Signal writeComplete;
				]
			on failure doing
				[
					error : {I/O-error code}ᵀ
				|
					/* All we know is that I/O failed. */
					Signal writeComplete;
				];
		Await writeComplete;
		Unless success then
		[
			Raise an I/O exception
		];
		fileWriter's buffer is dirty := false;
	];
] : ⊤;

file iterator's exit buffer method is
[
	fileIterator : file iterator
|
	/* Do nothing. */
];

file writer's exit buffer method is _privateWriteBuffer;

/**
 * Construct and answer a {@type "readable file iterator"} that is open on the
 * file named by {@param "fn"}.
 *
 * @method "a_for_«aligning buffers to_bytes»"
 * @param "fileIteratorType" "file iterator's type"
 * @param "fn" "file name"
 *        The {@method "file name"} of the target file.
 * @param "optionalAlignment" "<natural number…|0..1>"
 *        If specified, the number of bytes to buffer from the underlying {@type
 *        "file"}. If not specified, then a default value is used.
 * @returns "readable file iterator"
 * @raises "permission-denied exception"
 *         If permission is denied to use the specified {@type "file name"}.
 * @raises "I/O exception"
 *         If an I/O error occurs for any reason.
 */
Public method "a_for_«aligning buffers to_bytes»" is
[
	fileIteratorType : file iterator's type,
	fn : file name,
	optionalAlignment : <natural number…|0..1>
|
	options : {{read, write}ᵀ|} := ∅;
	If fileIteratorType ⊆ reader then [options := options ∪ {read};];
	If fileIteratorType ⊆ writer then [options := options ∪ {write};];
	theIterator ::= a fileIteratorType with
		element type ::= byte,
		alignment ::= optionalAlignment[1] else [1],
		element source ::= fn opened with options
			options ?→ {{read, write}ᵀ|1..2},
		maximum buffer size ::= optionalAlignment[1] else [32768],
		position variable := 1,
		buffer := <>,
		position in buffer := 1;
	Cast theIterator into
	[
		theWriter : file writer
	|
		theWriter's buffer is dirty := false;
	]
	else [];
	theIterator
] : file iterator;

Semantic restriction "a_for_«aligning buffers to_bytes»" is
[
	fileIteratorMeta : file iterator's type's type,
	fnType : file name's type,
	optionalAlignmentType : <natural number…|0..1>'s type
|
	fileIteratorMeta's instance
];

/**
 * Is the {@type "file"} underlying the specified {@type "file iterator"} open?
 *
 * @method "_is open"
 * @param "anIterator" "file iterator"
 * @returns "boolean"
 *          {@method "true"} if {@param "anIterator"} is open, {@method "false"}
 *          otherwise.
 */
Method "_is open" is
[
	anIterator : file iterator
|
	anIterator's element source is open
] : boolean;

/**
 * Is the {@type "file"} underlying the specified {@type "file iterator"}
 * closed?
 *
 * @method "_is closed"
 * @param "anIterator" "file iterator"
 * @returns "boolean"
 *          {@method "true"} if {@param "anIterator"} is closed, {@method
 *          "false"} otherwise.
 */
Method "_is closed" is
[
	anIterator : file iterator
|
	anIterator's element source is closed
] : boolean;

/**
 * Close the {@type "file"} underlying the specified {@type "file iterator"}.
 *
 * @method "Close_"
 * @param "anIterator" "file iterator"
 * @raises "file-closed exception"
 *         If {@param "anIterator"} has already been closed.
 */
Method "Close_" is
[
	anIterator : file iterator
|
	Close anIterator's element source;
];

/**
 * Perform the specified {@type "function" action}, passing {@param
 * "anIterator"} as the argument. Whether the action completes normally or
 * raises an exception, {@method "Close_" close} {@param "anIterator"}.
 *
 * @method "Using|using_,⁇do_"
 * @param "anIterator" "file iterator"
 *        A file iterator, typically opened very near the send of this method.
 *        The argument position works especially well.
 * @param "action" "[⊥]→⊤"
 *        A function to apply to {@param "anIterator"}.
 * @returns "⊤"
 *          The answer produced by applying {@param "action"} to {@param
 *          "anIterator"}.
 */
Method "Using|using_,⁇do_" is
[
	anIterator : file iterator,
	action : [⊥]→⊤
|
	Guard [action(anIterator);]
	ensure [Close anIterator;];
] : ⊤;

/**
 * @method "Using|using_,⁇do_"
 * @restricts "file iterator's type"
 * @restricts "[⊥]→⊤'s type"
 */
Semantic restriction "Using|using_,⁇do_" is
[
	anIterator : file iterator's type,
	action : [⊥]→⊤'s type
|
	If ¬anIterator ⊆ action[1] then
	[
		Reject parse, expected:
			format
				"function to accept the specified file iterator \
				\|(but “①” is not a subtype of “②”)"
			with anIterator, action[1]
	];
	action's return type
];

/**
 * Wait for all outstanding writes on this iterator to complete writing to the
 * physical medium associated with the file's filesystem.
 * 
 * @method "Synchronize_"
 * @param "anIterator" "file writer"
 * @raises "I/O exception"
 */
Public method "Synchronize_" is
[
	anIterator : file writer
|
	syncComplete ::= a semaphore named "sync is complete" with 0 permits;
	hadError : boolean := false;
	readFiber ::= a fiber
		synchronizing anIterator's element source with file system,
		then
		[
			Signal syncComplete;
		]
		else
		[
			error : {I/O-error code}ᵀ
		|
			hadError := true;
			Signal syncComplete;
		]
		priority current fiber's priority;
	Await syncComplete;
	If hadError then [Raise an I/O exception];
];

/** TODO MvG - Document */
Method "Truncate_" is
[
	anIterator : file writer
|
	syncComplete ::= a semaphore named "sync is complete" with 0 permits;
	hadError : boolean := false;
	readFiber ::= a fiber
		synchronizing anIterator's element source with file system,
		then
		[
			Signal syncComplete;
		]
		else
		[
			error : {I/O-error code}ᵀ
		|
			hadError := true;
			Signal syncComplete;
		]
		priority current fiber's priority;
	Await syncComplete;
	If hadError then [Raise an I/O exception];
];


"file iterator test suite" is a new atom;
New test suite file iterator test suite extends I/O test suite;

/* The test directory. */
testDir ::= a file named test directory;

Test "file iterator(readable)" in file iterator test suite is
[
	ref ::= map "abracadabra" through [c : character | c's code point];
	fn ::= testDir / "abracadabra.txt";
	iter ::= a file reader for fn;
	Require: iter is open;
	Require: take at most ∞ from iter = ref;
	Require: iter is exhausted;
	Require: iter is open;
	Close iter;
	Require: iter is closed;
];

Test "file iterator(readable,small buffer)" in file iterator test suite is
[
	ref ::= map "abracadabra" through [c : character | c's code point];
	fn ::= testDir / "abracadabra.txt";
	iter ::= a file reader for fn aligning buffers to 3 bytes;
	Require: iter is open;
	Require: take at most ∞ from iter = ref;
	Require: iter is exhausted;
	Require: iter is open;
	Close iter;
	Require: iter is closed;
];

Test "file iterator(readable,reposition)" in file iterator test suite is
[
	ref ::= map "abracadabra" through [c : character | c's code point];
	fn ::= testDir / "abracadabra.txt";
	iter ::= a file reader for fn;
	Require: iter is open;
	Require: take at most ∞ from iter = ref;
	Require: iter is exhausted;
	Require: iter is open;
	iter's position := 1;
	Require: take at most ∞ from iter = ref;
	Require: iter is exhausted;
	Require: iter is open;
	Close iter;
	Require: iter is closed;
];

Test "file iterator(double close)" in file iterator test suite is
[
	fn ::= testDir / "abracadabra.txt";
	iter ::= a file reader for fn;
	Close iter;
	Close iter;
]
must raise file-closed exception;

Test "file iterator(can't open for reading)" in file iterator test suite is
[
	fn ::= testDir / "doesntexist.txt";
	iter ::= a file reader for fn;
]
must raise I/O exception;
