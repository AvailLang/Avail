/*
 * UTF8 Converters.avail
 * Copyright ¬© 1993-2014, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "UTF-8 Converters"
Versions
	"1.0.0 DEV 2014-04-28"
Uses
	"Abstract Converters",
	"Foundation",
	"Iterators",
	"Unit Testing"
Names
	"a utf8 decoder",
	"a utf8 encoder",
	"utf8 decoder",
	"utf8 encoder"
Body

"residue" is a new field atom;

/**
 * Produce a sequence of bytes that constitute the UTF-8 encoding of the given
 * Unicode code point.
 * 
 * @method "bytes from_"
 * @param "codePoint" "code point"
 */
Abstract method "bytes from_" is [code point] ‚Üí <byte‚Ä¶|>;

Private method "bytes from_" is
[
	codePoint : [0..127]
|
	<codePoint>
];

Private method "bytes from_" is
[
	codePoint : [128..2047]
|
	<192 + (codePoint >> 6),
	 128 + (codePoint bit‚àß 63)>
] : <byte‚Ä¶|>;

Private method "bytes from_" is
[
	codePoint : [2048..65535]
|
	<224 + (codePoint >> 12),
	 128 + ((codePoint >> 6) bit‚àß 63),
	 128 + (codePoint bit‚àß 63)>
] : <byte‚Ä¶|>;

Private method "bytes from_" is
[
	codePoint : [65536..1114111]
|
	<240 + (codePoint >> 18),
	 128 + ((codePoint >> 12) bit‚àß 63),
	 128 + ((codePoint >> 6) bit‚àß 63),
	 128 + (codePoint bit‚àß 63)>
] : <byte‚Ä¶|>;

/**
 * A converter that translates a tuple of characters (i.e., a string) into a
 * tuple of UTF-8 encoded bytes.
 * 
 * @type "utf8 encoder"
 * @supertype "converter"
 * @category "Codecs"
 */
Public explicit class "utf8 encoder"
	extends converter from character to byte;

/* Compute [character]‚Üíbyte statically, so we have a strong enough argument
 * type.  That's because of contravariance of argument types, and the fact that
 * the expression "character" is theoretically allowed to produce something more
 * specific than the character type.
 */
charToByte ::= [character]‚Üíbyte;

Public method "a utf8 encoder" is
[
	a utf8 encoder with conversion type ::= charToByte
];

/**
 * Encode some characters into UTF-8 bytes.
 *
 * @method "_process_"
 * @param "encoder" "utf8 encoder"
 * @param "sourceTuple" "string"
 */
Method "_process_" is
[
	encoder : utf8 encoder,
	sourceTuple : string
|
	output : <byte‚Ä¶|> := <>;
	For each of sourceTuple do
	[
		c : character
	|
		output := eject output ++ bytes from c's code point;
	];
	output
];

/**
 * Flushing a UTF-8 encoder always produces an empty sequence of bytes.
 * 
 * @method "flush_"
 * @param "encoder" "utf8 encoder"
 */
Method "flush_" is
[
	encoder : utf8 encoder
|
	<>
];

/**
 * A converter that translates a tuple of UTF-8 encoded bytes into a tuple of
 * characters (i.e., a string).
 * 
 * @type "utf8 decoder"
 * @supertype "converter"
 * @category "Codecs"
 */
Public explicit class "utf8 decoder"
	extends converter from byte to character
	with mutable field
		referable residue : <byte‚Ä¶|>;

/* Compute [byte]‚Üícharacter statically, so we have a strong enough argument
 * type.  That's because of contravariance of argument types, and the fact that
 * the expression "byte" is theoretically allowed to produce something more
 * specific than the byte type.
 */
byteToChar ::= [byte]‚Üícharacter;

Public method "a utf8 decoder" is
[
	a utf8 decoder with
		conversion type ::= byteToChar,
		residue := <>
];

/**
 * Answer how many bytes long a UTF-8 sequence starting with the given byte will
 * be.  Note that some leading bytes are always illegal, and some leading bytes
 * may or may not be illegal, depending on the continuation bytes (for example,
 * they may produce an "overlong encoding").  We only detect leading bytes of
 * always-illegal sequences here, answering zero.
 * 
 * @method "byte count for_"
 * @param "leadingByte" "byte"
 * @returns "[0..4]"
 */
Private method "byte count for_" is [leadingByte : byte | 0] : [0..4];
Private method "byte count for_" is [leadingByte : [0..127] | 1];
Private method "byte count for_" is [leadingByte : [194..223] | 2];
Private method "byte count for_" is [leadingByte : [224..239] | 3];
Private method "byte count for_" is [leadingByte : [240..244] | 4];


/**
 * Decode some UTF-8 bytes into a Unicode string.  Unrecognized byte sequences
 * will be converted into the Unicode replacement character (U+FFFD).
 * An incomplete byte sequence will simply wait until more data is supplied or a
 * flush occurs (which will cause U+FFFD to be emitted for the truncated
 * buffered content).
 * 
 * @method "_process_"
 * @param "decoder" "utf8 decoder"
 * @returns "bytes" "<byte‚Ä¶|>"
 */
Method "_process_" is
[
	decoder : utf8 decoder,
	bytes : <byte‚Ä¶|>
|
	in : <byte‚Ä¶|> := decoder's residue ++ bytes;
	out : string := "";
	index : natural number := 1;
	leadByte : byte;
	count : [0..4];
	While
	[
		index ‚â§ |in| ‚àß [
			leadByte := in[index];
			count := byte count for leadByte;
			index + count - 1 ‚â§ |in|]
	]
	do
	[
		continuationBytes : <byte‚Ä¶|>;
		If count > 0 ‚àß
			[
				continuationBytes := in[index + 1 .. index + count - 1];
				continuationBytes ‚àà <[128..191]‚Ä¶|>] then
		[
			/* Extract the bytes and decode them. */
			accumulator : whole number := leadByte bit‚àß (255 >> count);
			index++;
			For each of continuationBytes do
			[
				nextByte : byte
			|
				accumulator := (eject accumulator << 6) + (nextByte bit‚àß 63);
				index++;
			];
			out := eject out ++ (cast accumulator
				into [cp : code point | <cp ‚Üí character>]
				else ["\(fffd)"]);
		]
		else
		[
			/* The continuation bytes are invalid.  For now, decode under the
			 * assumption that the leading byte correctly indicates the number
			 * of continuation bytes, but one of the continuation bytes is
			 * wrong.  Replace the sequence with the Unicode replacament
			 * character (U+FFFD), and skip the leading and continuation bytes.
			 */
			out := eject out ++ "\(fffd)";
			index := index + count + 1;
		];
	];
	decoder's residue := in[index..];
	out
];

/**
 * Flush the UTF-8 decoder.  Since a complete sequence of bytes representing a
 * character would have already produced a corresponding character, it must be
 * the case that a non-empty residue should be treated as an invalid sequence,
 * for which a single Unicode replacement character (U+FFFD) will be emitted.
 * 
 * @method "flush_"
 * @param "decoder" "utf8 decoder"
 * @returns "bytes" "<byte‚Ä¶|>"
 */
Method "flush_" is
[
	decoder : utf8 decoder
|
	out ::= if decoder's residue = <> then [""] else ["\(fffd)"];
	decoder's residue := <>;
	out
];


/**
 * Protect the constructor expressions from potentially ambiguous
 * interpretations.
 * 
 * @restrict "a|an_¬´with¬´_¬´:¬ª?:=_‚Ä°,¬ª¬ª"
 */
Grammatical restriction {"a|an_¬´with¬´_¬´:¬ª?:=_‚Ä°,¬ª¬ª"} is
<
	{"utf8 encoder", "utf8 decoder"},
	‚àÖ,
	‚àÖ
>;





/* TODO[MvG] - Obviously move this to a proper test. */
ENCODER ::= a utf8 encoder;
INPUT : string := "Cat‡¶¨‡¶ø‡¶°‡¶º‡¶æ‡¶≤Áå´üí©";
Print: format "INPUT=‚Äú‚ë†‚Äù\n" with INPUT;
TEST ::= ENCODER process INPUT;
Print: format "TEST=‚Äú‚ë†‚Äù\n" with TEST;

DECODER ::= a utf8 decoder;
OUTPUT ::= DECODER process TEST;
Print: format "OUTPUT=‚Äú‚ë†‚Äù\n" with OUTPUT;
Assert: INPUT = OUTPUT;



OLD UTF-8 CODE




/*UTF-8 Codec test suite*/
"UTF8 codec test suite" is a new atom;
New test suite UTF8 codec test suite extends codecs test suite;

Test "string encoding" in UTF8 codec test suite is
[
	testString ::= "‚ä§‚ä•‚Üì‚Üë¬±‚àÖ‚àä‚à∞‚à°‚ÑÄPog?";
	encodedTestString ::= encode testString using a UTF-8 codec;
	expectedEncoding ::=  <226,138,164,226,138,165,226,134,147,226,134,145,194,
			177,226,136,133,226,136,138,226,136,176,226,136,161,226,132,128,80,
			111,103,63>;
	Require: encodedTestString = expectedEncoding;
];

Test "byte decoding" in UTF8 codec test suite is
[
	testEncoding ::= <226,138,164,226,138,165,226,134,147,226,134,145,194,177,
		226,136,133,226,136,138,226,136,176,226,136,161,226,132,128,80,111,103,
		63>;
	decodedTestEncoding ::= decode testEncoding using a UTF-8 codec;
	expectedDecodedString ::= "‚ä§‚ä•‚Üì‚Üë¬±‚àÖ‚àä‚à∞‚à°‚ÑÄPog?";
	Require: decodedTestEncoding = expectedDecodedString;
];

Test "full decoding reader" in UTF8 codec test suite is
[
	testEncodingIterator ::= a reader over <226,138,164,226,138,165,226,134,
		147,226,134,145,194,177,226,136,133,226,136,138,226,136,176,226,136,161,
		226,132,128,80,111,103,63>;
	decodedTestEncoding ::= take at most ‚àû from a decoding reader of 
			testEncodingIterator using a UTF-8 codec;
	expectedDecodedString ::= "‚ä§‚ä•‚Üì‚Üë¬±‚àÖ‚àä‚à∞‚à°‚ÑÄPog?";
	Require: decodedTestEncoding = expectedDecodedString;
];

Test "partial decoding reader" in UTF8 codec test suite is
[
	testEncodingIterator ::= a reader over <226,138,164,226,138,165,226,134,
		147,63,226,134,145,194,177,226,136,133,226,136,138,226,136,176,226,136,161,
		226,132,128,80,111,103,63>;
	decodedTestEncoding ::= take at most 4 from a decoding reader of 
			testEncodingIterator using a UTF-8 codec;
	expectedDecodedString ::= "‚ä§‚ä•‚Üì?";
	Require: decodedTestEncoding = expectedDecodedString;
];

Test "full encoding reader" in UTF8 codec test suite is
[
	testString ::= "‚ä§‚ä•‚Üì‚Üë¬±‚àÖ‚àä‚à∞‚à°‚ÑÄPog?";
	encodedTestString ::= take at most ‚àû from a utf8 encoding reader 
		that buffers 10 characters of a reader over testString using a UTF-8 
		codec;
	expectedEncoding ::=  <226,138,164,226,138,165,226,134,147,226,134,145,194,
			177,226,136,133,226,136,138,226,136,176,226,136,161,226,132,128,80,
			111,103,63>;
	Require: encodedTestString = expectedEncoding;
];

Test "partial encoding reader" in UTF8 codec test suite is
[
	testString ::= "‚ä§‚ä•‚Üì?‚Üë¬±‚àÖ‚àä‚à∞‚à°‚ÑÄPog?";
	encodedTestString ::= take at most 10 from a utf8 encoding reader 
		that buffers 10 characters of a reader over testString using a UTF-8 
		codec;
	expectedEncoding ::=  <226,138,164,226,138,165,226,134,147,63>;
	Require: encodedTestString = expectedEncoding;
];
