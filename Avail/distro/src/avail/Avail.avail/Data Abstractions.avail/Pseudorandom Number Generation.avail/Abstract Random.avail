/*
 * Abstract Random.avail
 * Copyright © 1993-2014, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Abstract Random"
Versions
	"1.0.0 DEV 2014-04-28"
Uses
	"Common",
	"Foundation",
	"Iterators",
	"Streams"
Names
	/* Types. */
	"pRNG",
	"pRNG of_",

	/* Pseudorandom number generation. */
	"_'s⁇next«value in»⁇_",
	"_'s⁇next element of_",
	"_'s⁇next binding of_",
	"_'s⁇next shuffling of_"

Body

/**
 * A pseudorandom number generator employs a deterministic process to produce a
 * sequence of numbers with properties similar to those possessed by a truly
 * random sequence of numbers.
 *
 * @type "pRNG"
 */
Public explicit class "pRNG" extends iterator
	with fields
		element type : whole number's type;

/**
 * Construct and answer a {@type "pRNG"} type that answers values of the
 * specified type.
 * 
 * @method "pRNG of_"
 * @param "elementType" "whole number's type"
 *        The type of value produced by iterators of the answered type.
 * @returns "pRNG's type"
 *          The requested pRNG type.
 */
Public method "pRNG of_" is
[
	elementType : whole number's type
|
	extend pRNG with element type : elementType's type
] : pRNG's type;

/* Fractions for Mark's continuous border sampling equal distribution */
"numerator" is a new field atom;
"denominator" is a new field atom;
"whole number part" is a new field atom;

Explicit class "fraction" extends object
	with immutable fields
		numerator : whole number,
		denominator : natural number;

Explicit class "nonnegative mixed fraction" extends fraction
	with immutable fields
		whole number part : whole number;

Explicit class "improper fraction" extends fraction;

Method "“_”" is
[
 	f : fraction
 |
 	format "“①”/“②”" with f's numerator, f's denominator
]:string;

Method "“_”" is
[
 	f : nonnegative mixed fraction
 |
 	format "“①” “②”/“③”" with 
 		f's whole number part, f's numerator, f's denominator
]:string;

Private method "`|_`|→natural number" is
[
 	i : integer's type
 |
	 cast (⎡i⎤ - ⎣i⎦)
		into [n : natural number | n]
]:natural number;

Private method "_/_" is 
[
 	num : whole number,
 	den : natural number
 |
 	wholeNumber : whole number := num ÷ den;
	modNumerator ::= num mod den;
	if modNumerator = 0 then
	[
		a nonnegative mixed fraction with
			whole number part ::= wholeNumber,
			numerator ::= 0,
			denominator ::= den
	] else
	[
		gcd : natural number := greatest common denominator of 
			(cast modNumerator into [n : natural number | n]) and den;
		
		reducedNumerator : whole number := modNumerator ÷ gcd;
		
		reducedDenominator : natural number := cast den ÷ gcd into 
			[n : natural number | n];
		a nonnegative mixed fraction with
			whole number part ::= wholeNumber,
			numerator ::= reducedNumerator ,
			denominator ::= reducedDenominator
	]
]:nonnegative mixed fraction;
	
Private method "_'s⁇fraction" is
[
	mixed : nonnegative mixed fraction
 |
 	mixed's numerator / mixed's denominator
]:nonnegative mixed fraction;

Private method "_→improper fraction" is
[
 	f : nonnegative mixed fraction
 |
 	newNumerator ::= f's whole number part × f's denominator + f's numerator;
 	an improper fraction with
		numerator ::= newNumerator,
		denominator ::= f's denominator
]:improper fraction;

Private method "_→improper fraction" is
[
 	n : natural number
 |
 	an improper fraction with
		numerator ::= n,
		denominator ::= 1
]:improper fraction;

Private method "invert_" is
[
	f : improper fraction
 |
	f's denominator / cast f's numerator into 
		[n : natural number | n]
]: nonnegative mixed fraction;

Method "invert_" is
[
	f : nonnegative mixed fraction
 |
 	invert (f →improper fraction)
]: nonnegative mixed fraction;

Method "_×_" is
[
	f : improper fraction,
	n : whole number
 |
 	(f's numerator × n) / f's denominator
]:nonnegative mixed fraction;
 
Method "_×_" is
[
	f : improper fraction,
	f2 : improper fraction
 |
 	(f's numerator × f2's numerator) / (f's denominator × f2's denominator)
]:nonnegative mixed fraction;

Method "_×_" is
[
	n : whole number,
	f : improper fraction
 |
 	f × n
]:nonnegative mixed fraction;

Method "_×_" is
[
	f : nonnegative mixed fraction,
	n : whole number
 |
 	((f → improper fraction)'s numerator × n) / f's denominator
]:nonnegative mixed fraction;
 	
Method "_×_" is
[
	n : whole number,
	f : nonnegative mixed fraction
 |
 	f × n
]:nonnegative mixed fraction;

Method "_×_" is
[
	f : nonnegative mixed fraction,
	f2 : nonnegative mixed fraction
 |
 	(f → improper fraction) × (f2  → improper fraction)
]:nonnegative mixed fraction;

Method "_÷_" is
[
	w : whole number,
	f : nonnegative mixed fraction
 |
 	(invert f) × w
]:nonnegative mixed fraction;

Method "_÷_" is
[
	f : nonnegative mixed fraction,
	w : whole number
 |
 	f × invert (cast w into [n : natural number | n] → improper fraction)
]:nonnegative mixed fraction;

Method "_+_" is
[
	addend : fraction,
	addend2 : fraction
 |
 	commonDenominator ::= least common multiple of 
 		addend's denominator and addend2's denominator;

	totalNumerator ::= addend's numerator × 
		(commonDenominator ÷ addend's denominator) + 
		addend2's numerator × (commonDenominator ÷ addend2's denominator);
	
	totalNumerator / commonDenominator
	
]:nonnegative mixed fraction;
	
Method "_+_" is
[
	addend : nonnegative mixed fraction,
	addend2 : nonnegative mixed fraction
 |
 	addend → improper fraction + addend2 → improper fraction 
]:nonnegative mixed fraction;

Method "_-_" is
[
	minuend : fraction,
	subtrahend : fraction
 |
 	commonDenominator ::= least common multiple of 
 		minuend's denominator and subtrahend's denominator;

	totalNumerator ::= |minuend's numerator × 
		(commonDenominator ÷ minuend's denominator) - 
		subtrahend's numerator × 
		(commonDenominator ÷ subtrahend's denominator)|;
	
	totalNumerator / commonDenominator
	
]:nonnegative mixed fraction;
		
Method "_-_" is
[
	minuend : nonnegative mixed fraction,
	subtrahend : nonnegative mixed fraction
 |
 	minuend → improper fraction - subtrahend → improper fraction 
]:nonnegative mixed fraction;

Method "_-_" is
[
	minuend : natural number,
	subtrahend : nonnegative mixed fraction
 |
 	minuend → improper fraction - (subtrahend → improper fraction) 
]:nonnegative mixed fraction;

/* End Fractions */

/**
 * Consume and answer a pseudorandom value from the specified {@type "pRNG"
 * generator}.
 *
 * @method "_'s⁇next«value in»⁇_"
 * @param "rng" "pRNG"
 *        A pseudorandom number generator.
 * @param "range" "whole number's type"
 *        A subtype of the generator's {@method "_'s⁇element type" element
 *        type}. The result will lie within this range.
 * @returns "whole number"
 *          A pseudorandom value that is an instance of {@param "range"}.
 * @raises "incorrect-argument-type exception"
 *         If ⎡{@param "range"}⎤ is ∞.
 */
Public method "_'s⁇next«value in»⁇_" is
[
	rng : pRNG,
	range : integer's type
|
	If range = ⊥ ∨ [⎡range⎤ = ∞] then
	[
		Raise an incorrect-argument-type exception
	];

	/*TODO: [RAA] Write proof of equal probability distribution */

	/*The size of the random number range*/
	rngRangeSize : natural number := (|rng's element type|→natural number) + 1;
	
	/* The equal interval where border cases occur */
	baseInterval : nonnegative mixed fraction := 
			rngRangeSize / ((|range|→natural number) + 1);
		
	/* Determine the # of times a border case has been crossed; this indicates
	 * how far along the range's axis the value has progressed */
	result : nonnegative mixed fraction := 
			rng's current element ÷ baseInterval;
			
	/* Check the number of border cases crossed for rng's current element + 1.
	 * If the value of the whole number in the mixed fraction is not equal to 
	 * that of result's whole number and the value in the numerator is not equal 
	 * to 0, than a border has been crossed in the fractional range between
	 * rng's current element and rng's current element + 1 */
	incrementedResult :  nonnegative mixed fraction := 
		(rng's current element + 1) ÷ baseInterval;
					
	/* Shift the resulting value along the axis of the intended range */
	lowerLimit : integer := cast⎣range⎦ into [i : integer | i];
	
	/* The difference between the incremented result and the result */
	rolledDifferenceRange : nonnegative mixed fraction :=
		incrementedResult - result;
	

	
	/* Continue rolling until a non border condition is reached */
	While 
	[
		lowerLimit := lowerLimit + result's whole number part;
	 	
		rolledDifferenceRange's whole number part ≠ 0 
	 		∧ [ incrementedResult's numerator ≠ 0 ]
	]
	do
	[		
		/* The weighted probability of the lower limit of the subRange*/
		lowerLimitProbability : nonnegative mixed fraction :=
				result × baseInterval;
		
		/* The weighted probability of the lower limit of the subRange*/
		upperLimitProbability : nonnegative mixed fraction :=
				rolledDifferenceRange's fraction × baseInterval;
		
		/* The first border value in rngRangeSize */
		lowerLimitRange : nonnegative mixed fraction :=
			lowerLimitProbability × rngRangeSize;
		
		/* The last border value in rngRangeSize */
		upperLimitRange : nonnegative mixed fraction :=
				rngRangeSize - upperLimitProbability × rngRangeSize;
		
	 	/* Set the new base border interval */
		baseInterval := (upperLimitRange - lowerLimitRange) 
			÷ result's whole number part;
			
		/* Grab a new pseudo-random value */
		Advance rng;
		
		If rng's current element < lowerLimitRange's whole number part then
		[
		 	/* Result is the bottom of the reroll range.  The loop should end */
		 	result := 0 / 1;
			incrementedResult := 0 / 1;
		] 
		else if [rng's current element = lowerLimitRange's whole number part] 
		then
		[
		 	/* The first border condition is reached */
		 	result := lowerLimitRange;
			incrementedResult := (rng's current element + 1) ÷ baseInterval; 
		]
		else if [rng's current element < upperLimitRange's whole number part]
		then
		[
			/* Result is the bottom of the reroll range.  The loop should end */
			result := rolledDifferenceRange;
			incrementedResult := rolledDifferenceRange;
		] 
		else if [rng's current element = upperLimitRange's whole number part] 
		then
		[
		 	/* The last border condition is reached */
		 	result := upperLimitRange;
			incrementedResult := (rng's current element + 1) ÷ baseInterval;
		]
		else
		[
		 	/* Condition is equally distributed as was initial roll 
		 	 * need to adjust for unequal lower limit shift */
			result := lowerLimitRange + rng's current element ÷ baseInterval;
			incrementedResult := lowerLimitRange + 
				(rng's current element + 1) ÷ baseInterval;
		];
		
		rolledDifferenceRange := incrementedResult - result;
	];
	
/**DEBUG*Print: format "\nresult=“①”\n\n" with lowerLimit;*/
	lowerLimit
] : integer;

Semantic restriction "_'s⁇next«value in»⁇_" is
[
	rng : pRNG's type,
	range : integer's type's type
|
	range's instance
];

/**
 * Consume a pseudorandom value from the specified {@type "pRNG" generator} and
 * use it to select an instance of the specified {@param "enum" enumeration}.
 * 
 * @method "_'s⁇next«value in»⁇_"
 * @param "rng" "pRNG"
 *        A pseudorandom number generator.
 * @param "enum" "type"
 * @returns "any"
 *          A pseudorandomly selected instance of {@param "enum"}.
 */
Method "_'s⁇next«value in»⁇_" is
[
	rng : pRNG,
	enum : type
|
	Assert: |enum| is finite;
	result ::= enum's instances→tuple[rng's next [1..|enum|+1)];
	Advance rng;
	result
] : any;

Method "_'s⁇next«value in»⁇_" is
[
	rng : pRNG,
	enum : boolean's type
|
	result ::= rng's current element is odd;
	Advance rng;
	result
] : boolean;

Semantic restriction "_'s⁇next«value in»⁇_" is
[
	rng : pRNG's type,
	meta : type's type
|
	enum ::= meta's instance;
	if |enum| is finite then [enum] else [⊤]
];

/**
 * Consume a pseudorandom value from the specified {@type "pRNG" generator} and
 * use it to select an element of the specified tuple.
 * 
 * @method "_'s⁇next element of_"
 * @param "rng" "pRNG"
 *        A pseudorandom number generator.
 * @param "aTuple" "tuple"
 *        A non-empty tuple.
 * @returns "any"
 *          A pseudorandomly selected element of {@param "aTuple"}.
 */
Public method "_'s⁇next element of_" is
[
	rng : pRNG,
	aTuple : <any…|1..>
|
	result ::= aTuple[rng's next [1..|aTuple|+1)];
	Advance rng;
	result
] : any;

Semantic restriction "_'s⁇next element of_" is
[
	rng : pRNG's type,
	tupleType : <any…|1..>'s type
|
	∪ tupleType[1..⎣tupleType⎦ min (|tupleType's leading types| + 1)]
];

/**
 * Consume a pseudorandom value from the specified {@type "pRNG" generator} and
 * use it to select an element of the specified set.
 * 
 * @method "_'s⁇next element of_"
 * @param "rng" "pRNG"
 *        A pseudorandom number generator.
 * @param "aSet" "set"
 *        A non-empty set.
 * @returns "any"
 *          A pseudorandomly selected element of {@param "aSet"}.
 */
Method "_'s⁇next element of_" is
[
	rng : pRNG,
	aSet : {any|1..}
|
	aTuple ::= aSet→tuple;
	result ::= aTuple[rng's next [1..|aTuple|+1)];
	Advance rng;
	result
] : any;

Semantic restriction "_'s⁇next element of_" is
[
	rng : pRNG's type,
	setType : {any|1..}'s type
|
	setType's element type
];

/**
 * Consume a pseudorandom value from the specified {@type "pRNG" generator} and
 * use it to select a binding of the specified map.
 * 
 * @method "_'s⁇next binding of_"
 * @param "rng" "pRNG"
 *        A pseudorandom number generator.
 * @param "aMap" "map"
 *        A non-empty map.
 * @returns "any"
 *          A pseudorandomly selected element of {@param "aMap"}.
 */
Public method "_'s⁇next binding of_" is
[
	rng : pRNG,
	aMap : {any→any|1..}
|
	aTuple ::= aMap's bindings;
	result ::= aTuple[rng's next [1..|aTuple|+1)];
	Advance rng;
	result
] : <any…|2>;

Semantic restriction "_'s⁇next binding of_" is
[
	rng : pRNG's type,
	mapType : {any→any|1..}'s type
|
	<mapType's key type, mapType's value type…|2>
];

/**
 * Compute and answer a pseudorandom permutation of the specified tuple.
 *
 * @method "_'s⁇next shuffling of_"
 * @param "rng" "pRNG"
 *        A pseduorandom number generator.
 * @param "aTuple" "tuple"
 *        A tuple.
 * @returns "tuple"
 *          A permutation of {@param "aTuple"}.
 */
Public method "_'s⁇next shuffling of_" is
[
	rng : pRNG,
	aTuple : tuple
|
	result : tuple := aTuple;
	From |aTuple| to 2 by -1 do
	[
		index : [2..∞)
	|
		randomIndex ::= rng's next [1..index];
		result := eject result[index↔randomIndex];
	];
	result
] : tuple;

Semantic restriction "_'s⁇next shuffling of_" is
[
	rng : pRNG's type,
	tupleType : tuple's type
|
	<<>, ∪ tupleType[1..|tupleType's leading types| + 1]… | ||tupleType||>
];