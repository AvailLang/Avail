/*
 * Abstract Iterators.avail
 * Copyright © 1993-2014, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Abstract Iterators"
Versions
	"1.0.0 DEV 2014-04-28"
Extends
	"Common" = ("element type", "_'s⁇element type"),
	"Foundation" =
	(
		"For each of⁇_do_",
		"concatenate_",
		"filter_by_",
		"map_through_",
		"take from_until_",
		"take from_while_",
		"zip_",
		"«_‡zip»",
		"«_‡++»"
	)
Uses
	"Common" = ("Data|data abstractions test suite"),
	"Foundation",
	"Unit Testing" = ("New test suite,⁇_,⁇extends_")
Names
	"Advance_",
	"Drop from_until_",
	"Drop from_while_",
	"Drop«at most»?_from_",
	"Seal_'s⁇current element method",
	"Seal_'s⁇advance method",
	"an exhausted reader",
	"decorated reader|readers",
	"exhausted reader",
	"exhausted-iterator exception",
	"iterator",
	"iterators test suite",
	"reader",
	"reader of_",
	"take«at most»?_from_",
	"writer",
	"writer of_",
	"_is exhausted",
	"_is not exhausted",
	"_'s⁇advance method is_",
	"_'s⁇current element",
	"_'s⁇current element method is_"
Body

/* TODO: [TLS] Remove these constants once a macro is available for "$…". */
privateGetCurrentElementName ::= $"private_'s⁇current element";
privateSetCurrentElementName ::= $"private_'s⁇current element:=_";
privateAdvanceName ::= $"Private advance_";

Public "decorated reader|readers" is a new field atom;
"transformer" is a new field atom;
"filter" is a new field atom;
"reader index" is a new field atom;

/**
 * An iterator is a construct that can be advanced via {@method "Advance_"}
 * until the iterator {@method "_is exhausted"}. Subclasses like {@method
 * "reader"} and {@method "writer"} provide the necessary additional methods for
 * reading and writing data, respectively, at the current position.
 * @category "Data Abstractions"
 * @type "iterator"
 */
Public explicit class "iterator" extends object
	with fields
		element type : any's type;

/**
 * A reader is an {@iterator} through which reading may happen, via the method
 * {@method "_'s⁇current element"}.
 * @category "Data Abstractions"
 * @type "reader"
 * @supertype "iterator"
 */
Public explicit class "reader" extends iterator;

/**
 * A writer is an {@iterator} through which reading may happen, via the method
 * {@method "_'s⁇current element"}.
 * @category "Data Abstractions"
 * @type "writer"
 * @supertype "iterator"
 */
Public explicit class "writer" extends iterator;

/**
 * An exhausted-iterator exception is raised when an inappropriate operation,
 * like {@method "Advance_"}, is performed on an exhausted reader.
 *
 * @type "exhausted-iterator exception"
 * @supertype "exception"
 */
Public explicit class "exhausted-iterator exception" extends exception;

/**
 * Is the specified iterator exhausted?
 * @category "Data Abstractions"
 * @method "_is exhausted"
 * @param "anIterator" "iterator"
 *        An iterator.
 * @returns "boolean"
 *          {@code true} if the argument is exhausted, {@code false} otherwise.
 */
Abstract method "_is exhausted" is [iterator]→boolean;

Private abstract method privateAdvanceName is [iterator]→⊤;

/**
 * Ensure that the specified iterator is not exhausted, then advance its state.
 * @category "Data Abstractions"
 * @method "Advance_"
 * @param "anIterator" "iterator"
 *        An iterator.
 * @returns "⊤"
 * @raises "exhausted-iterator exception"
 *         If the iterator is exhausted.
 */
Method "Advance_" is
[
	anIterator : iterator
|
	Unless anIterator is exhausted then
	[
		Private advance anIterator;
	]
	else
	[
		Raise an exhausted-iterator exception
	];
] : ⊤;

/**
 * Define a method to advance the state of a non-exhausted iterator. The public
 * operation, {@method "Advance_"}, does not permit extension (to ensure that iterators
 * are always checked for exhaustion), but the private operation should not be
 * called directly from client code. This special defining method allows the
 * private operation to be overridden for specific iterator implementations
 * without exposing it for direct use. These mechanisms cooperate to ensure that
 * iterator exhaustion checking is never bypassed.
 * @category "Data Abstractions"
 * @method "_'s⁇advance method is_"
 * @param "iteratorType" "iterator's type"
 *        The iterator's type, as a cross check for the implementation.
 * @param "implementation" "[⊥]→⊤"
 *        The new method extension.
 * @returns "⊤"
 */
Public method "_'s⁇advance method is_" is
[
	iteratorType : iterator's type,
	implementation : [⊥]→⊤
|
	Private method privateAdvanceName is implementation;
] : ⊤;

Semantic restriction "_'s⁇advance method is_" is
[
	iteratorMeta : iterator's type's type,
	implementationType : [⊥]→⊤'s type
|
	If implementationType[1] = ⊥ then
	[
		Reject parse, expected:
			"function's parameter types to be statically known"
	];
	If ¬implementationType[1] ⊆ iteratorMeta's instance then
	[
		Reject parse, expected:
			"function parameter type ("
			++ “implementationType[1]”
			++ ") to be a subtype of the iterator type ("
			++ “iteratorMeta's instance”
			++ ")"
	];
	⊤
];

/**
 * Seal the advance method at the specified {@type "iterator"} type.
 * @category "Data Abstractions"
 * @method "Seal_'s⁇advance method"
 * @param "iteratorType" "iterator's type"
 * @returns "⊤"
 */
Public method "Seal_'s⁇advance method" is
[
	iteratorType : iterator's type
|
	Seal method privateAdvanceName at <iteratorType>;
] : ⊤;

/**
 * Construct and answer a {@type "reader"} type that produces values of the
 * specified type.
 * @category "Data Abstractions"
 * @method "reader of_"
 * @param "elementType" "any's type"
 *        The type of value produced by readers having the answered type.
 * @returns "reader's type"
 *          The requested reader type.
 */
Public method "reader of_" is
[
	elementType : any's type
|
	extend reader with element type : elementType's type
] : reader's type;

/**
 * Construct and answer a writer type that accepts values of the specified type.
 * @category "Data Abstractions"
 * @method "writer of_"
 * @param "elementType" "any's type"
 *        The type of value consumed by writers having the answered type.
 * @returns "writer's type"
 *          The requested writer type.
 */
Public method "writer of_" is
[
	elementType : any's type
|
	extend writer with element type : elementType's type
] : writer's type;

Private abstract method privateGetCurrentElementName is [reader]→any;

Private abstract method privateSetCurrentElementName is [writer, any]→⊥;

/**
 * Ensure that the specified reader is not exhausted, then answer its current
 * element.
 * @category "Data Abstractions"
 * @method "_'s⁇current element"
 * @param "aReader" "reader"
 *        A reader.
 * @returns "any"
 *          The current element of the specified reader.
 * @raises "exhausted-iterator exception"
 *         If the reader (iterator) is exhausted.
 */
Method "_'s⁇current element" is
[
	aReader : reader
|
	unless aReader is exhausted then
	[
		private aReader's current element
	]
	else
	[
		Raise an exhausted-iterator exception
	]
] : any;

Semantic restriction "_'s⁇current element" is
[
	readerType : reader's type
|
	readerType's element type's instance
];

/**
 * Define a method to provide the current element of a non-exhausted reader.
 * The public operation, {@"_'s⁇current element"}, does not permit extension (to
 * ensure that readers are always checked for exhaustion), but the private
 * operation should not be called directly from client code. This special
 * defining method allows the private operation to be overridden for specific
 * reader implementations without exposing it for direct use. These mechanisms
 * cooperate to ensure that reader exhaustion checking is never bypassed.
 * @category "Data Abstractions"
 * @method "_'s⁇current element method is_"
 * @param "readerType" "reader's type"
 *        The reader's type, as a cross check for the implementation.
 * @param "implementation" "[⊥]→any"
 *        The new method extension.
 * @returns "⊤"
 */
Public method "_'s⁇current element method is_" is
[
	readerType : reader's type,
	implementation : [⊥]→any
|
	Private method privateGetCurrentElementName is implementation;
] : ⊤;

Semantic restriction "_'s⁇current element method is_" is
[
	readerMeta : reader's type's type,
	implementationType : [⊥]→any's type
|
	If implementationType[1] = ⊥ then
	[
		Reject parse, expected:
			"function's parameter types to be statically known"
	];
	If ¬implementationType[1] ⊆ readerMeta's instance then
	[
		Reject parse, expected:
			"function parameter type ("
			++ “implementationType[1]”
			++ ") to be a subtype of the reader type ("
			++ “readerMeta's instance”
			++ ")"
	];
	⊤
];

/**
 * Seal the current element method at the specified {@type "reader"} type.
 * @category "Data Abstractions"
 * @method "Seal_'s⁇current element method"
 * @param "readerType" "reader's type"
 * @returns "⊤"
 */
Public method "Seal_'s⁇current element method" is
[
	readerType : reader's type
|
	Seal method privateGetCurrentElementName at <readerType>;
] : ⊤;

/**
 * An exhausted reader has ⊥ as its element type.
 *
 * @type "exhausted reader"
 * @supertype "iterator"
 */
Public explicit class "exhausted reader" extends reader
	with fields
		element type : ⊥'s type;

/**
 * Answer {@code true}.
 * @category "Data Abstractions"
 * @method "_is exhausted"
 * @param "anIterator" "exhausted reader"
 *        An {@type "exhausted reader"}.
 * @returns "true's type"
 *          {@code true}.
 */
Method "_is exhausted" is
[
	anIterator : exhausted reader
|
	true
] : true's type;

/**
 * Raise an {@type "exhausted-iterator exception"}.
 * @category "Data Abstractions"
 * @method "_s⁇current element"
 * @param "anIterator" "exhausted reader"
 *        An exhausted reader.
 * @returns "⊥"
 * @raises "exhausted-iterator exception"
 *         Always.
 */
Method "_s⁇current element" is
[
	anIterator : exhausted reader
|
	Raise an exhausted-iterator exception
] : ⊥;

Semantic restriction "_s⁇current element" is
[
	iteratorType : exhausted reader's type
|
	Reject parse, expected:
		"an exhausted reader not to be asked for its current element"
];

/**
 * Raise an `exhausted-iterator exception`.
 * @category "Data Abstractions"
 * @method "Advance_"
 * @param "anIterator" "exhausted reader"
 *        An exhausted reader.
 * @returns "⊥"
 * @raises "exhausted-iterator exception"
 *         Always.
 */
Method "Advance_" is
[
	anIterator : exhausted reader
|
	Raise an exhausted-iterator exception
] : ⊥;

Semantic restriction "Advance_" is
[
	iteratorType : exhausted reader's type
|
	Reject parse, expected:
		"an exhausted reader not to be asked to advance"
];

theExhaustedIterator ::= an exhausted reader with element type ::= ⊥;

/**
 * Answer an {@type "exhausted reader"}.
 * @category "Data Abstractions"
 * @method "an exhausted reader"
 * @returns "exhausted reader"
 *          An exhausted reader.
 */
Public method "an exhausted reader" is [ theExhaustedIterator ];
Grammatical restriction "a|an_«with«_:=_‡,»»"
	is <{"exhausted reader"}, ∅, ∅>;

/* Seal the public operations. */
Seal method "_is exhausted" at <exhausted reader>;
Seal method "_'s⁇current element" at <iterator>;
Seal method "Advance_" at <iterator>;

/**
 * Iteratively apply {@param "action"} to each consecutive element of {@param
 * "anIterator"}.
 * @category "Data Abstractions"
 * @method "For each of⁇_do_"
 * @param "anIterator" "iterator"
 *        An iterator.
 * @param "action" "[⊥]→⊤"
 *        A function that accepts the elements of the iterator.
 * @returns "⊤"
 */
Method "For each of⁇_do_" is
[
	aReader : reader,
	action : [⊥]→⊤
|
	Until [ aReader is exhausted ]
	do
	[
		action(aReader's current element);
		Advance aReader;
	];
] : ⊤;

/**
 * Helper method for semantic restrictions: If `action` does not accept the
 * element type of `readerType`, then reject the current parse.
 * @category "Data Abstractions"
 * @method "Require:_accepts_"
 * @param "action" "[⊥]→⊤'s type"
 *        A function type whose sole parameter must correspond to the element
 *        type of `readerType`.
 * @param "readerType" "reader's type"
 *        An reader type.
 * @returns "⊤"
 */
Method "Require:_accepts_" is
[
	actionType : [⊥]→⊤'s type,
	readerType : reader's type
|
	elementType ::= readerType's element type's instance;
	If actionType[1] ≠ ⊥ ∧ [ ¬elementType ⊆ actionType[1] ] then
	[
		Reject parse, expected:
			format
				"repeatedly applied function to accept all elements ∈ “①” \
				\|of the reader (but it only accepts “②”)"
			with elementType, actionType[1]
	];
] : ⊤;

Semantic restriction "For each of⁇_do_" is
[
	readerType : reader's type,
	actionType : [⊥]→⊤'s type
|
	Require: actionType accepts readerType;
	⊤
];

/**
 * {@method "map_through_"} produces mapped readers. A mapped reader
 * decorates another reader and retains a transformer function. When it is
 * asked for its current element, it answers the result of applying the function
 * to the current element of the decorated reader.
 * 
 * @category "Data Abstractions"
 * @type "mapped reader"
 * @supertype "reader"
 */
Class "mapped reader" extends reader
	with fields
		decorated reader : reader,
		transformer : [⊥]→any;

Method "_is exhausted" is
[
	aReader : mapped reader
|
	aReader's decorated reader is exhausted
] : boolean;

mapped reader's current element method is
[
	aReader : mapped reader
|
	invoke aReader's transformer
		with <aReader's decorated reader's current element>
] : any;

mapped reader's advance method is
[
	aReader : mapped reader
|
	Advance aReader's decorated reader;
] : ⊤;

/**
 * Construct and answer an reader that applies {@param "theTransformer"} to
 * the consecutive elements of {@param "aReader"}. The result is lazy, so
 * {@param "aReader"} may be infinite.
 * @category "Data Abstractions"
 * @method "map_through_"
 * @param "aReader" "reader"
 *        The source {@type "reader"}.
 * @param "theTransformer" "[⊥]→any"
 *        A function that accepts the elements of {@param "aReader"}.
 * @returns "reader"
 *          An reader that applies {@param "theTransformer"} to the current
 *          element of {@param "aReader"} when asked for its own current
 *          element.
 */
Method "map_through_" is
[
	aReader : reader,
	theTransformer : [⊥]→any
|
	a mapped reader with
		element type ::= theTransformer's type's return type,
		decorated reader ::= aReader,
		transformer ::= theTransformer
] : reader;

Semantic restriction "map_through_" is
[
	readerType : reader's type,
	transformerType : [⊥]→any's type
|
	Require: transformerType accepts readerType;
	extend reader with element type : transformerType's return type's type
];

/**
 * {@method "filter_by_"} produces filtered readers. A filtered reader
 * decorates another reader and retains a filter function. When asked for its
 * current element, it answers the first element of the decorated reader that
 * satisfies the filter function.
 *
 * @category "Data Abstractions"
 * @type "filtered reader"
 * @supertype "reader"
 */
Class "filtered reader" extends reader
	with fields
		decorated reader : reader,
		filter : [⊥]→boolean;

Method "_is exhausted" is
[
	aReader : filtered reader
|
	found : boolean := false;
	inner ::= aReader's decorated reader;
	Until [found ∨ [inner is exhausted]]
	do
	[
		If aReader's filter(inner's current element) then
		[
			found := true;
		]
		else
		[
			Advance inner;
		];
	];
	¬found
] : boolean;

filtered reader's current element method is
[
	aReader : filtered reader
|
	/* The current element of the decorated reader must satisfy the filter.
	 * This is ensured by "_is exhausted".
	 */
	aReader's decorated reader's current element
] : any;

filtered reader's advance method is
[
	aReader : filtered reader
|
	/* Unconditionally advance the decorated reader. "_is exhausted" will
	 * determine if there is actually another element that passes the filter.
	 */
	Advance aReader's decorated reader;
] : ⊤;

/**
 * Construct and answer an reader that applies {@param "predicate"} to
 * {@param "aReader"}. The result is lazy, so {@param "aReader"} may be
 * infinite. The result contains only those elements of {@param "aReader"}
 * that pass the specified filter.
 *
 * Note that {@method "_is exhausted"} may require an infinite amount of time to
 * complete when presented with an infinite filtered reader, e.g., consider
 * the case of:
 *
 * <pre>
 *     filter reader from 1 to ∞ by [ x : natural number | x < 10 ]
 * </pre>
 *
 * Which will require infinite computation after advancing beyond the element
 * {@code 10}.
 * @category "Data Abstractions"
 * @method "filter_by_"
 * @param "aReader" "reader"
 *        An {@type "reader"}.
 * @param "predicate" "[⊥]→boolean"
 *        A function that accepts the elements of {@param "aReader"} and
 *        answers {@code true} iff they should be obtainable via the result
 *        reader.
 * @returns "reader"
 *          An reader capable of producing exactly those elements of {@param
 *          "aReader"} for which {@param "predicate"} answers {@code true}.
 */
Method "filter_by_" is
[
	aReader : reader,
	predicate : [⊥]→boolean
|
	a filtered reader with
		element type ::= aReader's element type,
		decorated reader ::= aReader,
		filter ::= predicate
] : reader;

Semantic restriction "filter_by_" is
[
	readerType : reader's type,
	predicateType : [⊥]→boolean's type
|
	Require: predicateType accepts readerType;
	extend reader with element type : readerType's element type
];

/**
 * A concatenation reader produces values from a sequenced collection of
 * readers.
 *
 * @category "Data Abstractions"
 * @type "concatenation reader"
 * @supertype "reader"
 */
Class "concatenation reader" extends reader
	with field
		decorated readers : <reader…|>
	with mutable field
		referable reader index : natural number;

Method "_is exhausted" is
[
	aReader : concatenation reader
|
	index : ↑natural number := ↑aReader's reader index;
	readers ::= aReader's decorated readers;
	limit ::= |readers|;
	While [↓index ≤ limit ∧ [readers[↓index] is exhausted]]
	do
	[
		index++;
	];
	↓index > limit
] : boolean;

concatenation reader's current element method is
[
	aReader : concatenation reader
|
	inner ::= aReader's decorated readers[aReader's reader index];
	inner's current element
] : any;

concatenation reader's advance method is
[
	aReader : concatenation reader
|
	index ::= aReader's reader index;
	readers ::= aReader's decorated readers;
	Advance readers[index];
] : ⊤;

/**
 * Construct and answer an {@type "reader"} that produces values from the
 * specified tuple of readers The result first produces the values of the
 * first element of the tuple, then the second, etc.
 * @category "Data Abstractions"
 * @method "concatenate_"
 * @param "readers" "<reader…|>"
 *        A tuple of readers.
 * @returns "reader"
 *          The requested reader.
 */
Method "concatenate_" is
[
	readers : <reader…|>
|
	if |readers| = 0 then [an exhausted reader]
	else if [|readers| = 1] then [readers[1]]
	else
	[
		elementType ::=
			cast ∪ map readers through [i : reader | i's element type]
			into [t : any's type | t];
		a concatenation reader with
			element type ::= elementType,
			decorated readers ::= readers,
			reader index := 1
	]
] : reader;

/**
 * Construct and answer an {@type "reader"} that produces values from the
 * specified tuple of readers The result first produces the values of the
 * first lexical argument, then the second, etc.
 * @category "Data Abstractions"
 * @method "«_‡++»"
 * @param "readers" "<reader…|>"
 *        A tuple of readers.
 * @returns "reader"
 *          The requested reader.
 */
Method "«_‡++»" is
[
	readers : <reader…|2..>
|
	elementType ::=
		cast ∪ map readers through [i : reader | i's element type]
		into [t : any's type | t];
	a concatenation reader with
		element type ::= elementType,
		decorated readers ::= readers,
		reader index := 1
];

/**
 * Answer a function suitable for use as a semantic restriction for the
 * {@method "concatenate_"} and {@method "«_‡++»"} methods.
 * @category "Data Abstractions"
 * @method "concatenation semantic restriction"
 * @returns "[<reader…|>'s type]→(concatenation reader's type)"
 *          The requested function.
 */
Private method "concatenation semantic restriction" is
[
	[
		readers : <reader…|>'s type
	|
		elementType : any's type's type := ⊥;
		From 1 to (⎣readers⎦ min (|readers' leading types| + 1)) do
		[
			index : natural number
		|
			elementType := eject elementType ∪ readers[index]'s element type;
		];
		extend concatenation reader with
			element type : elementType,
			decorated readers : readers
	]
];

Semantic restriction "concatenate_" is concatenation semantic restriction;
Semantic restriction "«_‡++»" is concatenation semantic restriction;

/**
 * A zipped reader produces zipped tuples from a sequenced collection of
 * readers.
 *
 * @category "Data Abstractions"
 * @type "zipped reader"
 * @supertype "reader"
 */
Explicit class "zipped reader" extends reader
	with fields
		element type : tuple's type,
		decorated readers : <reader…|>;

Method "_is exhausted" is
[
	aReader : zipped reader
|
	any of aReader's decorated readers
		satisfies [i : reader | i is exhausted]
] : boolean;

zipped reader's current element method is
[
	aReader : zipped reader
|
	map aReader's decorated readers
		through [i : reader | i's current element]
] : any;

zipped reader's advance method is
[
	aReader : zipped reader
|
	For each aReader's decorated readers do [i : reader | Advance i;];
] : ⊤;

/**
 * Construct and answer the zip of the specified {@type "reader"}s. Given
 * <em>n</em> input readers, the output is the reader whose <em>i</em>-th
 * element is an <em>n</em>-tuple containing the <em>i</em>-th element from each
 * consecutive input reader. The answer is exhausted when any of the input
 * readers becomes exhausted.
 * @category "Data Abstractions"
 * @method "zip_"
 * @param "readers" "<reader…|>"
 *        A tuple of readers.
 * @returns "reader"
 *          The requested reader.
 */
Method "zip_" is
[
	readers : <reader…|1..>
|
	types ::= map readers through [i : reader | i's element type];
	elementType ::=
		<types[1..|types| - 1], types[|types|]… | |readers|'s type>;
	a zipped reader with
		element type ::= elementType,
		decorated readers ::= readers
] : reader;

/**
 * Construct and answer the zip of the specified {@type "reader"}s. Given
 * <em>n</em> input readers, the output is the reader whose <em>i</em>-th
 * element is an <em>n</em>-tuple containing the <em>i</em>-th element from each
 * consecutive input reader. The answer is exhausted when any of the input
 * readers becomes exhausted.
 * @category "Data Abstractions"
 * @method "«_‡zip»"
 * @param "readers" "<reader…|>"
 *        A tuple of readers.
 * @returns "reader"
 *          The requested reader.
 */
Method "«_‡zip»" is
[
	readers : <reader…|2..>
|
	types ::= map readers through [i : reader | i's element type];
	elementType ::=
		<types[1..|types| - 1], types[|types|]… | |readers|'s type>;
	a zipped reader with
		element type ::= elementType,
		decorated readers ::= readers
] : reader;

/**
 * Answer a function suitable for use as a semantic restriction for the
 * {@method "zip_"} and {@method "«_‡zip»"} methods.
 * @category "Data Abstractions"
 * @method "zip semantic restriction"
 * @returns "[<reader…|>'s type]→(zipped reader's type)"
 *          The requested function.
 */
Private method "zip semantic restriction" is
[
	[
		readers : <reader…|1..>'s type
	|
		types : <any's type…|> := <>;
		From 1 to (⎣readers⎦ min (|readers' leading types| + 1)) do
		[
			index : natural number
		|
			types := eject types
				++ <readers[index]'s element type's instance>;
		];
		nonempty ::= cast types into [t : <any's type…|1..> | t];
		elementType ::=
			<nonempty[1..|nonempty| - 1], nonempty[|nonempty|]…
				| ||readers||>;
		extend zipped reader with
			element type : elementType's type,
			decorated readers : readers
	]
];

Semantic restriction "zip_" is zip semantic restriction;
Semantic restriction "«_‡zip»" is zip semantic restriction;

/**
 * Answer a tuple containing (at most) the first {@param "count"} elements of
 * {@param "aReader"}.
 * @category "Data Abstractions"
 * @method "take«at most»?_from_"
 * @param "isLax" "boolean"
 *        {@code false} if an {@type "exhausted-iterator exception"} should be
 *        raised if {@param "count"} exceeds the number of elements remaining,
 *        {@code true} otherwise.
 * @param "count" "[0..∞]"
 *        The size of the requested tuple.
 * @param "aReader" "reader"
 *        An reader.
 * @returns "tuple"
 *          A tuple containing the first {@param "count"} elements of {@param
 *          "aReader"}, preserving the original order.
 * @raises "exhausted-iterator exception"
 *         If {@param "isLax"} is {@code false} and {@param "aReader"} does
 *         not contain {@param "count"} elements.
 */
Method "take«at most»?_from_" is
[
	isLax : boolean,
	count : [0..∞],
	aReader : reader
|
	result : tuple := <>;
	Guard
	[
		Repeat
		[
			next ::= aReader's current element;
			result := eject result ++ <next>;
			Advance aReader;
		] count times;
	]
	intercept
	[
		e : exhausted-iterator exception
	|
		Unless isLax then [Raise e];
	];
	result
] : tuple;

Semantic restriction "take«at most»?_from_" is
[
	laxity : boolean's type,
	count : [0..∞]'s type,
	readerType : reader's type
|
	min ::= if laxity = true's type then [0] else [⎣count⎦];
	<<>, readerType's element type's instance…|[min..⎡count⎤+1)>
];

/**
 * Checks to see if the reader of character is not exhausted.
 * 
 * @category "Data Abstractions"
 * @method "_is not exhausted"
 * @param "aReader" "reader"
 * @returns "boolean"
 * @author "Richard Arriaga"
 */
Public method "_is not exhausted" is
[
 	aReader : reader
|
 	¬aReader is exhausted
]:boolean;

/**
 * Answer a tuple containing the prefix of {@param "aReader"} that answered
 * {@method "true"} to {@param "predicate"}.
 * @category "Data Abstractions"
 * @method "take from_while_"
 * @param "aReader" "reader"
 *        An reader.
 * @param "predicate" "[⊥]→boolean"
 *        A function that can accept each element of the specified reader. It
 *        should answer {@code true} to keep the element (and continue scanning)
 *        or {@code false} to abort.
 * @returns "tuple"
 *          A tuple containing the prefix of {@param "aReader"} that
 *          satisfied {@param "predicate"}.
 */
Method "take from_while_" is
[
	aReader : reader,
	predicate : [⊥]→boolean
|
	result : tuple := <>;
	While
	[
		aReader is not exhausted ∧ [predicate(aReader's current element)]
	]
	do
	[
		result := eject result ++ <aReader's current element>;
		Advance aReader;
	];
	result
] : tuple;

Semantic restriction "take from_while_" is
[
	readerType : reader's type,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts readerType;
	<readerType's element type's instance…|>
];

/**
 * Answer a tuple containing the prefix of {@param "aReader"} that answered
 * {@method "false"} to {@param "predicate"}.
 * @category "Data Abstractions"
 * @method "take from_until_"
 * @param "aReader" "reader"
 *        An reader.
 * @param "predicate" "[⊥]→boolean"
 *        A function that can accept each element of the specified reader. It
 *        should answer {@code false} to keep the element (and continue
 *        scanning) or {@code true} to abort.
 * @returns "tuple"
 *          A tuple containing the prefix of {@param "aReader"} that
 *          satisfied {@param "predicate"}.
 */
Method "take from_until_" is
[
	aReader : reader,
	predicate : [⊥]→boolean
|
	result : tuple := <>;
	Until
	[
		aReader is exhausted ∨ [predicate(aReader's current element)]
	]
	do
	[
		result := eject result ++ <aReader's current element>;
		Advance aReader;
	];
	result
] : tuple;

Semantic restriction "take from_until_" is
[
	readerType : reader's type,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts readerType;
	<readerType's element type's instance…|>
];

/**
 * Forward the specified {@type "reader"} past (at most) the first {@param
 * "count"} elements.
 * @category "Data Abstractions"
 * @method "Drop«at most»?_from_"
 * @param "isLax" "boolean"
 *        {@code false} if an {@type "exhausted-iterator exception"} should be
 *        raised if {@param "count"} exceeds the number of elements remaining,
 *        {@code true} otherwise.
 * @param "count" "whole number"
 *        The size of the prefix of {@param "aReader"} that should be omitted
 *        from the result reader.
 * @param "aReader" "reader"
 *        An reader.
 * @returns "⊤"
 * @raises "exhausted-iterator exception"
 *         If {@param "isLax"} is {@code false} and {@param "aReader"} does
 *         not contain {@param "count"} elements.
 */
Method "Drop«at most»?_from_" is
[
	isLax : boolean,
	count : whole number,
	aReader : reader
|
	Guard
	[
		Repeat [Advance aReader;] count times;
	]
	intercept
	[
		e : exhausted-iterator exception
	|
		Unless isLax then [Raise e];
	];
] : ⊤;

/**
 * Forward the specified {@type "reader"} past the prefix of elements that
 * answer {@code true} to {@param "predicate"}.
 * @category "Data Abstractions"
 * @method "Drop from_while_"
 * @param "aReader" "reader"
 *        An reader.
 * @param "predicate" "[⊥]→boolean"
 *        A function that can accept each element of the specified reader. It
 *        should answer {@code true} to discard the element (and continue
 *        scanning) or {@code false} to abort.
 * @returns "⊤"
 */
Method "Drop from_while_" is
[
	aReader : reader,
	predicate : [⊥]→boolean
|
	While
	[
		aReader is not exhausted ∧ [predicate(aReader's current element)]
	]
	do
	[
		Advance aReader;
	];
] : ⊤;

Semantic restriction "Drop from_while_" is
[
	readerType : reader's type,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts readerType;
	⊤
];

/**
 * Forward the specified {@type "reader"} past the prefix of elements that
 * answer {@code false} to {@param "predicate"}.
 * @category "Data Abstractions"
 * @method "Drop from_while_"
 * @param "aReader" "reader"
 *        An reader.
 * @param "predicate" "[⊥]→boolean"
 *        A function that can accept each element of the specified reader. It
 *        should answer {@code false} to discard the element (and continue
 *        scanning) or {@code true} to abort.
 * @returns "⊤"
 */
Method "Drop from_until_" is
[
	aReader : reader,
	predicate : [⊥]→boolean
|
	Until
	[
		aReader is exhausted ∨ [predicate(aReader's current element)]
	]
	do
	[
		Advance aReader;
	];
] : ⊤;

Semantic restriction "Drop from_until_" is
[
	readerType : reader's type,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts readerType;
	⊤
];

Public "iterators test suite" is a new field atom;
New test suite iterators test suite extends data abstractions test suite;
