/*
 * Buffered Iterators.avail
 * Copyright © 1993-2014, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Buffered Iterators"
Versions
	"1.0.0 DEV 2014-04-28"
Uses
	"Abstract Iterators",
	"Common" = ("element type"),
	"Generators" = ("generator for_"),
	"Foundation",
	"Unit Testing"
Names
	/* Types. */
	"buffered iterator",
	"buffered reader",
	"buffered writer",

	/* Accessors. */
	"_'s⁇buffer",
	"_'s⁇maximum buffer size",
	"_'s⁇position in buffer",
	"`↑_'s⁇position in buffer",

	/* Extension. */
	"Seal_'s⁇exit buffer method",
	"Seal_'s⁇fetch current buffer method",
	"_'s⁇exit buffer method is_",
	"_'s⁇fetch current buffer method is_",

	/* Fields. */
	"maximum buffer size",

	/* Test suites. */
	"buffered iterator test suite"
Body

/* TODO: [TLS] Remove these constants once a macro is available for "$…". */
privateExitBufferName ::= $"Private exit_'s⁇current buffer";
privateFetchCurrentBufferName ::= $"private_'s⁇fetch current buffer";

"buffer" is a new field atom;
"position in buffer" is a new field atom;
"maximum buffer size" is a new field atom;

/**
 * Buffered iterator is an abstraction that maintains a buffer and a current
 * position within it, independently of being able to do anything <em>with</em>
 * the buffer, such as reading or writing elements.
 * 
 * Note that the {@code "position in buffer"} can be any {@type "integer"},
 * since we don't exit the buffer upon advancing (or generally positioning in
 * some subclasses), only upon subsequently attempting to read, write, or test
 * for exhaustion.
 * 
 * @type "buffered iterator"
 * @supertype "iterator"
 */
Public explicit class "buffered iterator" extends iterator
	with immutable fields
		maximum buffer size : [0..∞]
	with mutable fields
		referable buffer : tuple,
		referable position in buffer : integer;

/**
 * A buffered reader provides everything needed to be a {@type "reader"}, but it
 * uses the buffer and the position in the buffer to supply elements until the
 * buffer is exhausted, at which time a new buffer is fetched.
 *
 * @type "buffered reader"
 * @supertype "buffered iterator"
 * @supertype "reader"
 */
Public class "buffered reader"
	extends buffered iterator ∩ reader;

/**
 * A random access buffered writer supports writing to the buffer, including
 * extending it.  A facility will be (TODO[MvG]-buffered writer) provided to
 * flush the buffer to somewhere explicitly, and various subtypes may choose to
 * flush the buffer for other reasons, such as reaching a maximum buffer size.
 *
 * @type "buffered writer"
 * @supertype "buffered iterator"
 * @supertype "writer"
 */
Public class "buffered writer"
	extends buffered iterator ∩ writer;


Private abstract method privateExitBufferName is
	[buffered iterator]→⊤;

Private abstract method privateFetchCurrentBufferName is
	[buffered reader]→tuple;

/**
 * Define a method to deal with exiting the current buffer for a {@type
 * "buffered iterator"}.  This is a private operation that should not be called
 * directly from client code, but which must be overridden for specific {@type
 * "buffered iterator"} subtypes.  Exiting a buffer happens when an attempt is
 * made to read or write the current element when the iterator is positioned
 * somewhere other than directly at an element of the buffer.
 *
 * @method "_'s⁇exit buffer method is_"
 * @param "iteratorType" "random access buffered iterator's type"
 *        The iterator's type, as a cross check for the implementation.
 * @param "implementation" "[⊥]→⊤"
 *        The new method extension. The argument is the iterator.
 * @returns "⊤"
 */
Public method "_'s⁇exit buffer method is_" is
[
	iteratorType : buffered iterator's type,
	implementation : [⊥]→⊤
|
	Private method privateExitBufferName is implementation;
] : ⊤;

Semantic restriction "_'s⁇exit buffer method is_" is
[
	iteratorMeta : buffered iterator's type's type,
	implementationType : [⊥]→⊤'s type
|
	If implementationType[1] = ⊥ then
	[
		Reject parse, expected:
			"function's parameter types to be statically known"
	];
	If ¬implementationType[1] ⊆ iteratorMeta's instance then
	[
		Reject parse, expected:
			"function parameter type ("
			++ “implementationType[1]”
			++ ") to be a subtype of the iterator type ("
			++ “iteratorMeta's instance”
			++ ")"
	];
	⊤
];

/**
 * Seal the {@method "_'s⁇exit buffer method is_" exit buffer method} at the
 * specified {@type "random access buffered iterator"} type.
 *
 * @method "Seal_'s⁇exit buffer method"
 * @param "iteratorType" "buffered iterator's type"
 * @returns "⊤"
 */
Public method "Seal_'s⁇exit buffer method" is
[
	iteratorType : buffered iterator's type
|
	Seal method privateExitBufferName at <iteratorType>;
] : ⊤;



/**
 * Define a method to fetch the next buffer for a {@type "buffered reader"}.
 * This is a private operation that should not be called directly from client
 * code, but which must be overridden for specific {@type "buffered reader"}
 * subtypes.
 *
 * @method "_'s⁇fetch current buffer method is_"
 * @param "readerType" "buffered reader's type"
 *        The reader's type, as a cross check for the implementation.
 * @param "implementation" "[⊥]→tuple"
 *        The new method extension. The argument is the reader.
 * @returns "⊤"
 */
Public method "_'s⁇fetch current buffer method is_" is
[
	readerType : buffered reader's type,
	implementation : [⊥]→tuple
|
	Private method privateFetchCurrentBufferName is implementation;
] : ⊤;

Semantic restriction "_'s⁇fetch current buffer method is_" is
[
	readerMeta : buffered reader's type's type,
	implementationType : [⊥]→tuple's type
|
	If implementationType[1] = ⊥ then
	[
		Reject parse, expected:
			"function's parameter types to be statically known"
	];
	If ¬implementationType[1] ⊆ readerMeta's instance then
	[
		Reject parse, expected:
			"function parameter type ("
			++ “implementationType[1]”
			++ ") to be a subtype of the reader type ("
			++ “readerMeta's instance”
			++ ")"
	];
	⊤
];

/**
 * Seal the {@method "_'s⁇fetch current buffer method is_" fetch current buffer
 * method} at the specified {@type "buffered reader"} type.
 *
 * @method "Seal_'s⁇fetch current buffer method"
 * @param "readerType" "buffered reader's type"
 * @returns "⊤"
 */
Public method "Seal_'s⁇fetch current buffer method" is
[
	readerType : buffered reader's type
|
	Seal method privateFetchCurrentBufferName at <readerType>;
] : ⊤;


Method "_is exhausted" is
[
	aReader : buffered reader
|
	/* This completes initialization of the reader. */
	(↑aReader's buffer is unassigned
			∨ [
				¬ 1 ≤ aReader's position in buffer ≤ |aReader's buffer|])
		∧ [
			Private exit aReader's current buffer;
			aReader's position in buffer := 1;
			newBuffer ::= private aReader's fetch current buffer;
			aReader's buffer := newBuffer;
			¬ 1 ≤ aReader's position in buffer ≤ |newBuffer|
		]
] : boolean;

buffered reader's current element method is
[
	aReader : buffered reader
|
	/* We must have just ensured the current buffer position is within the
	 * buffer, so it must be a natural number.
	 */
	index : natural number;
	index ?= aReader's position in buffer;
	aReader's buffer[index]
] : any;

Seal buffered reader's current element method;


buffered iterator's advance method is
[
	anIterator : buffered iterator
|
	↑anIterator's position in buffer++;
] : ⊤;


/**
 * Answer a tuple containing (at most) the first {@param "count"} elements of
 * {@param "aReader"}.  Take advantage of the buffering for performance.
 * 
 * @category "Data Abstractions"
 * @method "take«at most»?_from_"
 * @param "isLax" "boolean"
 *        {@code false} if an {@type "exhausted-iterator exception"} should be
 *        raised if {@param "count"} exceeds the number of elements remaining,
 *        {@code true} otherwise.
 * @param "count" "[0..∞]"
 *        The size of the requested tuple.
 * @param "aReader" "buffered reader"
 *        A reader.
 * @returns "tuple"
 *          A tuple containing the first {@param "count"} elements of {@param
 *          "aReader"}, possibly less if {@param isLax} is {@code true}.
 * @raises "exhausted-iterator exception"
 *         If {@param "isLax"} is {@code false} and {@param "aReader"} does
 *         not contain {@param "count"} elements.
 */
Method "take«at most»?_from_" is
[
	isLax : boolean,
	count : [0..∞],
	aReader : buffered reader
|
	result : tuple := <>;
	Guard
	[
		Until
		[
			aReader is exhausted ∨ [ |result| = count ]
		]
		do
		[
			/* The "_is exhausted" above set up the buffer if necessary, and
			 * ensured (because it answered false for us to get here) that the
			 * buffer contains at least one element of interest to us.
			 */
			buffer ::= aReader's buffer;
			startInBuffer : natural number;
			startInBuffer ?= aReader's position in buffer;
			endInBuffer : natural number;
			endInBuffer ?=
				(startInBuffer + count - 1 - |result|) min |buffer|;
			batchSize : natural number;
			batchSize ?= endInBuffer - startInBuffer + 1;
			result := eject result ++ buffer[startInBuffer..endInBuffer];
			aReader's position in buffer :=
				aReader's position in buffer + batchSize;
		];
	]
	intercept
	[
		e : exhausted-iterator exception
	|
		Unless isLax then [Raise e];
	];
	result
] : tuple;
