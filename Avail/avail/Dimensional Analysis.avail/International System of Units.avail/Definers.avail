/*
 * Definers.avail
 * Copyright © 1993-2014, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Definers"
Versions
	"dev"
Uses
	"Avail",
	"Core" =
	(
		"_+_" → "_+_(Core)",
		"_-_" → "_-_(Core)",
		"_×_" → "_×_(Core)",
		"_÷_" → "_÷_(Core)",
		"_^_" → "_^_(Core)",
		…
	),
	"Types"
Names
	"prefixes",
	"_(_)is an SI base unit",
	"_(_)is an SI derived unit equivalent to_"
Body

/**
 * The table of standard SI scaling prefixes.
 *
 * @global "_prefixes" "<<string, string, double…|3>…|>"
 */
_prefixes ::=
<
	<"yocto", "y",  -24>,
	<"zepto", "z",  -21>,
	<"atto",  "a",  -18>,
	<"femto", "f",  -15>,
	<"pico",  "p",  -12>,
	<"nano",  "n",   -9>,
	<"micro", "µ",   -6>,
	<"milli", "m",   -3>,
	<"centi", "c",   -2>,
	<"deci",  "d",   -1>,
	<"",       "",    0>,
	<"deca",  "da",   1>,
	<"hecto", "h",    2>,
	<"kilo",  "k",    3>,
	<"mega",  "M",    6>,
	<"giga",  "G",    9>,
	<"tera",  "T",   12>,
	<"peta",  "P",   15>,
	<"exa",   "E",   18>,
	<"zetta", "Z",   21>,
	<"yotta", "Y",   24>
>;

Public method "prefixes" is [_prefixes];

/* These methods are needed for scaling function synthesis. */
metricAtom ::= $"_'s⁇metric";
scaleFactorAtom ::= $"_'s⁇scale factor";
minusAvailAtom ::= $"_-_";
powerAvailAtom ::= $"_^_";
extentAtom ::= $"_'s⁇extent";
timesAvailAtom ::= $"_×_";
juxtapositionAtom ::= $"__";

/**
 * Construct and answer a scaling function suitable for converting between
 * {@type "SI unit"}s within the same family.
 *
 * @method "SI scaling function for family_"
 * @param "unitType" "unit's type"
 *        The family.
 * @returns The requested function.
 */
Private method "SI scaling function for_" is
[
	unitType : SI unit's type
|
	/* Construct the argument declarations. The first argument is a
	 * dimensioned quantity, the second is the target unit. Both metrics are
	 * SI metrics.
	 */
	quantityType ::= extend SI dimensioned quantity with metric : unitType;
	args ::= <arg «`"quantity"` : quantityType», arg «`"aUnit"` : unitType»>;
	/* Construct the expression to obtain the scaling factor. */
	metricSend ::= send metricAtom with «<«↓args[1]»>» : SI unit;
	minuend ::= send scaleFactorAtom with «<metricSend>» : integer;
	subtrahend ::= send scaleFactorAtom with «<«↓args[2]»>» : integer;
	exponent ::= send minusAvailAtom with «<minuend, subtrahend>» : integer;
	scaleFactor ::= send powerAvailAtom with «<‘`10`’, exponent>» : number;
	/* Construct the expression to obtain the scaled magnitude. */
	extentSend ::= send extentAtom with «<«↓args[1]»>» : double;
	scaled ::= send timesAvailAtom with «<extentSend, scaleFactor>» : double;
	/* Construct the expression to obtain the resultant SI dimensioned
	 * quantity.
	 */
	juxtapositionSend ::= send juxtapositionAtom
		with «<scaled, «↓args[2]»>»
		: quantityType;
	/* Construct and answer the requested function. */
	newBlock ::= «[ args | <juxtapositionSend> ] : dimensioned quantity»;
	cast generate newBlock into [t : unit conversion function | t]
] : unit conversion function;

_conversionAtom ::= $"_converted to_";
Private method "conversion atom" is [_conversionAtom];

/**
 * Define an SI {@type "base unit"}. This makes available not only the unscaled
 * {@type "base unit"}, but also all prefixed long names and short symbols, as
 * well as {@method "_converted to_" conversions} between them.
 *
 * @method "_(_)is an SI base unit"
 * @param "name" "string"
 *        The name of the {@type "base unit"}, e.g., meters, seconds, grams.
 * @param "symbol" "string"
 *        A symbol which represents the defined {@type "base unit"}.
 */
Public method "_(_)is an SI base unit" is
[
	name : nonempty string,
	symbol : nonempty string
|
	id ::= atom for name;
	def ::= {id → 1};
	unitType ::= extend base unit ∩ SI unit with
		unit map : def's type;
	units ::=
		map prefixes through
		[
			prefix : <string, string, [-24..24]…|3>,
			index : [1..|prefixes|]
		|
			longName ::= prefix[1] ++ name;
			shortName ::= prefix[2] ++ symbol;
			aUnit ::= a unitType with
				unit map ::= def,
				scale factor ::= prefix[3];
			impl ::= generate «[ <> | <‘`aUnit` ("")’> ] : aUnit's type»;
			Method longName is impl;
			publicNames ::= current module's public names;
			Unless longName ∈ publicNames then [Publish new name: longName;];
			Unless longName = shortName then
			[
				Method shortName is impl;
				Unless shortName ∈ publicNames then
				[
					Publish new name: shortName;
				];
			];
			Prefer longName for printing aUnit;
			Prefer shortName for printing aUnit in a dimensioned quantity;
			aUnit
		];
	aUnit ::= a unitType with unit map ::= def, scale factor ::= 0;
	Prefer symbol for printing aUnit in a dimensioned quantity;
	scalingFunction ::= SI scaling function for unitType;
	Method conversion atom is scalingFunction;
] : ⊤;

Completely seal method "_(_)is an SI base unit";

/**
 * Define an SI {@type "derived unit"}. This makes available not only the
 * unscaled {@type "derived unit"}, but also all prefixed long names and short
 * symbols, as well as {@method "_converted to_" conversions} between them.
 *
 * @method "_(_)is an SI derived unit equivalent to_"
 * @param "name" "string"
 *        The name of the {@type "derived unit"}, e.g., newtons, pascals.
 * @param "symbol" "string"
 *        A symbol which represents the defined {@type "derived unit"}.
 * @param "referenceUnit" "SI unit"
 *        An equivalent {@type "SI unit"}, usually obtained from a lexical
 *        expression.
 */
Public method "_(_)is an SI derived unit equivalent to_" is
[
	name : nonempty string,
	symbol : nonempty string,
	referenceUnit : SI unit
|
	def ::= referenceUnit's unit map;
	baseUnitType ::= cast def
		into [t : {atom→1's type|1} | base unit]
		else [derived unit];
	unitType ::= extend baseUnitType ∩ SI unit with
		unit map : def's type;
	baseScaleFactor ::= referenceUnit's scale factor;
	units ::=
		map prefixes through
		[
			prefix : <string, string, [-24..24]…|3>,
			index : [1..|prefixes|]
		|
			longName ::= prefix[1] ++ name;
			shortName ::= prefix[2] ++ symbol;
			aUnit ::= a unitType with
				unit map ::= def,
				scale factor ::= baseScaleFactor + prefix[3];
			impl ::= generate «[ <> | <‘`aUnit` ("")’> ] : aUnit's type»;
			Method longName is impl;
			publicNames ::= current module's public names;
			Unless longName ∈ publicNames then [Publish new name: longName;];
			Unless longName = shortName then
			[
				Method shortName is impl;
				Unless shortName ∈ publicNames then
				[
					Publish new name: shortName;
				];
			];
			Prefer longName for printing aUnit;
			Prefer shortName for printing aUnit in a dimensioned quantity;
			aUnit
		];
	conversionAtom ::= conversion atom;
	quantityType ::= extend SI dimensioned quantity with metric : unitType;
	Unless conversionAtom has definition for <quantityType, unitType> then
	[
		scalingFunction ::= SI scaling function for unitType;
		Method conversion atom is scalingFunction;
	];
] : ⊤;

Completely seal method "_(_)is an SI derived unit equivalent to_";
