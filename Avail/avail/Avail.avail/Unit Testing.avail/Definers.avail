/*
 * Definers.avail
 * Copyright © 1993-2013, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Definers"
Versions
	"dev"
Uses
	"Framework State",
	"Foundation",
	"Types"
Names
	"After running each test in_,⁇do_",
	"After running_,⁇do_",
	"Before running each test in_,⁇do_",
	"Before running_,⁇do_",
	"New test suite,⁇_,⁇extends_",
	"Test_in_is_«must raise_»",
	"_is a new test suite"
Body

/**
 * Define a unit test suite.
 *
 * @method "New test suite,⁇_,⁇extends_"
 * @param "id" "atom"
 *        The identifier of the test suite.
 * @param "parentID" "atom"
 *        The identifier of the parent test suite. When a test suite is run,
 *        then all of its child test suites are also run (and their unit tests
 *        are treated as the parent's own).
 * @raises "bad-argument exception"
 *         If {@param "id"} = {@param "parentID"}.
 * @raises "test-suite-already-exists exception"
 *         If {@param "id"} references an existing unit test suite.
 * @raises "no-such-test-element exception"
 *         If the (optional) parent test suite identifiers does not reference an
 *         existing unit test suite.
 */
Public method "New test suite,⁇_,⁇extends_" is
[
	id : atom,
	parentID : atom
|
	Lock suite lock for
	[
		If id = parentID then
		[
			Raise a bad-argument exception
		];
		If id ∈ suites by atom then
		[
			Raise a test-suite-already-exists exception with suite ID ::= id
		];
		suite ::= a unit test suite with
			suite ID ::= id,
			parent suite ID ::= parentID,
			child suite IDs ::= <>,
			suite fixture setup ::= <>,
			suite fixture tear down ::= <>,
			test fixture setup ::= <>,
			test fixture tear down ::= <>,
			unit tests ::= <>;
		isRootTestSuite ::= parentID = root test suite ID;
		parent ::= if isRootTestSuite
			then [root suite]
			else
			[
				suites by atom[parentID] else
				[
					Raise a no-such-test-suite exception with
						suite ID ::= parentID
				]
			];
		suites by atom := suites by atom + id→suite;
		childSuites : <atom…|> := parent's child suite IDs ++ <id>;
		If isRootTestSuite then
		[
			root suite := root suite's child suite IDs ::= childSuites;
		]
		else
		[
			updatedParent ::= cast parent's child suite IDs ::= childSuites
				into [t : unit test suite | t];
			suites by atom := suites by atom + parentID→updatedParent;
		];
	];
] : ⊤;

/**
 * Define a unit test suite.
 *
 * @method "_is a new test suite"
 * @param "id" "atom"
 *        The identifier of the test suite.
 * @raises "test-suite-already-exists exception"
 *         If {@param "id"} references an existing unit test suite.
 * @raises "no-such-test-element exception"
 *         If the (optional) parent test suite identifiers does not reference an
 *         existing unit test suite.
 */
Public method "_is a new test suite" is
[
	id : atom
|
	New test suite id extends root test suite ID;
] : ⊤;

/**
 * Define a test fixure setup operation that will occur exactly once before the
 * specified test suite is run.
 *
 * @method "Before running_,⁇do_"
 * @param "id" "atom"
 *        The test suite identifier of an existing test suite.
 * @param "setup" "[]→⊤"
 *        A test-fixture setup function.
 * @raises "no-such-test-suite exception"
 *         If {@param "id"} does not reference an existing test suite.
 */
Public method "Before running_,⁇do_" is
[
	id : atom,
	setup : []→⊤
|
	Lock suite lock for
	[
		suite ::= suites by atom[id]
			else [Raise a no-such-test-suite exception with suite ID ::= id];
		before ::= suite's suite fixture setup ++ <setup>;
		suites by atom :=
			suites by atom + id→suite's suite fixture setup ::= before;
	];
] : ⊤;

Private method "fixture semantic restriction function" is
[
	[
		id : atom's type,
		test : []→⊤'s type
	|
		If test's return type ≠ ⊤ then
		[
			Reject parse, expected:
				format "test function's return type to be ⊤ (not “①”)"
					with test's return type
		];
		⊤
	] : type
] : [atom's type, []→⊤'s type]→type;

Semantic restriction "Before running_,⁇do_"
	is fixture semantic restriction function;

/**
 * Define a test fixure setup operation that will occur exactly once before each
 * unit test of the specified test suite is run. (If the test suite contains
 * <em>n</em> tests, then {@param "setup"} will run <em>n</em> times.)
 *
 * @method "Before running each test in_,⁇do_"
 * @param "id" "atom"
 *        The test suite identifier of an existing test suite.
 * @param "setup" "[]→⊤"
 *        A test-fixture setup function.
 * @raises "no-such-test-suite exception"
 *         If {@param "id"} does not reference an existing test suite.
 */
Public method "Before running each test in_,⁇do_" is
[
	id : atom,
	setup : []→⊤
|
	Lock suite lock for
	[
		suite ::= suites by atom[id]
			else [Raise a no-such-test-suite exception with suite ID ::= id];
		before ::= suite's test fixture setup ++ <setup>;
		suites by atom :=
			suites by atom + id→suite's test fixture setup ::= before;
	];
] : ⊤;

Semantic restriction "Before running each test in_,⁇do_"
	is fixture semantic restriction function;

/**
 * Define a test-fixure tear-down operation that will occur exactly once after
 * the specified test suite is run.
 *
 * @method "After running_,⁇do_"
 * @param "id" "atom"
 *        The test suite identifier of an existing test suite.
 * @param "tearDown" "[]→⊤"
 *        A test-fixture tear-down function.
 * @raises "no-such-test-suite exception"
 *         If {@param "id"} does not reference an existing test suite.
 */
Public method "After running_,⁇do_" is
[
	id : atom,
	tearDown : []→⊤
|
	Lock suite lock for
	[
		suite ::= suites by atom[id]
			else [Raise a no-such-test-suite exception with suite ID ::= id];
		after ::= suite's suite fixture tear down ++ <tearDown>;
		suites by atom :=
			suites by atom + id→suite's suite fixture tear down ::= after;
	];
] : ⊤;

Semantic restriction "After running_,⁇do_"
	is fixture semantic restriction function;

/**
 * Define a test-fixure tear-down operation that will occur exactly once after
 * each unit test of the specified test suite is run. (If the test suite
 * contains <em>n</em> tests, then {@param "tearDown"} will run <em>n</em>
 * times.)
 *
 * @method "After running each test in_,⁇do_"
 * @param "id" "atom"
 *        The test suite identifier of an existing test suite.
 * @param "tearDown" "[]→⊤"
 *        A test-fixture tear-down function.
 * @raises "no-such-test-suite exception"
 *         If {@param "id"} does not reference an existing test suite.
 */
Public method "After running each test in_,⁇do_" is
[
	id : atom,
	tearDown : []→⊤
|
	Lock suite lock for
	[
		suite ::= suites by atom[id]
			else [Raise a no-such-test-suite exception with suite ID ::= id];
		after ::= suite's test fixture tear down ++ <tearDown>;
		suites by atom :=
			suites by atom + id→suite's test fixture tear down ::= after;
	];
] : ⊤;

Semantic restriction "After running each test in_,⁇do_"
	is fixture semantic restriction function;

/**
 * Define a unit test.
 *
 * @method "Test_in_is_«must raise_»"
 * @param "name" "string"
 *        The name of the test. This name will be resolved to an atom in the
 *        context of the current module. Since an atom retains its provenance,
 *        this permits the unit testing framework to report the module that
 *        defined the test. This also allows name collisions between modules.
 * @param "id" "atom"
 *        The test suite identifier of the test suite to which the new test
 *        should belong.
 * @param "test" "[]→⊤"
 *        The unit test.
 * @param "optionalException" "<exception…|0..1>"
 *        If specified, then {@param "test"} must raise an exception of this
 *        type when applied. If not specified, then "test" must not raise any
 *        exceptions.
 * @raises "test-already-exists exception"
 *         If {@param "name"} names an existing unit test.
 */
Public method "Test_in_is_«must raise_»" is
[
	name : string,
	suiteID : atom,
	test : []→⊤,
	optionalException : <exception's type…|0..1>
|
	Lock suite lock for
	[
		trueName ::= atom for name;
			If trueName ∈ tests by atom then
			[
				Raise a test-already-exists exception with test ID ::= trueName
			];
			unitTest ::= a unit test with
				test ID ::= trueName,
				suite ID ::= suiteID,
				body ::= test,
				expected exception type ::= optionalException;
		tests by atom := tests by atom + trueName→unitTest;
		suite ::= suites by atom[suiteID] else
			[
				Raise a no-such-test-suite exception with suite ID ::= suiteID
			];
		suiteTests ::= suite's unit tests ++ <unitTest>;
		suites by atom :=
			suites by atom + suiteID→suite's unit tests ::= suiteTests;
	];
] : ⊤;

/**
 * Reject the current parse if the test's return type is not exactly ⊤.
 * 
 * @method "Test_in_is_«must raise_»"
 * @restricts "string's type"
 * @restricts "atom's type"
 * @restricts "[]→⊤'s type"
 * @restricts "<exception's type…|0..1>'s type"
 */
Semantic restriction "Test_in_is_«must raise_»" is
[
	name : string's type,
	suiteID : atom's type,
	test : []→⊤'s type,
	optionalException : <exception's type…|0..1>'s type
|
	If ⎡optionalException⎤ = 1 then
	[
		If ¬test's return type ∈ {⊤, ⊥} then
		[
			Reject parse, expected:
				format "test function's return type to be ⊤ or ⊥ (not “①”)"
					with test's return type
		];
	]
	else if [test's return type ≠ ⊤] then
	[
		Reject parse, expected:
			format "test function's return type to be ⊤ (not “①”)"
				with test's return type
	];
	⊤
];
