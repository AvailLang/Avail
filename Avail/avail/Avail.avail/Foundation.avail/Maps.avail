/*
 * Maps.avail
 * Copyright © 1993-2014, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Maps"
Versions
	"dev"
Extends
	"Collections",
	"Early Maps"
Uses
	"Bootstrap",
	"Control Structures",
	"Definers",
	"Early Functions",
	"Early Tuples",
	"Enumeration Support",
	"Literals",
	"Logic",
	"Math",
	"Sets",
	"Tuples",
	"Types",
	"Variables"
Names
	"counts for_",
	"integrate_and_with_"
Body

Method "“_”" is
[
	t : map meta
|
	s : nonempty string :=
		"{" ++ “t's key type” ++ "→" ++ “t's value type” ++ "|";
	lower ::= ⎣t⎦;
	upper ::= ⎡t⎤;
	s := eject ↑s ++ “||t||” (cardinality restriction);
	s := eject ↑s ++ "}";
	s
] : string;

/**
 * Is the specified map empty? 
 *
 * @method "_is empty"
 * @param "aMap" "map"
 * @returns "boolean"
 *          {@method "true"} if the argument is empty, {@method "false"}
 *          otherwise.
 * @category "Maps" "Queries"
 */
Method "_is empty" is
[
	aMap : map
|
	|aMap| = 0
];

/**
 * Is {@param "key"} not a key of {@param "aMap"}?
 *
 * @method "_∉_"
 * @param "key" "any"
 * @param "aMap" "map"
 * @returns "boolean"
 *          {@method "true"} if {@param "key"} is not an element of {@param
 *          "aMap"}, {@method "false"} otherwise.
 * @category "Maps" "Queries"
 */
Stable method "_∉_" is
[
	key : any,
	aMap : map
|
	¬ key ∈ aMap
] : boolean;

Semantic restriction "_∉_" is
[
	keyType : any meta,
	mapType : map meta
|
	if keyType ∩ (mapType's key type) = ⊥ then
	[
		true's type
	]
	else
	[
		/* Can't strengthen. */
		⊤
	]
];

/**
 * Iteratively apply {@param "action"} to each binding of {@param "aMap"}, but
 * in no particular order.
 * 
 * @method "For each of⁇_do_"
 * @param "aMap" "map"
 * @param "action" "[⊥, ⊥]→⊤"
 *        A function that accepts the bindings of the map. The first argument is
 *        a key from the map, the second is a value from the map.
 * @returns "⊤"
 * @category "Collections" "Maps" "Control Structures"
 */
Method "For each of⁇_do_" is
[
	aMap : map,
	action : [⊥, ⊥]→⊤
|
	index : natural number := 1;
	bindings ::= aMap's bindings;
	end ::= |aMap|;
	[
		$loop;
		If index ≤ end then
		[
			binding ::= bindings[index];
			action(binding[1], binding[2]);
			↑index++;
			Restart loop
		];
	]();
] : ⊤;

/**
 * Helper method for semantic restrictions: If `action` does not accept the
 * key and value types of `mapType`, then reject the current parse.
 * 
 * @method "Require:_accepts_"
 * @param "action" "function meta"
 *        A function type whose first two arguments must correspond to the key
 *        and value types of {@param "mapType"}.
 * @param "mapType" "map meta"
 * @returns "⊤"
 */
Private method "Require:_accepts_" is
[
	action : function meta,
	mapType : map meta
|
	If ⎣action's parameters' type⎦ < 2 then
	[
		Reject parse, expected:
			"repeatedly applied function to accept at least two arguments"
	];
	If action[1] ≠ ⊥ ∧ [ ¬mapType's key type ⊆ action[1] ] then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all keys ∈ "
			++ “mapType's key type”
			++ " (but it only accepts "
			++ “action[1]”
			++ ")"
	];
	If action[2] ≠ ⊥ ∧ [ ¬mapType's value type ⊆ action[2] ] then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all values ∈ "
			++ “mapType's value type”
			++ " (but it only accepts "
			++ “action[2]”
			++ ")"
	];
] : ⊤;

/**
 * Ensure that the function will accept all bindings of the map. If the map is
 * certainly nonempty and the function certainly does not complete if applied,
 * then answer ⊥.
 * 
 * @method "For each of⁇_do_"
 * @restricts "map meta"
 * @restricts "[⊥, ⊥]→⊤'s type"
 */
Semantic restriction "For each of⁇_do_" is
[
	mapType : map meta,
	action : [⊥, ⊥]→⊤'s type
|
	Require: action accepts mapType;
	if ⎣mapType⎦ > 0 ∧ [ action's return type = ⊥ ] then
	[
		⊥
	]
	else
	[
		⊤
	]
];

/**
 * Iteratively apply {@param "transformer"} to each binding of {@param "aMap"},
 * in no particular order, collecting the results into a new map. The resultant
 * map has the same keys as the original, but its values have been transformed
 * via {@param "transformer"}.
 * 
 * @method "map_through_"
 * @param "aMap" map"
 * @param "transformer" "[⊥, ⊥]→any"
 *        A function that accepts the bindings of the map. The first argument is
 *        a key from the map, the second is a value from the map. This function
 *        answers a replacement value for the given binding.
 * @returns "map"
 *          A map of results of applications of `transformer` to the elements of
 *          {@param "aMap"}.
 * @category "Collections" "Maps" "Control Structures"
 */
Method "map_through_" is
[
	aMap : map,
	transformer : [⊥, ⊥]→any
|
	index : natural number := 1;
	bindings ::= aMap's bindings;
	end ::= |aMap|;
	result : map := {};
	[
		$loop;
		If index ≤ end then
		[
			binding ::= bindings[index];
			key ::= binding[1];
			value ::= binding[2];
			result := eject ↑result + key→transformer(key, value);
			↑index++;
			Restart loop
		];
	]();
	result
] : map;

/**
 * Ensure that the function will accept all bindings of the map. If the map is
 * certainly nonempty, then the function cannot answer ⊥.
 *
 * @method "map_through_"
 * @restricts "map meta"
 * @restricts "[⊥, ⊥]→any's type"
 */
Semantic restriction "map_through_" is
[
	mapType : map meta,
	transformer : [⊥, ⊥]→any's type
|
	Require: transformer accepts mapType;
	If ⎣mapType⎦ > 0 then
	[
		If transformer's return type = ⊥ then
		[
			Reject parse, expected:
				"repeatedly applied function to have a return type other than\
				\| ⊥"
		];
	];
	{mapType's key type → transformer's return type | ||mapType||}
];

/**
 * Iteratively apply {@param "predicate"} to each binding of {@param "aMap"}, in
 * no particular order, collecting those bindings for which {@param "predicate"}
 * answers {@method "true"} into a new map. Answer the new map.
 *
 * @method "filter_by_"
 * @param "aMap" "map"
 * @param "predicate" "[⊥, ⊥]→boolean"
 *        A function that accepts the bindings of the map and answers {@method
 *        "true"} iff they should be accumulated into the output map.
 * @returns "map"
 *          A map containing exactly those bindings of {@param "aMap"} for which
 *          {@param "predicate"} answered {@method "true"}.
 * @category "Collections" "Maps" "Control Structures"
 */
Method "filter_by_" is
[
	aMap : map,
	predicate : [⊥, ⊥]→boolean
|
	bindings ::= aMap's bindings;
	index : natural number := 1;
	end ::= |bindings|;
	result : map := {};
	[
		$loop;
		If index ≤ end then
		[
			binding ::= bindings[index];
			key ::= binding[1];
			value ::= binding[2];
			If predicate(key, value) then
			[
				result := eject ↑result + key→value;
			];
			↑index++;
			Restart loop
		];
	]();
	result
] : map;

/**
 * Ensure that the function will accept all elements of the map.
 * 
 * @method "filter_by_"
 * @restricts "map meta"
 * @restricts "[⊥, ⊥]→boolean's type"
 */
Semantic restriction "filter_by_" is
[
	mapType : map meta,
	predicate : [⊥, ⊥]→boolean's type
|
	Require: predicate accepts mapType;
	sizes ::=
		if predicate's return type = true's type then [ ||mapType|| ]
		else if [ predicate's return type = false's type ] then [ 0's type ]
		else [ [0..⎡mapType⎤ + 1) ];
	{mapType's key type → mapType's value type|sizes}
];

/**
 * Iteratively apply {@param "accumulator"} to the bindings of {@param "aMap"},
 * in no particular order, in order to transform and filter its bindings into a
 * new map. When {@param "accumulator"} is invoked, it is passed a "keeper"
 * function. The keeper function may be invoked to "save" a particular value,
 * i.e., a value that will be associated with the current key in the output set.
 * The keeper function will save at most one value per binding of {@param
 * "aSet"}, i.e., each time that {@param "accumulator"} is invoked, it may
 * invoke the keeper function at most one time. Answer the new map.
 * 
 * @method "map and filter_by_"
 * @param "aMap" "map"
 * @param "accumulator" "[⊥, ⊥, ⊥]→⊤"
 *        A function that accepts 1) a key from {@param "aMap"}, 2) the value
 *        associated with that key, and 3) a keeper function. The keeper
 *        function accepts an argument of the (value) type that should be saved.
 * @returns "map"
 *          A map whose bindings are those saved by the {@param "accumulator"}.
 * @category "Collections" "Maps" "Control Structures"
 */
Method "map and filter_by_" is
[
	aMap : map,
	accumulator : [⊥, ⊥, ⊥]→⊤
|
	bindings ::= aMap's bindings;
	index : natural number := 1;
	end ::= |bindings|;
	result : map := {};
	[
		$loop;
		If index ≤ end then
		[
			hasAlreadyKept : boolean := false;
			binding ::= bindings[index];
			key ::= binding[1];
			value ::= binding[2];
			accumulator(
				key,
				value,
				[
					transformed : any
				|
					If ¬hasAlreadyKept then
					[
						result := eject ↑result + key→transformed;
						hasAlreadyKept := true;
					];
				]
			);
			↑index++;
			Restart loop
		];
	]();
	result
] : map;

/**
 * Ensure that the function will accept all bindings of the map and also an
 * appropriately typed keeper function.
 *
 * @method "map and filter_by_"
 * @restricts "map meta"
 * @restricts "[⊥, ⊥, ⊥]→⊤'s type"
 */
Semantic restriction "map and filter_by_" is
[
	mapType : map meta,
	accumulator : [⊥, ⊥, ⊥]→⊤'s type
|
	Require: accumulator accepts mapType;
	Require: accumulator's keeper is valid;
	If accumulator's return type ≠ ⊤ then
	[
		Reject parse, expected:
			"repeatedly applied function to have return type ⊤"
	];
	valueType ::= cast accumulator[3] into [ t : function meta | t[1] ];
	{
		mapType's key type → valueType
		| [0..⎡mapType⎤ + 1)
	}
];

/**
 * Compute and answer whether any of the elements of {@param "aMap"} satisfies
 * the specified function. Do not examine more elements than necessary.
 * 
 * @method "any of_satisfies_"
 * @param "aMap" "map"
 * @param "predicate" "[⊥, ⊥]→boolean"
 *        A function that accepts the elements of the map and answers a boolean.
 * @returns "boolean"
 *          {@method "true"} if {@param "predicate"} answers {@method "true"}
 *          for any element of {@param "aMap"}, {@method "false"} otherwise.
 * @category "Collections" "Maps" "Queries"
 */
Method "any of_satisfies_" is
[
	aMap : map,
	predicate : [⊥, ⊥]→boolean
|
	$body : boolean;
	For each aMap do
	[
		key : any,
		value : any
	|
		If predicate(key, value) then
		[
			Exit body with true
		];
	];
	false
] : boolean;

/**
 * Ensure that the function will accept all elements of the map.
 *
 * @method "any of_satisfies_"
 * @restricts "map meta"
 * @restricts "[⊥, ⊥]→boolean's type" 
 */
Semantic restriction "any of_satisfies_" is
[
	mapType : map meta,
	predicate : [⊥, ⊥]→boolean's type
|
	Require: predicate accepts mapType;
	predicate's return type
];

/**
 * Compute and answer whether each of the elements of {@param "aMap"} satisfies
 * the specified function. Do not examine more elements than necessary.
 * 
 * @method "each of_satisfies_"
 * @param "aMap" "map"
 * @param "predicate" "[⊥, ⊥]→boolean"
 *        A function that accepts the bindings of the map and answers a boolean.
 * @returns "boolean"
 *          {@method "true"} if {@param "predicate"} answers {@method "true"}
 *          for each element of {@param "aMap"}, {@method "false"} otherwise.
 * @category "Collections" "Maps" "Queries"
 */
Method "each of_satisfies_" is
[
	aMap : map,
	predicate : [⊥, ⊥]→boolean
|
	$body : boolean;
	For each aMap do
	[
		key : any,
		value : any
	|
		Unless predicate(key, value) then
		[
			Exit body with false
		];
	];
	true
] : boolean;

/**
 * Ensure that the function will accept all bindings of the map.
 * 
 * @method "each of_satisfies_"
 * @restricts "map meta"
 * @restricts "[⊥, ⊥]→boolean's type"
 */
Semantic restriction "each of_satisfies_" is
[
	mapType : map meta,
	predicate : [⊥, ⊥]→boolean's type
|
	Require: predicate accepts mapType;
	predicate's return type
];

/**
 * Compute and answer the count of bindings of {@param "aMap"} that satisfy the
 * given predicate.
 * 
 * @method "count of_where_"
 * @param "aMap" "map"
 * @param "predicate" "[⊥, ⊥]→boolean"
 *        A function that accepts the bindings of the map and answers {@method
 *       "true"} if the binding should be represented in the resulting count.
 * @returns "whole number"
 *          The number of bindings of {@param "aMap"} for which {@param
 *          "predicate"} answers {@method "true"}.
 * @category "Collections" "Maps" "Queries"
 */
Method "count of_where_" is
[
	aMap : map,
	predicate : [⊥, ⊥]→boolean
|
	|filter aMap by predicate|
] : whole number;

/**
 * Ensure that the function will accept all bindings of the map.
 * 
 * @method "count of_where_"
 * @restricts "map meta"
 * @restricts "[⊥, ⊥]→boolean's type"
 */
Semantic restriction "count of_where_" is
[
	mapType : map meta,
	predicate : [⊥, ⊥]→boolean's type
|
	Require: predicate accepts mapType;
	[0..⎡mapType⎤ + 1)
];

Method "_∈_" is stable at [any, map]→boolean;
Semantic restriction "_∈_" is
[
	keyType : any meta,
	mapType : map meta
|
	mapKeyType ::= mapType's key type;
	if keyType ∩ mapKeyType = ⊥ then
	[
		false's type
	]
	else
	[
		if (¬mapKeyType ∈ type)
			∧ [|mapKeyType| = ⎣mapType⎦
			∧ [|mapKeyType| = ⎡mapType⎤
			∧ [keyType ⊆ mapKeyType]]]
		then
		[
			true's type
		]
		else
		[
			/* Can't strengthen. */
			⊤
		]
	]
];

/**
 * Categorize the elements of {@param "aTuple"} via {@param "discriminator"}.
 *
 * @method "group_by_"
 * @param "aTuple" "tuple"
 *        The tuple to categorize.
 * @param "discriminator" "[⊥]→any"
 *        A function that accepts each element of the tuple and answers a value
 *        that represents the group to which the element belongs.
 * @returns "map"
 *          A map whose keys describe groups and whose elements are the groups
 *          themselves, i.e., the tuples of elements that constitute the
 *          described group.
 * @category "Collections" "Tuples" "Maps" "Transformers"
 */
Method "group_by_" is
[
	aTuple : tuple,
	discriminator : [⊥]→any
|
	groups : {any→tuple|} := {};
	For each aTuple do
	[
		element : any
	|
		key ::= discriminator(element);
		group ::= groups[key] else [ <> ] ++ <element>;
		groups := eject ↑groups + key→group;
	];
	groups
] : map;

Semantic restriction "group_by_" is
[
	aTupleType : tuple's type,
	discriminatorType : [⊥]→any's type
|
	Require: discriminatorType accepts aTupleType;
	tupleCardinality ::= ||aTupleType||;
	tupleUpperBound ::= ⎡tupleCardinality⎤;
	defaultType ::= ∪ aTupleType[1..|aTupleType's leading types| + 1];
	keyType ::= discriminatorType's return type;
	lowerBound ::= if ⎣tupleCardinality⎦ = 0 then [0] else [1];
	upperBound ::= if tupleUpperBound > |keyType| 
		then [|keyType|]
		else [tupleUpperBound];
	valueType ::= <defaultType… | 1..tupleUpperBound>;
	{keyType→valueType | lowerBound..upperBound}
];

/**
 * Categorize the elements of {@param "aSet"} via {@param "discriminator"}.
 *
 * @method "group_by_"
 * @param "aSet" "set"
 *        The set to categorize.
 * @param "discriminator" "[⊥]→any"
 *        A function that accepts each element of the set and answers a value
 *        that represents the group to which the element belongs.
 * @returns "map"
 *          A map whose keys describe groups and whose elements are the groups
 *          themselves, i.e., the sets of elements that constitute the described
 *          group.
 * @category "Collections" "Sets" "Maps" "Transformers"
 */
Method "group_by_" is
[
	aSet : set,
	discriminator : [⊥]→any
|
	groups : {any→set|} := {};
	For each aSet do
	[
		element : any
	|
		key ::= discriminator(element);
		group ::= groups[key] else [ ∅ ] + element;
		groups := eject ↑groups + key→group;
	];
	groups
] : map;

/**
 * Strengthen return type.
 *
 * @method "group_by_"
 * @restricts "set's type"
 * @restricts "[⊥]→any's type"
 */
Semantic restriction "group_by_" is
[
	aSetType : set's type,
	discriminatorType : [⊥]→any's type
|
	Require: discriminatorType accepts aSetType;
	setCardinality ::= ||aSetType||;
	setUpperBound ::= ⎡setCardinality⎤;
	keyType ::= discriminatorType's return type;
	lowerBound ::= if ⎣setCardinality⎦ = 0 then [0] else [1];
	upperBound ::= if setUpperBound > |keyType| 
		then [|keyType|]
		else [setUpperBound];
	valueType ::= {aSetType's element type | 1..setUpperBound};
	{keyType→valueType | lowerBound..upperBound}
];

/**
 * Group the elements of {@param "aTuple"} by their frequency.
 *
 * @method "counts for_"
 * @param "aTuple" "tuple"
 * @returns "map"
 *          A map whose keys are elements of the tuple and whose values are
 *          their frequencies.
 * @category "Collections" "Tuples" "Maps" "Transformers"
 */
Public stable method "counts for_" is
[
	aTuple : tuple
|
	groups ::= group aTuple by [a : any | a];
	map groups through [k : any, t : tuple | |t|]
] : map;

Semantic restriction "counts for_" is
[
	aTupleType : tuple's type
|
	keyType ::= ∪ aTupleType[1..|aTupleType's leading types| + 1];
	tupleCardinality ::= ||aTupleType||;
	lowerBound ::= if ⎣tupleCardinality⎦ = 0 then [0] else [1];
	upperBound ::= ⎡tupleCardinality⎤;
	{keyType→whole number|lowerBound..upperBound}
];

/**
 * Combine two {@param "map"}s. If there are duplicate keys, invoke {@param
 * "action"} to handle duplicates.
 * 
 * @method "integrate_and_with_"
 * @param "baseMap" "map"
 * @param "supplementMap" "map"
 * @param "action" "[⊥,⊥,⊥]→map"
 *         The function to apply when a duplicate key is encountered. The first
 *         argument is the partially combined map. The second argument is a key
 *         from {@param "supplementMap"} that was present in {@param "baseMap"}.
 *         The third argument is the value associated with the second argument
 *         within {@param "supplementValue"}. The answer is a complete
 *         replacement for the partially combined map.
 * @returns "map"
 *          The fully combined map.
 * @category "Collections" "Maps" "Transformers"
 */
Public method "integrate_and_with_" is
[
	baseMap : map,
	supplementMap : map,
	action : [⊥, ⊥, ⊥]→map
|
	baseMapkeys ::= baseMap's keys;
	newMap : map := baseMap;
	For each supplementMap do
	[
		supplementKey : any,
		supplementValue : any
	|
		newMap :=
			if baseMapkeys ∋ supplementKey then
			[
				action(newMap, supplementKey, supplementValue)
			]
			else
			[
				newMap + supplementKey→supplementValue
			];
	];
	newMap
] : map;

/**
 * @method "integrate_and_with_"
 * @restricts "map's type"
 * @restricts "map's type"
 * @restricts "[⊥,⊥,⊥]→map's type"
 */
Semantic restriction "integrate_and_with_" is
[
	baseMapType : map's type,
	supplementMapType : map's type,
	actionType : [⊥,⊥,⊥]→map's type
 |
 	if ⎣actionType's parameters' type⎦ < 3 then
	[
		Reject parse, expected:
			"\nFunction to accept three arguments. Only received"
			++ “⎣actionType's parameters' type⎦”
			++ " arguments.\n\n"
	]
 	/*else if [¬supplementMapType ⊆ baseMapType] then
 	[
		Reject parse, expected:
			"\nIncompatible map types.  Supplemental map type is not a"
			++ " subtype of the base map type"
			++ “supplementMapType” ++ "⊈" ++ “baseMapType” ++ ".\n\n"

 	]*/
 	else if [actionType[1] ≠ ⊥ ∧ [ ¬baseMapType ⊆ actionType[1] ]] then
	[
		Reject parse, expected:
			"\nFunction to accept for input 1, "
			++ “baseMapType”
			++ " (but it only accepts "
			++ “actionType[1]”
			++ ")\n\n"
	]
	else if [actionType[2] ≠ ⊥ ∧ 
		[ ¬supplementMapType's key type ⊆ actionType[2]]] 
	then
	[
		Reject parse, expected:
			"\nRepeatedly applied function to accept all key ∈ "
			++ “supplementMapType's key type”
			++ " (but it only accepts "
			++ “actionType[2]”
			++ ")\n\n"
	]
	else if [actionType[3] ≠ ⊥ ∧ 
		[ ¬supplementMapType's value type ⊆ actionType[3]]] 
	then
	[
		Reject parse, expected:
			"\nRepeatedly applied function to accept all values ∈ "
			++ “supplementMapType's value type”
			++ " (but it only accepts "
			++ “actionType[3]”
			++ ")\n\n"
	]
	else if [⎣baseMapType⎦ > 0 ∨ [⎣supplementMapType⎦ > 0]] then
	[
		If actionType's return type = ⊥ then
		[
			Reject parse, expected:
				"Repeatedly applied function to have a return type other than"
				++ "⊥\n\n"
		];
	];
	newKeyType ::= supplementMapType's key type ∪ baseMapType's key type;
	newValueType ::= supplementMapType's value type ∪ baseMapType's value type;
	lowerBound ::= ⎣baseMapType⎦ max ⎣supplementMapType⎦;
	upperBound ::= ⎡baseMapType⎤ + ⎡supplementMapType⎤;
	{newKeyType → newValueType | lowerBound..upperBound}
];
