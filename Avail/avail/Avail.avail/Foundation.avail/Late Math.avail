/*
 * Late Math.avail
 * Copyright © 1993-2014, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Late Math"
Versions
	"dev"
Extends
	"Math"
Uses
	"Bootstrap",
	"Control Structures",
	"Definers",
	"Early Assertions",
	"Early Error Codes",
	"Early Functions",
	"Early Logic",
	"Early Sets",
	"Early Tuples",
	"Enumeration Support",
	"Exceptions",
	"Literals",
	"Objects",
	"Sets",
	"Tuples",
	"Types",
	"Variables"
Names
Body

cannotRaiseZeroToZero ::= "either base or exponent not to be 0";
cannotRaiseInfinityToZero ::= "base not to be ±∞ or exponent not to be 0";
cannotRaiseNegativeToInfinity ::=
	"base not to be negative or exponent not to be ±∞";

/* The definitions of `_^_` are recursive, so forward declare them here. */
Abstract method "_^_" is [extended integer, [0..∞]]→extended integer;
Forward method "_^_" is [extended integer, whole number]→extended integer;
Forward method "_^_" is [extended integer, [∞..∞]]→{0, ∞}ᵀ;
Forward method "_^_" is [float, whole number]→float;
Forward method "_^_" is [double, whole number]→double;

/**
 * Compute and answer the result of exponentiating `base` by `exponent`.
 * 
 * Parameters:
 *    base - The base.
 *    exponent - The exponent.
 * Returns:
 *    The result of raising `base` to the `exponent` power.
 */
Method "_^_" is
[
	base : number,
	exponent : number
|
	/* Uses the identity: a^b = exp(ln(a^b)) = exp(b*ln(a)). */
	Euler's number ^ (exponent × ln (base→double))
] : number;

/**
 * Establish type promotion rules for exponentiation. Also handle instance
 * types.
 * 
 * Parameters:
 *    a - The base's type.
 *    b - The exponent's type.
 * Returns:
 *    A numeric type that is not an integral kind. (These are dealt with by
 *    another restriction.)
 */
Semantic restriction "_^_" is type promotion function for
[
	a : number,
	b : number
|
	If b = 0 then
	[
		If a = 0 then
		[
			Reject parse, expected: cannotRaiseZeroToZero
		];
		If a ∈ {-∞, ∞} then
		[
			Reject parse, expected: cannotRaiseInfinityToZero
		];
	];
	If a ∈ extended integer then
	[
		If a < 0 ∧ [ b ∈ {-∞, ∞} ] then
		[
			Reject parse, expected: cannotRaiseNegativeToInfinity
		];
	];
	a ^ b
];

/**
 * Compute and answer the result of exponentiating `base` by `exponent`.
 * In this case, the base is an extended integer but the exponent is ∞.
 * 
 * Parameters:
 *    base - The base.
 *    exponent - The exponent, which is ∞.
 * Returns:
 *    The result of raising `base` to ∞.
 */
Method "_^_" is
[
	base : extended integer,
	exponent : [∞..∞]
|
	/* Forbid [-∞..-1]^∞ and 1^∞.  For all other n, n^∞=∞. */
	If base < 0 ∨ [ base = 1 ] then
	[
		Raise an arithmetic exception
	];
	if base = 0 then [0] else [∞]
] : {0, ∞}ᵀ;

Forward method "_recursive^_"
	is [extended integer, whole number]→extended integer;

/**
 * Compute and answer the result of exponentiating `base` by `exponent`.
 * 
 * Parameters:
 *    base - The base.
 *    exponent - The exponent.
 * Returns:
 *    The result of raising `base` to the `exponent` power.
 */
Method "_^_" is
[
	base : extended integer,
	exponent : whole number
|
	/* Forbid -∞^0, and ∞^0.  Use 0^0=1, since this identity is *practical*,
	 * especially when the exponent is expected to be an integer, such as in
	 * power series.
	 *
	 * Use the identities: b^(2x) = (b^2)^x; and: b^(2x+1) = (b^2)^x*b.
	 */
	if exponent = 0 then
	[
		If base ∈ {∞, -∞} then
		[
			Raise an arithmetic exception
		];
		1
	]
	else
	[
		intermediate ::= (base × base) recursive^ (exponent ÷ 2);
		if exponent is odd then [ intermediate × base ] else [ intermediate ]
	]
] : extended integer;

	
/**
 * Compute and answer the result of exponentiating `base` by `exponent`.  Do not
 * complain about indeterminate values, under the assumption that those are
 * dealt with by the actual "_^_" method.
 * 
 * Parameters:
 *    base - The base.
 *    exponent - The exponent.
 * Returns:
 *    The result of raising `base` to the `exponent` power.
 */
Method "_recursive^_" is
[
	base : extended integer,
	exponent : whole number
|
	if exponent = 0 then
	[
		1
	]
	else
	[
		intermediate ::= (base × base) recursive^ (exponent ÷ 2);
		if exponent is odd then [ intermediate × base ] else [ intermediate ]
	]
] : extended integer;

/**
 * Compute and answer the result of exponentiating `base` by `exponent`.
 * 
 * Parameters:
 *    base - The base.
 *    exponent - The exponent.
 * Returns:
 *    The result of raising `base` to the `exponent` power.
 */
Method "_^_" is
[
	base : float,
	exponent : whole number
|
	/*  Uses the identities: b^(2x) = (b^2)^x; and: b^(2x+1) = (b^2)^x*b. */
	if exponent = 0 then
	[
		1.0→float
	]
	else
	[
		intermediate ::= (base × base) ^ (exponent ÷ 2);
		if exponent is odd then [ intermediate × base ] else [ intermediate ]
	]
] : float;

/**
 * Compute and answer the result of exponentiating `base` by `exponent`.
 * 
 * Parameters:
 *    base - The base.
 *    exponent - The exponent.
 * Returns:
 *    The result of raising `base` to the `exponent` power.
 */
Method "_^_" is
[
	base : double,
	exponent : whole number
|
	/*  Uses the identities: b^(2x) = (b^2)^x; and: b^(2x+1) = (b^2)^x*b. */
	if exponent = 0 then
	[
		1.0
	]
	else
	[
		intermediate ::= (base × base) ^ (exponent ÷ 2);
		if exponent is odd then [ intermediate × base ] else [ intermediate ]
	]
] : double;

/**
 * Support exponentiation of ranges of integral arguments.  This could be useful
 * for semantic restrictions in clients that compose things with exponentiation.
 */
Method "_^_" is
[
	base : extended integer's type,
	power : whole number's type
|
	interestingBases ::= {
		⎣base⎦,
		⎣base⎦ + 1,
		-2,
		-1,
		0,
		1,
		2,
		⎡base⎤ - 1,
		⎡base⎤
	} → tuple;
	interestingPowers ::= {
		⎣power⎦,
		⎣power⎦ + 1,
		2,
		3,
		⎡power⎤ - 1 max 0,
		⎡power⎤
	} → tuple;
	augmentedBase ::= [⎣base⎦ .. ⎡base⎤];
	augmentedPower ::= [⎣power⎦ .. ⎡power⎤];
	range : extended integer's type := ⊥;
	openLimits : extended integer's type := ⊥;
	For each interestingBases do
	[
		interestingBase : extended integer
	|
		If interestingBase ∈ augmentedBase then
		[
			baseInclusive ::= interestingBase ∈ base;
			For each interestingPowers do
			[
				interestingPower : [0..∞]
			|
				If interestingPower ∈ augmentedPower then
				[
					Guard
					[
						value : extended integer := interestingBase ^ interestingPower;
						If baseInclusive ∧ [interestingPower ∈ power] then
						[
							range := range ∪ [value..value];
						]
						else
						[
							openLimits := openLimits ∪ [value..value];
						];
					]
					intercept
					[
						suppressed : exception
					|
						/* This particular combination would fail at runtime
						 * anyhow, so it doesn't contribute to the type.
						 */
					];
				];
			];
		];
	];
	if range = ⊥ then
	[
		(⎣openLimits⎦..⎡openLimits⎤)
	]
	else if [ -∞ ∈ openLimits ∧ [ ∞ ∈ openLimits ] ] then
	[
		range ∪ integer
	]
	else if [ -∞ ∈ openLimits ] then
	[
		range ∪ (-∞..⎡range⎤)
	]
	else if [ ∞ ∈ openLimits ] then
	[
		range ∪ (⎣range⎦..∞)
	]
	else
	[
		range
	]
] : extended integer's type;


/**
 * Restrict integral exponentiation, in particular when the power is a whole
 * number.
 */
Semantic restriction "_^_" is
[
	base : extended integer's type,
	power : whole number's type
|
	base ^ power
];
