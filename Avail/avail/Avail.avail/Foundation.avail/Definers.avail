/*
 * Definers.avail
 * Copyright © 1993-2014, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Definers"
Versions
	"dev"
Extends
	"Early Definers"
Uses
	"Bootstrap",
	"Early Control Structures",
	"Early Enumeration Support",
	"Early Literals",
	"Phrases"
Names
	"Method_is stable at_",
	"Private stable abstract method_is_",
	"Private stable forward method_is_",
	"Private stable method_is_",
	"Public stable abstract method_is_",
	"Public stable forward method_is_",
	"Public stable method_is_",
	"Public read-only variable_is_",
	"Public variable_is_",
	"Stable abstract method_is_",
	"Stable forward method_is_",
	"Stable method_is_"
Body

/**
 * Utility method for "Method_is stable at_".  Test whether the tuple of types
 * have exactly one instance each.  Even though ⊥'s type is technically a
 * metatype rather than a pure enumeration, it only has one instance (⊥).
 * 
 * @method "«_‡,»are all singular"
 * @returns "boolean"
 */
Private method "«_‡,»are all singular" is
[
	argTypes : <<>, type…|whole number>
|
	$method : boolean;
	From 1 to |argTypes| do
	[
		index : natural number
	|
		argType ::= cast argTypes[index] into [t : type | t];
		If (|argType| = 1) = false then
		[
			Exit method with false
		];
		if (argType's instance ∈ type) = false then
		[
			true
		]
		else
		[
			if argType = ⊥'s type's type then
			[
				true
			]
			else
			[
				Exit method with false
			]
		]
	];
	true
] : boolean;

/* These methods are needed for autogeneration of stable method restrictions. */
ifThenElseAtom ::= atom for "If|if_then_else_";
instanceAtom ::= atom for "_'s⁇instance";
typeAtom ::= atom for "_'s⁇type";
areAllSingularAtom ::= atom for "«_‡,»are all singular";

/**
 * Declare that the method referenced by `methodName` is stable for the given
 * signature. A stable method produces the same value for the same arguments on
 * every call. Automatically generate and install a semantic restriction that
 * will statically strengthen the answer produced at a call site to a precisely
 * known value when all arguments are themselves precisely known.
 * 
 * @method "Method_is stable at_"
 * @param "methodName" "string"
 *        The name of the stable method.
 * @param "functionType" "function meta"
 *        The signature of the method that is being declared stable.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Method_is stable at_" is
[
	methodName : atom,
	functionType : function meta
|
	/* The goal is to take an invocation like:
	 *
	 *    Method "_[_]→_" is stable at [tuple, natural number, any]→tuple;
	 *
	 * And automatically generate something like this:
	 *
	 *    Semantic restriction "_[_]→_" is
	 *    [
	 *        arg1 : tuple's type,
	 *        arg2 : natural number's type,
	 *        arg3 : any's type
	 *    |
	 *        if <arg1, arg2, arg3> are all singular
	 *        [
	 *            (arg1's instance[arg2's instance]→arg3's instance)'s type
	 *        ]
	 *        else
	 *        [
	 *            ⊤
	 *        ]
	 *    ] : type;
	 *
	 * TODO: [TLS] Should the method name contain any lexical groups, then we
	 * have to do something more complex:
	 * 
	 *    Semantic restriction "«_‡++»" is
	 *    [
	 *       arg1 : <tuple…|[2..∞)>'s type
	 *    |
	 *        /* `counts` is initialized to the instance counts of the arguments
	 *         * that do not correspond to lexical groups. (In this case, there
	 *         * aren't any, so use the empty set.)
	 *         */
	 *        counts : set := ∅;
	 *        /* There will be one such loop for each argument that corresponds
	 *         * to a lexical group.
	 *         */
	 *        From 1 to |arg1| do
	 *        [
	 *            index : natural number
	 *        |
	 *            counts := eject ↑counts + |arg1[index]|;
	 *            true
	 *        ];
	 *        if counts = {1} then
	 *        [
	 *            /* There will be one such loop for each argument that
	 *             * corresponds to a lexical group.
	 *             */
	 *            instances1 : tuple := <>;
	 *            From 1 to |arg1| do
	 *            [
	 *                index : natural number
	 *            |
	 *                instances1 :=
	 *                    eject ↑instances1 ++ <arg1[index]'s instance>;
	 *                true;
	 *            ];
	 *            theMethod ::= method for atom for "«_‡++»";
	 *            (Invoke implementation of theMethod for <arg1>
	 *                with <instances1>)'s type
	 *        ]
	 *        else
	 *        [
	 *            ⊤
	 *        ]
	 *    ] : type;
	 *
	 * The code below generalizes the above to any method name and set of
	 * parameter types. Note that we do not actually have to synthesize an
	 * invocation of "(_)" or "<«_‡,»>".
	 */
	resultType ::= functionType's return type's type;
	argDecls : <<>, argument phrase…|whole number> := <>;
	argUses : <<>, variable use phrase…|whole number> := <>;
	instances : <<>, send phrase⇒any…|whole number> := <>;
	/* Construct the tuples of argument declarations, argument uses, and
	 * expressions to extract the singular instances.
	 */
	From 1 to |message methodName's name's parameters| do
	[
		index : natural number
	|
		argName ::= cast concatenate <"arg", “index”> into [t : string | t];
		argType ::= functionType[index];
		argToken ::= `argName`;
		argDecl ::= arg «argToken : argType's type»;
		argDecls := cast concatenate <eject ↑argDecls, <argDecl>>
			into [t : <<>, argument phrase…|whole number> | t];
		argUse ::= «↓argDecl»(`argToken`);
		argUses := cast concatenate <eject ↑argUses, <argUse>>
			into [t : <<>, variable use phrase…|whole number> | t];
		instance ::= send instanceAtom with «<argUse>» : argType;
		instances := cast concatenate <eject ↑instances, <instance>>
			into [t : <<>, send phrase⇒any…|whole number> | t];
		true
	];
	instanceCheck ::=
		send areAllSingularAtom
		with «<argUses → list phrase>»
		: boolean;
	answer ::= send methodName with instances → list phrase : any;
	answerType ::= send typeAtom with «<answer>» : resultType;
	answerTypeBlock ::= «[<answerType>] : resultType»;
	cantStrengthenBlock ::= «[<‘`⊤`’>] : ⊤'s type»;
	branch ::= send ifThenElseAtom
		with «<instanceCheck, answerTypeBlock, cantStrengthenBlock>» : type;
	restrictionBlock ::= «[argDecls | <branch>] : type»;
	restrictionFunction ::= generate restrictionBlock;
	Semantic restriction methodName is restrictionFunction;
] : ⊤;

/**
 * Declare that the method referenced by `methodName` is stable for the given
 * signature. A stable method produces the same value for the same arguments on
 * every call. Automatically generate and install a semantic restriction that
 * will statically strengthen the answer produced at a call site to a precisely
 * known value when all arguments are themselves precisely known.
 * 
 * @method "Method_is stable at_"
 * @param "methodName" "string"
 *        The name of the stable.
 * @param "functionType" "function meta"
 *        The signature of the method that is being declared stable.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Method_is stable at_" is
[
	methodName : string,
	functionType : function meta
|
	methodAtom ::= atom for methodName;
	Method methodAtom is stable at functionType;
] : ⊤;

/**
 * Reject the current parse if the specified message specifies any lexical
 * groups. Take no action if the actual message is not available.
 * 
 * @method "Require:message_does not specify lexical groups"
 * @param "nameType" "string's type"
 *        The type of the method name.
 * @returns "⊤"
 */
Private method "Require:message_does not specify lexical groups" is
[
	nameType : string's type
|
	If |nameType| = 1 then
	[
		methodName ::= cast nameType's instance into [ t : string | t ];
		If message methodName contains groups then
		[
			messageTuple ::= concatenate <
				"message name (",
				“methodName”,
				") must not specify lexical groups">;
			Invoke
			[
				messageString : string
			|
				Reject parse, expected: messageString
			]
			with <messageTuple>
		];
	];
] : ⊤;

/**
 * Reject the current parse if any of the argument's parameter types are
 * metatypes, i.e., the actual argument is a type, or function types. Take no
 * action if the argument's parameter types are not available.
 * 
 * @method "Require:_'s⁇parameters are not metatypes or function types"
 * @param "functionType" "function meta"
 *        A function type.
 * @returns "⊤"
 */
Private method "Require:_'s⁇parameters are not metatypes or function types" is
[
	functionType : function meta
|
	parametersType ::= functionType's parameters' type;
	cast ||parametersType||'s genuine upper bound into
	[
		limit : whole number
	|
		From 1 to limit do
		[
			index : natural number
		|
			parameterType ::= parametersType[index];
			If parameterType = ⊥ then
			[
				/* Can't tell anything about this argument. */
			]
			else
			[
				If parameterType ⊆ type then
				[
					messageTuple ::= concatenate <
						"parameter type (",
						“parameterType”,
						") not to be a metatype; metacovariance will allow \
						\|subtypes of this type, causing the operation not to \
						\|be stable">;
					Invoke
					[
						messageString : string
					|
						Reject parse, expected: messageString
					]
					with <messageTuple>
				];
				If parameterType ⊆ function then
				[
					messageTuple ::= concatenate <
						"parameter type (",
						“parameterType”,
						") not to be a function type">;
					Invoke
					[
						messageString : string
					|
						Reject parse, expected: messageString
					]
					with <messageTuple>
				];
			];
			true
		];
	]
	else
	[
		/* Can't check the parameter types. */
	];
] : ⊤;

/**
 * If possible, then ensure that the parameters are not types; because of
 * metacovariance, the operation would not actually be stable.
 * 
 * @method "Method_is stable at_"
 * @restricts "string's type"
 * @restricts "function meta"
 */
Semantic restriction "Method_is stable at_" is
[
	nameType : string's type,
	functionType : function meta
|
	Require: message nameType does not specify lexical groups;
	Require: functionType's parameters are not metatypes or function types;
	⊤
];

/**
 * Declare a new abstract stable method with the specified name and signature. A
 * concrete implementation is one whose parameter types and return type are
 * strictly more specific than the corresponding types of the abstract
 * signature. A stable method produces the same value for the same arguments on
 * every call. Automatically generate and install a semantic restriction that
 * will statically strengthen the answer produced at a call site to a precisely
 * known value when all arguments are themselves precisely known.
 *
 * @method "Stable abstract method_is_"
 * @param "methodName" "string"
 *        The name of the abstract method to declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Stable abstract method_is_" is
[
	methodName : string,
	aFunctionType : function meta
|
	Abstract method methodName is aFunctionType;
	Method methodName is stable at aFunctionType;
] : ⊤;

/**
 * @method "Stable abstract method_is_"
 * @restricts "string's type"
 * @restricts "function meta's type"
 */
Semantic restriction "Stable abstract method_is_" is
[
	nameType : string's type,
	functionMeta : function meta's type
|
	Require: message nameType does not specify lexical groups;
	If |functionMeta| = 1 then
	[
		functionType ::= cast functionMeta's instances→tuple[1] into
			[ t : function meta | t ];
		Require: functionType's parameters are not metatypes or function types;
	];
	⊤
];

/**
 * Declare the intention to locally define a method with the specified name and
 * signature. If no such method is defined before compilation of the containing
 * module completes, then the compiler will emit an appropriate error message.
 *
 * Recursive methods must be forward declared. Mutually recursive methods must
 * forward declare all but the lexically first participant in the recursion.
 * 
 * Also declare that the method is stable A stable method produces the same
 * value for the same arguments on every call. Automatically generate and
 * install a semantic restriction that will statically strengthen the answer
 * produced at a call site to a precisely known value when all arguments are
 * themselves precisely known.
 *
 * @method "Stable forward method_is_"
 * @param "methodName" "string"
 *        The name of the method to forward declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Stable forward method_is_" is
[
	methodName : string,
	aFunctionType : function meta
|
	Forward method methodName is aFunctionType;
	Method methodName is stable at aFunctionType;
] : ⊤;

/**
 * 
 * @method "Stable forward method_is_"
 * @restricts "string's type"
 * @restricts "function meta's type"
 */
Semantic restriction "Stable forward method_is_" is
[
	nameType : string's type,
	functionMeta : function meta's type
|
	Require: message nameType does not specify lexical groups;
	If |functionMeta| = 1 then
	[
		functionType ::= cast functionMeta's instances→tuple[1] into
			[ t : function meta | t ];
		Require: functionType's parameters are not metatypes or function types;
	];
	⊤
];

/**
 * Define a new stable method. A stable method produces the same value for the
 * same arguments on every call. Automatically generate and install a semantic
 * restriction that will statically strengthen the answer produced at a call
 * site to a precisely known value when all arguments are themselves precisely
 * known.
 * 
 * @method "Stable method_is_"
 * @param "methodName" "string"
 *        The name of the new method.
 * @param "implementation" "function"
 *        An implementation of the method.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Stable method_is_" is
[
	methodName : string,
	implementation : function
|
	Method methodName is implementation;
	Method methodName is stable at implementation's type;
];

/**
 * @method "Stable method_is_"
 * @restricts "string's type"
 * @restricts "function meta"
 */
Semantic restriction "Stable method_is_" is
[
	nameType : string's type,
	functionType : function meta
|
	Require: message nameType does not specify lexical groups;
	Require: functionType's parameters are not metatypes or function types;
	⊤
];

/**
 * Declare a new public abstract stable method with the specified name and
 * signature. A concrete implementation is one whose parameter types and return
 * type are strictly more specific than the corresponding types of the abstract
 * signature. A stable method produces the same value for the same arguments on
 * every call. Automatically generate and install a semantic restriction that
 * will statically strengthen the answer produced at a call site to a precisely
 * known value when all arguments are themselves precisely known. The semantic
 * restriction ensures that the method is named in the current module's "Names"
 * section. This should not be used to extend existing methods.
 *
 * @method "Public stable abstract method_is_"
 * @param "methodName" "string"
 *        The name of the abstract method to declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Public stable abstract method_is_" is
[
	methodName : string,
	aFunctionType : function meta
|
	Abstract method methodName is aFunctionType;
	Method methodName is stable at aFunctionType;
] : ⊤;

/**
 * Ensure that the new method is introduced by the module's "Names" section.
 * 
 * @method "Public stable abstract method_is_"
 * @restricts "string's type"
 * @restricts "function meta's type"
 */
Semantic restriction "Public stable abstract method_is_" is
[
	nameType : string's type,
	functionMeta : function meta's type
|
	Require: nameType is public;
	Require: message nameType does not specify lexical groups;
	If |functionMeta| = 1 then
	[
		functionType ::= cast functionMeta's instances→tuple[1] into
			[ t : function meta | t ];
		Require: functionType's parameters are not metatypes or function types;
	];
	⊤
];

/**
 * Declare the intention to locally define a public method with the specified
 * name and signature. If no such method is defined before compilation of the
 * containing module completes, then the compiler will emit an appropriate error
 * message.
 *
 * Recursive methods must be forward declared. Mutually recursive methods must
 * forward declare all but the lexically first participant in the recursion.
 * 
 * Also declare that the method is stable A stable method produces the same
 * value for the same arguments on every call. Automatically generate and
 * install a semantic restriction that will statically strengthen the answer
 * produced at a call site to a precisely known value when all arguments are
 * themselves precisely known.
 *
 * The semantic restriction ensures that the method is named in the current
 * module's "Names" section.
 * 
 * This should not be used to extend existing methods.
 *
 * @method "Public stable forward method_is_"
 * @param "methodName" "string"
 *        The name of the method to forward declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Public stable forward method_is_" is
[
	methodName : string,
	aFunctionType : function meta
|
	Forward method methodName is aFunctionType;
	Method methodName is stable at aFunctionType;
] : ⊤;

/**
 * Ensure that the new method is introduced by the module's "Names" section.
 * 
 * @method "Public stable forward method_is_"
 * @restricts "string's type"
 * @restricts "function meta's type"
 */
Semantic restriction "Public stable forward method_is_" is
[
	nameType : string's type,
	functionMeta : function meta's type
|
	Require: nameType is public;
	Require: message nameType does not specify lexical groups;
	If |functionMeta| = 1 then
	[
		functionType ::= cast functionMeta's instances→tuple[1] into
			[ t : function meta | t ];
		Require: functionType's parameters are not metatypes or function types;
	];
	⊤
];

/**
 * Define a new public stable method. A stable method produces the same value
 * for the same arguments on every call. Automatically generate and install a
 * semantic restriction that will statically strengthen the answer produced at a
 * call site to a precisely known value when all arguments are themselves
 * precisely known. The semantic restriction ensures that the method is named in
 * the current module's "Names" section. This should not be used to extend
 * existing methods.
 * 
 * @method "Public stable method_is_"
 * @param "methodName" "string"
 *        The name of the new method.
 * @param "implementation" "function"
 *        The original implementation of the method.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Public stable method_is_" is
[
	methodName : string,
	implementation : function
|
	Method methodName is implementation;
	Method methodName is stable at implementation's type;
];

/**
 * Ensure that the new method is introduced by the module's "Names" section.
 * 
 * @method "Public stable method_is_"
 * @restricts "string's type"
 * @restricts "function meta"
 */
Semantic restriction "Public stable method_is_" is
[
	nameType : string's type,
	functionType : function meta
|
	Require: nameType is public;
	Require: message nameType does not specify lexical groups;
	Require: functionType's parameters are not metatypes or function types;
	⊤
];

/**
 * Declare a new private abstract stable method with the specified name and
 * signature. A concrete implementation is one whose parameter types and return
 * type are strictly more specific than the corresponding types of the abstract
 * signature. A stable method produces the same value for the same arguments on
 * every call. Automatically generate and install a semantic restriction that
 * will statically strengthen the answer produced at a call site to a precisely
 * known value when all arguments are themselves precisely known. The semantic
 * restriction ensures that the method is not named in the current module's
 * "Names" section. This should not be used to extend existing methods.
 *
 * @method "Private stable abstract method_is_"
 * @param "methodName" "string"
 *        The name of the abstract method to declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Private stable abstract method_is_" is
[
	methodName : string,
	aFunctionType : function meta
|
	Abstract method methodName is aFunctionType;
	Method methodName is stable at aFunctionType;
] : ⊤;

/**
 * Ensure that the new method is not introduced by the module's "Names" section.
 * 
 * @method "Private stable abstract method_is_"
 * @restricts "string's type"
 * @restricts "function meta's type"
 */
Semantic restriction "Private stable abstract method_is_" is
[
	nameType : string's type,
	functionMeta : function meta's type
|
	Require: nameType is private;
	Require: message nameType does not specify lexical groups;
	If |functionMeta| = 1 then
	[
		functionType ::= cast functionMeta's instances→tuple[1] into
			[ t : function meta | t ];
		Require: functionType's parameters are not metatypes or function types;
	];
	⊤
];

/**
 * Declare the intention to locally define a private method with the specified
 * name and signature. If no such method is defined before compilation of the
 * containing module completes, then the compiler will emit an appropriate error
 * message.
 *
 * Recursive methods must be forward declared. Mutually recursive methods must
 * forward declare all but the lexically first participant in the recursion.
 * 
 * Also declare that the method is stable A stable method produces the same
 * value for the same arguments on every call. Automatically generate and
 * install a semantic restriction that will statically strengthen the answer
 * produced at a call site to a precisely known value when all arguments are
 * themselves precisely known.
 * 
 * The semantic restriction ensures that the method is not named in the current
 * module's "Names" section.
 * 
 * This should not be used to extend existing methods.
 *
 * @method "Private stable forward method_is_"
 * @param "methodName" "string"
 *        The name of the method to forward declare.
 * @param "aFunctionType" "function meta"
 *        The signature.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Private stable forward method_is_" is
[
	methodName : string,
	aFunctionType : function meta
|
	Forward method methodName is aFunctionType;
	Method methodName is stable at aFunctionType;
] : ⊤;

/**
 * Ensure that the new method is not introduced by the module's "Names" section.
 * 
 * @method "Private stable forward method_is_"
 * @restricts "string's type"
 * @restricts "function meta's type"
 */
Semantic restriction "Private stable forward method_is_" is
[
	nameType : string's type,
	functionMeta : function meta's type
|
	Require: nameType is private;
	Require: message nameType does not specify lexical groups;
	If |functionMeta| = 1 then
	[
		functionType ::= cast functionMeta's instances→tuple[1] into
			[ t : function meta | t ];
		Require: functionType's parameters are not metatypes or function types;
	];
	⊤
];

/**
 * Define a new private stable method. A stable method produces the same value
 * for the same arguments on every call. Automatically generate and install a
 * semantic restriction that will statically strengthen the answer produced at a
 * call site to a precisely known value when all arguments are themselves
 * precisely known. The semantic restriction ensures that the method is not
 * named in the current module's "Names" section. This should not be used to
 * extend existing methods.
 * 
 * @method "Private stable method_is_"
 * @param "methodName" "string"
 *        The name of the new method.
 * @param "implementation" "function"
 *        The original implementation of the method.
 * @returns "⊤"
 * @category "Declarations" "Methods"
 */
Public method "Private stable method_is_" is
[
	methodName : string,
	implementation : function
|
	Method methodName is implementation;
	Method methodName is stable at implementation's type;
];

/**
 * Ensure that the new method is not introduced by the module's "Names" section.
 * 
 * @method "Private stable method_is_"
 * @restricts "string's type"
 * @restricts "function meta"
 */
Semantic restriction "Private stable method_is_" is
[
	nameType : string's type,
	functionType : function meta
|
	Require: nameType is private;
	Require: message nameType does not specify lexical groups;
	Require: functionType's parameters are not metatypes or function types;
	⊤
];

/**
 * Define a new public variable. Automatically generate an accessor and a
 * mutator. The semantic restriction ensures that these methods are named in the
 * current module's "Names" section.
 *
 * @method "Public variable_is_"
 * @param "var" "variable"
 *        The variable for which an accessor and a mutator should be generated.
 * @param "accessorName" "string"
 *        The name of the accessor. The name of the mutator will be 
 *        {@param "accessorName"} ++ ":=_".
 * @returns "⊤"
 * @category "Declarations" "Variables"
 */
Public method "Public variable_is_" is
[
	var : variable,
	accessorName : string
|
	readType ::= cast var's type's read type into [t : any's type | t];
	writeType ::= cast var's type's write type into [t : any's type | t];
	Method accessorName is
		new function accepting <> and returning readType
		applying [ ↓var ];
	Method cast concatenate <accessorName, ":=_"> into [t : string | t] is
		new function accepting <writeType> and returning ⊤
		applying [t : any | ↓var ?= t;];
] : ⊤;

/**
 * Ensure that the new methods are introduced by the module's "Names" section.
 * 
 * @method "Public variable_is_"
 * @restricts "variable meta"
 * @restricts "string's type"
 */
Semantic restriction "Public variable_is_" is
[
	var : variable meta,
	nameType : string's type
|
	Require: nameType is public;
	If |nameType| = 1 then
	[
		accessorName ::= cast nameType's instance into [t : string | t];
		mutatorName ::= cast concatenate <accessorName, ":=_">
			into [t : string | t];
		Require: mutatorName's type is public;
	];
	⊤
];

/**
 * Define a new public variable. Automatically generate an accessor. The
 * semantic restriction ensures that these methods are named in the current
 * module's "Names" section.
 *
 * @method "Public read-only variable_is_"
 * @param "var" "variable"
 *        The variable for which an accessor should be generated.
 * @param "accessorName" "string"
 *        The name of the accessor.
 * @returns "⊤"
 * @category "Declarations" "Variables"
 */
Public method "Public read-only variable_is_" is
[
	var : variable,
	accessorName : string
|
	readType ::= cast var's type's read type into [t : any's type | t];
	Method accessorName is
		new function accepting <> and returning readType
		applying [ ↓var ];
] : ⊤;

/**
 * Ensure that the new methods are introduced by the module's "Names" section.
 * 
 * @method "Public variable_is_"
 * @restricts "variable meta"
 * @restricts "string's type"
 */
Semantic restriction "Public read-only variable_is_" is
[
	var : variable meta,
	nameType : string's type
|
	Require: nameType is public;
	⊤
];
