/*
 * Concurrency.avail
 * Copyright © 1993-2014, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Concurrency"
Versions
	"dev"
Uses
	"Atoms",
	"Bootstrap",
	"Collections",
	"Control Structures",
	"Definers",
	"Enumeration Support",
	"Exceptions",
	"Functions",
	"Literals",
	"Logic",
	"Math",
	"Objects",
	"Synchronization",
	"Tuples",
	"Types",
	"Variables"
Names
	/* Fiber-local variable access. */
	"current fiber[_]else_",

	/* Simplified forking. */
	"Fork_",
	"fork_",

	/* Parallel constructs. */
	"For each of⁇_in parallel do_",
	"map_in parallel through_",

	/* Futures. */
	"Cancel_",
	"future",
	"future of_",
	"the future of_",

	/* Exceptions. */
	"worker exception"
Body

/**
 * @method "_'s⁇result"
 * @restricts "filber's type"
 */
Semantic restriction "_'s⁇result" is
[
	fiberType : fiber's type
|
	fiberType's result type
];

/**
 * Require that the specified function type is applicable to the specified
 * argument types. If the function type is not sufficiently well known, then
 * no checks are possible. Otherwise, reject a parse if appropriate.
 *
 * @method "Require:_accepts_"
 * @param "functionType" "function's type"
 * @param "argumentsType" "tuple's type"
 */
Private method "Require:forked_accepts_" is
[
	functionType : function's type,
	argumentsType : tuple's type
|
	parametersType ::= functionType's parameters' type;
	parametersSizes ::= ||parametersType||;
	/* If `parameterSizes` = ⊥, then `parametersType` = ⊥. In this case, we
	 * cannot statically ascertain anything interesting about the function and
	 * the arguments to apply.
	 */
	If parametersSizes ≠ ⊥ then
	[
		argumentsSizes ::= ||argumentsType||;
		validSizes ::= parametersSizes ∩ argumentsSizes;
		If validSizes = ⊥ then
		[
			Reject parse, expected:
				"size of argument tuple to be compatible with size of applied\
				\| function's parameter tuple"
		];
	];
];

/**
 * @method "Invoke_with_,⁇forked at priority_"
 * @restricts "function's type"
 * @restricts "tuple's type"
 * @restricts "[0..255]'s type"
 */
Semantic restriction "Invoke_with_,⁇forked at priority_" is
[
	functionType : function's type,
	argumentsType : tuple's type,
	priorityType : [0..255]'s type
|
	Require: forked functionType accepts argumentsType;
	⊤
];

/**
 * @method "invoke_with_,⁇forked at priority_"
 * @restricts "function's type"
 * @restricts "tuple's type"
 * @restricts "[0..255]'s type"
 */
Semantic restriction "invoke_with_,⁇forked at priority_" is
[
	functionType : function's type,
	argumentsType : tuple's type,
	priorityType : [0..255]'s type
|
	Require: forked functionType accepts argumentsType;
	fiber→(functionType's return type)
];

/**
 * @method "In_millisecond|milliseconds,⁇invoke_with_,⁇forked at priority_"
 * @restricts "[0..∞]'s type"
 * @restricts "function's type"
 * @restricts "tuple's type"
 * @restricts "[0..255]'s type"
 */
Semantic restriction
	"In_millisecond|milliseconds,⁇invoke_with_,⁇forked at priority_"
is
[
	delayType : [0..∞]'s type,
	functionType : function's type,
	argumentsType : tuple's type,
	priorityType : [0..255]'s type
|
	Require: forked functionType accepts argumentsType;
	⊤
];

/**
 * @method "in_millisecond|milliseconds,⁇invoke_with_,⁇forked at priority_"
 * @restricts "[0..∞]'s type"
 * @restricts "function's type"
 * @restricts "tuple's type"
 * @restricts "[0..255]'s type"
 */
Semantic restriction
	"in_millisecond|milliseconds,⁇invoke_with_,⁇forked at priority_"
is
[
	delayType : [0..∞]'s type,
	functionType : function's type,
	argumentsType : tuple's type,
	priorityType : [0..255]'s type
|
	Require: forked functionType accepts argumentsType;
	fiber→(functionType's return type)
];

/* Disambiguate fiber-local access and atom property access. They are already
 * disambiguated by types, so this is not strictly necessary.
 */

/**
 * @method "Remove_[_]"
 * @forbids 1 "current fiber"
 */
Grammatical restriction "Remove_[_]" is <{"current fiber"}, ∅>;

/**
 * @method "_[_]"
 * @forbids 1 "current fiber"
 */
Grammatical restriction "_[_]" is <{"current fiber"}, ∅>;

/**
 * @method "_[_]else_"
 * @forbids 1 "current fiber"
 */
Grammatical restriction "_[_]else_" is <{"current fiber"}, ∅, ∅>;

/**
 * @method "_[_]:=_"
 * @forbids 1 "current fiber"
 */
Grammatical restriction "_[_]:=_" is <{"current fiber"}, ∅, ∅>;

/**
 * @method "_∈_"
 * @forbids 2 "current fiber"
 */
Grammatical restriction "_∈_" is <∅, {"current fiber"}>;

/**
 * Answer the value associated with the property {@param "key"} of {@param
 * "aFiber"}. If no such property exists, then answer the result of applying
 * {@param "else"}.
 *
 * @method "_[_]else_"
 * @param "aFiber" "fiber"
 *        A fiber.
 * @param "key" "atom"
 *        The property key.
 * @param "else" "[]→any"
 *        The function to apply if {@param "key"} is not a property of {@param
 *        "aFiber"}.
 * @returns Either the requested property value or the result of applying
 *          {@param "else"}.
 */
Method "current fiber[_]else_" is
[
	key : atom,
	else : []→any
|
	if key ∈ current fiber
	then [current fiber[key]]
	else else
] : any;

/**
 * Fork a new {@type "fiber"} to apply the specified arity-0 {@type "function"}.
 * The new fiber will run at the same {@method "_'s⁇priority" priority} as the
 * {@method "current fiber"}.
 *
 * @method "Fork_"
 * @param "aFunction" "[]→⊤"
 */
Public method "Fork_" is
[
	aFunction : []→⊤
|
	Invoke aFunction with <> forked at priority current fiber's priority;
] : ⊤;

/**
 * Fork a new {@type "fiber"} to apply the specified arity-0 {@type "function"}.
 * The new fiber will run at the same {@method "_'s⁇priority" priority} as the
 * {@method "current fiber"}.
 *
 * @method "Fork_"
 * @param "aFunction" "[]→⊤"
 * @returns "fiber"
 *          The new fiber.
 */
Public method "fork_" is
[
	aFunction : []→⊤
|
	invoke aFunction with <> forked at priority current fiber's priority
] : fiber;

/**
 * @method "fork_"
 * @restricts "[]→⊤'s type"
 */
Semantic restriction "fork_" is
[
	functionType : []→⊤'s type
|
	fiber→(functionType's return type)
];

/**
 * A worker exception indicates that a worker forked by a parallel construct
 * raised an exception.
 *
 * @type "worker exception"
 * @supertype "cascade exception"
 */
Public explicit class "worker exception" extends cascade exception;

"expected type" is a new field atom;
"future monitor" is a new field atom;
"completeness" is a new field atom;
"worker fiber" is a new field atom;
"product" is a new field atom;
"killer" is a new field atom;

/**
 * A future is a proxy for an operation that may not have completed yet. If
 * asked for its value prematurely, then it will block the current fiber until
 * the value becomes available.
 *
 * @type "future"
 * @supertype "object"
 */
Public class "future" extends object
	with fields
		expected type : any's type,
		future monitor : monitor,
		completeness : condition
	with mutable fields
		referable worker fiber : fiber,
		product : any,
		referable killer : exception;

/**
 * Construct and answer a future type that answers futures that produce values
 * of the specified type.
 *
 * @method "future of_"
 * @param "expectedType" "any's type"
 *        The type of value produced by futures of the answered type.
 * @returns "future's type"
 *          The requested future type.
 */
Public method "future of_" is
[
	expectedType : any's type
|
	extend future with expected type : expectedType's type
] : future's type;

/**
 * Answer the {@type "future"} of applying the specified {@type "function"} in
 * a new {@type "fiber"}.
 *
 * @method "the future of_"
 * @param "aFunction" "[]→any"
 *        The future whose result is desired.
 * @returns "future"
 *          The requested future.
 */
Public method "the future of_" is
[
	aFunction : []→any
|
	result : any;
	ex : exception;
	worker : fiber;
	mutex ::= a monitor named "future monitor";
	cond ::= a condition of mutex is [↑ex is assigned ∨ [↑result is assigned]];
	worker :=
		fork
		[
			Raise termination-requested exception if appropriate;
			Lock mutex for
			[
				Guard [result := aFunction();]
				intercept [e : exception | ex := e;]
				ensure
				[
					/* Discard the fiber, to be nice to memory. */
					Clear ↑worker;
					Signal cond;
				];
			];
		];
	a future with
		expected type ::= aFunction's type's return type,
		future monitor ::= mutex,
		completeness ::= cond,
		worker fiber ::= ↑worker,
		product ::= ↑result,
		killer ::= ↑ex
] : future;

/**
 * @method "the future of_"
 * @restricts "[]→any's type"
 */
Semantic restriction "the future of_" is
[
	functionType : []→any's type
|
	extend future with expected type : functionType's return type's type
];

/**
 * Obtain the value of the specified {@type "future"}, parking the current fiber
 * until a value is available if necessary. This method is idempotent.
 *
 * @method "_'s⁇value"
 * @param "aFuture" "future"
 * @returns "any"
 *          The result produced by the future.
 * @raises "worker exception"
 *         If the {@type "fiber"} forked to evaluate the future raised an
 *         {@type "exception"}.
 */
Method "_'s⁇value" is
[
	aFuture : future
|
	lock aFuture's future monitor for
	[
		Await aFuture's completeness;
		If ↑aFuture's killer is assigned then
		[
			Raise a worker exception with
				causal exception ::= aFuture's killer
		];
		aFuture's product
	]
] : any;

/**
 * @method "_'s⁇value"
 * @restricts "future's type"
 */
Semantic restriction "_'s⁇value" is
[
	futureType : future's type
|
	futureType's expected type's instance
];

/**
 * Cancel evaluation of the specified {@type "future"}. Cancellation is
 * best-effort only; the {@type "fiber"} responsible for evaluation of the
 * future is not obligated to honor a termination request. Cancellation of a
 * resolved future has no effect. Only the first cancellation attempt is
 * permitted to have an effect. Subsequent cancellation attempts are silently
 * ignored.
 *
 * @method "Cancel_"
 * @param "aFuture" "future"
 */
Public method "Cancel_" is
[
	aFuture : future
|
	/* Opportunistically read the future's worker fiber. If the variable has
	 * become unassigned, then do nothing. Otherwise, clear the variable and
	 * request termination of the worker.
	 */
	Guard
	[
		worker ::= aFuture's worker fiber;
		Clear ↑aFuture's worker fiber;
		Request termination of worker;
	]
	intercept [e : cannot-read-unassigned-variable exception | /* Nothing. */];
] : ⊤;

/**
 * Concurrently apply {@param "action"} to each consecutive element of {@param
 * "aTuple"}. Wait until all forked fibers have completed before returning
 * control to the caller.
 * 
 * @method "For each of⁇_in parallel do_"
 * @param "aTuple" "tuple"
 * @param "action" "[⊥, ⊥]→⊤"
 *        A function that accepts 1) an element of the tuple and 2) the index of
 *        that element.
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @raises "termination-requested exception"
 *         If termination of the current fiber is requested during an internal
 *         synchronization operation.
 */
Public method "For each of⁇_in parallel do_" is
[
	aTuple : tuple,
	action : [⊥, ⊥]→⊤
|
	fibers : <fiber…|> := <>;
	/* Pre-increment the workers started counter, to prevent races between the
	 * master and the workers. This prevents a race between queuing workers and
	 * workers completing.
	 */
	workersStarted : whole number := 1;
	workersFinished : whole number := 0;
	/* The first exception raised by a worker fiber will be stored here. */
	killer : exception;
	/* This monitor controls the interaction between the master and the
	 * workers.
	 */
	mutex ::= a monitor named "parallel for-each monitor";
	done ::= a condition of mutex
		is [↑killer is assigned ∨ [workersStarted = workersFinished]];
	/* Fork a fiber for each element. */
	index : natural number := 1;
	end ::= |aTuple|;
	newFiberPriority ::= 0 max current fiber's priority - 1;
	[
		$loop;
		If index ≤ end then
		[
			Lock mutex for [↑workersStarted++;];
			element ::= aTuple[index];
			theIndex ::= index;
			newFiber ::=
				invoke
				[
					Guard
					[
						killed ::= lock mutex for [↑killer is assigned];
						If ¬killed then
						[
							action(element, theIndex);
							Lock mutex for
							[
								↑workersFinished++;
								Signal done if satisfied;
							];
						];
					]
					intercept
					[
						e : exception
					|
						Lock mutex for
						[
							/* Only capture the first exception. */
							If ↑killer is unassigned then
							[
								killer := e;
								Signal done;
							];
						];
					];
				]
				with <>,
				forked at priority newFiberPriority;
			newFiber's name := "parallel for-each fiber #" ++ “index”;
			fibers := eject ↑fibers ++ <newFiber>;
			↑index++;
			Restart loop
		];
	]();
	/* Increment the workers finished counter, to counteract the effect of the
	 * pre-increment of the workers started counter, and then await the
	 * condition.
	 */
	Lock mutex for
	[
		↑workersFinished++;
		Await done;
	];
	/* If there were any exceptions, then raise the one that was captured. */
	If ↑killer is assigned then
	[
		Raise a worker exception with causal exception ::= killer
	];
] : ⊤;

/**
 * Concurrently apply {@param "action"} to each consecutive element of {@param
 * "aTuple"}. Wait until all forked fibers have completed before returning
 * control to the caller.
 * 
 * @method "For each of⁇_in parallel do_"
 * @param "aTuple" "tuple"
 * @param "action" "[⊥]→⊤"
 *        A function that accepts the elements of the tuple.
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @raises "termination-requested exception"
 *         If termination of the current fiber is requested during an internal
 *         synchronization operation.
 */
Public method "For each of⁇_in parallel do_" is
[
	aTuple : tuple,
	action : [⊥]→⊤
|
	For each of aTuple in parallel do
	[
		element : any,
		ignoredIndex : natural number
	|
		action(element);
	];
] : ⊤;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * If the tuple is certainly nonempty and the function certainly does not
 * complete if applied, then answer ⊥.
 * 
 * @method "For each of⁇_in parallel do_"
 * @restricts "tuple meta"
 * @restricts "function meta"
 */
Semantic restriction "For each of⁇_in parallel do_" is
[
	tupleType : tuple meta,
	action : function meta
|
	Require: action accepts tupleType;
	if ⎣tupleType⎦ > 0 ∧ [action's return type = ⊥] then [⊥] else [⊤]
];

/**
 * Concurrently apply {@param "action"} to each key-value pair of {@param
 * "aMap"}. Wait until all forked fibers have completed before returning
 * control to the caller.
 * 
 * @method "For each of⁇_in parallel do_"
 * @param "aMap" "map"
 * @param "action" "[⊥, ⊥]→⊤"
 *        A function that accepts 1) a map key and 2) the value at that key
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @raises "termination-requested exception"
 *         If termination of the current fiber is requested during an internal
 *         synchronization operation.
 * @author "Richard Arriaga"
 */
Public method "For each of⁇_in parallel do_" is
[
	aMap : map,
	action : [⊥, ⊥]→⊤
|
	For each of aMap's bindings in parallel do
	[
		binding : <any…|2>
	|
		action(binding[1],binding[2]);
	];
] : ⊤;

/**
 * @method "For each of⁇_in parallel do_"
 * @restricts "map meta"
 * @restricts "[⊥, ⊥]→⊤'s type"
 */
Semantic restriction "For each of⁇_in parallel do_" is
[
	mapType : map meta,
	action : [⊥, ⊥]→⊤'s type
|
	Require: action accepts mapType;
	if ⎣mapType⎦ > 0 ∧ [ action's return type = ⊥ ] then
	[
		⊥
	]
	else
	[
		⊤
	]
];

/**
 * Concurrently apply {@param "action"} to each element of {@param
 * "aSet"}. Wait until all forked fibers have completed before returning
 * control to the caller.
 * 
 * @method "For each of⁇_in parallel do_"
 * @param "aSet" "set"
 * @param "action" "[⊥]→⊤"
 *        A function that accepts the elements of the set
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @raises "termination-requested exception"
 *         If termination of the current fiber is requested during an internal
 *         synchronization operation.
 * @author "Richard Arriaga"
 */
Public method "For each of⁇_in parallel do_" is
[
	aSet : set,
	action : [⊥]→⊤
|
	For each of aSet → tuple in parallel do
	[
		element : any
	|
		action(element);
	];
] : ⊤;

/**
 * @method "For each of⁇_in parallel do_"
 * @restricts "set meta"
 * @restricts "[⊥]→⊤'s type"
 */
Semantic restriction "For each of⁇_in parallel do_" is
[
	setType : set meta,
	action : [⊥]→⊤'s type
|
	Require: action accepts setType;
	if ⎣setType⎦ > 0 ∧ [ action's return type = ⊥ ] then
	[
		⊥
	]
	else
	[
		⊤
	]
];
	
/**
 * Concurrently apply {@param "transformer"} to each consecutive element of
 * {@param "aTuple"}, collecting the results into a new tuple (and preserving
 * ordering of the transformed elements). Answer this tuple.
 *
 * @method "map_in parallel through_"
 * @param "aTuple" "tuple"
 * @param "transformer" "[⊥, ⊥]→any"
 *        A function that accepts 1) an element of the tuple and 2) the index of
 *        that element.
 * @returns "tuple"
 *          A tuple of results of applications of {@param "transformer"} to the
 *          elements and indices of {@param "aTuple"}.
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @raises "termination-requested exception"
 *         If termination of the current fiber is requested during an internal
 *         synchronization operation.
 */
Public method "map_in parallel through_" is
[
	aTuple : tuple,
	transformer : [⊥, ⊥]→any
|
	fibers : <fiber…|> := <>;
	/* Pre-increment the workers started counter, to prevent races between the
	 * master and the workers. This prevents a race between queuing workers and
	 * workers completing.
	 */
	workersStarted : whole number := 1;
	workersFinished : whole number := 0;
	/* The first exception raised by a worker fiber will be stored here. */
	killer : exception;
	/* This monitor controls the interaction between the master and the
	 * workers.
	 */
	mutex ::= a monitor named "parallel map monitor";
	done ::= a condition of mutex
		is [↑killer is assigned ∨ [workersStarted = workersFinished]];
	/* Fork a fiber for each element. */
	index : natural number := 1;
	end ::= |aTuple|;
	newFiberPriority ::= 0 max current fiber's priority - 1;
	[
		$loop;
		If index ≤ end then
		[
			Lock mutex for [↑workersStarted++;];
			element ::= aTuple[index];
			theIndex ::= index;
			newFiber ::=
				invoke
				[
					guard
					[
						killed ::= lock mutex for [↑killer is assigned];
						if ¬killed then
						[
							result ::= transformer(element, theIndex);
							Lock mutex for
							[
								↑workersFinished++;
								Signal done if satisfied;
							];
							result
						]
						/* Doesn't matter what we actually answer here, since
						 * the value will never be read by the master.
						 */
						else [0]
					]
					intercept
					[
						e : exception
					|
						Lock mutex for
						[
							/* Only capture the first exception. */
							If ↑killer is unassigned then
							[
								killer := e;
								Signal done;
							];
						];
						/* Doesn't matter what we actually answer here, since
						 * the value will never be read by the master.
						 */
						0
					]
				]
				with <>,
				forked at priority newFiberPriority;
			newFiber's name := "parallel map fiber #" ++ “index”;
			fibers := eject ↑fibers ++ <newFiber>;
			↑index++;
			Restart loop
		];
	]();
	result : tuple := <>;
	/* Increment the workers finished counter, to counteract the effect of the
	 * pre-increment of the workers started counter, and then await the
	 * condition.
	 */
	Lock mutex for
	[
		↑workersFinished++;
		Await done;
	];
	/* If there were any exceptions, then raise the one that was captured. */
	If ↑killer is assigned then
	[
		Raise a worker exception with causal exception ::= killer
	];
	/* Otherwise, collect the results into a tuple. */
	index := 1;
	[
		$loop;
		If index ≤ end then
		[
			aFiber ::= fibers[index];
			/* Make sure that the fiber has actually exited; it may only have
			 * signaled, but not exited yet.
			 */
			Join aFiber, then honor a termination request;
			result := eject ↑result ++ <aFiber's result>;
			↑index++;
			Restart loop
		];
	]();
	result
];

/**
 * Concurrently apply {@param "transformer"} to each consecutive element of
 * {@param "aTuple"}, collecting the results into a new tuple (and preserving
 * ordering of the transformed elements). Answer this tuple.
 *
 * @method "map_in parallel through_"
 * @param "aTuple" "tuple"
 * @param "transformer" "[⊥]→any"
 *        A function that accepts an element of the tuple.
 * @returns "tuple"
 *          A tuple of results of applications of {@param "transformer"} to the
 *          elements of {@param "aTuple"}.
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @raises "termination-requested exception"
 *         If termination of the current fiber is requested during an internal
 *         synchronization operation.
 */
Public method "map_in parallel through_" is
[
	aTuple : tuple,
	transformer : [⊥]→any
|
	map aTuple in parallel through
	[
		element : any,
		ignoredIndex : natural number
	|
		transformer(element)
	]
];

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * If the tuple is certainly nonempty, then the function cannot answer ⊥.
 * 
 * @method "map_in parallel through_"
 * @restricts "tuple meta"
 * @restricts "[…]→any's type"
 */
Semantic restriction "map_in parallel through_" is
[
	tupleType : tuple meta,
	transformer : […]→any's type
|
	Require: transformer accepts tupleType;
	If ⎣tupleType⎦ > 0 then
	[
		If transformer's return type = ⊥ then
		[
			Reject parse, expected:
				"repeatedly applied function to have a return type other than\
				\| ⊥"
		];
	];
	<<>, transformer's return type… | ||tupleType||>
];

/**
 * Concurrently apply {@param "transformer"} to each binding of a map
 * {@param "map"}, collecting the results into a new map (and preserving
 * the original keys).
 *
 * @method "map_in parallel through_"
 * @param "aTuple" "tuple"
 * @param "transformer" "[⊥, ⊥]→any"
 *        A function that accepts 1) a key of the map and 2) the value at the 
 *        keyed location
 * @returns "map"
 *          A map of results of applications of {@param "transformer"} to the
 *          values at the keyed location.
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @raises "termination-requested exception"
 *         If termination of the current fiber is requested during an internal
 *         synchronization operation.
 * @author "Richard Arriaga"
 */
Public method "map_in parallel through_" is
[
	aMap : map,
	transformer : [⊥, ⊥]→any
|
	transformedBindings : <<any…|2>…|> := 	
		map aMap's bindings in parallel through
		[
			binding : <any…|2>,
			ignoredIndex : natural number
		|
			<binding[1], transformer(binding[1],binding[2])>
		];
	newMap : map := {};
	For each of transformedBindings do
	[
	 	binding: <any…|2>
	 |
	 	newMap := newMap + binding[1] → binding[2];
	];
	newMap
]:map;
	
/**
 * Ensure that the function will accept all bindings of the map. If the map is
 * certainly nonempty, then the function cannot answer ⊥.
 * 
 * @method "map_in parallel through_"
 * @restricts "map meta"
 * @restricts "[⊥, ⊥]→any's type"
 */
Semantic restriction "map_in parallel through_" is
[
	mapType : map meta,
	transformer : [⊥, ⊥]→any's type
|
	Require: transformer accepts mapType;
	If ⎣mapType⎦ > 0 then
	[
		If transformer's return type = ⊥ then
		[
			Reject parse, expected:
				"repeatedly applied function to have a return type other than\
				\| ⊥"
		];
	];
	{mapType's key type → transformer's return type | ||mapType||}
];

/**
 * Concurrently apply {@param "transformer"} to each element of a 
 * {@param "set"}, collecting the results into a new set
 *
 * @method "map_in parallel through_"
 * @param "aTuple" "tuple"
 * @param "transformer" "[⊥]→any"
 *        A function that accepts the type of the elements of the set
 * @returns "set"
 *          A set of results of applications of {@param "transformer"} to the
 *          elements of the original set.
 * @raises "worker exception"
 *         If any of the forked workers raise an exception.
 * @raises "termination-requested exception"
 *         If termination of the current fiber is requested during an internal
 *         synchronization operation.
 * @author "Richard Arriaga"
 */
Public method "map_in parallel through_" is
[
	aSet : set,
	transformer : [⊥]→any
|
	map aSet → tuple in parallel through
	[
		element : any
	|
		transformer(element)
	] → set
]:set;
	
/**
 * Ensure that the function will accept elements of the set. If the set is
 * certainly nonempty, then the function cannot answer ⊥.
 * 
 * @method "map_in parallel through_"
 * @restricts "set meta"
 * @restricts "[⊥]→any's type"
 */
Semantic restriction "map_in parallel through_" is
[
	setType : set meta,
	transformer : [⊥]→any's type
|
	Require: transformer accepts setType;
	If ⎣setType⎦ > 0 then
	[
		If transformer's return type = ⊥ then
		[
			Reject parse, expected:
				"repeatedly applied function to have a return type other than\
				\| ⊥"
		];
	];
	{transformer's return type | 1..⎡setType⎤}
];

/**
 * @method "a|an_«with«_«:»?:=_‡,»»"
 * @restricts 1 "future"
 */
Grammatical restriction "a|an_«with«_«:»?:=_‡,»»" is <{"future"}, ∅, ∅>;
