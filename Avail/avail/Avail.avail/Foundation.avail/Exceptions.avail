/*
 * Exceptions.avail
 * Copyright © 1993-2014, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Exceptions"
Versions
	"dev"
Uses
	"Atoms",
	"Bootstrap",
	"Control Structures",
	"Definers",
	"Early Assertions",
	"Early Error Codes",
	"Enumeration Support",
	"Functions",
	"Literals",
	"Logic",
	"Math",
	"Objects",
	"Strings",
	"Tuples",
	"Types",
	"Variables"
Names
	"Current fiber's unhandled exception handler is_",
	"Guard|guard_«intercept_»«ensure_»",
	"Raise_",
	"an exception for_",
	"cascade_",
	"current fiber's unhandled exception handler",
	"causal exception",
	"descriptive_",
	"error message",
	"try_else_",
	"_caused by_",
	"_'s⁇causal exception",
	"_'s⁇error message",
	"_'s⁇stack summary",
	"“_”(stack summary)",
	"“_”(frames_of stack summary«,⁇renumbered starting at_»)",

	/* System exception categories. */
	"arithmetic exception",
	"bad-argument exception",
	"bad-format exception",
	"bad-message exception",
	"bad-phrase exception",
	"bad-primitive exception",
	"cascade exception",
	"code-generation exception",
	"definition exception",
	"descriptive exception",
	"element-access exception",
	"I/O exception",
	"instantiation exception",
	"invocation exception",
	"security exception",
	"trace exception",
	"unsupported-operation exception",
	"variable-use exception",

	/* Voluntary termination. */
	"Raise termination-requested exception if appropriate",
	"termination-requested exception",

	/* Java exceptions. */
	"Java exception",
	"a Java exception caused by_",
	"_'s⁇throwable"

	/* Quite a few names are introduced, but all dynamically by the
	 * "Public exception_(_)extends_" defining method.
	 */
Body

/**
 * Answer a summary of the continuation stack associated with the specified
 * {@type "exception"}.
 *
 * @method "_'s⁇stack summary"
 * @param "e" "exception"
 *        An {@type "exception"}.
 * @returns "<string…|>"
 *          A tuple of strings, each of which describes a continuation.
 * @category "Exceptions" "Queries"
 */
Public method "_'s⁇stack summary" is
[
	e : exception
|
	Primitive 203 (failureCode : incorrect-argument-type code's type);
	early failure function(failureCode)
] : <string…|>;

/* Private field definitions. */
"error code" is a new atom;
"error name" is a new atom;

/**
 * Answer the field atom that represents an exception's cause.
 *
 * @method "causal exception"
 * @returns "atom"
 */
"causal exception" is a new atom;

/**
 * Answer the field atom that represents an error message.
 *
 * @method "error message"
 * @returns "atom"
 */
"error message" is a new atom;

/**
 * Answer the heritable fiber-local atom that represents a fiber's unhandled
 * exception handler.
 *
 * @method "unhandled exception handler"
 * @returns "atom"
 */
"unhandled exception handler" is a new heritable fiber-local atom;

/**
 * Answer the unhandled exception handler for the current fiber.
 *
 * @method "current fiber's unhandled exception handler"
 * @returns "[exception]→⊥"
 * @category "Exception Handling"
 */
Public method "current fiber's unhandled exception handler" is
[
	cast current fiber[unhandled exception handler] into [t : [exception]→⊥ | t]
] : [exception]→⊥;

/**
 * Establish {@param "handler"} as the function that the current fiber will
 * apply in the event of an unhandled exception.
 * 
 * @method "Current fiber's unhandled exception handler is_"
 * @param "handler" "[exception]→⊥"
 *    The unhandled exception handler. When an unhandled exception is trapped by
 *    the VM, the exception machinery will arrange to apply this function with
 *    the unhandled exception.
 * @category "Exception Handling"
 */
Public method "Current fiber's unhandled exception handler is_" is
[
	handler : [exception]→⊥
|
	current fiber[unhandled exception handler] := handler;
] : ⊤;

/* This function that "Raise_" should invoke if the current fiber does not have
 * an unhandled exception handler. This will be updated after all other
 * exception machinery has been built.
 */
noUnhandledExceptionHandler : [exception]→⊥ :=
	[
		anException : exception
	|
		Crash: "unhandled exception: " ++ “anException”
	];

/**
 * Raise the specified {@type "exception"}. The virtual machine scans the
 * {@method "current fiber"}'s chain of {@type "continuation"}s to identify an
 * invocation of {@method "Guard|guard_«intercept_»«ensure_»"} (primitive 200).
 * Extract the second argument from that continuation. This is a {@type "tuple"}
 * of arity-one exception handling {@type "function"}. If any of these handlers,
 * from left to right, accepts {@param "anException"}, then discard all
 * continuations after this one and then invoke the handler with {@param
 * "anException"}. If none of these handlers accept the argument, then the
 * virtual machine continues scanning the chain of continuations for correctly
 * typed exception handling functions. If no suitable exception handling
 * function is found, then invoke the current fiber's {@method
 * "_'s⁇unhandled exception handler is_" unhandled exception handler}. {@method
 * "Crash:_" Crash} the current fiber if no such handler exists.
 *
 * @method "Raise_"
 * @param "anException" "exception"
 * @returns "⊥"
 * @category "Exception Handling" "Control Structures"
 */
Public method "Raise_" is
[
	anException : exception
|
	Primitive 201 (unhandledException : exception);
	If unhandled exception handler ∈ current fiber then
	[
		handler ::= current fiber's unhandled exception handler;
		handler(unhandledException)
	]
	else
	[
		noUnhandledExceptionHandler(anException)
	]
] : ⊥;

/**
 * Mark the nearest {@method "Guard|guard_«intercept_»«ensure_»" guard frame}
 * with the current exception handling state.
 *
 * @method "Mark nearest guard frame with_"
 * @param "marker" "{handler-sentinel code, unwind-sentinel code}ᵀ"
 * @returns "ᵀ"
 * @category "Bootstrap" "Primitives" "Exception Handling"
 */
Private method "Mark nearest guard frame with_" is
[
	marker : {handler-sentinel code, unwind-sentinel code}ᵀ
|
	Primitive 202 (failureCode : 
		{cannot-mark-handler-frame code, no-handler-frame code}ᵀ);
	early failure function(failureCode)
] : ⊤;

/**
 * This is a helper for {@method "Private guard_intercept_ensure_"}. Run
 * {@param "body"} and then {@param "unwind"}. If {@param "body"} produces a
 * value, then polymorphism and a semantic restriction make sure that it gets
 * returned.
 *
 * @method "Run_and_"
 * @param "body" "[]→⊤"
 * @param "unwind" "[]→⊤"
 * @returns "⊤"
 * @category "Bootstrap" "Exception Handling"
 */
Private method "Run_and_" is
[
	body : []→⊤,
	unwind : []→⊤
|
	body();
	Mark nearest guard frame with handler-sentinel code;
	unwind();
	Mark nearest guard frame with unwind-sentinel code;
] : ⊤;

Method "Run_and_" is
[
	body : []→any,
	unwind : []→⊤
|
	result ::= body();
	Mark nearest guard frame with handler-sentinel code;
	unwind();
	Mark nearest guard frame with unwind-sentinel code;
	result
] : any;

/**
 * Though this is the primitive guard method, it is merely a helper for
 * {@method "Guard|guard_«intercept_»«ensure_»"}, the public exception
 * protection control structure.
 *
 * Execute {@param "body"}. If an {@type "exception"} is {@method "Raise_"
 * raised}, the virtual machine will scan the {@method "current fiber"}'s chain
 * of {@type "continuation"}s to identify invocations of this primitive. The
 * continuation nearest to the end of the continuation chain, i.e., closest to
 * the raise of the exception, that defines a handler that accepts an argument
 * of the correct type is invoked with the exception. So an exception handler
 * will potentially run if code run (directly or indirectly) by {@param "body"}
 * raises an exception of the accepted type.
 *
 * Whether {@param "body"} succeeds or is curtailed by an exception, always
 * apply {@param "unwind"}. This is a safe place to clean up an algorithm after
 * it runs or fails. If one of the handlers is invoked, then it will run after
 * the handler runs, even if the handler raises its own exception. This happens
 * because the public control structure, {@method
 * "Guard|guard_«intercept_»«ensure_»"}, embeds {@param "unwind"} into each of
 * the (modified) exception handlers.
 *
 * @method "Private guard_intercept_ensure_"
 * @param "body" "[]→⊤"
 *    The protected function.
 * @param "handlers" "<[⊥]→⊤…|>"
 *    A tuple of exception handlers.
 * @param "optionalUnwind" "<[]→⊤…|0..1>"
 *    If specified, then a function to apply after either the successful
 *    completion of {@param "body"} or an unwind through this continuation.
 * @returns "⊤"
 * @category "Bootstrap" "Primitives" "Exception Handling" "Control Structures"
 */
Private method "Private guard_intercept_ensure_" is
[
	body : []→⊤,
	handlers : <[⊥]→⊤…|>,
	optionalUnwind : <[]→⊤…|0..1>
|
	Primitive 200 (failureCode :
		{
			0,
			incorrect-argument-type code,
			handler-sentinel code,
			unwind-sentinel code
		}ᵀ);
	If failureCode = 0 then
	[
		Run body and optionalUnwind[1] else [[]];
	]
	else
	[
		early failure function(incorrect-argument-type code)
	];
] : ⊤;

/**
 * A cascade exception retains the exception that originally caused it.
 *
 * @type "cascade exception"
 * @supertype "exception"
 */
Public class "cascade exception" extends exception
	with fields
		public causal exception : exception;

/**
 * Construct and answer the type intersection of the argument and {@type
 * "cascade exception"}.
 *
 * @method "cascade_"
 * @param "exceptionType" "exception's type"
 *        An exception type.
 * @returns "cascade exception"
 *          An exception type that is a subtype of both {@type "cascade
 *          exception"} and {@param "exceptionType"}.
 * @category "Exceptions" "Types" "Constructors"
 */
Public method "cascade_" is
[
	exceptionType : exception's type
|
	cascade exception ∩ exceptionType
] : cascade exception's type;

/**
 * @method "cascade_"
 * @forbids 1 "exception"
 */
Grammatical restriction "cascade_" is <{"exception"}>;

/**
 * @method "cascade_"
 * @restricts "exception's type's type"
 */
Semantic restriction "cascade_" is
[
	exceptionMeta : exception's type's type
|
	((cascade exception) ∩ (exceptionMeta's instance))'s type
];

/**
 * Answer a {@type "cascade exception"} based on {@param "newException"} and
 * caused by {@param "originalException"}.
 *
 * @method "_caused by_"
 * @param "newException" "exception"
 * @param "originalException" "exception"
 * @returns "cascade exception"
 * @category "Exceptions" "Constructors"
 */
Public method "_caused by_" is
[
	newException : exception,
	originalException : exception
|
	fields ::= newException→map + causal exception→originalException;
	cast fields→object into [t : cascade exception | t]
] : cascade exception;

/**
 * This is a helper for {@method "Guard|guard_«intercept_»«ensure_»"}. Having
 * intercepted {@param "originalException"}, invoke {@param "handler"}. If it
 * raises an {@type "exception", then intercept it and store it locally. Run
 * {@param "unwind"}. If it raises an exception, then intercept it and store it
 * locally, overwriting any exception intercepted by a failure of {@param
 * "handler"}. If a new exception has been stored locally, then convert it into
 * a {@type "cascade exception"} and reraise it. Otherwise answer the result
 * produced by {@param "handler"}.
 *
 * @method "Handle_with_and_"
 * @param "originalException" "exception"
 *        The exception originally caught by the handler that {@method
 *        "Guard|guard_«intercept_»«ensure_»"} wrapped around {@param
 *        "handler"}.
 * @param "handler" "[⊥]→⊤"
 *        An exception handler lexically specified in the send of {@method
 *        "Guard|guard_«intercept_»«ensure_»"}.
 * @param "unwind" "[]→⊤"
 *        The unwind handler lexically specified in the send of {@method
 *        "Guard|guard_«intercept_»«ensure_»"}.
 * @returns "any"
 *          The value, if any, produced by {@param "handler"}.
 * @raises "cascade exception"
 *         If either {@param "handler"} or {@param "unwind"} raises an
 *         {@type "exception"}.
 * @category "Bootstrap" "Exception Handling"
 */
Private method "Handle_with_and_" is
[
	originalException : exception,
	handler : [⊥]→⊤,
	unwind : []→⊤
|
	preemptiveException : exception;
	/* Guard the handler, because we need to try the unwind no matter what
	 * happens.
	 */
	Private guard [handler(originalException);]
	intercept <[e : exception | preemptiveException := e;]>
	ensure <>;
	/* Guard the unwind, because if it blows up, then we want to build a cascade
	 * exception from it instead of from the handler.
	 */
	Private guard [unwind();]
	intercept <[e : exception | preemptiveException := e;]>
	ensure <>;
	/* Forbid a subsequent unwind. */
	Mark nearest guard frame with unwind-sentinel code;
	/* If either the handler or the unwind raised an exception, then convert it
	 * to a cascade exception (with the original exception attached) and reraise
	 * it.
	 */
	If ↑preemptiveException is assigned then
	[
		Raise preemptiveException caused by originalException
	];
] : ⊤;

Private method "Handle_with_and_" is
[
	originalException : exception,
	handler : [⊥]→any,
	unwind : []→⊤
|
	result : any;
	preemptiveException : exception;
	/* Guard the handler, because we need to try the unwind no matter what
	 * happens.
	 */
	Private guard [result := handler(originalException);]
	intercept <[e : exception | preemptiveException := e;]>
	ensure <>;
	/* Guard the unwind, because if it blows up, then we want to build a cascade
	 * exception from it instead of from the handler.
	 */
	Private guard [unwind();]
	intercept <[e : exception | preemptiveException := e;]>
	ensure <>;
	/* Forbid a subsequent unwind. */
	Mark nearest guard frame with unwind-sentinel code;
	/* If either the handler or the unwind raised an exception, then convert it
	 * to a cascade exception (with the original exception attached) and reraise
	 * it.
	 */
	If ↑preemptiveException is assigned then
	[
		Raise preemptiveException caused by originalException
	];
	/* The result must be assigned, or control would have left because of a
	 * raised exception.
	 */
	Assert: ↑result is assigned;
	result
] : any;

/**
 * Execute {@param "body"}. If an {@type "exception"} is {@method "Raise_"
 * raised}, the virtual machine will scan the {@method "current fiber"}'s chain
 * of {@type "continuation"}s to identify invocations of this primitive. The
 * continuation nearest to the end of the continuation chain, i.e., closest to
 * the raise of the exception, that defines a handler that accepts an argument
 * of the correct type is invoked with the exception. So an exception handler
 * will potentially run if code run (directly or indirectly) by {@param "body"}
 * raises an exception of the accepted type.
 *
 * Whether {@param "body"} succeeds or is curtailed by an exception, always
 * apply {@param "unwind"}. This is a safe place to clean up an algorithm after
 * it runs or fails. If one of the handlers is invoked, then it will run after
 * the handler runs, even if the handler raises its own exception.
 *
 * @method "Guard|guard_«intercept_»«ensure_»"
 * @param "body" "[]→⊤"
 *    The protected function.
 * @param "handlers" "<[⊥]→⊤…|>"
 *    A tuple of exception handlers.
 * @param "optionalUnwind" "<[]→⊤…|0..1>"
 *    If specified, then a function to apply after either the successful
 *    completion of {@param "body"} or an unwind through this continuation.
 * @returns "⊤"
 * @category "Exception Handling" "Control Structures"
 */
Public method "Guard|guard_«intercept_»«ensure_»" is
[
	body : []→⊤,
	handlers : <[⊥]→⊤…|>,
	optionalUnwind : <[]→⊤…|0..1>
|
	unwind ::= optionalUnwind[1] else [[]];
	realHandlers ::=
		/* If only an unwind handler was provided, then synthesize a catch-all
		 * exception handler.
		 */
		if handlers is empty then
		[
			<[
				e : exception
			|
				Handle e with [ex : exception | Raise ex] and unwind
			]>
		]
		/* Otherwise, wrap each of the handlers. The wrapper will call the
		 * user-supplied exception handler and then the unwind handler.
		 */
		else
		[
			map handlers through
			[
				handler : [⊥]→⊤
			|
				handlerType ::= handler's type;
				/* Make sure that the new handler has the same signature as
				 * the wrapped handler.
				 */
				new [handlerType[1]]→(handlerType's return type) applying
				[
					originalException : exception
				|
					Handle originalException with handler and unwind;
				]
			]
		];
	Private guard body intercept realHandlers ensure optionalUnwind;
] : ⊤;

/**
 * Reject the current parse if 1) any of the exception handlers aren't or 2) any
 * earlier handlers hide later handlers (by having a more general type).
 * 
 * @method "Guard|guard_«intercept_»«ensure_»"
 * @restricts "[]→⊤'s type"
 * @restricts "<[⊥]→⊤…|>'s type"
 * @restricts "<[]→⊤…|0..1>'s type"
 */
Semantic restriction "Guard|guard_«intercept_»«ensure_»" is
[
	bodyType : []→⊤'s type,
	handlersType : <[⊥]→⊤…|>'s type,
	unwindType : <[]→⊤…|0..1>'s type
|
	returnType : type := bodyType's return type;
	handlerCount ::= ⎣handlersType⎦;
	unwindCount ::= ⎣unwindType⎦;
	If handlerCount = 0 ∧ [unwindCount = 0] then
	[
		Reject parse, expected:
			"at least one exception handler or an unwind handler"
	];
	From 1 to handlerCount do
	[
		index : natural number
	|
		handlerType ::= handlersType[index];
		argType ::= handlerType[1];
		If argType = ⊥ then
		[
			Reject parse, expected: format
				"exception handler #“①”'s parameter type to be \
				\|statically known"
				with index
		];
		If ¬argType ⊆ exception then
		[
			Reject parse, expected: format
				"exception handler to accept only exceptions (not “①”)"
				with argType
		];
		hidingArgTypes : <type…|> := <>;
		From 1 to index - 1 do
		[
			inner : natural number
		|
			previousArgType ::= handlersType[inner][1];
			If argType ⊆ previousArgType then
			[
				hidingArgTypes := eject ↑hidingArgTypes ++ <previousArgType>;
			];
		];
		If ¬hidingArgTypes is empty then
		[
			Reject parse, expected: format
			"exception handler for “①” to be reachable \
			\|(but it is hidden by each of: “②”)"
			with argType, hidingArgTypes
		];
		returnType := eject ↑returnType ∪ handlerType's return type;
	];
	returnType
];

/**
 * Attempt {@param "protected"}. If it does not raise an {@type "exception"},
 * then answer its result. Otherwise, answer the result of applying {@param
 * "else"}.
 *
 * @method "try_else_"
 * @param "protected" "[]→any"
 *    The function whose answer is preferred.
 * @param "else" "[]→any"
 *    The function whose answer will be returned if {@param "protected"} raises
 *    an {@type "exception"}.
 * @returns "any"
 *    If possible, then the answer obtained by applying {@param "protected"}.
 *    Otherwise, the answer obtained by applying {@param "else"}.
 * @category "Exception Handling" "Control Structures"
 */
Public method "try_else_" is
[
	protected : []→any,
	else : []→any
|
	guard protected
	intercept [e : exception | else()]
] : any;

/**
 * @method "try_else_"
 * @restricts "[]→any's type"
 * @restricts "[]→any's type"
 */
Semantic restriction "try_else_" is
[
	protected : []→any's type,
	else : []→any's type
|
	if protected's return type = ⊥ then [else's return type]
	else [protected's return type ∪ else's return type]
];

/**
 * A system exception privately contains a system error code.
 * 
 * @type "system exception"
 * @supertype "exception"
 */
Class "system exception" extends exception
	with fields
		error code : natural number,
		error name : string;

/**
 * @method "“_”"
 * @param "anException" "system exception"
 * @returns "string"
 */
Stable method "“_”" is
[
	anException : system exception
|
	(a|an) “anException's error name”
] : string;

/* A map from error codes to system exceptions. */
exceptionsByCode : {natural number→system exception's type|} := {};

/**
 * Define a new system exception class. Publish the name of the class.
 *
 * @method "System exception_(_)extends_"
 * @param "exceptionBaseName" "nonempty string"
 *    The base name of the exception class (without the trailing " exception").
 * @param "code" "natural number"
 *    The error code that uniquely identifies the system exception.
 * @param "supertype" "exception's type"
 *    The nearest supertype of the new exception class.
 * @returns "⊤"
 * @category "Bootstrap" "Declarations" "Exceptions"
 */
Private method "System exception_(_)extends_" is
[
	exceptionBaseName : nonempty string,
	code : natural number,
	supertype : exception's type
|
	Assert: ¬code ∈ exceptionsByCode ("code " ++ “code” ++ " already in use");
	Assert: ¬exceptionBaseName ends with " exception"
		(format "\"‘①’\" ends with \" exception\"" with exceptionBaseName);
	exceptionName ::= exceptionBaseName ++ " exception";
	Class exceptionName extends supertype ∩ system exception
		with fields
			error code : code's type,
			error name : exceptionName's type;
	Publish new name: exceptionName;
	site ::= cast method definition of atom for exceptionName for <>
		into [ t : method definition | t ];
	implementation ::= cast site's function into [t : []→object meta | t];
	exceptionType ::= cast implementation()
		into  [ t : system exception's type | t ];
	exceptionsByCode := eject ↑exceptionsByCode + code→exceptionType;
];

/**
 * An arithmetic exception describes error conditions related to arithmetic and
 * manipulation of numbers.
 * 
 * @type "arithmetic exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "arithmetic exception" extends exception;

/**
 * A bad-argument exception describes error conditions related to invoking a
 * method, function, or similar entity with arguments that are correctly typed
 * but not semantically valid.
 * 
 * @type "bad-argument exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "bad-argument exception" extends exception;

/**
 * A bad-format exception describes error conditions related to invalid formats
 * and/or format applications.
 * 
 * @type "bad-format exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "bad-format exception" extends bad-argument exception;

/**
 * A message exception describes error conditions related to messages, i.e.,
 * method names.
 * 
 * @type "bad-message exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "bad-message exception" extends exception;

/**
 * A bad phrase exception describes error conditions related to phrase
 * construction.
 * 
 * @type "bad-phrase exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "bad-phrase exception" extends exception;

/**
 * A bad-primitive exception describes error conditions related to invocations
 * of nonexistent or not meaningfully implemented primitives.
 * 
 * @type "bad=primitive exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "bad-primitive exception" extends exception;

/**
 * A code-generation exception describes error conditions related to runtime
 * generation of code.
 * 
 * @type "code-generation exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "code-generation exception" extends exception;

/**
 * A definition exception describes error conditions related to defining Avail
 * methods, restrictions, types, and other entities.
 * 
 * @type "definition exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "definition exception" extends exception;

/**
 * An element-access exception describes error conditions related to failed
 * retrieval of an object from a larger structure (including the runtime
 * system).
 * 
 * @type "element-access exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "element-access exception" extends exception;

/**
 * An I/O exception describes error conditions related to program input or
 * output.
 * 
 * @type "I/O exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "I/O exception" extends exception;

/**
 * An invocation exception describes error conditions related to invoking
 * functions, methods, or similar objects with the wrong number or types of
 * arguments.
 * 
 * @type "invocation exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "invocation exception" extends exception;

/**
 * An instantiation exception describes error conditions related to
 * instantiating types (particularly user-defined object types).
 * 
 * @type "instantiation exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "instantiation exception" extends exception;

/**
 * A security exception describes error conditions related to program
 * permissions.
 * 
 * @type "security exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "security exception" extends exception;

/**
 * A trace exception describes error conditions related to system tracing.
 *
 * @type "trace exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "trace exception" extends exception;

/**
 * An unsupported-operation exception describes error conditions related to
 * performing operations that are not supported by the underlying platform.
 *
 * @type "unsupported-operation exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "unsupported-operation exception" extends exception;

/**
 * A variable use exception describes error conditions related to usage of
 * variables.
 * 
 * @type "variable-use exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "variable-use exception" extends exception;

/* Define specific exception classes for each of the VM and Foundation error
 * codes.
 */
System exception "cannot-add-unlike-infinities" (1)
	extends arithmetic exception;
System exception "cannot-subtract-like-infinities" (2)
	extends arithmetic exception;
System exception "cannot-multiply-zero-and-infinity" (3)
	extends arithmetic exception;
System exception "cannot-divide-by-zero" (4)
	extends arithmetic exception;
System exception "cannot-divide-infinities" (5)
	extends arithmetic exception;
System exception "cannot-read-unassigned-variable" (6)
	extends variable-use exception;
System exception "cannot-store-incorrectly-typed-value" (7)
	extends variable-use exception;
System exception "cannot-swap-contents-of-differently-typed-variables" (8)
	extends variable-use exception;
System exception "no-such-fiber-variable" (9)
	extends element-access exception;
System exception "subscript-out-of-bounds" (10)
	extends element-access exception;
System exception "incorrect-number-of-arguments" (11)
	extends invocation exception;
System exception "incorrect-argument-type" (12)
	extends invocation exception;
System exception "method-return-type-not-as-forward-declared" (13)
	extends definition exception;
System exception "continuation-expected-stronger-type" (14)
	extends invocation exception;
System exception "primitive-not-supported" (15)
	extends bad-primitive exception ∩ unsupported-operation exception;
System exception "not-enumeration" (17)
	extends invocation exception;
System exception "shift-and-truncate-requires-non-negative" (18)
	extends arithmetic exception;
System exception "no-method" (19)
	extends element-access exception;
System exception "wrong-outers" (20)
	extends code-generation exception;
System exception "key-not-found" (21)
	extends element-access exception;
System exception "negative-size" (22)
	extends bad-argument exception;
System exception "general-I/O" (23)
	extends I/O exception;
System exception "permission-denied" (24)
	extends security exception;
System exception "invalid-handle" (25)
	extends bad-argument exception;
System exception "invalid-primitive-number" (26)
	extends code-generation exception;
System exception "function-disagrees-with-primitive-restriction" (27)
	extends code-generation exception;
System exception "local-type-literal-is-not-a-type" (28)
	extends code-generation exception;
System exception "outer-type-literal-is-not-a-type" (29)
	extends code-generation exception;
System exception "too-large-to-represent" (30)
	extends system exception;
System exception "type-restriction-must-accept-only-types" (31)
	extends definition exception;
System exception "incorrect-type-for-group" (32)
	extends bad-message exception;
System exception "no-special-object" (33)
	extends element-access exception;
System exception "macro-argument-must-be-a-parse-node" (34)
	extends definition exception;
System exception "ambiguous-name" (35)
	extends bad-message exception;
System exception "declaration-kind-does-not-support-assignment" (36)
	extends bad-phrase exception;
System exception "declaration-kind-does-not-support-reference" (37)
	extends bad-phrase exception;
System exception "exclamation-mark-must-follow-an-alternation-group" (38)
	extends bad-message exception;
System exception "redefined-with-same-argument-types" (39)
	extends definition exception;
System exception "result-type-should-covary-with-arguments" (40)
	extends definition exception;
System exception "special-atom" (41)
	extends bad-argument exception;
System exception "incorrect-type-for-complex-group" (42)
	extends bad-message exception;
System exception "incorrect-use-of-double-dagger" (43)
	extends bad-message exception;
System exception "unbalanced-guillemets" (44)
	extends bad-message exception;
System exception "method-name-is-not-canonical" (45)
	extends bad-message exception;
System exception "expected-operator-after-backquote" (46)
	extends bad-message exception;
System exception "incorrect-type-for-boolean-group" (47)
	extends bad-message exception;
System exception "incorrect-type-for-counting-group" (48)
	extends bad-message exception;
System exception "octothorp-must-follow-a-simple-group" (49)
	extends bad-message exception;
System exception "question-mark-must-follow-a-simple-group" (50)
	extends bad-message exception;
System exception "case-insensitive-expression-canonization" (51)
	extends bad-message exception;
System exception "tilde-must-not-follow-argument" (52)
	extends bad-message exception;
System exception "double-question-mark-must-follow-a-simple-or-simple-group" (53)
	extends bad-message exception;
System exception "alternative-must-not-contain-arguments" (54)
	extends bad-message exception;
System exception "vertical-bar-must-follow-a-simple-or-simple-group" (55)
	extends bad-message exception;
System exception "cannot-convert-not-a-number-to-integer" (56)
	extends bad-argument exception;
System exception "incorrect-type-for-numbered-choice" (57)
	extends bad-message exception;
System exception "label-macro-must-occur-inside-a-block" (58)
	extends bad-phrase exception;
System exception "macro-prefix-functions-must-return-top" (59)
	extends definition exception;
System exception "primitive-fallibility-disagrees-with-failure-variable" (60)
	extends definition exception;
System exception "final-expression-should-agree-with-declared-return-type" (61)
	extends definition exception;
System exception "primitive-should-agree-with-declared-return-type" (62)
	extends definition exception;
System exception "label-type-should-agree-with-declared-return-type" (63)
	extends definition exception;
System exception "return-type-is-mandatory-with-primitives-or-labels" (64)
	extends definition exception;
System exception "declaration-type-must-not-be-top-or-bottom" (65)
	extends definition exception;
System exception "local-declaration-shadows-another" (66)
	extends definition exception;
System exception "macro-prefix-function-argument-must-be-a-parse-node" (67)
	extends definition exception;
System exception "macro-must-return-a-parse-node" (68)
	extends definition exception;
System exception "no-such-field" (69)
	extends element-access exception;
System exception "loading-is-over" (70)
	extends system exception;
System exception "method-is-sealed" (72)
	extends definition exception;
System exception "no-implementation" (73)
	extends bad-primitive exception;
System exception "atom-already-exists" (74)
	extends definition exception;
System exception "cannot-mix-method-and-macro-definitions" (75)
	extends definition exception;
System exception "cannot-create-continuation-for-infallible-primitive-function" (76)
	extends invocation exception;
System exception "illegal-trace-mode" (77)
	extends trace exception;
System exception "result-disagreed-with-expected-type" (79)
	extends definition exception;
System exception "handler-sentinel" (80)
	extends system exception;
System exception "cannot-mark-handler-frame" (81)
	extends system exception;
System exception "no-handler-frame" (82)
	extends system exception;
System exception "unwind-sentinel" (83)
	extends system exception;
System exception "no-method-definition" (84)
	extends definition exception;
System exception "ambiguous-method-definition" (85)
	extends definition exception;
System exception "forward-method-definition" (86)
	extends definition exception;
System exception "abstract-method-definition" (87)
	extends definition exception;
System exception "fiber-is-terminated" (89)
	extends system exception;
System exception "fiber-result-unavailable" (90)
	extends system exception;
System exception "fiber-cannot-join-itself" (91)
	extends system exception;
System exception "fiber-produced-incorrectly-typed-result" (92)
	extends element-access exception;
System exception "block-contains-invalid-statements" (100)
	extends bad-phrase exception;
System exception "block-is-invalid" (101)
	extends bad-phrase exception;
System exception "block-must-not-contain-outers" (102)
	extends bad-phrase exception;
System exception "block-compilation-failed" (103)
	extends code-generation exception;
System exception "sequence-contains-invalid-statements" (105)
	extends bad-phrase exception;
System exception "no-file" (200)
	extends I/O exception;
System exception "file-exists" (201)
	extends I/O exception;
System exception "directory-not-empty" (202)
	extends I/O exception;
System exception "partial-success" (203)
	extends system exception;
System exception "illegal-option" (204)
	extends bad-argument exception;
System exception "invalid-path" (205)
	extends bad-argument exception;
System exception "Java-class-not-available" (500)
	extends element-access exception;
System exception "pojo-type-is-abstract" (501)
	extends bad-argument exception;
System exception "Java-method-not-available" (502)
	extends element-access exception;
System exception "Java-marshaling-failed" (504)
	extends invocation exception;
System exception "Java-field-not-available" (505)
	extends element-access exception;
System exception "Java-field-reference-is-ambiguous" (506)
	extends bad-message exception;
System exception "cannot-modify-final-Java-field" (507)
	extends variable-use exception;
System exception "Java-method-reference-is-ambiguous" (508)
	extends bad-message exception;
System exception "object-type-extension-contains-duplicates" (1000)
	extends definition exception;
System exception "object-type-extension-did-not-produce-subtype" (1001)
	extends definition exception;
System exception "object-instantiation-contains-duplicates" (1002)
	extends instantiation exception;
System exception "object-instantiation-did-not-produce-instance" (1004)
	extends instantiation exception;
System exception "invalid-argument" (1005)
	extends bad-format exception;
System exception "runaway-format-variable" (1006)
	extends bad-format exception;
System exception "empty-format-variable" (1007)
	extends bad-format exception;
System exception "invalid-format-metacharacter-escape" (1008)
	extends bad-format exception;
System exception "invalid-format-metacharacter-use" (1009)
	extends bad-format exception;
System exception "format-variable-interpolation-failed" (1010)
	extends bad-format exception;
System exception "invalid-format-variable" (1011)
	extends bad-format exception;
System exception "missing-format-variable-binding" (1012)
	extends bad-format exception;

/**
 * Ensure that all error codes have corresponding exceptions.
 *
 * @method "Ensure:all error codes have corresponding exceptions"
 * @category "Bootstrap" "Assertions"
 */
Private method "Ensure:all error codes have corresponding exceptions" is [];
Semantic restriction "Ensure:all error codes have corresponding exceptions" is
[
	missingExceptionClasses ::= filter error codes by
	[
		errorCode : natural number,
		errorName : string
	|
		¬errorCode ∈ exceptionsByCode
	];
	If |missingExceptionClasses| ≠ 0 then
	[
		Reject parse, expected:
			format
				"exception classes to be defined for the following \
				\|error codes: “①”"
			with missingExceptionClasses
	];
	⊤
];

Ensure: all error codes have corresponding exceptions;

/**
 * A descriptive exception holds an error message.
 * 
 * @type "descriptive exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public class "descriptive exception" extends exception
	with fields
		public error message : string;

/**
 * Construct and answer the type intersection of the argument and {@type
 * "descriptive exception"}.
 *
 * @method "descriptive_"
 * @param "exceptionType" "exception's type"
 *        An exception type.
 * @returns "descriptive exception"
 *          An exception type that is a subtype of both {@type "descriptive
 *          exception"} and {@param "exceptionType"}.
 * @category "Exceptions" "Types" "Constructors"
 */
Public method "descriptive_" is
[
	exceptionType : exception's type
|
	descriptive exception ∩ exceptionType
] : descriptive exception's type;

/**
 * @method "descriptive_"
 * @forbids 1 "exception"
 */
Grammatical restriction "descriptive_" is <{"exception"}>;

/**
 * @method "descriptive_"
 * @restricts "exception's type's type"
 */
Semantic restriction "descriptive_" is
[
	exceptionMeta : exception's type's type
|
	((descriptive exception) ∩ (exceptionMeta's instance))'s type
];

/**
 * @method "“_”"
 * @param "e" "descriptive exception"
 */
Stable method "“_”" is
[
	e : descriptive exception
|
	(a|an) “e's type” ++ " (" ++ e's error message ++ ")"
];

/**
 * Answer the right exception for the specified system error code.
 *
 * @method "an exception for_"
 * @param "errorCode" "natural number"
 *        A system error code.
 * @returns "exception"
 *          The appropriate exception for the specified error code.
 * @category "Exceptions" "Constructors"
 */
Public method "an exception for_" is
[
	errorCode : natural number
|
	exceptionType ::= exceptionsByCode[errorCode];
	an exceptionType with
		error code ::= errorCode,
		error name ::= exceptionType's error name's instance
] : exception;

"throwable" is a new field atom;

/**
 * A Java exception wraps a pojo representing a Java-style {@code Throwable}.
 *
 * @type "Java exception"
 * @supertype "exception"
 * @category "Exceptions" "POJO"
 */
Public class "Java exception" extends exception
	with field
		public throwable : pojo exception;

/**
 * Construct and answer a {@type "Java exception"} that was conceptually caused
 * by the {@type "pojo exception" argument}.
 *
 * @method "a Java exception caused by_"
 * @param "e" "pojo exception"
 *        A Java-style {@code Throwable}.
 * @returns "Java exception"
 * @category "Exceptions" "POJO" "Constructors"
 */
Method "a Java exception caused by_" is
[
	e : pojo exception
|
	a Java exception with throwable ::= e
] : Java exception;

/**
 * Obtain a printed representation of the specified {@type "exception"}'s stack
 * summary, suitable for printing.
 *
 * @method "“_”(stack summary)"
 * @param "e" "exception"
 * @returns "string"
 * @category "Exceptions" "Stringification"
 */
Public method "“_”(stack summary)" is
[
	e : exception
|
	dump ::= e's stack summary;
	text : string := "";
	From |dump| to 1 by -1 do
	[
		index : natural number
	|
		frame ::= dump[index];
		text := eject ↑text ++ (format "\t‘①’\n" with frame);
	];
	text
];

/**
 * Obtain a printed representation of the specified {@type "exception"}'s stack
 * summary, suitable for printing. Only summarize frames in the given range.
 *
 * @method "“_”(stack summary)"
 * @param "e" "exception"
 * @param "range" "natural number's type"
 *        The range of the stack to summarize. The ordinal of the base frame is
 *        {@code 1}. If the ceiling of the range is out of bounds for the stack,
 *        then substitute the actual size of the stack.
 * @param "start" "natural number"
 *        If specified, then the ordinal to present for the {@code ⎣range⎦}-th
 *        frame of the stack.
 * @returns "string"
 * @category "Exceptions" "Stringification"
 */
Public method "“_”(frames_of stack summary«,⁇renumbered starting at_»)" is
[
	e : exception,
	range : [1..∞)'s type,
	start : <natural number…|0..1>
|
	dump ::= e's stack summary;
	text : string := "";
	ordinal : natural number := start[1] else [1];
	From ⎣range⎦ to ⎡range⎤ min |dump| do
	[
		index : natural number
	|
		frame ::= dump[index];
		colon ::= first index of ":" in frame;
		Assert: colon ≠ 0;
		withoutOrdinal ::= frame[colon + 1..];
		newFrame ::= format "\t#“①”:‘②’\n" with ordinal, withoutOrdinal;
		text := newFrame ++ eject ↑text;
		↑ordinal++;
	];
	text
];

/**
 * A termination-requested exception indicates that termination has been
 * requested for the current fiber.
 *
 * @type "termination-requested exception"
 * @supertype "exception"
 * @category "Exceptions"
 */
Public explicit class "termination-requested exception" extends exception;

/**
 * Raise a {@type "termination-requested exception"} iff {@method
 * "termination requested" termination has been requested}.
 *
 * @method "Raise termination-requested exception if appropriate"
 * @returns "⊤"
 * @raises "termination-requested exception"
 *         If {@method "termination requested" termination has been requested}.
 * @category "Exceptions" "Control Structures"
 */
Public method "Raise termination-requested exception if appropriate" is
[
	If termination requested then
	[
		Raise a termination-requested exception
	];
];

/**
 * Set the function that should be invoked whenever an unassigned variable is
 * read.
 *
 * @method "unassigned variable read function:=_"
 * @param "aFunction" "[]→⊥"
 * @returns "⊤"
 * @category "Bootstrap" "Primitives" "Exceptions" "Variables"
 */
Private method "unassigned variable read function:=_" is
[
	aFunction : []→⊥
|
	Primitive 75;
] : ⊤;

/* Raise a cannot-read-unassigned-variable exception whenever an unassigned
 * variable is read.
 */
unassigned variable read function :=
	[Raise a cannot-read-unassigned-variable exception];

/**
 * Set the function that should be invoked whenever a method send produces a
 * result whose type disagrees with the expected type as determined at compile
 * time by applicable semantic restrictions.
 *
 * @method "unexpected result function:=_"
 * @param "aFunction" "[]→⊥"
 * @returns "⊤"
 * @category "Bootstrap" "Primitives" "Exceptions" "Methods"
 */
Private method "unexpected result function:=_" is
[
	aFunction : []→⊥
|
	Primitive 76;
] : ⊤;

/* Raise a result-disagreed-with-expected-type whenever a method send produces
 * a result whose type disagrees with the expected type as determined at
 * comile time by applicable semantic restrictions.
 */
unexpected result function :=
	[Raise a result-disagreed-with-expected-type exception];

/**
 * Set the function that should be invoked whenever a message send encounters
 * a definitional error, such as ambiguous or failed method definition lookup,
 * or invocation of a forward or abstract method.
 *
 * @method "invalid method send function:=_"
 * @returns "⊤"
 * @category "Bootstrap" "Primitives" "Exceptions" "Methods"
 */
Private method "invalid method send function:=_" is
[
	aFunction : [{
		no-method code,
		no-method-definition code,
		ambiguous-method-definition code,
		forward-method-definition code,
		abstract-method-definition code}ᵀ]→⊥
|
	Primitive 78;
] : ⊤;

/* Raise the appropriate exception whenever a message send fails dynamically. */
invalid method send function :=
	[
		code : {
			no-method code,
			no-method-definition code,
			ambiguous-method-definition code,
			forward-method-definition code,
			abstract-method-definition code}ᵀ
	|
		Raise an exception for code
	] : ⊥;

/* If the unhandled exception handler catches a termination-requested exception,
 * we want the fiber to exit cleanly, so use an uninitialized variable. This is
 * because we don't want the synthetic base continuation to have a calling
 * continuation. When a base continuation returns, the fiber exits cleanly, in
 * this case without a final result.
 *
 * Note that the stack tuple must include a value for each stack slot required
 * by the continuation. The stack grows downward, and predecrements before
 * pushing, so the stack pointer should begin at the first invalid index.
 */
syntheticBase ::=
	[
		caller : continuation;
		$[Ignore: 0;]@pc=1 stack=<⊥>[2] caller=↑caller
	]();

/* This completes the behavior of "Raise_" in the event that no unhandled
 * exception handler has been specified for the current fiber.
 */
noUnhandledExceptionHandler :=
	[
		unhandled : exception
	|
		msg : string := "";
		/* If the error was encountered during compilation, then indicate which
		 * module was being compiled.
		 */
		Guard
		[
			m ::= current module;
			msg :=
				format "Unhandled exception during compilation of “①”:\n"
				with m's name;
		]
		intercept [e : loading-is-over exception |];
		e : exception := unhandled;
		firstTime : boolean := true;
		While [↑e is assigned] do
		[
			spec ::= if firstTime
				then ["unhandled exception [“ex”]:\n"]
				else ["“ex”:\n"];
			firstTime := false;
			msg := eject ↑msg ++ format spec with ex ::= e;
			msg := eject ↑msg ++ “e” (stack summary);
			Cast e into
			[
				cascade : cascade exception
			|
				msg := eject ↑msg ++ "\ncaused by…\n";
				e := cascade's causal exception;
			]
			else
			[
				Clear ↑e;
			];
		];
		msg := eject ↑msg ++ "\nThe current fiber will be terminated.\n";
		/* If the current fiber was launched in order to apply a semantic
		 * restriction, then reject the current parse. Otherwise, emit the
		 * error message to the stardard error stream and terminate the current
		 * fiber.
		 */
		If current fiber is applying a semantic restriction then
		[
			Reject parse, expected: msg
		];
		/* If the unhandled exception is a termination-requested exception, then
		 * arrange to exit the current fiber cleanly. Note that this will only
		 * work correctly if the current fiber isn't expected to produce a
		 * result.
		 */
		Cast unhandled into
		[
			unused : termination-requested exception
		|
			Exit syntheticBase
		]
		else
		[
			Error: msg;
			Terminate current fiber
		]
	];

/* Exceptions are going live! Failures of bootstrap linked primitives will now
 * raise appropriate exceptions.
 */
Set early failure function to
[
	errorCode : natural number
|
	Assert: errorCode ∈ exceptionsByCode
		("no exception class for " ++ “errorCode”);
	exceptionType ::= exceptionsByCode[errorCode];
	Raise an exceptionType with
		error code ::= errorCode,
		error name ::= exceptionType's error name's instance
] : ⊥;
