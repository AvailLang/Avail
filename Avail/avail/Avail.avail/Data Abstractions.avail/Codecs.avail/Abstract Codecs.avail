/*
 * Abstract Codecs.avail
 * Copyright © 1993-2013, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Abstract Codecs"
Versions
	"dev"
Uses
	"Foundation",
	"Iterators"
Names
	"a decoding iterator of_using_",
	"a decoding iterator that buffers_element|elements of_using_",
	"an encoding iterator that buffers_element|elements of_using_",
	"byte tuple",
	"codec",
	"correction instruction",
	"decoder",
	"decode_using_",
	"decoding corrector",
	"decoding iterator",
	"encoder",
	"encode_using_",
	"encoding corrector",
	"encoding iterator",
	"finish decoding with_",
	"ignore instruction",
	"internal encoder",
	"invalid encoding",
	"malformed-encoding exception",
	"raise exception",
	"raise instruction",
	"replace instruction",
	"replacement character",
	"unsupported character",
	"unsupported-character exception",
	"_'s⁇decoding corrector",
	"_'s⁇encoded input buffer",
	"_'s⁇encoded input buffer:=_",
	"_'s⁇encoded input position",
	"_'s⁇encoded input position:=_",
	"_'s⁇encoding corrector",
	"_'s⁇invalid encoding",
	"_'s⁇raise exception",
	"_'s⁇replacement character",
	"_'s⁇unsupported character"
	
Body

/**
 * This method defines an alias for the type integer range [0..255] which is
 * the size of one byte of data.
 * 
 * @method "byte tuple"
 * @category "Codecs"
 * @returns "<[0..255]…|>"
 *          a byte
 * @author "Richard Arriaga"
 */
Public method "byte tuple" is [<[0..255]…|>];

/**
 * An object type that provides the decoder with a structured heirarchy of what
 * action to take upon decoding something.
 * 
 * @type "correction instruction"
 * @supertype {@type "object" object}
 * @category "Codecs"
 * @author "Richard Arriaga"
 */
Public explicit class "correction instruction" extends object;

/**
 * An object type that provides the decoder with the instruction to take no
 * action for the current encoded bytes.
 * 
 * @type "ignore instruction"
 * @supertype {@type "correction instruction"}
 * @category "Codecs"
 * @author "Richard Arriaga"
 */
Public explicit class "ignore instruction" extends correction instruction;

Public "unsupported character" is a new field atom;

/**
 * An exception that indicates a specific character is not supported by the 
 * codec.  For example down tack, ⊤, is not supported by the ASCII codec.
 * 
 * @type "unsupported-character exception"
 * @supertype {@type "exception" exception}
 * @category "Codecs"
 * @field "unsupported character" "character"
 *        The character that is not supported by the codec
 * @author "Richard Arriaga"
 */
Public explicit class "unsupported-character exception" 
	extends descriptive exception
		with field
			public unsupported character : character;

Public "raise exception" is a new field atom;

/**
 * An object type that provides the decoder with the instruction to raise an
 * an exception in the event a bad encoding is encountered.
 * 
 * @type "raise instruction"
 * @supertype {@type "correction instruction"}
 * @category "Codecs"
 * @author "Richard Arriaga"
 */
Public explicit class "raise instruction" extends correction instruction
	with fields
		public raise exception : unsupported-character exception;

Public "replacement character" is a new field atom;

/**
 * An object type that provides the decoder with the instruction to insert the
 * replacement character in place of the bad encoding in the event a bad 
 * encoding is encountered.
 * 
 * @type "replace instruction"
 * @supertype {@type "correction instruction"}
 * @category "Codecs"
 * @field "replacement character" "character"
 *        The character that replaces the bad encoding.
 * @author "Richard Arriaga"
 */
Public explicit class "replace instruction" extends correction instruction
	with fields
		public replacement character : character;

Public "encoding corrector" is a new field atom;

/**
 * A class that contains instructions for the encoding of data.
 * 
 * @type "encoder"
 * @supertype {@type "object" object}
 * @category "Codecs"
 * @field "encoding corrector" "[character]→correction instruction"
 *        A function that takes a character and encodes it per the
 *        specifications of the encoder.
 * @author "Richard Arriaga"
 */
Public class "encoder" extends object
	with fields
		public encoding corrector : [character]→correction instruction;


/**
 * A method that encodes a string using the provided encoder.
 * 
 * @method "byte encode_using_"
 * @category "Codecs"
 * @param "string"
 *        The string to be encoded.
 * @param "encoder"
 *        The encoder used to encode the string.
 * @exception {@type "unsupported-character exception"}
 *            Thrown when an encoding does not surrport the character being
 *            processed.
 * @returns "<[0..255]…|>"
 *             A byte.
 * @author "Richard Arriaga"
 */
Public abstract method "encode_using_" is
	[tuple, encoder]→byte tuple;

"invalid encoding" is a new field atom;

/**
 * An exception that indicates the particular bytes attempting to be decoded
 * does not adhere to the specification of the encoder.
 * 
 * @type "malformed-encoding exception"
 * @supertype {@type "exception" exception}
 * @category "Codecs"
 * @field "invalid encoding" "byte tuple"
 *        The tuple of bytes that are not valid under the encoding
 *        specifications.
 * @author "Richard Arriaga"
 */
Public explicit class "malformed-encoding exception" extends exception
	with fields
		public invalid encoding : byte tuple;

Public "decoding corrector" is a new field atom;
"encoded input buffer" is a new field atom;
"encoded input position" is a new field atom;

/**
 * A class that contains instructions for the encoding of data.
 * 
 * @type "decoder"
 * @supertype {@type "object" object}
 * @category "Codecs"
 * @field "decoding corrector" "[byte tuple]→correction instruction"
 *        a function that takes a character and encodes it per the
 *        specifications of the encoder.
 * @author "Richard Arriaga"
 */
Public class "decoder" extends object
	with fields
		public decoding corrector : [byte tuple]→correction instruction
	with mutable fields
		public encoded input buffer : byte tuple,
		public encoded input position : natural number;

/**
 * The method that accepts a byte tuple and the decoding specificaiton that
 * transforms the byte tuple into a character.
 * 
 * @method "decode_using_"
 * @category "Codecs"
 * @param "byte tuple"
 * @param "decoder"
 * @returns "string"
 *          The decoded string
 * @raises {@type "malformed-encoding exception"}
 *         Thrown when the encoding specification is violated
 * @author "Richard Arriaga"
 */
Public abstract method "decode_using_" is
	[byte tuple, decoder]→string;

/**
 * The final method call when all the byte data has been read and no further 
 * byte data is expected.  If the continuation contains data when it is awoken
 * this method will return an exception as the final data is incomplete.  If 
 * there is no data within the continuation, then the decoding is complete
 * in a correct state.
 * 
 * @method "byte tuple"
 * @category "Codecs"
 * @param "decoder"
 *        The codec specification for decoding the byte tuple.
 * @return "string"
 *         The decoded string.
 * @raises {@type "malformed-encoding exception"}
 *         Thrown when the encoding specification is violated 
 * @author "Richard Arriaga"
 */
Public abstract method "finish decoding with_" is
	[decoder]→string;

/**
 * An object that is the intersection of both the encoder and decoder object
 * types.  As it is the subtype of both encoder and decoder, it will have the 
 * structure required to be used in methods that accept encoders as input as
 * well as methods that accept decoders as input.
 * 
 * @type "codec"
 * @supertype {@type "encoder" encoder} {@type "decoder" decoder}
 * @category "Codecs"
 * @author "Richard Arriaga"
 */
Public class "codec" extends encoder ∩ decoder;

Public "internal encoder" is a new field atom;

/**
 * An iterator with data that is to be encoded into byte data.
 * 
 * @type "encoding iterator"
 * @supertype {@type "iterator" iterator}
 * @category "Codecs"
 * @field "internal encoder" "encoder"
 * @field "source" "iterator"
 * @author "Richard Arriaga"
 */
Public class "encoding iterator" extends buffered iterator ∩ iterator of byte
	with fields
		element source : iterator, 
		internal encoder : encoder;

/**
 * A constructor method to create a decoding iterator with a variable buffer 
 * size
 *
 * @method "a decoding iterator that buffers_element|elements of_using_"
 * @categories "Codec"
 * @param "size" "natural number" 
 *        The size of the iterator buffer
 * @param "src" "iterator of byte" 
 *        The source iterator to be decoded
 * @param "dc" "decoder" 
 *        The codec that is used to complete the decoding of the iterator
 * @returns "decoding iterator"
 *          Decoding iterator.
 * @raises "exceptionName" 
 *		exceptionDescription
 * @author "Richard Arriaga"
 */
Public method "an encoding iterator that buffers_element|elements of_using_" is
[
 	size : [2..∞),
 	src : iterator,
 	ec : encoder
 |
	an encoding iterator with
		element type ::= byte,
		element source ::= src,
		maximum buffer size ::= size,
		internal encoder ::= ec
] : encoding iterator; 

/*
 * 
 * @author "Richard Arriaga"
 */
encoding iterator's next buffer method is
[
	anIterator : encoding iterator
|
	encode take at most anIterator's maximum buffer size from anIterator's 
		element source using anIterator's internal encoder
] : byte tuple;

"internal decoder" is a new field atom;

/**
 * An iterator with byte data that is to be decoded into character data.
 * 
 * @type "decoding iterator"
 * @supertype {@type "iterator" object}
 * @category "Codecs"
 * @field "internal decoder" "decoder"
 * @author "Richard Arriaga"
 */
Public class "decoding iterator" extends 
	buffered iterator ∩ iterator of character
		with fields
			element source : iterator of byte,
			internal decoder : decoder,
			maximum buffer size : [4096..∞);

/* Use "take«at most»?_from_" at the decoded iterator level to obtain decoded 
 * data.  Following two methods are first attempt*/
	
/**
 * A constructor method to create a decoding iterator with a variable buffer 
 * size
 *
 * @method "a decoding iterator that buffers_element|elements of_using_"
 * @categories "Codec"
 * @param "size" "natural number" 
 *        The size of the iterator buffer
 * @param "src" "iterator of byte" 
 *        The source iterator to be decoded
 * @param "dc" "decoder" 
 *        The codec that is used to complete the decoding of the iterator
 * @returns "decoding iterator"
 *          A decoding iterator
 * @raises "exceptionName" 
 *         exceptionDescription
 * @author "Richard Arriaga"
 */
Public method "a decoding iterator that buffers_element|elements of_using_" is
[
 	size : [4096..∞),
 	src : iterator of byte,
 	dc : decoder
 |
	a decoding iterator with
		element type ::= character,
		element source ::= src,
		maximum buffer size ::= size,
		internal decoder ::= dc
] : decoding iterator;
	
/**
 * A constructor method to create a decoding iterator with a fixed buffer size
 * of 32,768.
 *
 * @method "a decoding iterator of_using_"
 * @categories "Codec"
 * @param "src" "iterator of byte" 
 *        The source iterator to be decoded
 * @returns "decoding iterator"
 *          A decoding iterator
 * @raises "exceptionName" 
 *         exceptionDescription
 * @author "Richard Arriaga"
 */
Public method "a decoding iterator of_using_" is
[
 	src : iterator of byte,
 	cdc : codec
 |
 	a decoding iterator that buffers 32768 elements of src using cdc
]:decoding iterator;


/*
 * Ensure that the specified iterator is not exhausted, then advance its state.
 *
 * @param "anIterator" "decoding iterator"
 *        An encoding iterator.
 * @author "Richard Arriaga"
 */
decoding iterator's next buffer method is
[
	anIterator : decoding iterator
|
	next ::= take at most anIterator's maximum buffer size from anIterator's 
		element source;
	if next is empty then [finish decoding with anIterator's internal decoder]
	else [decode next using anIterator's internal decoder]
] : tuple;

/**
 * @method "a|an_«with«_«:»?:=_‡,»»"
 * @forbids "1" "decoding iterator" "encoding iterator"
 */
Grammatical restriction "a|an_«with«_«:»?:=_‡,»»" is
	<{
	 	"decoding iterator",
	 	"encoding iterator"
	}, ∅, ∅>;
