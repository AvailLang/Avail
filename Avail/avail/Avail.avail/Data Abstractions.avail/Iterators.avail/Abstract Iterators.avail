/*
 * Abstract Iterators.avail
 * Copyright © 1993-2014, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Abstract Iterators"
Versions
	"dev"
Extends
	"Common" = ("element type", "_'s⁇element type"),
	"Foundation" =
	(
		"For each of⁇_do_",
		"concatenate_",
		"filter_by_",
		"map_through_",
		"take from_until_",
		"take from_while_",
		"zip_",
		"«_‡zip»",
		"«_‡++»"
	)
Uses
	"Common" = ("Data|data abstractions test suite"),
	"Foundation",
	"Unit Testing" = ("New test suite,⁇_,⁇extends_")
Names
	"Advance_",
	"Drop from_until_",
	"Drop from_while_",
	"Drop«at most»?_from_",
	"Seal_'s⁇current element method",
	"Seal_'s⁇advance method",
	"an exhausted iterator",
	"decorated iterator|iterators",
	"exhausted iterator",
	"exhausted-iterator exception",
	"iterator",
	"iterators test suite",
	"iterator of_",
	"take«at most»?_from_",
	"_is exhausted",
	"_is not exhausted",
	"_'s⁇current element",
	"_'s⁇current element method is_",
	"_'s⁇advance method is_"
Body

/* TODO: [TLS] Remove these constants once a macro is available for "$…". */
privateCurrentElementName ::= $"private_'s⁇current element";
privateAdvanceName ::= $"Private advance_";

Public "decorated iterator|iterators" is a new field atom;
"transformer" is a new field atom;
"filter" is a new field atom;
"iterator index" is a new field atom;

/**
 * An iterator is a mutable lazy list of arbitrarily many elements.
 *
 * @type "iterator"
 */
Public explicit class "iterator" extends object
	with fields
		element type : any's type;

/**
 * Construct and answer an iterator type that answers values of the specified
 * type.
 *
 * @method "iterator of_"
 * @param "elementType" "any's type"
 *        The type of value produced by iterators of the answered type.
 * @returns "iterator's type"
 *          The requested iterator type.
 */
Public method "iterator of_" is
[
	elementType : any's type
|
	extend iterator with element type : elementType's type
] : iterator's type;

/**
 * An exhausted-iterator exception is raised when an inappropriate operation,
 * like {@method "Advance_"}, is performed on an exhausted iterator.
 *
 * @type "exhausted-iterator exception"
 * @supertype "exception"
 */
Public explicit class "exhausted-iterator exception" extends exception;

/**
 * Is the specified iterator exhausted?
 *
 * @method "_is exhausted"
 * @param "anIterator" "iterator"
 *        An iterator.
 * @returns "boolean"
 *          {@code true} if the argument is exhausted, {@code false} otherwise.
 */
Abstract method "_is exhausted" is [iterator]→boolean;

Private abstract method privateCurrentElementName is [iterator]→any;

/**
 * Ensure that the specified iterator is not exhausted, then answer its current
 * element.
 *
 * @method "_'s⁇current element"
 * @param "anIterator" "iterator"
 *        An iterator.
 * @returns "any"
 *          The current element of the specified iterator.
 * @raises "exhausted-iterator exception"
 *         If the iterator is exhausted.
 */
Method "_'s⁇current element" is
[
	anIterator : iterator
|
	unless anIterator is exhausted then
	[
		private anIterator's current element
	]
	else
	[
		Raise an exhausted-iterator exception
	]
] : any;

Semantic restriction "_'s⁇current element" is
[
	iteratorType : iterator's type
|
	iteratorType's element type's instance
];

/**
 * Define a method to provide the current element of a non-exhausted iterator.
 * The public operation, {@"_'s⁇current element"}, does not permit extension (to
 * ensure that iterators are always checked for exhaustion), but the private
 * operation should not be called directly from client code. This special
 * defining method allows the private operation to be overridden for specific
 * iterator implementations without exposing it for direct use. These mechanisms
 * cooperate to ensure that iterator exhaustion checking is never bypassed.
 *
 * @method "_'s⁇current element method is_"
 * @param "iteratorType" "iterator's type"
 *        The iterator's type, as a cross check for the implementation.
 * @param "implementation" "[⊥]→any"
 *        The new method extension.
 * @returns "⊤"
 */
Public method "_'s⁇current element method is_" is
[
	iteratorType : iterator's type,
	implementation : [⊥]→any
|
	Private method privateCurrentElementName is implementation;
] : ⊤;

Semantic restriction "_'s⁇current element method is_" is
[
	iteratorMeta : iterator's type's type,
	implementationType : [⊥]→any's type
|
	If implementationType[1] = ⊥ then
	[
		Reject parse, expected:
			"function's parameter types to be statically known"
	];
	If ¬implementationType[1] ⊆ iteratorMeta's instance then
	[
		Reject parse, expected:
			"function parameter type ("
			++ “implementationType[1]”
			++ ") to be a subtype of the iterator type ("
			++ “iteratorMeta's instance”
			++ ")"
	];
	⊤
];

/**
 * Seal the current element method at the specified {@type "iterator"} type.
 *
 * @method "Seal_'s⁇current element method"
 * @param "iteratorType" "iterator's type"
 * @returns "⊤"
 */
Public method "Seal_'s⁇current element method" is
[
	iteratorType : iterator's type
|
	Seal method privateCurrentElementName at <iteratorType>;
] : ⊤;

Private abstract method privateAdvanceName is [iterator]→⊤;

/**
 * Ensure that the specified iterator is not exhausted, then advance its state.
 *
 * @method "Advance_"
 * @param "anIterator" "iterator"
 *        An iterator.
 * @returns "⊤"
 * @raises "exhausted-iterator exception"
 *         If the iterator is exhausted.
 */
Method "Advance_" is
[
	anIterator : iterator
|
	Unless anIterator is exhausted then
	[
		Private advance anIterator;
	]
	else
	[
		Raise an exhausted-iterator exception
	];
] : ⊤;

/**
 * Define a method to advance the state of a non-exhausted iterator. The public
 * operation, {@method "Advance_"}, does not permit extension (to ensure that iterators
 * are always checked for exhaustion), but the private operation should not be
 * called directly from client code. This special defining method allows the
 * private operation to be overridden for specific iterator implementations
 * without exposing it for direct use. These mechanisms cooperate to ensure that
 * iterator exhaustion checking is never bypassed.
 *
 * @method "_'s⁇advance method is_"
 * @param "iteratorType" "iterator's type"
 *        The iterator's type, as a cross check for the implementation.
 * @param "implementation" "[⊥]→⊤"
 *        The new method extension.
 */
Public method "_'s⁇advance method is_" is
[
	iteratorType : iterator's type,
	implementation : [⊥]→⊤
|
	Private method privateAdvanceName is implementation;
] : ⊤;

Semantic restriction "_'s⁇advance method is_" is
[
	iteratorMeta : iterator's type's type,
	implementationType : [⊥]→⊤'s type
|
	If implementationType[1] = ⊥ then
	[
		Reject parse, expected:
			"function's parameter types to be statically known"
	];
	If ¬implementationType[1] ⊆ iteratorMeta's instance then
	[
		Reject parse, expected:
			"function parameter type ("
			++ “implementationType[1]”
			++ ") to be a subtype of the iterator type ("
			++ “iteratorMeta's instance”
			++ ")"
	];
	⊤
];

/**
 * Seal the advance method at the specified {@type "iterator"} type.
 *
 * @method "Seal_'s⁇advance method"
 * @param "iteratorType" "iterator's type"
 * @returns "⊤"
 */
Public method "Seal_'s⁇advance method" is
[
	iteratorType : iterator's type
|
	Seal method privateAdvanceName at <iteratorType>;
] : ⊤;

/**
 * An exhausted iterator has ⊥ as its element type.
 *
 * @type "exhausted iterator"
 * @supertype "iterator"
 */
Public explicit class "exhausted iterator" extends iterator
	with fields
		element type : ⊥'s type;

/**
 * Answer {@code true}.
 *
 * @method "_is exhausted"
 * @param "anIterator" "exhausted iterator"
 *        An {@type "exhausted iterator"}.
 * @returns "true's type"
 *          {@code true}.
 */
Method "_is exhausted" is
[
	anIterator : exhausted iterator
|
	true
] : true's type;

/**
 * Raise an {@type "exhausted-iterator exception"}.
 *
 * @method "_s⁇current element"
 * @param "anIterator" "exhausted iterator"
 *        An exhausted iterator.
 * @returns "⊥"
 * @raises "exhausted-iterator exception"
 *         Always.
 */
Method "_s⁇current element" is
[
	anIterator : exhausted iterator
|
	Raise an exhausted-iterator exception
] : ⊥;

Semantic restriction "_s⁇current element" is
[
	iteratorType : exhausted iterator's type
|
	Reject parse, expected:
		"an exhausted iterator not to be asked for its current element"
];

/**
 * Raise an `exhausted-iterator exception`.
 *
 * @method "Advance_"
 * @param "anIterator" "exhausted iterator"
 *        An exhausted iterator.
 * @returns "⊥"
 * @raises "exhausted-iterator exception"
 *         Always.
 */
Method "Advance_" is
[
	anIterator : exhausted iterator
|
	Raise an exhausted-iterator exception
] : ⊥;

Semantic restriction "Advance_" is
[
	iteratorType : exhausted iterator's type
|
	Reject parse, expected:
		"an exhausted iterator not to be asked to advance"
];

theExhaustedIterator ::= an exhausted iterator with element type ::= ⊥;

/**
 * Answer an {@type "exhausted iterator"}.
 *
 * @method "an exhausted iterator"
 * @returns "exhausted iterator"
 *          An exhausted iterator.
 */
Public method "an exhausted iterator" is [ theExhaustedIterator ];
Grammatical restriction "a|an_«with«_:=_‡,»»"
	is <{"exhausted iterator"}, ∅, ∅>;

/* Seal the public operations. */
Seal method "_is exhausted" at <exhausted iterator>;
Seal method "_'s⁇current element" at <iterator>;
Seal method "Advance_" at <iterator>;

/**
 * Iteratively apply {@param "action"} to each consecutive element of {@param
 * "anIterator"}.
 *
 * @method "For each of⁇_do_"
 * @param "anIterator" "iterator"
 *        An iterator.
 * @param "action" "[⊥]→⊤"
 *        A function that accepts the elements of the iterator.
 * @returns "⊤"
 */
Method "For each of⁇_do_" is
[
	anIterator : iterator,
	action : [⊥]→⊤
|
	Until [ anIterator is exhausted ]
	do
	[
		action(anIterator's current element);
		Advance anIterator;
	];
] : ⊤;

/**
 * Helper method for semantic restrictions: If `action` does not accept the
 * element type of `iteratorType`, then reject the current parse.
 *
 * @method "Require:_accepts_"
 * @param "action" "[⊥]→⊤'s type"
 *        A function type whose sole parameter must correspond to the element
 *        type of `iteratorType`.
 * @param "iteratorType" "iterator's type"
 *        An iterator type.
 * @returns "⊤"
 */
Method "Require:_accepts_" is
[
	actionType : [⊥]→⊤'s type,
	iteratorType : iterator's type
|
	elementType ::= iteratorType's element type's instance;
	If actionType[1] ≠ ⊥ ∧ [ ¬elementType ⊆ actionType[1] ] then
	[
		Reject parse, expected:
			format
				"repeatedly applied function to accept all elements ∈ “①” \
				\|of the iterator (but it only accepts “②”)"
			with elementType, actionType[1]
	];
] : ⊤;

Semantic restriction "For each of⁇_do_" is
[
	iteratorType : iterator's type,
	actionType : [⊥]→⊤'s type
|
	Require: actionType accepts iteratorType;
	⊤
];

/**
 * {@method "map_through_"} produces mapped iterators. A mapped iterator
 * decorates another iterator and retains a transformer function. When it is
 * asked for its current element, it answers the result of applying the function
 * to the current element of the decorated iterator.
 *
 * @type "mapped iterator"
 * @supertype "iterator"
 */
Class "mapped iterator" extends iterator
	with fields
		decorated iterator : iterator,
		transformer : [⊥]→any;

Method "_is exhausted" is
[
	anIterator : mapped iterator
|
	anIterator's decorated iterator is exhausted
] : boolean;

mapped iterator's current element method is
[
	anIterator : mapped iterator
|
	invoke anIterator's transformer
		with <anIterator's decorated iterator's current element>
] : any;

mapped iterator's advance method is
[
	anIterator : mapped iterator
|
	Advance anIterator's decorated iterator;
] : ⊤;

/**
 * Construct and answer an iterator that applies {@param "theTransformer"} to
 * the consecutive elements of {@param "anIterator"}. The result is lazy, so
 * {@param "anIterator"} may be infinite.
 *
 * @method "map_through_"
 * @param "anIterator" "iterator"
 *        The source {@type "iterator"}.
 * @param "theTransformer" "[⊥]→any"
 *        A function that accepts the elements of {@param "anIterator"}.
 * @returns "iterator"
 *          An iterator that applies {@param "theTransformer"} to the current
 *          element of {@param "anIterator"} when asked for its own current
 *          element.
 */
Method "map_through_" is
[
	anIterator : iterator,
	theTransformer : [⊥]→any
|
	a mapped iterator with
		element type ::= theTransformer's type's return type,
		decorated iterator ::= anIterator,
		transformer ::= theTransformer
] : iterator;

Semantic restriction "map_through_" is
[
	iteratorType : iterator's type,
	transformerType : [⊥]→any's type
|
	Require: transformerType accepts iteratorType;
	extend iterator with element type : transformerType's return type's type
];

/**
 * {@method "filter_by_"} produces filtered iterators. A filtered iterator
 * decorates another iterator and retains a filter function. When asked for its
 * current element, it answers the first element of the decorated iterator that
 * satisfies the filter function.
 *
 * @type "filtered iterator"
 * @supertype "iterator"
 */
Class "filtered iterator" extends iterator
	with fields
		decorated iterator : iterator,
		filter : [⊥]→boolean;

Method "_is exhausted" is
[
	anIterator : filtered iterator
|
	found : boolean := false;
	inner ::= anIterator's decorated iterator;
	Until [found ∨ [inner is exhausted]]
	do
	[
		If anIterator's filter(inner's current element) then
		[
			found := true;
		]
		else
		[
			Advance inner;
		];
	];
	¬found
] : boolean;

filtered iterator's current element method is
[
	anIterator : filtered iterator
|
	/* The current element of the decorated iterator must satisfy the filter.
	 * This is ensured by "_is exhausted".
	 */
	anIterator's decorated iterator's current element
] : any;

filtered iterator's advance method is
[
	anIterator : filtered iterator
|
	/* Unconditionally advance the decorated iterator. "_is exhausted" will
	 * determine if there is actually another element that passes the filter.
	 */
	Advance anIterator's decorated iterator;
] : ⊤;

/**
 * Construct and answer an iterator that applies {@param "predicate"} to
 * {@param "anIterator"}. The result is lazy, so {@param "anIterator"} may be
 * infinite. The result contains only those elements of {@param "anIterator"}
 * that pass the specified filter.
 *
 * Note that {@method "_is exhausted"} may require an infinite amount of time to
 * complete when presented with an infinite filtered iterator, e.g., consider
 * the case of:
 *
 * <pre>
 *     filter iterator from 1 to ∞ by [ x : natural number | x < 10 ]
 * </pre>
 *
 * Which will require infinite computation after advancing beyond the element
 * {@code 10}.
 *
 * @method "filter_by_"
 * @param "anIterator" "iterator"
 *        An {@type "iterator"}.
 * @param "predicate" "[⊥]→boolean"
 *        A function that accepts the elements of {@param "anIterator"} and
 *        answers {@code true} iff they should be obtainable via the result
 *        iterator.
 * @returns "iterator"
 *          An iterator capable of producing exactly those elements of {@param
 *          "anIterator"} for which {@param "predicate"} answers {@code true}.
 */
Method "filter_by_" is
[
	anIterator : iterator,
	predicate : [⊥]→boolean
|
	a filtered iterator with
		element type ::= anIterator's element type,
		decorated iterator ::= anIterator,
		filter ::= predicate
] : iterator;

Semantic restriction "filter_by_" is
[
	iteratorType : iterator's type,
	predicateType : [⊥]→boolean's type
|
	Require: predicateType accepts iteratorType;
	extend iterator with element type : iteratorType's element type
];

/**
 * A concatenation iterator produces values from a sequenced collection of
 * iterators.
 *
 * @type "concatenation iterator"
 * @supertype "iterator"
 */
Class "concatenation iterator" extends iterator
	with field
		decorated iterators : <iterator…|>
	with mutable field
		referable iterator index : natural number;

Method "_is exhausted" is
[
	anIterator : concatenation iterator
|
	index : ↑natural number := ↑anIterator's iterator index;
	iterators ::= anIterator's decorated iterators;
	limit ::= |iterators|;
	While [↓index ≤ limit ∧ [iterators[↓index] is exhausted]]
	do
	[
		index++;
	];
	↓index > limit
] : boolean;

concatenation iterator's current element method is
[
	anIterator : concatenation iterator
|
	inner ::= anIterator's decorated iterators[anIterator's iterator index];
	inner's current element
] : any;

concatenation iterator's advance method is
[
	anIterator : concatenation iterator
|
	index ::= anIterator's iterator index;
	iterators ::= anIterator's decorated iterators;
	Advance iterators[index];
] : ⊤;

/**
 * Construct and answer an {@type "iterator"} that produces values from the
 * specified tuple of iterators The result first produces the values of the
 * first element of the tuple, then the second, etc.
 *
 * @method "concatenate_"
 * @param "iterators" "<iterator…|>"
 *        A tuple of iterators.
 * @returns "iterator"
 *          The requested iterator.
 */
Method "concatenate_" is
[
	iterators : <iterator…|>
|
	if |iterators| = 0 then [an exhausted iterator]
	else if [|iterators| = 1] then [iterators[1]]
	else
	[
		elementType ::=
			cast ∪ map iterators through [i : iterator | i's element type]
			into [t : any's type | t];
		a concatenation iterator with
			element type ::= elementType,
			decorated iterators ::= iterators,
			iterator index := 1
	]
] : iterator;

/**
 * Construct and answer an {@type "iterator"} that produces values from the
 * specified tuple of iterators The result first produces the values of the
 * first lexical argument, then the second, etc.
 *
 * @method "«_‡++»"
 * @param "iterators" "<iterator…|>"
 *        A tuple of iterators.
 * @returns "iterator"
 *          The requested iterator.
 */
Method "«_‡++»" is
[
	iterators : <iterator…|2..>
|
	elementType ::=
		cast ∪ map iterators through [i : iterator | i's element type]
		into [t : any's type | t];
	a concatenation iterator with
		element type ::= elementType,
		decorated iterators ::= iterators,
		iterator index := 1
];

/**
 * Answer a function suitable for use as a semantic restriction for the
 * {@method "concatenate_"} and {@method "«_‡++»"} methods.
 *
 * @method "concatenation semantic restriction"
 * @returns "[<iterator…|>'s type]→(concatenation iterator's type)"
 *          The requested function.
 */
Private method "concatenation semantic restriction" is
[
	[
		iterators : <iterator…|>'s type
	|
		elementType : any's type's type := ⊥;
		From 1 to (⎣iterators⎦ min (|iterators' leading types| + 1)) do
		[
			index : natural number
		|
			elementType := eject ↑elementType ∪ iterators[index]'s element type;
		];
		extend concatenation iterator with
			element type : elementType,
			decorated iterators : iterators
	]
];

Semantic restriction "concatenate_" is concatenation semantic restriction;
Semantic restriction "«_‡++»" is concatenation semantic restriction;

/**
 * A zipped iterator produces zipped tuples from a sequenced collection of
 * iterators.
 *
 * @type "zipped iterator"
 * @supertype "iterator"
 */
Explicit class "zipped iterator" extends iterator
	with fields
		element type : tuple's type,
		decorated iterators : <iterator…|>;

Method "_is exhausted" is
[
	anIterator : zipped iterator
|
	any of anIterator's decorated iterators
		satisfies [i : iterator | i is exhausted]
] : boolean;

zipped iterator's current element method is
[
	anIterator : zipped iterator
|
	map anIterator's decorated iterators
		through [i : iterator | i's current element]
] : any;

zipped iterator's advance method is
[
	anIterator : zipped iterator
|
	For each anIterator's decorated iterators do [i : iterator | Advance i;];
] : ⊤;

/**
 * Construct and answer the zip of the specified {@type "iterator"}s. Given
 * <em>n</em> input iterators, the output is the iterator whose <em>i</em>-th
 * element is an <em>n</em>-tuple containing the <em>i</em>-th element from each
 * consecutive input iterator. The answer is exhausted when any of the input
 * iterators becomes exhausted.
 *
 * @method "zip_"
 * @param "iterators" "<iterator…|>"
 *        A tuple of iterators.
 * @returns "iterator"
 *          The requested iterator.
 */
Method "zip_" is
[
	iterators : <iterator…|1..>
|
	types ::= map iterators through [i : iterator | i's element type];
	elementType ::=
		<types[1..|types| - 1], types[|types|]… | |iterators|'s type>;
	a zipped iterator with
		element type ::= elementType,
		decorated iterators ::= iterators
] : iterator;

/**
 * Construct and answer the zip of the specified {@type "iterator"}s. Given
 * <em>n</em> input iterators, the output is the iterator whose <em>i</em>-th
 * element is an <em>n</em>-tuple containing the <em>i</em>-th element from each
 * consecutive input iterator. The answer is exhausted when any of the input
 * iterators becomes exhausted.
 *
 * @method "«_‡zip»"
 * @param "iterators" "<iterator…|>"
 *        A tuple of iterators.
 * @returns "iterator"
 *          The requested iterator.
 */
Method "«_‡zip»" is
[
	iterators : <iterator…|2..>
|
	types ::= map iterators through [i : iterator | i's element type];
	elementType ::=
		<types[1..|types| - 1], types[|types|]… | |iterators|'s type>;
	a zipped iterator with
		element type ::= elementType,
		decorated iterators ::= iterators
] : iterator;

/**
 * Answer a function suitable for use as a semantic restriction for the
 * {@method "zip_"} and {@method "«_‡zip»"} methods.
 *
 * @method "zip semantic restriction"
 * @returns "[<iterator…|>'s type]→(zipped iterator's type)"
 *          The requested function.
 */
Private method "zip semantic restriction" is
[
	[
		iterators : <iterator…|1..>'s type
	|
		types : <any's type…|> := <>;
		From 1 to (⎣iterators⎦ min (|iterators' leading types| + 1)) do
		[
			index : natural number
		|
			types := eject ↑types
				++ <iterators[index]'s element type's instance>;
		];
		nonempty ::= cast types into [t : <any's type…|1..> | t];
		elementType ::=
			<nonempty[1..|nonempty| - 1], nonempty[|nonempty|]…
				| ||iterators||>;
		extend zipped iterator with
			element type : elementType's type,
			decorated iterators : iterators
	]
];

Semantic restriction "zip_" is zip semantic restriction;
Semantic restriction "«_‡zip»" is zip semantic restriction;

/**
 * Answer a tuple containing (at most) the first {@param "count"} elements of
 * {@param "anIterator"}.
 *
 * @method "take«at most»?_from_"
 * @param "isLax" "boolean"
 *        {@code false} if an {@type "exhausted-iterator exception"} should be
 *        raised if {@param "count"} exceeds the number of elements remaining,
 *        {@code true} otherwise.
 * @param "count" "[0..∞]"
 *        The size of the requested tuple.
 * @param "anIterator" "iterator"
 *        An iterator.
 * @returns "tuple"
 *          A tuple containing the first {@param "count"} elements of {@param
 *          "anIterator"}, preserving the original order.
 * @raises "exhausted-iterator exception"
 *         If {@param "isLax"} is {@code false} and {@param "anIterator"} does
 *         not contain {@param "count"} elements.
 */
Method "take«at most»?_from_" is
[
	isLax : boolean,
	count : [0..∞],
	anIterator : iterator
|
	result : tuple := <>;
	Guard
	[
		Repeat
		[
			next ::= anIterator's current element;
			result := eject ↑result ++ <next>;
			Advance anIterator;
		] count times;
	]
	intercept
	[
		e : exhausted-iterator exception
	|
		Unless isLax then [Raise e];
	];
	result
] : tuple;

Semantic restriction "take«at most»?_from_" is
[
	laxity : boolean's type,
	count : [0..∞]'s type,
	iteratorType : iterator's type
|
	min ::= if laxity = true's type then [0] else [⎣count⎦];
	<<>, iteratorType's element type's instance…|[min..⎡count⎤+1)>
];

/**
 * Checks to see if the iterator of character is not exhausted.
 * @method "_is not exhausted"
 * @public
 * @category "Annals"
 * @param "anIterator" "iterator"
 * @returns "boolean"
 * @author "Richard Arriaga"
 */
Public method "_is not exhausted" is
[
 	anIterator : iterator
|
 	¬anIterator is exhausted
]:boolean;

/**
 * Answer a tuple containing the prefix of {@param "anIterator"} that answered
 * {@code "true"} to {@param "predicate"}.
 *
 * @method "take from_while_"
 * @param "anIterator" "iterator"
 *        An iterator.
 * @param "predicate" "[⊥]→boolean"
 *        A function that can accept each element of the specified iterator. It
 *        should answer {@code true} to keep the element (and continue scanning)
 *        or {@code false} to abort.
 * @returns "tuple"
 *          A tuple containing the prefix of {@param "anIterator"} that
 *          satisfied {@param "predicate"}.
 */
Method "take from_while_" is
[
	anIterator : iterator,
	predicate : [⊥]→boolean
|
	result : tuple := <>;
	While
	[
		anIterator is not exhausted ∧ [predicate(anIterator's current element)]
	]
	do
	[
		result := eject ↑result ++ <anIterator's current element>;
		Advance anIterator;
	];
	result
] : tuple;

Semantic restriction "take from_while_" is
[
	iteratorType : iterator's type,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts iteratorType;
	<iteratorType's element type's instance…|>
];

/**
 * Answer a tuple containing the prefix of {@param "anIterator"} that answered
 * {@code "false"} to {@param "predicate"}.
 *
 * @method "take from_until_"
 * @param "anIterator" "iterator"
 *        An iterator.
 * @param "predicate" "[⊥]→boolean"
 *        A function that can accept each element of the specified iterator. It
 *        should answer {@code false} to keep the element (and continue
 *        scanning) or {@code true} to abort.
 * @returns "tuple"
 *          A tuple containing the prefix of {@param "anIterator"} that
 *          satisfied {@param "predicate"}.
 */
Method "take from_until_" is
[
	anIterator : iterator,
	predicate : [⊥]→boolean
|
	result : tuple := <>;
	Until
	[
		anIterator is exhausted ∨ [predicate(anIterator's current element)]
	]
	do
	[
		result := eject ↑result ++ <anIterator's current element>;
		Advance anIterator;
	];
	result
] : tuple;

Semantic restriction "take from_until_" is
[
	iteratorType : iterator's type,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts iteratorType;
	<iteratorType's element type's instance…|>
];

/**
 * Forward the specified {@type "iterator"} past (at most) the first {@param
 * "count"} elements.
 *
 * @method "Drop«at most»?_from_"
 * @param "isLax" "boolean"
 *        {@code false} if an {@type "exhausted-iterator exception"} should be
 *        raised if {@param "count"} exceeds the number of elements remaining,
 *        {@code true} otherwise.
 * @param "count" "whole number"
 *        The size of the prefix of {@param "anIterator"} that should be omitted
 *        from the result iterator.
 * @param "anIterator" "iterator"
 *        An iterator.
 * @returns "⊤"
 * @raises "exhausted-iterator exception"
 *         If {@param "isLax"} is {@code false} and {@param "anIterator"} does
 *         not contain {@param "count"} elements.
 */
Method "Drop«at most»?_from_" is
[
	isLax : boolean,
	count : whole number,
	anIterator : iterator
|
	Guard
	[
		Repeat [Advance anIterator;] count times;
	]
	intercept
	[
		e : exhausted-iterator exception
	|
		Unless isLax then [Raise e];
	];
] : ⊤;

/**
 * Forward the specified {@type "iterator"} past the prefix of elements that
 * answer {@code true} to {@param "predicate"}.
 *
 * @method "Drop from_while_"
 * @param "anIterator" "iterator"
 *        An iterator.
 * @param "predicate" "[⊥]→boolean"
 *        A function that can accept each element of the specified iterator. It
 *        should answer {@code true} to discard the element (and continue
 *        scanning) or {@code false} to abort.
 * @returns "⊤"
 */
Method "Drop from_while_" is
[
	anIterator : iterator,
	predicate : [⊥]→boolean
|
	While
	[
		anIterator is not exhausted ∧ [predicate(anIterator's current element)]
	]
	do
	[
		Advance anIterator;
	];
] : ⊤;

Semantic restriction "Drop from_while_" is
[
	iteratorType : iterator's type,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts iteratorType;
	⊤
];

/**
 * Forward the specified {@type "iterator"} past the prefix of elements that
 * answer {@code false} to {@param "predicate"}.
 *
 * @method "Drop from_while_"
 * @param "anIterator" "iterator"
 *        An iterator.
 * @param "predicate" "[⊥]→boolean"
 *        A function that can accept each element of the specified iterator. It
 *        should answer {@code false} to discard the element (and continue
 *        scanning) or {@code true} to abort.
 * @returns "⊤"
 */
Method "Drop from_until_" is
[
	anIterator : iterator,
	predicate : [⊥]→boolean
|
	Until
	[
		anIterator is exhausted ∨ [predicate(anIterator's current element)]
	]
	do
	[
		Advance anIterator;
	];
] : ⊤;

Semantic restriction "Drop from_until_" is
[
	iteratorType : iterator's type,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts iteratorType;
	⊤
];

Public "iterators test suite" is a new field atom;
New test suite iterators test suite extends data abstractions test suite;
