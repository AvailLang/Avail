/**
 * Guillemet-Test.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Guillemet-Test"
Extends
Uses
	"Kernel"
Names
Body

Method "Start«_‡@»End" is [x : tuple |
	x;
];

Assert Start End = <>;
Assert Start 1 End = <1>;
Assert Start 1 @ 2 End = <1, 2>;
Assert Start 1 @ 2 @ 3 End = <1, 2, 3>;


/* Test no arguments. */
Method "«Spam»" is [x : tuple of tuple like <> |
	||x||;
];

Assert Spam = 1;
Assert Spam Spam Spam Spam = 4;


/* Test argument to the right of the double-dagger. */
Method "«!‡_»" is [x : tuple of (tuple [0..1] like <> default integer) |
	x;
];

Assert !10!20!30! = <<10>,<20>,<30>,<>>;
Assert !1!1!1!1!1! = <<1>,<1>,<1>,<1>,<1>,<>>;
Assert !0! = <<0>,<>>;
Assert ! = <<>>;


/* Test nullable content (guillemet group occurrence with nothing inside). */
Method "««cat»«dog»»" is [
		t : tuple of tuple [2..2] of tuple [0..1] of tuple [0..0] of any |
	t collect [y : tuple [2..2] of tuple |
		if ||y[1]|| = 1 then [$"c";] else [$"d";];
	];
] : string;

Restriction "««cat»«dog»»" is [xT : tupleType |
	limit ::= cast xT sizes upper bound into [lim : [0..INF) | lim;];
	good ::= (1 to limit) all [
			subscript : natural number |
		cast xT[subscript] into [pairT : tupleType |
			catCount ::= cast pairT[1] into [catT : tupleType |
				catT sizes upper bound;];
			dogCount ::= cast pairT[2] into [dogT : tupleType |
				dogT sizes upper bound;];
			catCount + dogCount = 1;
		];
	];
	if not good then [
		Fail parse "Invalid cat/dog counts";];
	void;
];

Assert cat = "c";
Assert dog = "d";
Assert cat cat = "cc";
Assert cat dog = "cd";
Assert dog cat = "dc";
Assert dog dog = "dd";
Assert cat cat cat = "ccc";
Assert cat cat dog = "ccd";
Assert cat dog cat = "cdc";
Assert cat dog dog = "cdd";
Assert dog cat cat = "dcc";
Assert dog cat dog = "dcd";
Assert dog dog cat = "ddc";
Assert dog dog dog = "ddd";

Method "«very»#good" is
[
	count : whole number
|
	count;
];

Assert good = 0;
Assert very good = 1;
Assert very very good = 2;
Assert very very very good = 3;

Method "«very‡,»#bad" is
[
	count : [3..5]
|
	count;
];

Assert very, very, very bad = 3;
Assert very, very, very, very bad = 4;
Assert very, very, very, very, very bad = 5;

Method "«extremely»?plaid" is
[
	extremely : boolean
|
	extremely;
];

Assert plaid = false;
Assert extremely plaid = true;

_token ::= Special Object 115;
_literalToken ::= Special Object 116;

Method "token" is [ _token; ];
Method "literal token" is [ _literalToken; ];
Method "_'s lexeme" is [ aToken : token | Primitive 356; ] : string;

Method "I««really»?like to»eat…«very»#much" is
[
	really : tuple [0..1] of boolean,
	subject : token,
	very : natural number
|
	reallyText ::= if ||really|| = 0
		then [ ""; ]
		else [
			(if really[1] then [ "really "; ] else [ ""; ]) then "like to "; ];
	veryText : string := "";
	From 1 to very do [ i : whole number |
		veryText := veryText then "very "; ];
	"I "
		then reallyText
		then "eat "
		then subject's lexeme
		then " "
		then veryText
		then "much";
] : string;

Assert I eat bacon very much = "I eat bacon very much";
Assert I like to eat tires very much = "I like to eat tires very much";
Assert I really like to eat perfume very very very much =
	"I really like to eat perfume very very very much";
