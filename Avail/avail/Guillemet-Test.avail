/**
 * Guillemet-Test.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Guillemet-Test"
Extends
Uses
	"Kernel"
Names
Body

Method "Start«_‡@»End" is [x : tuple |
	x
];

Assert Start End = <>;
Assert Start 1 End = <1>;
Assert Start 1 @ 2 End = <1, 2>;
Assert Start 1 @ 2 @ 3 End = <1, 2, 3>;


/* Test no arguments. */
Method "«Spam»" is [x : tuple of tuple like <> |
	||x||
];

Assert Spam = 1;
Assert Spam Spam Spam Spam = 4;


/* Test argument to the right of the double-dagger. */
Method "«`!‡_»" is [x : tuple of (tuple [0..1] like <> default integer) |
	x
];

Assert !10!20!30! = <<10>,<20>,<30>,<>>;
Assert !1!1!1!1!1! = <<1>,<1>,<1>,<1>,<1>,<>>;
Assert !0! = <<0>,<>>;
Assert ! = <<>>;


/* Test nullable content (guillemet group occurrence with nothing inside). */
Method "««cat»«dog»»" is [
		t : tuple of tuple [2..2] of tuple [0..1] of tuple [0..0] of any |
	t collect [y : tuple [2..2] of tuple |
		if ||y[1]|| = 1 then [$"c"] else [$"d"]
	]
] : string;

Restriction "««cat»«dog»»" is [xT : tupleType |
	limit ::= cast xT sizes upper bound into [lim : [0..INF) | lim];
	good ::= (1 to limit) all [
			subscript : natural number |
		cast xT[subscript] into [pairT : tupleType |
			catCount ::= cast pairT[1] into [catT : tupleType |
				catT sizes upper bound];
			dogCount ::= cast pairT[2] into [dogT : tupleType |
				dogT sizes upper bound];
			catCount + dogCount = 1
		]
	];
	if not good then [
		Fail parse "Invalid cat/dog counts"];
	void
];

Assert cat = "c";
Assert dog = "d";
Assert cat cat = "cc";
Assert cat dog = "cd";
Assert dog cat = "dc";
Assert dog dog = "dd";
Assert cat cat cat = "ccc";
Assert cat cat dog = "ccd";
Assert cat dog cat = "cdc";
Assert cat dog dog = "cdd";
Assert dog cat cat = "dcc";
Assert dog cat dog = "dcd";
Assert dog dog cat = "ddc";
Assert dog dog dog = "ddd";

Method "«very»#good" is
[
	count : whole number
|
	count
];

Assert good = 0;
Assert very good = 1;
Assert very very good = 2;
Assert very very very good = 3;

Method "«very‡,»#bad" is
[
	count : [3..5]
|
	count
];

Assert very, very, very bad = 3;
Assert very, very, very, very bad = 4;
Assert very, very, very, very, very bad = 5;

Method "«super»?«extremely»?plaid" is
[
	super : boolean,
	extremely : boolean
|
	super & extremely
];

Assert plaid = false;
Assert extremely plaid = false;
Assert super plaid = false;
Assert super extremely plaid = true;

_token ::= Special Object 115;
_literalToken ::= Special Object 116;

Method "token" is [ _token ];
Method "literal token" is [ _literalToken ];
Method "_'s⁇lexeme" is [ aToken : token | Primitive 356; ] : string;

Method "I««really»?like to»eat…«very»#much" is
[
	really : tuple [0..1] of boolean,
	subject : token,
	very : natural number
|
	reallyText ::= if ||really|| = 0
		then [ "" ]
		else [
			(if really[1] then [ "really " ] else [ "" ]) then "like to " ];
	veryText : string := "";
	From 1 to very do [ i : whole number |
		veryText := veryText then "very "; ];
	"I "
		then reallyText
		then "eat "
		then subject's lexeme
		then " "
		then veryText
		then "much"
] : string;

Assert I eat bacon very much = "I eat bacon very much";
Assert I like to eat tires very much = "I like to eat tires very much";
Assert I really like to eat perfume very very very much =
	"I really like to eat perfume very very very much";

Method "chaos~speak~" is [ true ] : boolean;

Assert chaos speak;
Assert CHAOS SPEAK;
Assert Chaos Speak;
Assert cHaOs SpEaK;
Assert ChAoS sPeAk;

Method "I«want some gravy,«please‡,»#»~or else kablam" is
[
	please : tuple [1..1] of natural number
|
	please[1]
] : natural number;

Assert I want some gravy, please or else kablam = 1;
Assert I WANT somE gRAVy, pLEasE, pleASE, PlEaSe, pLEAse or else kablam = 4;

Method "«go away»#~«maybe»?~" is
[
	begone : [2..5],
	maybe : boolean
|
	begone
] : [2..5];

Assert GO AWAY go away = 2;
Assert go away go away go away go away GO AWAY MAYBE = 5;
Assert GO AWAY GO AWAY GO AWAY maybe = 3;

Method "«intruder~ALERT»" is [ intruder : tuple [1..∞) of tuple | true ];

Assert intruder ALERT;
Assert InTrUdEr ALERT iNtRuDeR ALERT INTRUDER ALERT intruder ALERT;

Method "«filthy grubby»⁇~maggots" is [ true ];

Assert maggots;
Assert filthy grubby maggots;
Assert filthy GRUBBY maggots;
