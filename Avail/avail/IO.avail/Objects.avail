/**
 * IO/Objects.avail
 * Copyright (c) 2010, Mark van Gulik.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Objects"
Extends
Uses
	"Kernel",
	"Reflection"
Names
	"_exploded",
	"_imploded"
Body



/* I define the object input / output protocol for Avail. */

/* Helper tables... */

primitiveTypes : tuple of type;
primitiveTypes := <
	boolean,
	trueType,
	falseType,
	character,
	function,
	compiledCode,
	container,
	continuation,
	double,
	float,
	implementationSet,
	messageBundle,
	messageBundleTree,
	parseNode,
	assignmentNode,
	blockNode,
	tupleNode,
	literalNode,
	referenceNode,
	sendNode,
	superCastNode,
	variableDeclarationNode,
	syntheticConstantNode,
	initializingDeclarationNode,
	constantDeclarationNode,
	labelNode,
	syntheticDeclarationNode,
	variableUseNode,
	process,
	signature,
	abstractSignature,
	forwardSignature,
	methodSignature>;
primitiveTypeIndices : map from type to natural number;
primitiveTypeIndices := [->];
1 to ||primitiveTypes|| do [i : natural number |
	*&primitiveTypeIndices[primitiveTypes[i]] := i;
];


/* Basic algorithm... */

Abstract method "_exploded" for [any] -> tuple;
Abstract method "_imploded" for [tuple] -> any;

Method "encoder_decoder_" is [encoder : [terminates]->tuple, decoder : [terminates]->any |
	Method "_exploded" is encoder;
	Method "_imploded" is decoder;
]: void
requires [encT : functionType, decT : functionType |
	/* Make sure of a couple of things:  You get back the kind of thing you
	   put in, and the decoder accepts everything the encoder produces.  */
	decT result = encT[1]
		& [
			cast decT[1] into [decoderTupleType : tupleType |
				cast encT result into [encoderTupleType : tupleType |
					encoderTupleType[1] <= decoderTupleType[1];
				];
			];
		];
];


encoder [i : [0..INF) | <0>;]     /* Special case in "Dump_on_". */
decoder [t : tuple like <[0..0]> |
	Crash "Don't actually call the positive integer decoder";
] : [0..INF);

encoder [i : [-INF..-INF] | <1>;]
decoder [t : tuple like <[1..1]> | -INF;];

encoder [i : [INF..INF] | <2>;]
decoder [t : tuple like <[2..2]> | INF;];

encoder [i : (-INF..-1] | <3, -i>;]
decoder [t : tuple like <[3..3], [1..INF)> | -t[2];];

encoder [f : falseType | <4>;]
decoder [t : tuple like <[4..4]> | false;];

encoder [t : trueType | <5>;]
decoder [t : tuple like <[5..5]> | true;];

encoder [t : tuple |
	<6> then t;
] : tuple [1..INF) like <[6..7]> default any
decoder [t : tuple [1..INF) like <[6..7]> default any |
	t[2..||t||];];

encoder [t : string | <7> then t;]
decoder [t : tuple [1..INF) like <[7..7]> default character | t[2..||t||];];

encoder [s : set | <8> then s as tuple;]
decoder [t : tuple [1..INF) like <[8..8]> default any | t[2..||t||] as set;];

encoder [m : map |
	<9> then splice (m keys as tuple collect [k : any | <k,m[k]>;]);]
decoder [t : tuple [1..INF) like <[9..9]> default any |
	m : map := [->];
	i : natural number := 2;
	While [
		i < ||t||;
	] loop [
		*&m [t[i]] := t[i+1];
		i := i + 2;
	];
	m;
];

encoder [c : compiledCode |
	<10, c numArgs, c numLocals, c numOuters, c stackSize,
		c nybbles, c functionType, c primitive> then c literals;]
decoder [t : tuple [8..INF)
		like <[10..10],
			[0..INF), [0..INF), [0..INF), [0..INF),
			tuple of [0..15], functionType, [0..65535]>
		default any |
	compiledCode for
		t[2] args
		t[3] locals
		t[4] outers
		t[5] stack entries,
		with nybbles t[6]
		functionType t[7]
		primitive t[8]
		literals t[9..||t||];
];

encoder [c : function |
	<11, c compiledCode> then c outerVars;]
decoder [t : tuple [2..INF) like <[11..11], compiledCode> default any |
	function from t[2] outer variables t[3..||t||];];

encoder [t : type |
	<12, primitiveTypeIndices[t]>;
] : tuple [1..INF) like <[12..16]> default any
decoder [t : tuple [1..INF) like <[12..16]> default any |
	cast t[2] into [n : natural number | primitiveTypes[n];];
];

encoder [ct : functionType |
	<13, ct result> then (1 to ||ct|| collect [i : natural number | ct[i];]);]
decoder [t : tuple [2..INF) like <[13..13]> default type |
	block type taking t[3..||t||] and returning t[2];];

encoder [tt : tupleType |
	<14, tt sizes, tt default type> then tt leading types;]
decoder [t : tuple [3..INF) like <[14..14], integerType> default type |
	tuple t[2] like t[4..||t||] default t[3];];

encoder [iType : integerType |
	inclusion ::= if iType lower inclusive then [1;] else [0;]
		+ if iType upper inclusive then [2;] else [0;];
	<15, iType lower bound, iType upper bound, inclusion>;]
decoder [t : tuple like <[15..15], extended integer, extended integer, [0..3]> |
	range from t[2] inclusive t[4] is odd to t[3] inclusive t[4] >= 2;];

encoder [ct : atom |
	<16, ct name>;]
decoder [t : tuple like <[16..16], string> |
	lookup t[2];
	/* new cyclic type t[2]; */];

encoder [con : container |
	if *con = nil then [<17, con type readType>;]
	else [<17, con type readType, *con>;];]
decoder [t : tuple [2..3] like <[17..17], type> default any |
	/* Note - container values are fixed up in a second pass within Load_from_
	   so that Dump_on_ can perform a topological sort.  The idea is to break cycles.
	   Since every cycle must pass through a container, well, you get the idea.  */
	new container with content type t[2];];

encoder [impSet : implementationSet |
	<18, impSet name>;]
decoder [t : tuple like <[18..18], atom> |
	/* For now, we just save the atom, and assume that all the
	   actual implementations will be dumped/loaded separately. */
	t[2] implementation set;];

encoder [c : character | <19,code point of c>;]
decoder [t : tuple [2..2] like <[19..19]> default whole number | code point t[2];];

