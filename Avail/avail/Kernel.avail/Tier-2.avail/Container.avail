/**
 * .../Tier-2/Container.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Container"
Extends
Uses
	"Tier-1"
Names
	"*_:=_",
	"*_",
	"clearing*_",
	"*_:=nil",
	"*_=nil",
	"swap_and_"
Body


Method "*_:=_" is [var : container, arg : any |
	Primitive 11 (failureCode : natural number);
	Failed
] : void;

Restriction "*_:=_" is [varType : container type, argType : type |
	/* varType should be a subclass of container.  This ensures the metatype
	   will be containerType, so that the content type can be extracted (at link
	   time). */
	ok ::= if varType = container
	then [false]
	else [
		varTypeAsTypedContainer : containerType;
		*↑varTypeAsTypedContainer ?:= varType;
		argType <= varTypeAsTypedContainer writeType
	];
	if not ok then [ Fail parse "cannot assign to variable" ];
	void
];


Method "*_" is [var : container |
	Primitive 10 (failureCode : natural number);
	Failed
] : any;

Restriction "*_" is [varType : container type |
	/* If at some call site we don't know anything except that we have a
	   container, we must be careful to say the content type is any.  Otherwise
	   use the content type. */
	if varType = container
	then [any]
	else [
		/* Use the downcasting assignment operator *_?:=_  */
		varTypeAsTypedContainer : containerType;
		*↑varTypeAsTypedContainer ?:= varType;
		varTypeAsTypedContainer readType
	]
];

Method "clearing*_" is [var : container |
	/* Extract the current value of the variable, then clear the variable.
	   Answer the extracted value. */
	Primitive 18 (failureCode : natural number);
	Failed
] : any;

Restriction "clearing*_" is [varType : container type |
	/* If at some call site we don't know anything except that we have a
	   container, we must be careful to say the content type is any.  Otherwise
	   use the content type. */
	if varType = container
	then [any]
	else [
		/* Use the downcasting assignment operator *_?:=_  */
		varTypeAsTypedContainer : containerType;
		*↑varTypeAsTypedContainer ?:= varType;
		varTypeAsTypedContainer readType
	]
];

Method "*_:=nil" is [var : container |
	/* Clear the variable. */
	Primitive 12;
] : void;

Method "*_=nil" is [var : container |
	/* Test for an unassigned variable. */
	Primitive 17;
] : boolean;


/* Convenient swap method.  Probably impossible to type except as primitive.
   Primitive also avoids incrementing sticky reference counts when replicating
   variable contents. */

Method "swap_and_" is [var1 : container, var2 : container |
	/* In theory, I believe the following commented-out implementation would
	   work, but the primitive is more efficient.
		t : any;
		*& t ?:= clearing* var1;
		*& var1 ?:= clearing* var2;
		*& var2 ?:= clearing* t;
	   Let's just use the primitive instead... */

	Primitive 15 (failureCode : natural number);
	Failed
] : void;

Restriction "swap_and_" is [t1 : container type, t2 : container type |
	/* The containers must be the same type, otherwise the swap could break
	   the type constraints.  The container types must, therefore, be known at
	   the call site. */
	if t1 readType <= t2 writeType & t2 readType <= t1 writeType then [
		void
	] else [
		Fail parse "Container contents can not be swapped."
	]
];
