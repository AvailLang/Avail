/**
 * .../Tier-2/Tuple.avail
 * Copyright (c) 2010, Mark van Gulik.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Tuple"
Extends
Uses
	"Tier-1",
	"BlockA",
	"Container",
	"Continuation",
	"Number"
Names
	"«_‡then»",
	"splice_",
	"_do_",
	"_collect_",
	"_select_",
	"_reject_",
	"_all_",
	"_any_",
	"_to_",
	"_sum_",
	"_sum",
	"type of subtuple_from range_to range_",
	"concatenate tuple type_and_",
	"_[_->_]",
	"_[_.._->_]",
	"_[_.._]",
	"_[.._]",
	"_[_..]",
	"_radix_",
	"_decimal",
	"_hex",
	"code point_",
	"code point of_",
	"#_",
	"$_",
	"<«_‡,»`…|_.._>"
Body

/* Forward declarations of the remainder of this module... */

Forward "_[_]" for [tuple, natural number]->any;
Forward "«_‡then»" for [tuple of tuple]->tuple;
Forward "splice_" for [tuple of tuple]->tuple;
Forward "_to_" for [integer, integer]->tuple;
Forward "_[_->_]" for [tuple, natural number, any]->tuple;

/* Set up precedence rules to avoid ambiguity of _to_, _do_, and _to_do_... */

{"_do_"} can't have <{"_to_"}, {}>;

{"«_‡then»"} can't have <{"«_‡then»"}>;



/* Helper function for computing types of concatenations. */

Method "concatenate tuple type_and_" is [
		tt1 : tupleType,
		tt2 : tupleType |
	Primitive 144;
] : tupleType;

Method "«_‡then»" is [tuples : tuple of tuple |
	Primitive 136;
] : tuple;


Restriction "«_‡then»" is [outerTupleType : tupleType |
	output : tupleType := tuple like <>;
	exactSize : whole number := outerTupleType sizes lower bound;
	Assert exactSize = outerTupleType sizes upper bound;
	index : natural number := 1;
	While [index <= exactSize;] loop [
		output := concatenate tuple type clearing*&output
			and cast outerTupleType[index] into [t : tupleType | t;];
		index := index + 1;
	];
	output;
];



/* Iteration... */

Method "check_accepts_" is [blkType : functionType, tType : tupleType |
	union ::= type union of tType default type and
		union of types in tType leading types;
	if not union <= blkType[1] then [
		Fail parse "block requires an instance of "
			then blkType[1] as basic string
			then ", but might be passed an instance of "
			then union as basic string;];
] : void;

Method "_do_" is [tup : tuple, blk : [terminates]->void |
	From 1 to ||tup|| do [i : natural number |
		blk apply <tup[i]>;
	];
] : void;

Restriction "_do_" is [tType : tupleType, blkType : functionType |
	check blkType accepts tType;
	/* This is kind of neat.  Normally the result type is void (to indicate
	   no return value).  In the case that the block always terminates
	   *and* there is at least one item in the tuple for sure, the invocation
	   of _do_ will also always terminate.  */
	if tType sizes lower bound > 0 & [blkType result = terminates;] then [
		terminates;
	] else [
		void;
	];
];
	

Method "_collect_" is [t : tuple, blk : [terminates]->any |
	result : tuple := <>;
	From 1 to ||t|| do [i : natural number |
		result := result then <blk apply <t[i]>>;
	];
	result;
] : tuple;

Restriction "_collect_" is [tType : tupleType, blkType : functionType |
	check blkType accepts tType;
	tuple tType sizes
		like <>
		default blkType result;
];



Method "_select_" is [t : tuple, blk : [terminates]->boolean |
	result : tuple := <>;
	From 1 to ||t|| do [i : natural number |
		if blk apply <t[i]> then [
			result := result then <t[i]>;
		];
	];
	result;
] : tuple;

Restriction "_select_" is [tType : tupleType, blkType : functionType |
	check blkType accepts tType;
	union ::= type union of tType default type and
		union of types in tType leading types;
	sizes ::=
		if blkType result = trueType then [tType sizes;]
		else [
			if blkType result = falseType then [[0..0];]
			else [[0..tType sizes upper bound + 1);];];
	tuple sizes
		like <>
		default union;
];


Method "_reject_" is [t : tuple, blk : [terminates]->boolean |
	result : tuple := <>;
	From 1 to ||t|| do [i : natural number |
		if not blk apply <t[i]> then [
			result := result then <t[i]>;
		];
	];
	result;
] : tuple;

Restriction "_reject_" is [tType : tupleType, blkType : functionType |
	check blkType accepts tType;
	union ::= type union of tType default type and
		union of types in tType leading types;
	sizes ::=
		if blkType result = trueType then [[0..0];]
		else [
			if blkType result = falseType then [tType sizes;]
			else [[0..tType sizes upper bound + 1);];];
	tuple sizes
		like <>
		default union;
];


Method "_all_" is [t : tuple, blk : [terminates]->boolean |
	index : natural number := 1;
	While [
		index <= ||t|| & [blk apply <t[index]>;];
	] loop [
		index := index + 1;
	];
	index > ||t||;
] : boolean;

Restriction "_all_" is [tType : tupleType, blkType : functionType |
	check blkType accepts tType;
	void;
];


Method "_any_" is [t : tuple, blk : [terminates]->boolean |
	index : natural number := 1;
	While [
		index <= ||t|| & [not blk apply <t[index]>;];
	] loop [
		index := index + 1;
	];
	index <= ||t||;
] : boolean;

Restriction "_any_" is [tType : tupleType, blkType : functionType |
	check blkType accepts tType;
	void;
];


Method "_sum_" is [t : tuple, blk : [terminates]->extended integer |
	sum : extended integer := 0;
	t do [ element : any | sum := sum + blk apply <element>; ];
	sum;
] : extended integer;

Restriction "_sum_" is [tType : tupleType, blkType : functionType |
	check blkType accepts tType;
	blkResultType ::= cast blkType result into [intT : integerType | intT; ];
	integer range tType sizes times blkResultType;
];


Method "_sum" is [t : tuple of extended integer |
	sum : extended integer := 0;
	t do [ element : extended integer | sum := sum + element; ];
	sum;
] : extended integer;

Restriction "_sum" is [tType : tupleType |
	currentRange : integerType := [0..0];
	From 1 to tType sizes lower bound do [i : natural number |
		elementRange ::= cast tType[i] into [intT : integerType | intT; ];
		currentRange := integer range currentRange plus elementRange;];
	broadRange : integerType := currentRange;
	endOfVariation ::= tType sizes upper bound min (||tType leading types|| + 1);
	From tType sizes lower bound + 1 to endOfVariation do [i : natural number |
		elementRange ::= cast tType[i] into [intT : integerType | intT; ];
		currentRange := integer range currentRange plus elementRange;
		broadRange := type union of broadRange and currentRange;];
	/* Now that the variation in the tuple type is over, use multiplication to
	    calculate the remaining effect on the range. */
	maximumNumberOfAdditionalElements ::= (tType sizes upper bound - endOfVariation) max 0;
	if maximumNumberOfAdditionalElements > 0 then [
		scaledDeltaRange ::= integer range (cast tType default type into [intT : integerType | intT;])
			times [maximumNumberOfAdditionalElements..maximumNumberOfAdditionalElements];
		broadRange := type union of broadRange and (integer range currentRange plus scaledDeltaRange);];
	broadRange;
] : integerType;


/* Indexing... */

Method "_[_]" is [t : tuple, i : natural number |
	/* Get tuple entry with given index. */
	Primitive 131 (failureCode : natural number);
	Failed;
] : any;

Restriction "_[_]" is [tType : tupleType, iType : natural number type |
	Assert iType not = terminates;
	/* Require that it's at least possible that the subscript is in range. */
	if iType lower bound > tType sizes upper bound then [
		Fail parse "Tuple subscript is always out of bounds";];
	/* Compute the type union of all the possible types it could be,
	   depending on what indices could be applied. */
	possible : type := terminates;
	low ::= cast iType lower bound into [x : natural number | x;];
	high ::= cast iType upper bound into [x : [1..INF] | x;];
	From low min (|| tType leading types || + 1)
		to high min (|| tType leading types || + 1)
		do [x : natural number |
			possible := type union of tType[x] and possible;
		];
	possible;
] : type;


/* Interval construction... */

Method "_to_" is [a : integer, b : integer |
	/* Use a weak type so result of unrefined "«_‡then»" operation will fit. */
	result : tuple := <>;
	From a to b do [i : integer | result := result then <i>;];
	/* The "«_‡then»" operation is not yet refined with a returns clause.
	   Cast the type downwards, as we know the entries are all integers. */
	cast result into [x : tuple of integer | x;];
] : tuple of integer;

Restriction "_to_" is [aRange : integerType, bRange : integerType |
	if aRange lower bound > bRange upper bound then [
		<> type;
	] else [
		sizes ::= [(bRange lower bound - aRange upper bound + 1) max 0
			.. bRange upper bound - aRange lower bound + 2);
		uncertainty ::= aRange upper bound - aRange lower bound;
		if uncertainty is finite & sizes upper bound is finite then [
			/* We have a static finite bound on tuple length and on
			   the amount of uncertainty there will be at each index... */
			cast aRange lower bound into [min : integer |
				cast bRange upper bound into [max : integer |
					tuple sizes
						like (min to max
							collect [weakX : any |
								cast weakX into [strongX : integer |
									range from strongX
										inclusive true
										to strongX + uncertainty + 1
										inclusive false;
								];
							])
						default terminates;
				];
			];
		] else [
			/* Either the uncertainty of the starting value is arbitrarily
			   large or we have no static bound on the final tuple length.
			   Either way, we approximate with a homogeneous tuple... */
			tuple sizes
				like <>
				default [aRange lower bound..bRange upper bound + 1);
		];
	];
] : tupleType;

/* Private subtuple extraction type helper... */

Method "type of subtuple_from range_to range_" is [
		tt : tupleType,
		starts : integerType,
		ends : integerType |
	minStart ::= starts lower bound max 1;
	maxStart ::= starts upper bound max 1;
	minEnd ::= ends lower bound max 0;
	maxEnd ::= ends upper bound max 0;
	if minEnd > tt sizes upper bound then [
		/* All possible subtuples that this subrange could represent are out
		   of bounds for the tuple.  Answer terminates to indicate this
		   operation will never succeed at runtime. */
		terminates;
	] else [
		limit ::= maxEnd
			min tt sizes upper bound
			min (|| tt leading types || + 1);
		minTrimmedStart ::= (minStart min limit) max 1;
		maxTrimmedStart ::= (maxStart min limit) max 1;
		variance ::= maxTrimmedStart - minTrimmedStart;
		resultPattern ::= minTrimmedStart to limit collect [index : [1..INF) |
			u : type := terminates;
			From index to (index + variance) min limit do [subindex : [1..INF) |
				u := type union of u and tt[subindex];
			];
			u;
		];
		default ::= cast ||resultPattern|| into [n : [1..INF) |
			resultPattern[n];
		] otherwise [
			terminates;
		];
		clipMinStart ::= (minStart max 1) min tt sizes upper bound;
		clipMaxStart ::= (maxStart max 1) min tt sizes upper bound;
		clipMinEnd ::= (minEnd max 0) min tt sizes upper bound;
		clipMaxEnd ::= (maxEnd max 0) min tt sizes upper bound;
		sizes ::= [(clipMinEnd - clipMaxStart + 1) max 0
			.. ((clipMaxEnd - clipMinStart + 1) max 0) + 1);
		tuple sizes
			like resultPattern
			default default;
	];
] : tupleType;



/* Replacement... */

Method "_[_->_]" is [t : tuple, i : natural number, v : any |
	/* Answer new tuple with given index set to the given value. */
	Primitive 132 (failureCode : natural number);
	Failed;
] : tuple;

Restriction "_[_->_]" is [tType : tupleType, iType : integerType, vType : type |
	leading : tuple of type := tType leading types;
	default : type := tType default type;
	/* Deal with replacement in leading types... */
	if iType lower bound <= || leading || then [
		cast iType lower bound into [low : natural number |
			From low max 1 to || leading || do [x : natural number |
				newLeading ::= leading[x -> type union of leading[x] and vType];
				/* Since we haven't defined "_[_->_]" with a strong enough
				   returns clause yet (that's what we're in the middle of
				   doing!), we have to dynamically cast into tuple of type. */
				cast newLeading into [y : tuple of type | leading := y;];
			];
		];
	];
	/* Deal with finite or infinite extension of leading types... */
	cast iType upper bound into [upper : integer |
		/* Finite extension - countably many indices are weakened to vType... */
		if upper > || leading || & not vType <= default then [
			weaker ::= type union of default and vType;
			leading := leading then
				(|| leading || + 1 to upper collect [x : integer | weaker;]);
		];
	] otherwise [
		/* Infinite extension - all indices >= lower bound are weakened to
		   vType... */
		if iType upper bound not = INF then [
			Crash "Inconsistency in returns clause of _[_->_]";];
		default := type union of default and vType;
	];
	tuple tType sizes
		like leading
		default default;
] : tupleType;


Method "*_[_]:=_" is [tupleVar : &:tuple, i : natural number, v : any |
	/* Make a new tuple like that in tupleVar, but with the given index set to
	   the given value.  Set tupleVar to this new tuple.  */
	*tupleVar ?:= clearing* tupleVar [i->v];
] : void;

Restriction "*_[_]:=_" is [tvt : containerType, it : integerType, vt : type |
	good ::= tvt readType = tvt writeType &
		cast tvt readType into [tt : tupleType |
			/* Make sure we can store back any possible result. */
			vt <= union of types in
				tt [(it lower bound max 1) min (||tt leading types|| + 1)
					.. (it upper bound max 0) min (||tt leading types|| + 1)];
		] otherwise [
			false;
		];
	if not good then [
		Fail parse "tuple replacement expression to have appropriate types";];
	void;
];



Method "splice_" is [tupleOfTuples : tuple of tuple |
	/* Concatenate a tuple of tuples into one big tuple. */
	Primitive 136;
] : tuple;

Restriction "splice_" is [ttType : tupleType |
	limit ::= if ttType sizes upper bound is infinite then [
		ttType sizes lower bound max (||ttType leading types|| + 1);
	] else [
		ttType sizes upper bound;
	];
	result : tupleType := <> type;
	From 1 to limit do [i : natural number |
		result := concatenate tuple type result
			and cast ttType[i] into [x : tupleType | x;];
	];
	if ttType sizes upper bound is infinite then [
		result := tuple [result sizes lower bound .. INF)
			like result
				[1 ..
					cast result sizes upper bound into [w : whole number | w;]]
			default union of types in
				(cast ttType default type
					into [t : tupleType |
						t[1 .. ||t leading types|| + 1];
					]
				);
	];
	result;
];



Method "_[_.._]" is [t : tuple, start : natural number, end : whole number |
	/* Extract a contiguous region from a tuple. */
	Primitive 135 (failureCode : natural number);
	Failed;
] : tuple;

Restriction "_[_.._]" is [
		tt : tupleType,
		startT : integerType,
		endT : integerType |
	type of subtuple tt
	from range startT
	to range endT;
] : tupleType;


Method "_[.._]" is [t : tuple, end : whole number |
	/* Extract a contiguous region from a tuple. */
	t[1..end];
] : tuple;

Restriction "_[.._]" is [tt : tupleType, endT : integerType |
	type of subtuple tt
	from range [1..1]
	to range endT;
] : tupleType;


Method "_[_..]" is [t : tuple, start : natural number |
	/* Extract a contiguous region from a tuple. */
	t[start..||t||];
] : tuple;

Restriction "_[_..]" is [tt : tupleType, startT : integerType |
	type of subtuple tt
	from range startT
	to range tt sizes;
] : tupleType;



Method "_[_.._->_]" is [
		t : tuple,
		start : natural number,
		end : whole number,
		replacement : tuple |
	/* Create a tuple with the given range replaced by replacement.  The
	   range need not match the size of the replacement. */
	splice <t[1..start-1], replacement, t[end+1..||t||]>;
] : tuple;

Restriction "_[_.._->_]" is [
		tt : tupleType,
		startT : integerType,
		endT : integerType,
		repT : tupleType |
	part1 ::= type of subtuple tt
		from range [1..1]
		to range (startT lower bound - 2 .. startT upper bound);
	part2 ::= repT;
	part3 ::= type of subtuple tt
		from range (endT lower bound .. endT upper bound + 2)
		to range tt sizes;
	concatenate tuple type
		concatenate tuple type part1
		and part2
	and part3;
] : tupleType;


/* Conversion from integer to string */
Forward "_radix_" for [integer, [2..36]]->string;
Method "_radix_" is [i : integer, rad : [2..36] |
	if i < 0 then [
		"-" then -i radix rad;
	] else [
		index ::= i mod rad + 1;
		digit ::= "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" [index];
		if i < rad then [
			<digit>;
		] else [
			i / rad radix rad then <digit>;
		];
	];
] : string;

Method "_decimal" is [a : integer |
	a radix 10;
] : string;

Method "_hex" is [a : integer |
	a radix 16;
] : string;

Method "code point_" is [cp : character code points |
	Primitive 331;
] : character;

Method "code point of_" is [c : character |
	Primitive 330;
] : character code points;

Method "$_" is [str : tuple [1..1] of character |
	str [1];
] : character;

Method "#_" is [str : tuple [1..1] of character |
	code point of str [1];
] : character code points;

digitZero ::= #"0";
digitNine ::= #"9";
lettera ::= #"a";
letterz ::= #"z";
letterA ::= #"A";
letterZ ::= #"Z";

Method "_to_" is [a : character, b : character |
	result : string := "";
	start : whole number := code point of a;
	end : whole number := code point of b;
	From start to end do [i : whole number |
		cp ::= cast i into [narrow : character code points | narrow;];
		result := result then <code point cp>;
	];
	result;
] : string;

Method "<«_‡,»`…|_.._>" is
[
	aTupleOfTypes : tuple [1..∞) like <> default type,
	cardinalityLower : whole number,
	cardinalityUpper : [0..∞]
 |
 	tuple [cardinalityLower..cardinalityUpper+1)
 		like aTupleOfTypes[1..||aTupleOfTypes||-1]
 		default aTupleOfTypes[||aTupleOfTypes||];
] : tupleType;