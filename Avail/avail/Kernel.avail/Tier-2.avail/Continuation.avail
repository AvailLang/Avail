/**
 * .../Tier-2/Continuation.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Continuation"
Extends
Uses
	"Tier-1",
	"BlockA",
	"Number"
Names
	"$_",
	"_functionType",
	"Restart_",
	"Restart_with_",
	"Exit_",
	"Exit_with_",
	"Loop_",
	"Loop_until_",
	"Loop_until_do_",
	"Loop_while_",
	"Until_loop_",
	"While_loop_",
	"From_to_do_",
	"From_to_by_do_"
Body


Restriction "_(«_‡,»)" is [bt : functionType, argsType : tupleType |
	bt result;
];


/* Continuation type primitives. */

Method "$_" is [closType : functionType |
	/* Construct a continuation type from the given function type. */
	Primitive 51;
] : continuationType;

Method "_functionType" is [contType : continuationType |
	/* Answer the functionType that this continuation type uses. */
	Primitive 50;
] : functionType;


/**
 * Restart the passed continuation.  I've dropped support for labels in the
 * middle of a sequence of statements, and only allow a leading label (as
 * part of the block syntax rather than statement syntax).  If the continuation
 * requires arguments, use the values captured by its invocation 'con'.
 */
Method "Restart_" is [con : continuation |
	Primitive 58 (failureCode : natural number);
	Failed;
] : terminates;


/**
 * Restart the passed continuation, using the given arguments in place of
 * the arguments that were passed in originally.  The continuation is restarted
 * in the same context it was originally executed.  That is, its caller is the
 * same continuation as what it was in the original invocation.
 */
Method "Restart_with_" is [con : continuation, args : tuple |
	Primitive 56 (failureCode : natural number);
	Failed;
] : terminates;

Restriction "Restart_with_" is [conType : type, argsType : tupleType |
	good ::= cast conType into [conType2 : continuationType |
		closType ::= conType2 functionType;
		numArgs ::= closType arguments type sizes lower bound;
		Assert numArgs = closType arguments type sizes upper bound;
		argsType sizes lower bound = numArgs
			& argsType sizes upper bound = numArgs
			& closType <=
				block type
					taking cast argsType[1..numArgs] into [ t : tuple of any type | t; ]
					and returning void;
	];
	if not good then [
		Fail parse "Restart_with_ to be provided arguments that conform to the continuation argument types";];
	void;
];

/**
 * Exit the passed continuation.  The continuation's function must have a
 * return type general enough to accept the given return value.  Don't allow
 * this form if the continuation has return type void (the passed argument
 * would be misleading).
 */
Method "Exit_with_" is [con : continuation, value : any |
	Primitive 57 (failureCode : natural number);
	Failed;
] : terminates;

Restriction "Exit_with_" is [conType : type, valueType : type |
	good ::= cast conType into [conType2 : continuationType |
		conType2 functionType result not = void
			& valueType <= conType2 functionType result;
	];
	if not good then [
		Fail parse "Exit_with_ to be supplied a value that conforms to the continuation result type";];
	void;
];

/**
 * Exit the passed continuation.  The continuation's function must have a return
 * type of void to use this special form of Exit.
 */
Method "Exit_" is [con : $[...]->void |
	[c : continuation, ignored : any |
		Primitive 57 (failureCode : natural number);
		Failed;
	] : terminates apply <con,123>;
] : terminates;


/* Basic looping constructs */

Method "Loop_" is [block : []->void |
	$body;
	block();
	Restart body;
] : terminates;

Method "Loop_until_" is [block : []->void, predicate : []->boolean |
	$body;
	block();
	if not predicate() then [Restart body;];
] : void;

Method "Loop_until_do_" is
[
	block : []->void,
	predicate : []->boolean,
	alternateBlock : []->void
|
	$body;
	block();
	if not predicate() then [alternateBlock(); Restart body;];
] : void;

Method "Loop_while_" is [block : []->void, predicate : []->boolean |
	$body;
	block();
	if predicate() then [Restart body;];
] : void;

Method "Until_loop_" is [predicate : []->boolean, block : []->void |
	$body;
	if not predicate() then [
		block();
		Restart body;
	];
] : void;

Method "While_loop_" is [predicate : []->boolean, block : []->void |
	$body;
	if predicate() then [
		block();
		Restart body;
	];
] : void;




/* Counting... */

Method "From_to_do_" is [start : integer, end : (-INF..INF], blk : [terminates]->void |
	$body;
	if start <= end then [
		blk apply <start>;
		Restart body with <start + 1, end, blk>;
	];
] : void;

Restriction "From_to_do_" is [
		startT : integerType,
		endT : integerType,
		blkT : functionType |
	if startT lower bound <= endT upper bound then [
		/* At least one iteration.  Make sure the block can accept all possible
		   indices. */
		indices ::= range from startT lower bound
			inclusive startT lower inclusive
			to endT upper bound + 1
			inclusive false;
		if not indices <= blkT[1] then [
			Fail parse "block of _to_do_ to accept all integers in the range";];
	];
	void;
];

Method "From_to_by_do_" is
[
start : integer,
end : extended integer,
incrementer : integer,
action : [integer]->void
|
   counter : integer := start;
   if incrementer = 0 then [
   		Crash "Cannot increment by 0.";
   ];
   guard : [] -> boolean := if incrementer > 0
   		then [ [counter <= end;]; ]
   		else [ [counter >= end;]; ];
   [
        $body;

        if guard() then
        [
           action apply <counter>;
           counter := counter + incrementer;
           Restart body;
        ];
   ]();
] : void;

Restriction "From_to_by_do_" is
[
   startType : integer type,
   endType : extended integer type,
   incrementerType : integer type,
   actionType : ([integer]->void) type
|
   startTypeLower :: = startType lower bound;
   endTypeLower ::= endType lower bound;
   startTypeUpper :: = startType upper bound;
   endTypeUpper ::= endType upper bound;
   if incrementerType <= [0..0] then
   [
        Fail parse "The incrementing value must be a non-zero value.";
   ];
   if incrementerType <= (-∞..-1] then
   [
     if startTypeLower < endTypeLower - 1 then
     [
        Fail parse "The starting count's lowest potential value cannot be lower than the ending count's lowest
        potential value for a decrementing counter";
     ];
     if startTypeUpper < endTypeUpper then
     [
       Fail parse "The starting count's largest potential value cannot be lower than the ending count's largest potential
       value for a decrementing counter";
     ];
  ];
  if incrementerType <= [1..∞) then
  [
     if startTypeLower > endTypeLower then
     [
        Fail parse "The starting count's lowest potential value cannot be greater than the ending count's lowest potential
        value for an incrementing counter";
     ];
     if startTypeUpper > endTypeUpper then
     [
        Fail parse "The starting count's largest potential value cannot be greater than the ending count's largest
        potential value for an incrementing counter";
     ];
  ];
  void;
];
