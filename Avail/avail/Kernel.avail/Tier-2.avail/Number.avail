/**
 * .../Tier-2/Number.avail
 * Copyright © 1993-2013, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Number"
Extends
Uses
	"Tier-1",
	"BlockA",
	"Container"
Names
	"_<_", "_>_", "_<=_", "_>=_",
	"_<_<_", "_<_<=_", "_<=_<_", "_<=_<=_",
	"_>_>_", "_>_>=_", "_>=_>_", "_>=_>=_",

	"_+_" , "_-_", "-_", "_*_" ,
	"_/_", "_mod_", "_is odd", "_is even",
	"_max_", "_min_", "_^_", "`|_`|",

	"_++", "_--",

	"_as float", "_as double",
	"floor_",
	"ln_",

	"nonpositive integer",
	"negative integer",
	"integer range_plus_",
	"integer range_times_",
	"_negated"
Body


/* This module defines integer arithmetic operations.  Forward declare the
   basic arithmetic operations so the integer range code will have access to
   them.  The range manipulation code won't have to actually *run* these
   methods until link time after a definition point for the method, so apparent
   circularities are easily avoided by the forward declaration mechanism. */

Forward "_+_" for [number, number]->number;
Forward "_-_" for [number, number]->number;
Forward "-_" for [number]->number;
Forward "_*_" for [number, number]->number;
Forward "_/_" for [number, number]->number;
Forward "_mod_" for [number, number]->number;
Forward "_^_" for [number, number]->number;
Forward "_max_" for [number, number]->number;
Forward "_min_" for [number, number]->number;

/* Integer comparison operations... */

Method "_<_" is [a : number, b : number |
	Primitive 5;
] : boolean;

Method "_>_" is [a : number, b : number |
	b < a
] : boolean;

Method "_<=_" is [a : number, b : number |
	Primitive 6;
] : boolean;

Method "_>=_" is [a : number, b : number |
	b <= a
] : boolean;


/* Define the tertiary comparators.  Very handy, syntactically. */

Method "_<_<_" is [a : number, b : number, c : number |
	a < b & [b < c]
] : boolean;

Method "_<_<=_" is [a : number, b : number, c : number |
	a < b & [b <= c]
] : boolean;

Method "_<=_<_" is [a : number, b : number, c : number |
	a <= b & [b < c]
] : boolean;

Method "_<=_<=_" is [a : number, b : number, c : number |
	a <= b & [b <= c]
] : boolean;

Method "_>_>_" is [a : number, b : number, c : number |
	a > b & [b > c]
] : boolean;

Method "_>_>=_" is [a : number, b : number, c : number |
	a > b & [b >= c]
] : boolean;

Method "_>=_>_" is [a : number, b : number, c : number |
	a >= b & [b > c]
] : boolean;

Method "_>=_>=_" is [a : number, b : number, c : number |
	a >= b & [b >= c]
] : boolean;


/* Private helper for defining precedence rules... */

setOfString ::= Special Object 75;

Method "_U_" is [s1 : setOfString, s2 : setOfString |
	Primitive 102;
] : set;

Restriction "_U_" is [st : setType, st2 : setType |
	setOfString
];

{"_U_"} can't have <{},{"_U_"}>;


/* Tuple subscript for bootstrapping. */
Method "private_[_]" is [t : tuple, i : natural number |
	Primitive 131 (failureCode : natural number);
	Failed
] : any;

Restriction "private_[_]" is [tT : tuple type, iT : natural number type |
	number
];

/* Utility for computing "type promotions" for dyadic math operators. */
Method "numberRestrictionFunction_" is
[
	operator : [number, number] -> number
|
	[
		aT : number type,
		bT : number type
	|
		if |aT| = 1 & |bT| = 1 then
		[
			/* The exact values are known statically.  Calculate it exactly. */
			aValue ::= private aT instances as tuple [1];
			bValue ::= private bT instances as tuple [1];
			(operator apply <aValue, bValue>) type
		]
		else
		[
			if aT <= double | bT <= double then
			[
				/* At least one is known to be double, which forces the result
				   to be a double. */
				double
			]
			else
			[
				if aT = number | bT = number then
				[
					/* Neither is known to be a double, and at least one is as
					   weak as a number.  The weak one might be a double at run
					   time, so we can't limit the output type any more. */
					number
				]
				else
				[
					/* Neither one is as weak as number. */
					if aT <= float | bT <= float then
					[
						/* Either {float,float} or {float,int}, which each
						   produce a float. */
						float
					]
					else
					[
						if aT <= extended integer & bT <= extended integer
						then [ extended integer ] 
						else [ number ]
					]
				]
			]
		]
	]
] : [number type, number type] -> number type;



/* Integer primitives, including precedence rules... */

sum      ::= {"_+_" , "_-_"};
product  ::= {"_*_" , "_/_", "_mod_"};
negation ::= {"-_"};
power    ::= {"_^_"};

sum      can't have <{}, sum>;
product  can't have <sum, sum U product>;
negation can't have <sum U product>;
power    can't have <sum U product U negation U power, sum U product>;

{"_min_"} can't have <{},{"_min_"}>;  /* group min expressions on the left. */
{"_max_"} can't have <{},{"_max_"}>;  /* group max expressions on the left. */

{"`|_`|"} can't have <{"`|_`|"}>;  /* disallow dangerous and redundant ||x|| for abs(abs(x)). */


Method "_+_" is [a : number, b : number |
	Primitive 1 (failureCode : natural number);
	Crash "addition failed"
] : number;

Method "_-_" is [a : number, b : number |
	Primitive 2 (failureCode : natural number);
	Crash "subtraction failed"
] : number;

Method "_*_" is [a : number, b : number |
	Primitive 3 (failureCode : natural number);
	Crash "multiplication failed"
] : number;

Method "_/_" is [a : number, b : number |
	Primitive 4 (failureCode : natural number);
	Crash "division failed"
] : number;


Restriction "_+_" is
	numberRestrictionFunction [a : number, b : number | a + b];
Restriction "_-_" is
	numberRestrictionFunction [a : number, b : number | a - b];
Restriction "_*_" is
	numberRestrictionFunction [a : number, b : number | a * b];
Restriction "_/_" is
	numberRestrictionFunction [a : number, b : number | a / b];
Restriction "_mod_" is
	numberRestrictionFunction [a : number, b : number | a mod b];

Method "-_" is [a : number |
	/* Unary negation.  There are no negative numeric constants in Avail.
	   Just use negation - it looks the same.  */
	0 - a
] : number;

Restriction "-_" is
[
	aT : number type
|
	resultType : number type := number;
	if aT <= extended integer then [ resultType := extended integer; ];
	if aT <= double then [ resultType := double; ];
	if aT <= float then [ resultType := float; ];
	resultType
];

eulerNumber ::= Special Object 111;

Method "e" is [eulerNumber];

Abstract method "floor_" for [number]->number;

Method "floor_" is [value : extended integer |
	value
] : extended integer;

Method "floor_" is [value : float |
	Primitive 292;
] : float;

Method "floor_" is [value : double |
	Primitive 322;
] : double;

Restriction "floor_" is [valueT : type |
	if valueT <= extended integer then
	[
		Fail parse "Floor of integer is unnecessary and potentially misleading."
	];
	if |valueT| = 1 then
	[
		/* The exact value is known statically.  Calculate it exactly. */
		value ::= private valueT instances as tuple [1];
		valueFloor ::= floor(value);
		valueFloor type
	]
	else
	[
		void
	]
];

Restriction "floor_" is [valueT : integerType |
	/* Integers and infinities are their own floors. */
	valueT
];


Method "_mod_" is [a : number, b : number |
	/* General case. */
	a - (b * floor(a / b))
] : number;

Method "_mod_" is [a : integer, b : [INF..INF] |
	/* If b is infinite, then the modulus is defined as just a. */
	a
] : extended integer;


Method "_max_" is [first : number, second : number |
	if first < second then [second] else [first]
] : number;

Method "_min_" is [first : number, second : number |
	if first < second then [first] else [second]
] : number;

Method "_is odd" is [a : integer |
	a mod 2 = 1
] : boolean;

Method "_is even" is [a : integer |
	a mod 2 = 0
] : boolean;


Method "integer range_plus_" is [a : integerType, b : integerType |
	/* If one of these types is forced to be either INF or -INF, and
	    if the other type is forced to be the opposite infinity, then return
	    terminates, which is in fact the most specific integerType.  The
	    logic is that some call site using this calculation to propagate
	    the types is unaware that an operation will always fail, so we
	    feed that information back as a kindness. */
	if {{a lower bound,a upper bound},{b lower bound, b upper bound}}
			= {{-INF},{INF}} then [
		terminates
	] else [
		/* The range calculation below is ok with respect to infinite bounds,
		   because a bound can only be exclusive if it is infinite. */
		range from (a lower bound + b lower bound) - 1
			inclusive (a lower inclusive & a lower bound is infinite)
				| (b lower inclusive & b lower bound is infinite)
			to (a upper bound + b upper bound) + 1
			inclusive (a upper inclusive & a upper bound is infinite)
				| (b upper inclusive & b upper bound is infinite)
	]
] : integerType;


Method "integer range_times_" is [aT : integerType, bT : integerType |
	/* Deal with call sites that use this to compute the resulting range from
	    multiplying [INF..INF] or [-INF..-INF] by [0..0].  Since this will always
	    fail at runtime (i.e., when actual integers are supplied), be nice and
	    tell the call site that the result has type terminates. */

	ranges ::= {{aT lower bound,aT upper bound},{bT lower bound,bT upper bound}};
	if ranges = {{0}, {INF}} | ranges = {{0}, {-INF}} then [
		terminates
	] else [

		/* Relies on fact that finite boundaries are always canonized at range
		   creation time into inclusive form.  We consider negative b's, positive
		   b's, and zero b separately to simplify the cases.  If we tried to merge
		   zero with one of the other cases, the code might attempt to multiply
		   zero by an infinity (even if it's an exclusive boundary), which would
		   be an exception.  */

		negAs : integerType := type intersection of aT and [-INF..-1];
		negBs : integerType := type intersection of bT and [-INF..-1];
		posAs : integerType := type intersection of aT and [1..INF];
		posBs : integerType := type intersection of bT and [1..INF];
		range : integerType := terminates;
		/* This does not work for inclusive infinite bounds. See the
		 * implementation in new library.
		 */
		if posAs not = terminates then [
			if posBs not = terminates then [
				range := type union of range and
					range from posAs lower bound * posBs lower bound
					inclusive posAs lower inclusive & posBs lower inclusive
					to posAs upper bound * posBs upper bound
					inclusive posAs upper inclusive & posBs upper inclusive;
			];
			if negBs not = terminates then [
				range := type union of range and
					range from posAs upper bound * negBs lower bound
					inclusive posAs upper inclusive & negBs lower inclusive
					to posAs lower bound * negBs upper bound
					inclusive posAs lower inclusive & negBs upper inclusive;
			];
		];
		if negAs not = terminates then [
			if posBs not = terminates then [
				range := type union of range and
					range from negAs lower bound * posBs upper bound
					inclusive negAs lower inclusive & posBs upper inclusive
					to negAs upper bound * posBs lower bound
					inclusive negAs upper inclusive & posBs lower inclusive;
			];
			if negBs not = terminates then [
				range := type union of range and
					range from negAs upper bound * negBs upper bound
					inclusive negAs upper inclusive & negBs upper inclusive
					to negAs lower bound * negBs lower bound
					inclusive negAs lower inclusive & negBs lower inclusive;
				];
		];
		if 0 type <= aT | 0 type <= bT then [
			/* Force zero to be included in final range... */
			range := type union of range and 0 type;
		];
		range
	]
] : integerType;


Method "_negated" is [a : integerType |
	/* Negate an integer range. */
	integer range a times [-1..-1]
] : integerType;


Restriction "-_" is [aT : integerType |
	aT negated
] : integerType;

Restriction "_+_" is [aT : integerType, bT : integerType |
	integer range aT plus bT
] : integerType;

Restriction "_-_" is [aT : integerType, bT : integerType |
	integer range aT plus (bT negated)
] : integerType;

Restriction "_*_" is [aT : integerType, bT : integerType |
	integer range aT times bT
] : integerType;



Method "_divide range by_" is [
		numeratorRange : integerType,
		denominator : extended integer |
	if numeratorRange = terminates | denominator = 0 then [
		terminates
	] else [
		if denominator is infinite then [
			/* Either infinity over ±INF is a runtime error, and therefore not
			   of interest here, but finites over ±INF are always 0. */
			[0..0]
		] else [
			/* Finite non-zero denominator.  Just scale the numerator range. */
			minNumerator ::= numeratorRange lower bound;
			maxNumerator ::= numeratorRange upper bound;
			if denominator < 0 then [
				range from maxNumerator / denominator
					inclusive numeratorRange upper inclusive
					to minNumerator / denominator
					inclusive numeratorRange lower inclusive
			] else [
				range from minNumerator / denominator
					inclusive numeratorRange lower inclusive
					to maxNumerator / denominator
					inclusive numeratorRange upper inclusive
			]
		]
	]
] : integerType;


Restriction "_/_" is [aT : integerType, bT : integerType |
	/* Ok, try the outer bounds of the denominator, but also the bounds as
	   denominators approach 0 from above and from below (but excluding 0).
	   We don't need to distinguish between including infinities and excluding
	   infinities in the denominator, as either case approaches zero equally
	   well.  Since all finite bounds are canonized into inclusive form, we can
	   therefore treat these bounds as inclusive.  */
	soFar : integerType := terminates;
	negativeDenominators ::= type intersection of bT and [-INF..-1];
	if negativeDenominators not = terminates then
	[
		soFar := type union of soFar and
			(aT divide range by negativeDenominators lower bound);
		soFar := type union of soFar and
			(aT divide range by negativeDenominators upper bound);
	];
	positiveDenominators ::= type intersection of bT and [1..INF];
	if positiveDenominators not = terminates then
	[
		soFar := type union of soFar and
			(aT divide range by positiveDenominators lower bound);
		soFar := type union of soFar and
			(aT divide range by positiveDenominators upper bound);
	];
	soFar
] : integerType;


Restriction "_mod_" is [aT : integerType, bT : integerType |
	/* One would think the return type would be constrained
	   to [0..bT upper bound), which it is, but we might be able
	   to do better than that if aT is a small enough range. We
	   also require bT to restrict b to a single value (known at
	   link-time) before we're willing to try harder to compute the
	   shrunken range.  */
	if bT lower bound = bT upper bound
			& [aT lower bound is finite
			& [aT upper bound is finite
			& [aT lower bound / bT lower bound
				= aT upper bound / bT lower bound]]]
	then [
		/* Makes use of fact that finite bounds are always canonized
		   into inclusive form. */
		cast aT lower bound into [aLower : integer |
			cast aT upper bound into [aUpper : integer |
				cast bT lower bound into [bValue : [1..INF] |
					[aLower mod bValue..aUpper mod bValue]]]]
	] else [
		[0..bT upper bound)
	]
] : integerType;



Method "_as float" is [n : number |
	Primitive 280;
] : float;

Method "_as double" is [n : number |
	Primitive 281;
] : double;

Method "ln_" is [exponent : float |
	Primitive 286;
] : float;

Method "ln_" is [exponent : double |
	Primitive 316;
] : double;

Method "_^_" is [base : e type, exponent : float |
	Primitive 287;
] : float;

Method "_^_" is [base : e type, exponent : double |
	Primitive 317;
] : double;

Method "_^_" is [base : number, exponent : number |
	/* Uses identity a^b = exp(ln(a^b)) = exp(b*ln(a)). */
	e^(exponent * ln(base as double))
] : number;

Forward "_^_" for [extended integer, whole number] -> extended integer;
Forward "_^_" for [float, whole number] -> float;
Forward "_^_" for [double, whole number] -> double;

Method "_^_" is [base : extended integer, exponent : whole number |
	/*  Uses identities b^(2x) = (b^2)^x, and b^(2x+1) = (b^2)^x*b  */
	if exponent = 0 then [
		1
	] else [
		temp ::= (base*base)^(exponent/2);
		if exponent is odd then [temp*base] else [temp]
	]
] : extended integer;

Method "_^_" is [base : float, exponent : whole number |
	/*  Uses identities b^(2x) = (b^2)^x, and b^(2x+1) = (b^2)^x*b  */
	if exponent = 0 then [
		1.0 as float
	] else [
		temp ::= (base*base)^(exponent/2);
		if exponent is odd then [temp*base] else [temp]
	]
] : float;

Method "_^_" is [base : double, exponent : whole number |
	/*  Uses identities b^(2x) = (b^2)^x, and b^(2x+1) = (b^2)^x*b  */
	if exponent = 0 then [
		1.0
	] else [
		temp ::= (base*base)^(exponent/2);
		if exponent is odd then [temp*base] else [temp]
	]
] : double;




/* Look for obvious bugs (I was bitten once)... */
Assert 1<2;
Assert 1<=2;
Assert 1<=1;
Assert 2>1;
Assert 2>=1;
Assert 2>=2;
Assert -1<1;
Assert 1>-1;
Assert -1=-1;
Assert -1<=-1;
Assert -1>=-1;
Assert -3<=-1;
Assert -1>=-2;

Assert [3*5] type <= []->[15..15];
Assert [x : [-3..11]; y : [-5..3]; x * y] type <= []->[-55..33];
Assert [x : [-11..3]; y : [-5..3]; x * y] type <= []->[-33..55];






Restriction "_max_" is [aT : integerType, bT : integerType |
	/* If [a1..a2] and [b1..b2] are the ranges, then the max will be between
	   max(a1,b1) and max(a2,b2).  Watch out for the inclusion / exclusion
	   cases. */
	min : extended integer;
	minInclusive : boolean;
	if (bT lower bound > aT lower bound) then [
		min := bT lower bound;
		minInclusive := bT lower inclusive;
	] else [
		min := aT lower bound;
		minInclusive := aT lower inclusive;
	];
	if aT lower bound = bT lower bound then [
		minInclusive := aT lower inclusive & bT lower inclusive;
	];
	max : extended integer;
	maxInclusive : boolean;
	if (bT upper bound > aT upper bound) then [
		max := bT upper bound;
		maxInclusive := bT upper inclusive;
	] else [
		max := aT upper bound;
		maxInclusive := aT upper inclusive;
	];
	if aT upper bound = bT upper bound then [
		maxInclusive := aT upper inclusive | bT upper inclusive;
	];
	range from min
		inclusive minInclusive
		to max
		inclusive maxInclusive
] : integerType;


Restriction "_min_" is [aT : integerType, bT : integerType |
	/* If [a1..a2] and [b1..b2] are the ranges, then the min will be between
	   min(a1,b1) and min(a2,b2).  Watch out for the inclusion / exclusion
	   cases.  */
	min : extended integer;
	minInclusive : boolean;
	if (bT lower bound < aT lower bound) then [
		min := bT lower bound;
		minInclusive := bT lower inclusive;
	] else [
		min := aT lower bound;
		minInclusive := aT lower inclusive;
	];
	if aT lower bound = bT lower bound then [
		minInclusive := aT lower inclusive | bT lower inclusive;
	];
	max : extended integer;
	maxInclusive : boolean;
	if (bT upper bound < aT upper bound) then [
		max := bT upper bound;
		maxInclusive := bT upper inclusive;
	] else [
		max := aT upper bound;
		maxInclusive := aT upper inclusive;
	];
	if aT upper bound = bT upper bound then [
		maxInclusive := aT upper inclusive & bT upper inclusive;
	];
	range from min
		inclusive minInclusive
		to max
		inclusive maxInclusive
] : integerType;


Restriction "_^_" is [
		baseT : extended integer type,
		exponentT : whole number type |
	low : extended integer := INF;
	high : extended integer := -INF;
	includeMinusINF : boolean := false;
	includeINF : boolean := false;
	tryBase ::= [base : extended integer |
		if base is finite then [
			tryExponent ::= [exponent : [0..INF] |
				cast exponent into [finiteExponent : whole number |
					/* finite ^ bounded case */
					value ::= base ^ finiteExponent;
					low := low min value;
					high := high max value;
				] otherwise [
					/* finite ^ unbounded case */
					if base < -1 then [
						/* -2^n produces arbitrarily large positives and
						   negatives (as can -3^n, etc). */
						low := -INF;
						high := INF;
					] else [
						if base = -1 then [
							low := low min -1;
							high := high max 1;
						] else [
							if base <= 1 then [
								/* 0^n and 1^n are 0 and 1 respectively. */
								low := low min base;
								high := high max base;
							] else [
								/* 2^n can be arbitrarily large (as can 3^n,
								   etc). */
								high := INF;
							];
						];
					];
				];
			];
			tryExponent apply <exponentT lower bound>;
			tryExponent apply <exponentT upper bound>;
			if exponentT upper bound > exponentT lower bound then [
				/* At least two exponents are possible. */
				if exponentT upper bound is finite then [
					/* Consider the top two (legal) exponents, since odd and
					   even can produce differently signed results. */
					tryExponent apply <exponentT upper bound - 1>;
				];
				if exponentT lower bound is finite then [
					/* And just for giggles, use the second-lowest bound. */
					tryExponent apply <exponentT lower bound + 1>;
				];
			];
		] else [
			/* unbounded or infinite base */
			inclusive ::= [base..base] <= baseT;
			if base = -INF then [
				if exponentT lower bound = exponentT upper bound then [
					/* Only one exponent is possible, so it only needs to be
					   extended to one of the infinities. */
					cast exponentT lower bound into [exponent : whole number |
						value ::= if exponent is odd then [-INF] else [INF];
						high := high max value;
						low := low min value;
						includeMinusINF := includeMinusINF
							| (inclusive & value = -INF);
						includeINF := includeINF | (inclusive & value = INF);
					];
				] else [
					/* At least two exponents are possible (one odd, one even),
					   so extend to both infinities. */
					low := -INF;
					high := INF;
					includeINF := includeINF | inclusive;
					includeMinusINF := includeMinusINF | inclusive;
				];
			] else [
				/* Positive unbounded base. */
				high := INF;
				includeINF := includeINF |  inclusive;
			];
		];
	];
	tryBase apply<baseT lower bound>;
	tryBase apply<baseT upper bound>;
	if [-1..-1] <= baseT then [
		tryBase apply <-1>;
	];
	if [0..0] <= baseT then [
		tryBase apply <0>;
	];
	if [1..1] <= baseT then [
		tryBase apply <1>;
	];
	Assert includeMinusINF implies low = -INF;
	Assert includeINF implies high = INF;
	range
		from low
		inclusive low not = -INF | includeMinusINF
		to high
		inclusive high not = INF | includeINF
] : integerType;


Method "`|_`|" is [a : number |
	/* Compute the absolute value of the argument... */
	if a < 0 then [0-a] else [a]
] : number;

Restriction "`|_`|" is [ aT : double type | aT ];

Restriction "`|_`|" is [ aT : float type | aT ];

Restriction "`|_`|" is [aT : integerType |
	type intersection of (type union of aT and (aT negated)) and [0..INF]
] : integerType;


/* Convenience methods.  Increment and decrement à la C.  Postfix ++ and --
   provide a convenient shorthand when used with a container of some
   integerType.  Note that these operations are not statically bounds-checked
   (but they are dynamically).  */

Method "_++" is [intCon : container |
	*intCon ?:= cast clearing* intCon into [i : extended integer | i + 1];
];

Restriction "_++" is [ct : containerType |
	if ct readType <= extended integer
		& ct writeType <= extended integer
	then [void]
	else [Fail parse "Don't apply \"_++\" to a non-integral container"]
];


Method "_--" is [intCon : container |
	*intCon ?:= cast clearing* intCon into [i : extended integer | i - 1];
];

Restriction "_--" is [ct : containerType |
	if ct readType <= extended integer
		& ct writeType <= extended integer
	then [void]
	else [Fail parse "Don't apply \"_--\" to a non-integral container"]
];


Method "nonpositive integer" is [
	(-INF .. 0]
] : integerType;

Method "negative integer" is [
	(-INF .. -1]
] : integerType;
