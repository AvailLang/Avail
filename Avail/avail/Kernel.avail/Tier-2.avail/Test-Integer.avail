/**
 * .../Tier-2/Test-Integer.avail
 * Copyright (c) 2010, Mark van Gulik.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Test-Integer"
Extends
Uses
	"Tier-1",
	"Number"
Names
Body

Method "_EQ_" is [a : extended integer type, b : extended integer type |
	a as range = b as range;
];

Assert integer range INF type plus -INF type EQ terminates;
Assert integer range extended integer plus extended integer EQ extended integer;
Assert integer range [5..INF] plus [-INF..-10] EQ extended integer;
Assert integer range [5..INF) plus (-INF..-10] EQ integer;
Assert integer range [-5..INF) plus (-INF..10] EQ integer;
Assert integer range integer plus integer EQ integer;
Assert integer range [2..10] plus [3..8] EQ [5..18];


Assert integer range INF type times -INF type EQ -INF type;
Assert integer range INF type times -5 type EQ -INF type;
Assert integer range 5 type times -INF type EQ -INF type;
Assert integer range 6 type times 9 type EQ 54 type;
Assert integer range [-3..5] times [-4..-2] EQ [-20..12];
Assert integer range [0..3] times [-4..-2] EQ [-12..0];
Assert integer range [-3..0] times [-4..-2] EQ [0..12];
Assert integer range 0 type times -INF type EQ terminates;
Assert integer range 0 type times INF type EQ terminates;

Method "phony_+_" is
[
	a : number,
	b : number
|
	Primitive 1 (failureReason : natural number);
	/* Print failureReason; */
	/* Print "Answering 666 instead."; */
	666;
] : number;

Assert phony 1 + 2 = 3;
Assert phony 2 + 2 = 4;
Assert phony INF + INF = INF;
Assert phony -INF + -INF = -INF;
Assert phony INF + -INF = 666;

two30 ::= 2^30;
two31 ::= two30 * 2;
Print two30;
Print two30 * 2;
Print two30 * -2;
Print (two30 * 2) * -1;
Print [10..20];
Print [10..20] negated;
Print [-10..20] negated;
Print 0 - 1000;
Print [0 - two30;] type result;
Print 0 - two30;
Print [two30..two30] negated;
Print [two30..two31] negated;
Print [two31..two31] negated;
Print [0 - two31;] type result;
Print 0 - two31;
bigNeg ::= -two31;
Print two31;

/* Test that restrictions on "_^_" are as precise as possible. */
/****
bases ::= <-INF, -2, -1, 0, 1, 2, INF>;
exponents ::= <0, 1, 2, 3, 4, INF>;

From 1 to ||bases|| do [lowerSubscript : natural number |
	From lowerSubscript to ||bases|| do [upperSubscript : natural number |
		baseType : extended integer := terminates;
		From lowerSubscript to upperSubscript do [subscript : natural number |
			baseType := type union of baseType and bases[subscript];
		];



		bases ::= bases[lowerSubscript..upperSubscript]
**/

Assert [x : extended integer, y : whole number | x ^ y;] type result = extended integer;
Assert [x : integer, y : whole number | x ^ y;] type result = integer;
