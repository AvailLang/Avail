/**
 * .../Tier-2/Map.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Map"
Extends
Uses
	"Tier-1",
	"BlockA",
	"Container",
	"Number",
	"Set",
	"Tuple",
	"Continuation"
Names
	"{_->_`|_}",
	"map_from_to_",
	"map from_to_",
	"map",
	"_sizes",
	"_keyType",
	"_valueType",
	"`|`|_`|`|",
	"_[_]`?",
	"_[_->_]",
	"_[_->nil]",
	"*_[_]:=_",
	"*_[_]:=nil",
	"[->]",
	"«[_->_]»",
	"_keys",
	"_values"
Body



/* Maps are discrete functions mapping keys onto values.  A map type consists of a range
   of sizes, a keyType, and a valueType.  Instances of a map type are precisely those maps
   that respect these three constraints.
*/


/* mapType construction and manipulation primitives... */

Method "{_->_`|_}" is [
		keyType : any type,
		valueType : any type,
		sizes : whole number type |
	Primitive 87;
] : mapType;

Method "map_from_to_" is [
		sizes : whole number type,
		keyType : any type,
		valueType : any type |
	{keyType->valueType|sizes}
] : mapType;


Method "map from_to_" is [
		keyType : any type,
		valueType : any type |
	map whole number from keyType to valueType
] : mapType;


Method "map" is [
	map from any to any
] : mapType;


Method "_sizes" is [mt : mapType |
	Primitive 88;
] : whole number type;


Method "_keyType" is [mt : mapType |
	Primitive 89;
] : any type;


Method "_valueType" is [mt : mapType |
	Primitive 90;
] : any type;


Method "`|`|_`|`|" is [m : map |
	Primitive 80;
] : integer;

Restriction "`|`|_`|`|" is [mt : mapType |
	mt sizes
];

Method "_∈_keys" is [k : any, m : map |
	/* Test if the key is present */
	Primitive 81;
] : boolean;	

Method "_[_]`?" is [m : map, k : any |
	k ∈ m keys
] : boolean;

Restriction "_[_]`?" is [mt : mapType, kt : type |
	if type intersection of mt keyType and kt = terminates
			| [mt sizes upper bound = 0]
	then [
		/* No value of the k argument could ever be in the map. */
		falseType
	] else [
		boolean
	]
];


Method "_[_]" is [m : map, k : any |
	Primitive 82 (failureCode : natural number);
	Failed
] : any;

Restriction "_[_]" is [mt : mapType, kt : type |
	if type intersection of mt keyType and kt = terminates then [
		/* No value of the k argument could ever be in the map. */
		Fail parse "Argument type is not compatible with map's key type"];
	mt valueType
];


Method "_[_->_]" is [m : map, k : any, v : any |
	/* Copy map but with k->v in it. */
	Primitive 83;
] : map;

Restriction "_[_->_]" is [mt : mapType, kt : type, vt : type |
	sizes ::= cast [mt sizes lower bound .. mt sizes upper bound + 2)
		into [ i : whole number type | i ];
	map sizes
		from cast (type union of mt keyType and kt) into [ t : any type | t ]
		to cast (type union of mt valueType and vt) into [ t : any type | t ]
];


Method "_[_->nil]" is [m : map, k : any |
	/* Copy map but without the given key. */
	Primitive 84;
] : map;

Restriction "_[_->nil]" is [mt : mapType, kt : type |
	/* Original map type but allowing one fewer element (dealing with possibly
	   empty map). */
	map [(mt sizes lower bound - 1) max 0 .. mt sizes upper bound + 1)
		from (mt keyType)
		to (mt valueType)
];



/* Store-back forms... */

Method "*_[_]:=_" is [mapVar : container, key : any, value : any |
	/* Copy map but with k->v in it.  Store back in mapVar. */
	*mapVar ?:=
		cast
			clearing* mapVar
		into [m : map | m[key->value]];
] : void;

Restriction "*_[_]:=_" is [mvt : containerType, kt : type, vt : type |
	good ::= mvt readType = mvt writeType &
		cast mvt readType into [mt : mapType |
			mt sizes upper bound = INF
				& kt <= mt keyType
				& vt <= mt valueType]
		otherwise [false];
	if not good then [
		Fail parse "types to conform for map replacement"];
	void
];


Method "*_[_]:=nil" is [mapVar : container, k : any |
	/* Copy map but without the given key.  Store back in mv. */
	*mapVar ?:= cast *mapVar into [m : map | m[k->nil]];
] : void;

Restriction "*_[_]:=nil" is [mvt : containerType, kt : type |
	/* Allow nonexistent keys to be excluded.  Hence, don't check key
	   types here. */
	good ::= mvt readType = mvt writeType &
		cast mvt readType into [mt : mapType |
			/* Make sure map can shrink arbitrarily small and still fit in variable. */
			mt sizes lower bound = 0]
		otherwise [false];
	if not good then [
		Fail parse "types to conform for map key removal"];
	void
];



/* Map constructors... */

emptyMap ::= ([t : <terminates…|0..0> | Primitive 85; ] : map) apply <<>>;
Method "[->]" is [emptyMap];

Method "«[_->_]»" is [t : <<any…|2..2>…|1..∞> |
	Primitive 85;
] : map;

{"_[_->_]"} can't have <{"«[_->_]»"}, {}, {}>;

Restriction "«[_->_]»" is [tt : <<any…|2..2>…|0..∞> type |
	sizes ::= tt sizes;
	limit ::= cast sizes upper bound into [ i : natural number | i ];
	keyType : type := terminates;
	valueType : type := terminates;
	From 1 to limit do [ i : natural number |
		strongType ::= cast tt[i] into [ t : tupleType | t ];
		keyType := type union of keyType and (strongType[1]);
		valueType := type union of valueType and (strongType[2]); ];
	map sizes
		from cast keyType into [ t : any type | t ]
		to cast valueType into [ t : any type | t ]
];


/* Iteration support... */

Method "_keys" is [m : map |
	Primitive 86;
] : set;

Restriction "_keys" is [mt : mapType |
	set mt sizes of mt keyType
];

Method "_values" is [m : map |
	Primitive 91;
] : tuple;

Restriction "_values" is [mt : mapType |
	tuple mt sizes of mt valueType
];


Method "_do_" is [m : map , blk : [terminates, terminates]->void |
	m keys do [key : any |
		blk apply <key, m[key]>;
	];
] : void;

Restriction "_do_" is [mt : mapType, bT : functionType |
	if not mt keyType <= bT[1] & mt valueType <= bT[2] then [
		Fail parse "block requires an instance of "
			then bT[1] as basic string
			then ", but might be passed an instance of "
			then mt keyType as basic string];
	void
];
