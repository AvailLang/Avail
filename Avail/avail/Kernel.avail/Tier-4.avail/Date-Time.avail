/**
 * Date and Time.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/** A Temporary Date & Time Library.  Will be phased-out with completion
 *  of POJOs
 */
System Module "Date-Time"
Extends
Uses
	"Tier-3"
Names

	/* Time */
	"time",
	"_:_:_:_«_»",
	"_:_:_«_»",
	"_:_«_»",
	"_as string",
	"the current time«in_»",
	"meridiem form of_",
	
	/* Date */
	"date",
	"a date",
	"year_month_day_«time zone_»",
	"_size",
	"_is a leap year",
	"Date_days into the year_",
	"Date_transformed into number of days into the year",
	"today's date«in_»",
	"days since unix epoch from date_",
	"number of leap years between_and_",
	"Subtract_from_«in_»",
	"convert_of form YYYY-MM-DD to a date",
	"valid date month_day_year_",
	"Invalid Date Format",
	"Invalid Day",
	"Invalid Month",
	
	/* Timestamp */
	"timestamp",
	"year_month_day_hour_minute_second_«time zone_»",
	"current date and time«in_»",
	"Unix Epoch",
	
	/* Timezone */
	"time zone",
	"UTC",
	"EST",
	"EDT",
	"CST", 
	"CDT",
	"MST",
	"MDT",
	"PST",
	"PDT"

Body

/** Date-Time Exceptions **/
result ::= lookup "result";

"Invalid Date Format" is explicit subtype of Exception with
	result -> string;

"Invalid Day" is explicit subtype of Exception with
	result -> integer;
	
"Invalid Month" is explicit subtype of Exception with
	result -> integer;

/** Time Zone Object - accounts for time difference from UTC **/
hourDifference ::= new atom "hourDifference";
minuteDifference ::= new atom "minuteDifference";
timeZoneName ::= new atom "timeZoneName";

/* Define the time zone object */
"time zone" is implicit subtype of Object with 
	hourDifference -> [-12..12],
	minuteDifference -> [-59..59],
	timeZoneName -> string;

/* Create "Coordinated Universal Time" time zone */
utc ::= time zone new with
	<<hourDifference,0>,
	<minuteDifference,0>,
	<timeZoneName,"UTC">>;
	
Method "UTC" is [utc];

/* Create "Eastern Standard Time" time zone */
easternStandardTime ::= time zone new with
	<<hourDifference,-5>,
	<minuteDifference,0>,
	<timeZoneName,"EST">>;
	
Method "EST" is [easternStandardTime];

/* Create "Eastern Daylight Time" time zone */
easternDaylightTime ::= time zone new with
	<<hourDifference,-4>,
	<minuteDifference,0>,
	<timeZoneName,"EDT">>;
	
Method "EDT" is [easternDaylightTime];

/* Create "Central Standard Time" time zone */
centralStandardTime ::= time zone new with
	<<hourDifference,-6>,
	<minuteDifference,0>,
	<timeZoneName,"CST">>;
	
Method "CST" is [centralStandardTime];

/* Create "Central Daylight Time" time zone */
centralDaylightTime ::= time zone new with
	<<hourDifference,-5>,
	<minuteDifference,0>,
	<timeZoneName,"CDT">>;
	
Method "CDT" is [centralDaylightTime];

/* Create "Mountain Standard Time" time zone */
mountainStandardTime ::= time zone new with
	<<hourDifference,-7>,
	<minuteDifference,0>,
	<timeZoneName,"MST">>;
	
Method "MST" is [mountainStandardTime];

/* Create "Mountain Daylight Time" time zone */
mountainDaylightTime ::= time zone new with
	<<hourDifference,-6>,
	<minuteDifference,0>,
	<timeZoneName,"MDT">>;
	
Method "MDT" is [mountainDaylightTime];

/* Create "Pacific Standard Time" time zone */
pacificStandardTime ::= time zone new with
	<<hourDifference,-8>,
	<minuteDifference,0>,
	<timeZoneName,"PST">>;
	
Method "PST" is [pacificStandardTime];

/* Create "Pacific Daylight Time" time zone */
pacificDaylightTime ::= time zone new with
	<<hourDifference,-7>,
	<minuteDifference,0>,
	<timeZoneName,"PDT">>;
	
Method "PDT" is [pacificDaylightTime];


/** Time Object **/
hour ::= new atom "hour";
minute ::= new atom "minute";
second ::= new atom "second";
millisecond ::= new atom "millisecond";

/* Define the time object */
"time" is implicit subtype of Object with
	hour -> integer,
	minute -> integer,
	second -> integer,
	millisecond -> integer,
	timeZoneName -> string;

Rule
[
	t : time
|
	t->hour < 24 & t->hour >= 0 & 
	t->minute < 60 & t->minute >= 0 & 
	t->second < 60 & t->second >= 0 &
	t->millisecond < 1000 & t->millisecond >= 0
];

/* Create a time object h:min:sec:milliseconds «time zone» */
Method "_:_:_:_«_»" is 
[
	hr : integer,
	min : integer,
	sec : integer,
	mil : integer,
	tz : <time zone…|0..1>
|
	timezn : string;
	if ||tz|| = 0 then [timezn := "UTC";] else [timezn := tz[1]->timeZoneName;];
	time new with
		<<hour,hr>,
		<minute,min>,
		<second,sec>,
		<millisecond,mil>,
		<timeZoneName,timezn>>
]:time;

/* Create a time object h:min:sec «time zone»
 * Populates milliseconds with 0.
 */
Method "_:_:_«_»" is 
[
	hr : integer,
	min : integer,
	sec : integer,
	tz : <time zone…|0..1>
|
	timezn : time zone;
	if ||tz|| = 0 then [timezn := UTC;] else [timezn := tz[1];];
	
	hr:min:sec:0 timezn
]:time;

/* Create a time object h:min «time zone» 
 * Populates milliseconds with 0.
 * Populates seconds with 0. 
 */
Method "_:_«_»" is 
[
	hr : integer,
	min : integer,
	tz : <time zone…|0..1>
|
	timezn : time zone;
	if ||tz|| = 0 then [timezn := UTC;] else [timezn := tz[1];];
	
	hr:min:0:0 timezn
]:time;

/* Create time string of structure hh:mm:ss time zone */
Method "_as string" is
[
	t : time
|
	hr : string;
	min : string;
	sec : string;
	
	if t->hour < 10 then [hr := "0" then t->hour as basic string;]
		else [hr := t->hour as basic string;];
	
	if t->minute < 10 then [min := "0" then t->minute as basic string;]
		else [min := t->minute as basic string;];
	
	if t->second < 10 then [sec := "0" then t->second as basic string;]
		else [sec := t->second as basic string;];
		
	hr then ":" then min then ":" then sec then " " then t->timeZoneName
]:string;

/* Provide a string time of the 12 hour meridiem clock */
Method "meridiem form of_" is
[
	t : time
|
	hr : string;
	min : string;
	ampm : string;
		
	if 0 < t->hour < 12 then 
	[
		ampm := "AM";
		hr := t->hour as basic string;
	] else if t->hour = 0 then
	[
		ampm := "AM";
		hr := "12";	
	] else
	[
		
		ampm := "PM";
		hr := (t->hour - 12) as basic string;
	];
	
	if t->minute < 10 then [min := "0" then t->minute as basic string;]
		else [min := t->minute as basic string;];
	
	hr then ":" then min then " " then ampm
]:string;

/* Returns the current time for optional given time zone (default - UTC) */
Method "the current time«in_»" is
[
	tz : <time zone…|0..1>
|
	hourDiff : integer; 
	minuteDiff : integer;
	tzName : string;
	
	/* check to see if a time zone was provided */
	if (||tz||) = 1 then
	[
		hourDiff := tz[1]->hourDifference;
		minuteDiff := tz[1]->minuteDifference;
		tzName := tz[1]->timeZoneName;
	] else
	[
		hourDiff := 0;
		minuteDiff := 0;
		tzName := "UTC";
	];
	
	ctm : integer := current time in milliseconds;
	
	hourNowUTC : integer := ((ctm mod 
		(1000*60*60*24))/(1000*60*60));
		
	minuteNowUTC : integer := (((ctm mod 
		(1000*60*60*24)) mod 
		(1000*60*60))/(1000*60));
		
	secondNow : integer := (((ctm mod 
		(1000*60*60*24)) mod 
		(1000*60*60)) mod 
		(1000*60))/1000;
		
	millisecondNow : integer := (((ctm mod 
		(1000*60*60*24)) mod 
		(1000*60*60)) mod 
		(1000*60)) mod 1000;
		
	if tzName = "UTC" then
	[
		time new with <<hour,hourNowUTC>,
			   		<minute,minuteNowUTC>,
					<second,secondNow>,
					<millisecond,millisecondNow>,
					<timeZoneName,tzName>>
	]else
	[
		hourNow : integer;
		minuteNow : integer;
		
		if hourDiff < 0 then
		[
			if |hourDiff| > hourNowUTC then
			[
				hourNow := hourNowUTC + hourDiff + 24;
			] else
			[
				hourNow := hourNowUTC + hourDiff;
			];
		] else
		[
			if hourDiff + hourNowUTC > 23 then
			[
				hourNow := hourNowUTC + hourDiff - 24;
			] else
			[
				hourNow := hourNowUTC + hourDiff;
			];
		
		];
		
		if 	minuteDiff not = 0 then
		[
			minuteNow := minuteNowUTC;
		] else
		[
			minuteNow := minuteNowUTC;
		];
		time new with <<hour,hourNow>,
			   		<minute,minuteNow>,
					<second,secondNow>,
					<millisecond,millisecondNow>,
					<timeZoneName,tzName>>
	]
		
]:time;


/** Date Object **/
month ::= new atom "month";
day ::= new atom "day";
year ::= new atom "year";

/* Define the date object */
"date" is implicit subtype of Object with
	month -> integer,
	day -> integer,
	year -> integer,
	timeZoneName -> string;

Rule
[
	d : date
|
	d->month < 13 & d->month > 0 & 
	d->day < 32 & d->day > 0 &
	d->year < ∞ & d->year > -∞
];

/* Create a date type */
Method "a date" is [date];

/* Creates a string of a date in the form YYYY-MM-DD */
Method "_as string" is
[
	dt : date
|
	mth : string;
	dy : string;
	
	if dt->month < 10 then [mth := "0" then dt->month as basic string;]
		else [mth := dt->month as basic string;];
	
	if dt->day < 10 then [dy := "0" then dt->day as basic string;]
		else [dy := dt->day as basic string;];
	
	dt->year as basic string then "-" then mth then "-" then dy
	
]:string;


/** Timestamp Object **/

/* Define the timestamp object */
"timestamp" is implicit subtype of Object with 
	month -> integer,
	day -> integer,
	year -> integer,
	hour -> integer,
	minute -> integer,
	second -> integer,
	millisecond -> integer,
	timeZoneName -> string;

Rule
[
	ts : timestamp
|
	ts->hour < 24 & ts->hour >= 0 & 
	ts->minute < 60 & ts->minute >= 0 &
	ts->millisecond < 1000 & ts->millisecond >= 0 & 
	ts->second < 60 & ts->second >= 0 &
	ts->month < 13 & ts->month > 0 & 
	ts->day < 32 & ts->day > 0 &
	ts->year < ∞ & ts->year > -∞
];

/* Create a timestamp */
Method "year_month_day_hour_minute_second_«time zone_»" is
[
	yr : integer,
	mth : integer,
	dy : integer,
	hr : integer,
	min : integer,
	sec : integer,
	tz : <time zone…|0..1>
|
	timezn : string;
	
	if ||tz|| = 0 then [timezn := "UTC";] else [timezn := tz[1]->timeZoneName;];
	
	timestamp new with
	<<month,mth>,
	<day,dy>,
	<year,yr>,
	<hour,hr>,
	<minute,min>,
	<second,sec>,
	<millisecond,0>,
	<timeZoneName,timezn>>
	
]:timestamp;

/* Create string from of the timestamp YYYY-MM-DDThh:mm:ss timezone */
Method "_as string" is
[
	ts : timestamp
|
	mth : string;
	dy : string;
	hr : string;
	min : string;
	sec : string;
	
	if ts->hour < 10 then [hr := "0" then ts->hour as basic string;]
		else [hr := ts->hour as basic string;];
	
	if ts->minute < 10 then [min := "0" then ts->minute as basic string;]
		else [min := ts->minute as basic string;];
	
	if ts->second < 10 then [sec := "0" then ts->second as basic string;]
		else [sec := ts->second as basic string;];
		
	if ts->month < 10 then [mth := "0" then ts->month as basic string;]
		else [mth := ts->month as basic string;];
	
	if ts->day < 10 then [dy := "0" then ts->day as basic string;]
		else [dy := ts->day as basic string;];
		
	(ts->year as basic string then "-" then mth then "-") then (dy then "T" then
		hr then ":" then min then ":" then sec then " " then ts->timeZoneName)

]:string;

/* Unix Epoch Date */
unixEpoch ::= timestamp new with
	<<month,1>,
	<day,1>,
	<year,1970>,
	<hour,0>,
	<minute,0>,
	<second,0>,
	<millisecond,0>,
	<timeZoneName,"UTC">>;
	
Method "Unix Epoch" is [unixEpoch];

/* Accepts a date and returns an integer of the form YYYYMMDD */
Method "_size" is
[
	dt : date
|
	dt->year * 10000 + dt->month * 100 + dt->day
	
]:integer;

/* Check if given year is a leap year */
Method "_is a leap year" is
[
	year : integer
|
	if (year mod 4) = 0 then
	[
		if (year mod 100) = 0 then
		[
			if (year mod 400) = 0 then
			[
				true
			] else
			[
				false
			]
		] else
		[
			true
		]
	] else
	[
		false
	]
]:boolean;

/* Checks to see if a valid date */

Method "valid date month_day_year_" is
[
	mth : integer,
	dy : integer,
	yr : integer
|
	outcome : boolean := false;

	if 0 >= mth | mth > 12 then 
	[
		Invalid Month with mth
	]
	else 
	[
		Switch mth
		case 1 do
		[
			if 0 < dy < 32 then [outcome := true;] else 
				[Invalid Day with dy];
		]:
		case 2 do
		[
			ld : integer := 0;
			if yr is a leap year then [ld := 1;];
			if 0 < dy < 29 + ld then [outcome := true;] else 
				[Invalid Day with dy];
		]:
		case 3 do
		[
			if 0 < dy < 32 then [outcome := true;] else 
				[Invalid Day with dy];
		]:
		case 4 do
		[
			if 0 < dy < 31 then [outcome := true;] else 
				[Invalid Day with dy];
		]:
		case 5 do
		[
			if 0 < dy < 32 then [outcome := true;] else 
				[Invalid Day with dy];
		]:
		case 6 do
		[
			if 0 < dy < 31 then [outcome := true;] else 
				[Invalid Day with dy];
		]:
		case 7 do
		[
			if 0 < dy < 32 then [outcome := true;] else 
				[Invalid Day with dy];
		]:
		case 8 do
		[
			if 0 < dy < 32 then [outcome := true;] else 
				[Invalid Day with dy];
		]:
		case 9 do
		[
			if 0 < dy < 31 then [outcome := true;] else 
				[Invalid Day with dy];
		]:
		case 10 do
		[
			if 0 < dy < 32 then [outcome := true;] else 
				[Invalid Day with dy];
		]:
		case 11 do
		[
			if 0 < dy < 31 then [outcome := true;] else 
				[Invalid Day with dy];
		]:
		default
		[
			if 0 < dy < 32 then [outcome := true;] else 
				[Invalid Day with dy];
		];
	];
	outcome
]:boolean;

/* Create a date */
Method "year_month_day_«time zone_»" is
[
	yr : integer,
	mth : integer,
	dy : integer,
	tz : <time zone…|0..1>
|


	catch
	[
		e : Invalid Month
	|
		Crash "Received an invalid month while attempting to construct a date"
	],
	[
		e : Invalid Day
	|
		Crash "Received an invalid day while attempting to construct a date"
	] in
	[
		boo : boolean := valid date month mth day dy year yr;
		
		timezn : string;
		if ||tz|| = 0 then [timezn := "UTC";] 
			else [timezn := tz[1]->timeZoneName;];
		date new with <<month,mth>,
        <day,dy>,
        <year,yr>,
        <timeZoneName,timezn>>
	]
]:any;

Restriction "year_month_day_«time zone_»" is
[
	yrType : integer type,
	mthType : integer type,
	dyType : integer type,
	tzType : (<time zone…|0..1>) type
|
	date
];
/* Given a number of days, calculate the month and day in the year */
Method "Date_days into the year_" is
[
	days : integer,
	yearInput : integer
|
	leapShift : integer := 0;
	if yearInput is a leap year then [leapShift := 1;];
	
	monthNow : integer;
	daysNow : integer;

	 /* In January */
     if days > 0 & days <= 30 then 
     [
         monthNow := 1;
         daysNow := days;
     ]
     /* In February */
     else if days > 30 & days <= (58 + leapShift) then 
     [
         monthNow := 2;
         daysNow := days - 30;
     ]
     /* In March */
     else if days > (58 + leapShift) & days <= (89 + leapShift) then 
     [
         monthNow := 3;
         daysNow := days - (58 + leapShift);
     ] 
     /* In April */
     else if days > (89  + leapShift) & days <= (119 + leapShift) then
     [
         monthNow := 4;
         daysNow := days - (89 + leapShift);
     ] 
     /* In May */
     else if days > (119 + leapShift) & days <= (150 + leapShift) then
     [
         monthNow := 5;
         daysNow := days - (119 + leapShift);
     ]
     /* In June */
     else if days > (150 + leapShift) & days <= (180 + leapShift) then
     [
         monthNow := 6;
         daysNow := days - (150 + leapShift);
     ]
     /* In July */
     else if days > (180 + leapShift) & days <= (211 + leapShift) then
     [
         monthNow := 7;
         daysNow := days - (180 + leapShift);
     ]
     /* In August */
     else if days > (211 + leapShift) & days <= (242 + leapShift) then
     [
         monthNow := 8;
         daysNow := days - (211 + leapShift);
     ]
     /* In September */
     else if days > (242 + leapShift) & days <= (272 + leapShift) then
     [
         monthNow := 9;
         daysNow := days - (242 + leapShift);
     ]
     /* In October */
     else if days > (272 + leapShift) & days <= (303 + leapShift) then
     [
         monthNow := 10;
         daysNow := days - (272 + leapShift);
     ]
     /* In November */
     else if days > (303 + leapShift) & days <= (333 + leapShift) then
     [
         monthNow := 11;
         daysNow := days - (303 + leapShift);
     ]
      /* In December */
     else /* days > (333 + leapShift) & days <= (364 + leapShift) */
     [
         monthNow := 12;
         daysNow := days - (333 + leapShift);
     ];   
       
     date new with <<month,monthNow>,
        <day,daysNow>,
        <year,yearInput>,
        <timeZoneName,"UTC">>

]:date;

/* Given a date, calculate the number of days progressed in the year */
Method "Date_transformed into number of days into the year" is
[
	dateInput : date
|
	leapShift : integer := 0;
	if dateInput->year is a leap year then [leapShift := -1;];
	
	days : integer :=
		 /* In January */
		if dateInput->month = 1 then 
		 [
		     dateInput->day
		 ]
		 /* In February */
		else if dateInput->month = 2 then 
		 [
		     dateInput->day + 30
		 ]
		 /* In March */
		else if dateInput->month = 3 then 
		 [
		     dateInput->day + (58 + leapShift)
		 ] 
		 /* In April */
		else if dateInput->month = 4 then
		 [
		     dateInput->day + (89 + leapShift)
		 ] 
		 /* In May */
		else if dateInput->month = 5 then
		 [
		     dateInput->day + (119 + leapShift)
		 ]
		 /* In June */
		else if dateInput->month = 6 then
		 [
		     dateInput->day + (150 + leapShift)
		 ]
		 /* In July */
		else if dateInput->month = 7 then
		 [
		     dateInput->day + (180 + leapShift)
		 ]
		 /* In August */
		else if dateInput->month = 8 then
		 [
		     dateInput->day + (211 + leapShift)
		 ]
		 /* In September */
		else if dateInput->month = 9 then
		 [
		     dateInput->day + (242 + leapShift)
		 ]
		 /* In October */
		else if dateInput->month = 10 then
		 [
		     dateInput->day + (272 + leapShift)
		 ]
		 /* In November */
		else if dateInput->month = 11 then
		 [
		     dateInput->day + (303 + leapShift)
		 ]
		  /* In December */
		else /* if dateInput->month = 12 */
		 [
		     dateInput->day + (333 + leapShift)
		 ];
	days
]:integer;

/* Method that returns the current date for optional given time zone 
 * (default - UTC) 
 */
Method "today's date«in_»" is
[
    tz : <time zone…|0..1>
|
    /* This method was written on 12/25/2011 ~12:22 am central.
     * It is known that there are 31,622,400,400 milliseconds in a leap year.  
     * There have been 10 leap years since 1970.  That is 316,224,000,000
     * milliseconds.  That can be subtracted from the current milliseconds.
     * There are 31,536,000,000 milliseconds in a regular year and
     * in a 4 year cycle (including the leap year),
     * there are 126,230,400,000 milliseconds.  There have been 10
     * such 4 year cycles since the Java base date of 1/1/1970.  There have been
     * 29 normal years and 10 leap years in years: [1970,2008].  That is a 
     * total of 1,230,768,000,000 milliseconds.  
     */
     
     yearNow : integer;
     monthNow : integer;
     daysNow : integer;
     tzDiffMilliseconds : integer;
     tzTimeZone : string;
     
     if ||tz|| = 1 then
    [
        tzDiffMilliseconds := tz[1]->hourDifference * 60 * 60 *1000 + 
            tz[1]->minuteDifference * 60 * 1000;
        tzTimeZone := tz[1]->timeZoneName;
    ] else
    [
        tzDiffMilliseconds := 0;
        tzTimeZone := "UTC";
    ];
     
     /* current time in milliseconds */
     ctm : integer := current time in milliseconds + tzDiffMilliseconds;
     
     /* time in milliseconds since end of last known leap year (2008) */
     rt : integer := ctm - 1230768000000;
     
     /* leap year cycles since 2008 */
     lpc : integer := rt / 126230400000;
 
     /* milliseconds since last leap year*/
     mllp : integer := rt mod 126230400000;

     /* Calculate date if currently in Leap Year. */
     if mllp > 94608000000 then
     [
        /* days fully passed in current leap year */
        dily : integer := (mllp - 94608000000)/(1000*60*60*24);

		/* Add 1 to dily as current date is day not fully passed
		 * E.g. 4.29 days into the year is not Jan 4th, but Jan 5th. 
		 */
    	currentMonthAndDay: date := 
    		Date (dily + 1) days into the year ((lpc + 1) * 4 + 2008);
    			
		date new with <<month,currentMonthAndDay->month>,
        	<day,currentMonthAndDay->day>,
        	<year,currentMonthAndDay->year>,
        	<timeZoneName,tzTimeZone>>
     ] else      
	 [
        /* Years since last leap year */
        ysly : integer := (mllp / 31536000000);
		 
        /* Days progressed in current nonleap year */
        dty : integer := (mllp mod 31536000000)/ (1000*60*60*24);
        
		/* Add 1 to dty as current date is day not fully passed
		 * E.g. 4.29 days into the year is not Jan 4th, but Jan 5th. 
		 */
    	currentMonthAndDay: date := 
    		Date (dty + 1) days into the year (lpc * 4 + ysly + 2009);
		
		date new with <<month,currentMonthAndDay->month>,
        	<day,currentMonthAndDay->day>,
        	<year,currentMonthAndDay->year>,
        	<timeZoneName,tzTimeZone>>
	]
]:date;

/* Method that returns the current date and time for optional given time zone 
 * (default - UTC) 
 */
Method "current date and time«in_»" is
[
	tz : <time zone…|0..1>
|
	currentDate : date;
	currentTime : time;
	timeZoneString : string;
	
	if ||tz|| = 1 then
	[
		currentDate := today's date in tz[1];
		currentTime := the current time in tz[1];
		timeZoneString := tz[1]->timeZoneName;
	] else
	[
		currentDate := today's date;
		currentTime := the current time;
		timeZoneString := "UTC";
	];	
	
	timestamp new with
		<<month,currentDate->month>,
		<day,currentDate->day>,
		<year,currentDate->year>,
		<hour,currentTime->hour>,
		<minute,currentTime->minute>,
		<second,currentTime->second>,
		<millisecond,currentTime->millisecond>,
		<timeZoneName,timeZoneString>>
]:timestamp;

/* Calculate the number of days that have occurred since the Unix Epoch.
 * Negative days indicate date was before Unix Epoch.
 */
Method "days since unix epoch from date_" is
[
	dt : date
|
	daysIntegerSign : integer;
	daysSinceUnixEpoch : integer := 0;
	
	if dt size > unixEpoch size then
	[ 
		daysIntegerSign := 1;
	] else
	[
		daysIntegerSign := -1;
	];
	
 	sdYearsDiff : integer := (dt->year) - (unixEpoch->year);
 	
 	/* Handle full years passing */
 	if sdYearsDiff not = 0 then 
 	[
 		From 0 to sdYearsDiff - daysIntegerSign by daysIntegerSign do
 		[
 			i : integer
 		|	
 			if ((1970 + i) is a leap year) then 
 			[
 				daysSinceUnixEpoch := 
 					daysSinceUnixEpoch + (366 * daysIntegerSign);
 			] else
 			[
 				daysSinceUnixEpoch := 
 					daysSinceUnixEpoch + (365 * daysIntegerSign);	
 			];
 		];

		/* Handle partial year passing */ 
		if daysIntegerSign = 1 then 
		[
			daysSinceUnixEpoch := daysSinceUnixEpoch +
	 			Date dt transformed into number of days into the year;
	 	] else
	 	[
	 		if dt->year is a leap year then
	 		[
	 			daysSinceUnixEpoch := daysSinceUnixEpoch +
	 			 (Date dt transformed into number of days into the year - 366);
	 		] else
	 		[
	 			daysSinceUnixEpoch := daysSinceUnixEpoch +
	 			 (Date dt transformed into number of days into the year - 365);
	 		];
	 	];
	 ];
	 
 	daysSinceUnixEpoch
]:integer;

/* Number of leap years to occur between two years inclusive */
Method "number of leap years between_and_" is
[
	year1 : integer,
	year2 : integer
|
	numOfLeapYears : integer := 0;
	
	if year1 = year2 then
	[
		if year1 is a leap year then [numOfLeapYears := 1;];
	] else if year1 < year2 then
	[
		From year1 to year2 do
		[
			i : integer
		|
			if i is a leap year then [numOfLeapYears := numOfLeapYears + 1;];
		];
	] else
	[
		From year2 to year1 do
		[
			i : integer
		|
			if i is a leap year then [numOfLeapYears := numOfLeapYears + 1;];
		];
	];
	
	numOfLeapYears

	
]: integer;

/* Method that subtracts two dates.  The first given date should be larger
 * than the second given date.  The optional portion dictates the return values
 * measurement: "days", "months", or "years".  A default measurement of years
 * is chosen if optional is left blank.
 */
Method "Subtract_from_«in_»" is
[
	subtractingDate : date,
	baseDate: date,
	unitOfTime : <string…|0..1>
	
|
	/* Confirm date order is correct */
	if subtractingDate size > baseDate size then
	[
		Crash "The subtracting date must be lesser than the base date"
	];
	
	/* Check to see which MMDD is larger */
	baseMDgreaterSubtractingMD : boolean := 
		(baseDate size - (baseDate->year * 10000)) >=
		(subtractingDate size - (subtractingDate->year * 10000));
	
	/* Check to see which DD is larger */
	baseDDgreaterSubtractingDD : boolean := 
		(baseDate size - (baseDate->year * 10000 + baseDate->month * 100)) >=
		(subtractingDate size - 
			(subtractingDate->year * 10000 + subtractingDate->month * 100));
	
	if ||unitOfTime|| = 1 then
	[
		daysIntoBaseYear : integer :=
			Date baseDate transformed into number of days into the year;
		daysIntoSubtractYear : integer :=
			Date subtractingDate transformed into number of days into the year;
		
		Switch unitOfTime[1]
			case "days" do
			[		 
				days since unix epoch from date baseDate -
					days since unix epoch from date subtractingDate
			]:
			case "months" do
			[
				Switch true
					case baseMDgreaterSubtractingMD & 
						baseDDgreaterSubtractingDD do 
					[ 
						(baseDate->year - subtractingDate->year) * 12 + 
						  baseDate->month - subtractingDate->month
					]: 
					case not baseMDgreaterSubtractingMD & 
						baseDDgreaterSubtractingDD do
					[
						(baseDate->year - subtractingDate->year - 1) * 12 +
						  12 + baseDate->month - subtractingDate->month
					]:
					case baseMDgreaterSubtractingMD & 
						not baseDDgreaterSubtractingDD do
					[
						(baseDate->year - subtractingDate->year) * 12 +
						  ((daysIntoBaseYear - daysIntoSubtractYear) / 30)
					]:
					default
					[
						(baseDate->year - subtractingDate->year - 1) * 12 +
						  ((365 + daysIntoBaseYear - daysIntoSubtractYear) / 30)
					]
			]:
			default
			[
				yearShift : integer := 0;
				if  baseMDgreaterSubtractingMD then 
				[
					yearShift := 1;
				];
				baseDate->year - subtractingDate->year - yearShift
			]
	] else
	[	
		if  baseMDgreaterSubtractingMD then 
		[
			baseDate->year - subtractingDate->year
		] else
		[
			baseDate->year - subtractingDate->year - 1
		]
	]
]:integer;

/* Convert a string to a date.  Requires form YYYY-MM-DD */
Method "convert_of form YYYY-MM-DD to a date" is
[
	dtString : string
|
	if ||dtString|| not = 10  then
	[  
		Raise Invalid Date Format with dtString
	];
	
	if dtString[5] not = $"-" | dtString[5] not = $"-" then
	[  
		Raise Invalid Date Format with dtString
	];
	
	yr : integer;
	mth : integer;
	dy : integer;
	
	catch
	[
		e : Invalid Numeral
	|
		Raise Invalid Date Format with dtString
	] in
	[
		yr := convert dtString[1..4] to an integer;
		mth := convert dtString[6..7] to an integer;
		dy := convert dtString[9..10] to an integer;
		
		if not valid date month mth day dy year yr then 
		[Raise Invalid Date Format with dtString];
		
		year yr month mth day dy
	]
]:any;

Restriction "convert_of form YYYY-MM-DD to a date" is
[
	dtStringType : string type
|
	date
];