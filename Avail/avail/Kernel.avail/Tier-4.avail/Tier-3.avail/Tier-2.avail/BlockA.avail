/**
 * .../Tier-2/BlockA.avail
 * Copyright (c) 2010, Mark van Gulik.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "BlockA"
Extends
Uses
	"Tier-1"
Names
	"_apply_",
	"cast_into_otherwise_",
	"cast_into_"
Body


/* Dynamically typed block evaluation... */

/**
 * This function application only checks its arguments at runtime.  If more
 * information is known at a call site, however, try to use the block's declared
 * return result type as the result of the application.  If the arguments are
 * known to conflict with the block's argument types at some call site (i.e.,
 * it'll always fail), report a compile error.
 */
Method "_apply_" is [block : [...]->void, args : tuple |
	Primitive 40 (failureCode : natural number);
	Crash "Bad argument during function application.";
] : void
requires [functionT : functionType, argsT : tupleType |
	/* The function type is allowed to be too weak, so that this operation will
	 * be useful as a kind of downcast mechanism.  If the function type is not
	 * consistent with the argument types (i.e., it is known statically that the
	 * call will never work), then report the problem at compile time.  */
	functionSizes ::= functionT arguments type sizes;
	argsSizes ::= argsT sizes;
	if argsSizes = terminates then [
		Fail parse "Some argument expressions must terminate";
	];
	validSizes ::= type intersection of functionSizes and argsSizes;
	if functionSizes not = terminates & validSizes = terminates then [
		Fail parse "Number of arguments will always be wrong at this function application site";
	];
	/* I don't believe the argument types can be checked here in any meaningful
	 * way.  If a function argument is terminates, an actual function can be
	 * supplied at runtime that is broader for that (contravariant) argument --
	 * in fact, any function argument type can be broadened up to an "any", which
	 * will accept any argument.
	 */  
	true;
] : boolean
returns [ct : functionType, at : type |
	ct result;
];


/* Type downcasting operation... */

Method "cast_into_otherwise_" is [
		value : any,
		blk1 : [terminates]->void,
		blk2 : []-> void |
	/* Attempt to call the first block, but if the dynamic type isn't right,
	   call the second one. */
	if value type <= blk1 type[1] then [
		blk1 apply <value>;
	] else blk2;
] : void
returns [valType : type, blk1Type : functionType, blk2Type : functionType |
	type union of blk1Type result and blk2Type result;
]
requires [valType : type, blk1Type : functionType, blk2Type : functionType |
	if valType <= blk1Type[1] then [
		Fail parse "Warning - unnecessary cast expression";
	];
	true;
];


Method "cast_into_" is [value : any, block : [terminates]->void |
	/* Same as cast_into_otherwise_, but fail if type isn't right. */
	if value type <= block type[1] then [
		block apply <value>;
	] else [
		Crash <"Bad dynamic cast of a ", value type, " into a ", block type[1]>;
	];
] : void
returns [valType : type, blockType : functionType |
	blockType result;
]
requires [valType : type, blockType : functionType |
	if valType <= blockType[1] then [
		Fail parse "Warning - unnecessary cast expression";
	];
	true;
];
