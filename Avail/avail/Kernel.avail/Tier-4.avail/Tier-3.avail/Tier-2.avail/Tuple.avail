/**
 * .../Tier-2/Tuple.avail
 * Copyright (c) 2010, Mark van Gulik.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Tuple"
Extends
Uses
	"Tier-1",
	"BlockA",
	"Container",
	"Continuation",
	"Integer"
Names
	"_do_",
	"_collect_",
	"_select_",
	"_reject_",
	"_all_",
	"_any_",
	"_to_",
	"_sum_",
	"_sum",
	"type of subtuple_from range_to range_",
	"concatenate tuple type_and_",
	"_[_]",
	"_[_->_]",
	"_[_.._->_]",
	"_then_",
	"_then_then_",
	"splice_",
	"_[_.._]",
	"_[.._]",
	"_[_..]",
	"_radix_",
	"_decimal",
	"_hex",
	"code point_",
	"code point of_",
	"#_",
	"$_",
	"_r_"
Body

/* Forward declarations of the remainder of this module... */

Forward "_[_]" for [tuple, natural number]->all;
Forward "_then_" for [tuple, tuple]->tuple;
Forward "splice_" for [tuple of tuple]->tuple;
Forward "_to_" for [integer, integer]->tuple;
Forward "_[_->_]" for [tuple, natural number, all]->tuple;


/* Set up precedence rules to avoid ambiguity of _to_, _do_, and _to_do_... */

{"_do_"} can't have <{"_to_"}, {}>;

/* Also support up to three-at-a-time chained concatenation via _then_then_... */

{"_then_"} can't have <{"_then_"} , {"_then_" , "_then_then_"}>;
{"_then_then_"} can't have <{"_then_"} , {"_then_" , "_then_then_"} , {"_then_" , "_then_then_"}>;


/* Iteration... */

Method "_do_" is [tup : tuple, blk : [terminates]->void |
	1 to ||tup|| do [i : natural number |
		blk apply <tup[i]>;
	];
] : void
requires [tType : tupleType, blkType : closureType |
	union ::= type union of tType default type and
		union of types in tType leading types;
	union <= blkType[1];
]
returns [tType : tupleType, blkType : closureType |
	/* This is kind of neat.  Normally the result type is void (to indicate
	   no return value).  In the case that the block always terminates
	   and there is at least one item in the tuple for sure, the invocation
	   of _do_ will also always terminate.  */
	if tType sizes lower bound > 0 & [blkType result = terminates;] then [
		terminates;
	] else [
		void;
	];
];
	   

Method "_collect_" is [t : tuple, blk : [terminates]->all |
	result : tuple := <>;
	1 to ||t|| do [i : natural number |
		result := result then <blk apply <t[i]>>;
	];
	result;
] : tuple
requires [tType : tupleType, blkType : closureType |
	union ::= type union of tType default type and
		union of types in tType leading types;
	union <= blkType[1];
]
returns [tType : tupleType, blkType : closureType |
	tuple tType sizes
		like <>
		default blkType result;
];



Method "_select_" is [t : tuple, blk : [terminates]->boolean |
	result : tuple := <>;
	1 to ||t|| do [i : natural number |
		if blk apply <t[i]> then [
			result := result then <t[i]>;
		];
	];
	result;
] : tuple
requires [tType : tupleType, blkType : closureType |
	union ::= type union of tType default type and
		union of types in tType leading types;
	union <= blkType[1];
]
returns [tType : tupleType, blkType : closureType |
	union ::= type union of tType default type and
		union of types in tType leading types;
	sizes ::=
		if blkType result = trueType then [tType sizes;]
		else [
			if blkType result = falseType then [[0..0];]
			else [[0..tType sizes upper bound + 1);];];
	tuple sizes
		like <>
		default union;
];


Method "_reject_" is [t : tuple, blk : [terminates]->boolean |
	result : tuple := <>;
	1 to ||t|| do [i : natural number |
		if not blk apply <t[i]> then [
			result := result then <t[i]>;
		];
	];
	result;
] : tuple
requires [tType : tupleType, blkType : closureType |
	union ::= type union of tType default type and
		union of types in tType leading types;
	union <= blkType[1];
]
returns [tType : tupleType, blkType : closureType |
	union ::= type union of tType default type and
		union of types in tType leading types;
	sizes ::=
		if blkType result = trueType then [[0..0];]
		else [
			if blkType result = falseType then [tType sizes;]
			else [[0..tType sizes upper bound + 1);];];
	tuple sizes
		like <>
		default union;
];


Method "_all_" is [t : tuple, blk : [terminates]->boolean |
	index : natural number := 1;
	While [
		index <= ||t|| & [blk apply <t[index]>;];
	] loop [
		index := index + 1;
	];
	index > ||t||;
] : boolean
requires [tType : tupleType, blkType : closureType |
	union ::= type union of tType default type and
		union of types in tType leading types;
	union <= blkType[1];
];


Method "_any_" is [t : tuple, blk : [terminates]->boolean |
	index : natural number := 1;
	While [
		index <= ||t|| & [not blk apply <t[index]>;];
	] loop [
		index := index + 1;
	];
	index <= ||t||;
] : boolean
requires [tType : tupleType, blkType : closureType |
	union ::= type union of tType default type and
		union of types in tType leading types;
	union <= blkType[1];
];


Method "_sum_" is [t : tuple, blk : [terminates]->extended integer |
	sum : extended integer := 0;
	t do [ element : all | sum := sum + blk apply <element>; ];
	sum;
] : extended integer
requires [tType : tupleType, blkType : closureType |
	union ::= type union of tType default type and
		union of types in tType leading types;
	union <= blkType[1];
]
returns [tType : tupleType, blkType : closureType |
	blkResultType ::= cast blkType result into [intT : integerType | intT; ];
	integer range tType sizes times blkResultType;
];


Method "_sum" is [t : tuple of extended integer |
	sum : extended integer := 0;
	t do [ element : extended integer | sum := sum + element; ];
	sum;
] : extended integer
returns [tType : tupleType |
	currentRange : integerType := [0..0];
	1 to tType sizes lower bound do [i : natural number |
		elementRange ::= cast tType[i] into [intT : integerType | intT; ];
		currentRange := integer range currentRange plus elementRange;];
	broadRange : integerType := currentRange;
	endOfVariation ::= tType sizes upper bound min (||tType leading types|| + 1);
	tType sizes lower bound + 1 to endOfVariation do [i : natural number |
		elementRange ::= cast tType[i] into [intT : integerType | intT; ];
		currentRange := integer range currentRange plus elementRange;
		broadRange := type union of broadRange and currentRange;];
	/* Now that the variation in the tuple type is over, use multiplication to
	    calculate the remaining effect on the range. */
	maximumNumberOfAdditionalElements ::= (tType sizes upper bound - endOfVariation) max 0;
	if maximumNumberOfAdditionalElements > 0 then [
		scaledDeltaRange ::= integer range (cast tType default type into [intT : integerType | intT;])
			times [maximumNumberOfAdditionalElements..maximumNumberOfAdditionalElements];
		broadRange := type union of broadRange and (integer range currentRange plus scaledDeltaRange);];
	broadRange;
] : integerType;


/* Indexing... */

Method "_[_]" is [t : tuple, i : natural number |
	/* Get tuple entry with given index. */
	Primitive 131 (failureCode : all);
	Failed;
] : all
requires [tType : tupleType, iType : integerType |
	/* Require that it's at least possible that the subscript is in range. */
	if iType lower bound > tType sizes upper bound then [
		Fail parse "Tuple subscript is always out of bounds";];
	true;
] : boolean
returns [tType : tupleType, iType : integerType |
	/* Compute the type union of all the possible types it could be,
	   depending on what indices could be applied. */
	possible : type := terminates;
	if iType not = terminates then [
		cast iType lower bound into [low : natural number |
			cast iType upper bound into [high : [1..INF] |
				(low min (|| tType leading types || + 1)) max 1
					to high min (|| tType leading types || + 1)
					do [x : natural number |
						possible := type union of tType[x] and possible;
					];
			] otherwise [
				Crash "Tuple subscript type isn't strict enough at top - see _[_]";
			];
		] otherwise [
			Crash "Tuple subscript type isn't strict enough at bottom - see _[_]";
		];
	];
	possible;
] : type;


/* Interval construction... */

Method "_to_" is [a : integer, b : integer |
	result : tuple := <>;   /* Weak type so result of unrefined "_then_" operation will fit. */
	a to b do [i : integer | result := result then <i>;];
	/* The "_then_" operation is not yet refined with a returns clause.
	   Cast the type downwards, as we know the entries are all integers. */
	cast result into [x : tuple of integer | x;];
] : tuple of integer
returns [aRange : integerType, bRange : integerType |
	if aRange lower bound > bRange upper bound then [
		<> type;
	] else [
		sizes ::= [(bRange lower bound - aRange upper bound + 1) max 0
			.. bRange upper bound - aRange lower bound + 2);
		uncertainty ::= aRange upper bound - aRange lower bound;
		if uncertainty is finite & sizes upper bound is finite then [
			/* We have a static finite bound on tuple length and on
			   the amount of uncertainty there will be at each index... */
			cast aRange lower bound into [min : integer |
				cast bRange upper bound into [max : integer |
					tuple sizes
						like (min to max
							collect [weakX : all |
								cast weakX into [strongX : integer |
									range from strongX
										inclusive true
										to strongX + uncertainty + 1
										inclusive false;
								];
							])
						default terminates;
				];
			];
		] else [
			/* Either the uncertainty of the starting value is arbitrarily
			   large or we have no static bound on the final tuple length.
			   Either way, we approximate with a homogenous tuple... */
			tuple sizes
				like <>
				default [aRange lower bound..bRange upper bound + 1);
		];
	];
] : tupleType;

/* Private subtuple extraction type helper... */

Method "type of subtuple_from range_to range_" is [tt : tupleType, starts : integerType, ends : integerType |
	minStart ::= starts lower bound max 1;
	maxStart ::= starts upper bound max 1;
	minEnd ::= ends lower bound max 0;
	maxEnd ::= ends upper bound max 0;
	if minEnd > tt sizes upper bound then [
		/* All possible subtuples that this subrange could represent are out
		   of bounds for the tuple.  Answer terminates to indicate this operation
		   will never succeed at runtime. */
		terminates;
	] else [
		limit ::= maxEnd min tt sizes upper bound min (|| tt leading types || + 1);
		minTrimmedStart ::= (minStart min limit) max 1;
		maxTrimmedStart ::= (maxStart min limit) max 1;
		variance ::= maxTrimmedStart - minTrimmedStart;
		resultPattern ::= minTrimmedStart to limit collect [index : [1..INF) |
			u : type := terminates;
			index to (index + variance) min limit do [subindex : [1..INF) |
				u := type union of u and tt[subindex];
			];
			u;
		];
		default ::= cast ||resultPattern|| into [n : [1..INF) |
			resultPattern[n];
		] otherwise [
			terminates;
		];
		clipMinStart ::= (minStart max 1) min tt sizes upper bound;
		clipMaxStart ::= (maxStart max 1) min tt sizes upper bound;
		clipMinEnd ::= (minEnd max 0) min tt sizes upper bound;
		clipMaxEnd ::= (maxEnd max 0) min tt sizes upper bound;
		sizes ::= [(clipMinEnd - clipMaxStart + 1) max 0
			.. ((clipMaxEnd - clipMinStart + 1) max 0) + 1);
		tuple sizes
			like resultPattern
			default default;
	];
] : tupleType;


/* Helper function for computing types of concatenations. */

Method "concatenate tuple type_and_" is [
		tt1 : tupleType,
		tt2 : tupleType |
	Primitive 144 (failureCode : all);
	Failed;
] : tupleType;


/* Replacement... */

Method "_[_->_]" is [t : tuple, i : natural number, v : all |
	/* Answer new tuple with given index set to the given value. */
	Primitive 132 (failureCode : all);
	Failed;
] : tuple
returns [tType : tupleType, iType : integerType, vType : type |
	leading : tuple of type := tType leading types;
	default : type := tType default type;
	/* Deal with replacement in leading types... */
	if iType lower bound <= || leading || then [
		cast iType lower bound into [low : natural number |
			low max 1 to || leading || do [x : natural number |
				newLeading ::= leading[x -> type union of leading[x] and vType];
				/* Since we haven't defined "_[_->_]" with a strong enough
				   returns clause yet (that's what we're in the middle of
				   doing!), we have to dynamically cast into tuple of type. */
				cast newLeading into [y : tuple of type | leading := y;];
			];
		];
	];
	/* Deal with finite or infinite extension of leading types... */
	cast iType upper bound into [upper : integer |
		/* Finite extension - countably many indices are weakened to vType... */
		if upper > || leading || & not vType <= default then [
			weaker ::= type union of default and vType;
			newLeading ::= leading then
				(|| leading || + 1 to upper collect [x : integer | weaker;]);
			/* "_then_" is still too weak, so cast newLeading back to a tuple of
			   type.  It'll be defined more strongly once it's defined below... */
			cast newLeading into [x : tuple of type | leading := x;];
		];
	] otherwise [
		/* Infinite extension - all indices >= lower bound are weakened to vType... */
		if iType upper bound not = INF then [
			Crash "Inconsistency in returns clause of _[_->_]";];
		default := type union of default and vType;
	];
	tuple tType sizes
		like leading
		default default;
] : tupleType;


Method "*_[_]:=_" is [tupleVar : &:tuple, i : natural number, v : all |
	/* Make a new tuple like that in tupleVar, but with the given index set to
	   the given value.  Set tupleVar to this new tuple.  */
	*tupleVar ?:= clearing* tupleVar [i->v];
] : void
requires [tvt : containerType, it : integerType, vt : type |
	cast tvt contentType into [tt : tupleType |
		/* Make sure we can store back any possible result. */
		vt <= union of types in
			tt [(it lower bound max 1) min (||tt leading types|| + 1)
				.. (it upper bound max 0) min (||tt leading types|| + 1)];
	] otherwise [
		false;
	];
];



Method "_then_" is [t1 : tuple, t2 : tuple |
	/* Concatenate two tuples. */
	splice <t1, t2>;
] : tuple
returns [tt1 : tupleType, tt2 : tupleType |
	concatenate tuple type tt1 and tt2;
];

Method "_then_then_" is [t1 : tuple, t2 : tuple , t3 :tuple |
	/* Concatenate three tuples. */
	splice <t1, t2, t3>;
] : tuple
returns [tt1 : tupleType, tt2 : tupleType, tt3 : tupleType |
	concatenate tuple type
		concatenate tuple type tt1 and tt2
	and tt3;
];

Method "splice_" is [tupleOfTuples : tuple of tuple |
	/* Concatenate a tuple of tuples into one big tuple. */
	Primitive 136 (failureCode : all);
	Failed;
] : tuple
returns [ttType : tupleType |
	limit ::= if ttType sizes upper bound is infinite then [
		ttType sizes lower bound max (||ttType leading types|| + 1);
	] else [
		ttType sizes upper bound;
	];
	result : tupleType := <> type;
	1 to limit do [i : natural number |
		result := concatenate tuple type result
			and cast ttType[i] into [x : tupleType | x;];
	];
	if ttType sizes upper bound is infinite then [
		result := tuple [result sizes lower bound .. INF)
			like result [1 .. cast result sizes upper bound into [w : whole number | w;]]
			default union of types in
				(cast ttType default type
					into [t : tupleType |
						t[1 .. ||t leading types|| + 1];
					]
				);
	];
	result;
];



Method "_[_.._]" is [t : tuple, start : natural number, end : whole number |
	/* Extract a contiguous region from a tuple. */
	Primitive 135 (failureCode : all);
	Failed;
] : tuple
returns [tt : tupleType, startT : integerType, endT : integerType |
	type of subtuple tt
	from range startT
	to range endT;
] : tupleType;


Method "_[.._]" is [t : tuple, end : whole number |
	/* Extract a contiguous region from a tuple. */
	t[1..end];
] : tuple
returns [tt : tupleType, endT : integerType |
	type of subtuple tt
	from range [1..1]
	to range endT;
] : tupleType;


Method "_[_..]" is [t : tuple, start : natural number |
	/* Extract a contiguous region from a tuple. */
	t[start..||t||];
] : tuple
returns [tt : tupleType, startT : integerType |
	type of subtuple tt
	from range startT
	to range tt sizes;
] : tupleType;



Method "_[_.._->_]" is [t : tuple, start : natural number, end : whole number, replacement : tuple |
	/* Create a tuple with the given range replaced by replacement.  The
	   range need not match the size of the replacement. */
	splice <t[1..start-1], replacement, t[end+1..||t||]>;
] : tuple
returns [tt : tupleType, startT : integerType, endT : integerType, repT : tupleType |
	part1 ::= type of subtuple tt
		from range [1..1]
		to range (startT lower bound - 2 .. startT upper bound);
	part2 ::= repT;
	part3 ::= type of subtuple tt
		from range (endT lower bound .. endT upper bound + 2)
		to range tt sizes;
	concatenate tuple type
		concatenate tuple type part1
		and part2
	and part3;
] : tupleType;


/* Conversion from integer to string */
Forward "_radix_" for [integer, [2..36]]->string;
Method "_radix_" is [i : integer, rad : [2..36] |
	if i < 0 then [
		"-" then -i radix rad;
	] else [
		index ::= i mod rad + 1;
		digit ::= "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" [index];
		if i < rad then [
			<digit>;
		] else [
			i / rad radix rad then <digit>;
		];
	];
] : string;

Method "_decimal" is [a : integer |
	a radix 10;
] : string;

Method "_hex" is [a : integer |
	a radix 16;
] : string;

Method "code point_" is [w : whole number |
	Primitive 331 (failureCode : all);
	Failed;
] : character;

Method "code point of_" is [c : character |
	Primitive 330 (failureCode : all);
	Failed;
] : whole number;

Method "$_" is [str : tuple [1..1] of character |
	str [1];
] : character;

Method "#_" is [str : tuple [1..1] of character |
	code point of str [1];
] : whole number;

digitZero ::= #"0";
digitNine ::= #"9";
lettera ::= #"a";
letterz ::= #"z";
letterA ::= #"A";
letterZ ::= #"Z";

Method "_r_" is [radix : [2..36], digits : string |
	/* Variable-radix string to integer conversion.  For example, 16r"ff" is 255. */
	result : whole number := 0;
	digits do [char : character |
		dig ::= code point of char;
		digValue ::= cast dig into [numericDig : [digitZero..digitNine] |
			numericDig - digitZero;
		] otherwise [
			cast dig into [lowercaseDig : [lettera..letterz] |
				lowercaseDig - lettera + 10;
			] otherwise [
				cast dig into [uppercaseDig : [letterA..letterZ] |
					uppercaseDig - letterA + 10;
				] otherwise [
					Crash "Unknown digit during radix conversion: " then <dig>;
				];
			];
		];
		Assert 0 <= digValue < radix;
		result := result * radix + digValue;
	];
	result;
];

Method "_to_" is [a : character, b : character |
	result : string := "";
	code point of a to code point of b do [cp : whole number | result := result then <code point cp>; ];
	result;
] : string;

