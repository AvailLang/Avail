/**
 * .../Tier-1/Method.avail
 * Copyright (c) 2010, Mark van Gulik.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Method"
Extends
Uses
	"Tier-0",
	"Block"
Names
	"Method_is_requires_returns_",
	"Method_is_returns_requires_",
	"Method_is_requires_",
	"Method_is_returns_",
	"Forward_for_",
	"Abstract method_for_requires_returns_",
	"Abstract method_for_returns_requires_",
	"Abstract method_for_requires_",
	"Abstract method_for_returns_",
	"Abstract method_for_",
	"lookup_",
	"(_)"
Body



/* Private utility methods for type extraction.  It will be defined in all its glory
   later, using the method-defining methods defined in this module. */

Method "_basicType" is [a : all |
	Primitive 30;
	Failed;
] : type;


/* Private - override to support metacovariance in closure types... */

Method "_basicType" is [c : closure |
	Primitive 30;
	Failed;
] : closureType;


/* Add support for alternative forms of method declarations.  These forms allow
the user to attach two blocks during method definition.  The 'returns' block is
evaluated to compute the return type that a CALL SITE will produce.  Thus, it
is a linkage time construct, and is evaluated when code using the new method
is compiled.  Similarly, the 'requires' block answers whether a particular call site
provides types that fit together in ways the type system is too weak to validate.
This flexibility should even allow general function applicators to be defined,
while retaining all the warm fuzzies associated with static typing. */

Method "Method_is_requires_returns_"
is [name : string, body : closure, requires: closure, returns : closure |
	Primitive 254;
	Failed;
] : void;

Method "Method_is_returns_requires_"
is [name : string, body : closure, returns : closure, requires: closure |
	/* Alternate order for requires / returns clauses */
	Method name is body requires requires returns returns;
] : void;

Method "Method_is_requires_"
is [name : string, body : closure, requires : closure |
	Method name
	is body
	requires requires
	returns stub block taking ||body basicType|| arguments and returning body basicType result;
];

Method "Method_is_returns_"
is [name : string, body : closure, returns : closure |
	Method name
	is body
	requires stub block taking ||body basicType|| arguments and returning true
	returns returns;
];

Method "Forward_for_"
is [name : string, blockType : closureType |
	/* Declare method without body (for recursion / mutual recursion).  Must be
	   followed in same module by a legitimate definition. */
	Primitive 252;
	Failed;
] : void;


/* Abstract method declarations.  Stubbed for now, but eventually the concept of
   an abstract class will be any class for which there is an abstract method that has
   not been overridden.  It's illegal to add an abstract method in an extension of a
   class (i.e., the class must still be open in the current module), otherwise a module
   could have the effect of changing a concrete class into an abstract class. */

Method "Abstract method_for_requires_returns_" is [
		name : string, bodyType : closureType, requires : closure, returns : closure |
	Primitive 251;
	Failed;
] : void;

Method "Abstract method_for_returns_requires_" is [
		name : string, bodyType : closureType, returns : closure, requires : closure |
	/* Switch the returns and requires clause order for convenience. */
	Abstract method name for bodyType
		requires stub block taking ||bodyType|| arguments and returning true
		returns stub block taking ||bodyType|| arguments and returning bodyType result;
] : void;

Method "Abstract method_for_returns_" is [
		name : string, bodyType : closureType, returns : closure |
	/* Allow returns clause to be specified while omitting the requires clause. */
	Abstract method name for bodyType
		requires stub block taking ||bodyType|| arguments and returning true
		returns returns;
] : void;

Method "Abstract method_for_requires_" is [
		name : string, bodyType : closureType, requires : closure |
	/* Allow requires clause to be specified while omitting the returns clause. */
	Abstract method name for bodyType
		requires requires
		returns stub block taking ||bodyType|| arguments and returning bodyType result;
] : void;

Method "Abstract method_for_" is [
		name : string, bodyType : closureType |
	/* Declare an abstract method with no specified returns clause or requires clause. */
	Abstract method name for bodyType
		requires stub block taking ||bodyType|| arguments and returning true
		returns stub block taking ||bodyType|| arguments and returning bodyType result;
] : void;


/* Method name lookup operation.  Looks up a given string in the current
   module's namespace. */

Method "lookup_" is [t : string |
	Primitive 245;
	Failed;
] : cyclicType;

/* Define simple parentheses.  This is not part of the built-in syntax
of Avail because I want to emphasize the fact that things like function
application and array subscripting can be added dynamically to the
syntax, and these similar operations "_(_)" look so much like simple
parentheses "(_)" that doing them two different ways would be a
shameful inconsistency.  Besides, this is an excellent example of
parametric result typing.  Note that list expressions *can not* be
parenthesized.  This is to avoid confusion with function evaluation,
and possibly the syntax of Points.  */

Method "(_)" is [arg : all |
	arg;
] returns [argType : type |
	argType;
];

