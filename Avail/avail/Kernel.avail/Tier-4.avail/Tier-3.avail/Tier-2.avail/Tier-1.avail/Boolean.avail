/**
 * .../Tier-1/Boolean.avail
 * Copyright (c) 2010, Mark van Gulik.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Boolean"
Extends
Uses
	"Tier-0",
	"Block",
	"Method",
	"Set",
	"Tuple",
	"Type"
Names
	"if_then_else_",
	"if_then_",
	"_&_",
	"_|_",
	"not_",
	"_xor_",
	"_not=_",
	"Assert_"
Body



/* Elementary boolean choice operator... */

Forward "if_then_else_" for [boolean, []->void, []->void] -> void;

Method "if_then_else_"
is [
		bool : boolean,
		trueBlock : []->void,
		falseBlock : []->void |
	/* Conditionally evaluate either the trueBlock or the falseBlock. */
	Primitive 43 (failureCode : all);
	Failed;
] : void
returns [bt : type, tbt : closureType, fbt : closureType |
	/* We have to use a local variable (result) because at this point
	   the definition of if_then_else_ does not exist, and we are linking
	   to it.  The rule is that the forward definition's return type is what
	   will be used until the forward has been replaced, so the type would
	   be void, which makes it impossible to use the return type from the
	   conditionals.  By using a local we can ignore the return types.  */
	result : type;
	if bt = boolean then [
		result := type union of tbt result and fbt result;
	] else [
		if bt = trueType then [
			result := tbt result;
		] else [
			if bt = falseType then [
				result := fbt result;
			] else [
				Crash "Conditional's type is unknown in if_then_else_";
			];
		];
	];
	result;
] : type;



Method "if_then_" is [bool : boolean, trueBlock : []->void |
	/* "if_then_" is always a statement (always returns void).  We could
	   simply call if_then_else_ with an empty block [] for the else clause.
	   We use another primitive instead, just for performance of the Level
	   One interpreter.  */
	Primitive 44 (failureCode : all);
	Failed;
] : void;


/* Define ambiguous precedence between & and |, but let & be
   left associative, and let | also be left associative.  Do the same for
   xor, keeping it mutually ambiguous with & and |.  Let 'not' be tighter
   bound than each of &, |, xor.  Note that the short circuiting forms
   are the same operators but with a block as the second argument.  */

{"_&_"} can't have <{},{"_&_"}>;
{"_|_"} can't have <{},{"_|_"}>;
{"_xor_"} can't have <{},{"_xor_"}>;
{"not_"} can't have <{"_&_", "_|_", "_xor_"}>;

/* Now define the boolean operators.  When the static types are known
   well enough, use that additional static information to strengthen the
   return type to trueType or falseType. */

Method "_&_" is [a : boolean, b : boolean |
	false;
] : boolean
returns [at : type, bt : type |
	res : type := boolean;
	if at = falseType then [res := falseType;];
	if bt = falseType then [res := falseType;];
	res;
] : type;


Method "_&_" is [a : trueType, b : trueType |
	true;
] :  trueType;


Abstract method "_&_" for [boolean,  []->boolean]->boolean
returns [at : type, bt : closureType |
	res : type := boolean;
	if at = trueType then [res := bt result;];
	if at = falseType then [res := falseType;];
	if bt result = falseType then [res := falseType;];
	res;
] : type;


Method "_&_" is [a : trueType, b :  []->boolean |
	/* Evaluate b because a leaves it contingent. */
	Primitive 45 (failureCode : all);
	Failed;
] : boolean
returns [at : type, bt : closureType |
	bt result;
] : type;


Method "_&_" is [a : falseType, b :  []->boolean |
	false;
] : falseType;



Method "_|_" is [a : boolean, b : boolean |
	true;
] : boolean
returns [at : type, bt : type |
	res : type := boolean;
	if at = trueType then [res := trueType;];
	if bt = trueType then [res := trueType;];
	res;
] : type;


Method "_|_" is [a : falseType, b : falseType |
	false;
] : falseType;


Abstract method "_|_" for [boolean,  []->boolean]->boolean
returns [at : type, bt : closureType |
	res : type := boolean;
	if at = falseType then [res := bt result;];
	if at = trueType then [res := trueType;];
	if bt result = trueType then [res := trueType;];
	res;
] : type;


Method "_|_" is [a : trueType, b :  []->boolean |
	true;
] : trueType;


Method "_|_" is [a : falseType, b :  []->boolean |
	/* Evaluate b because a leaves it contingent. */
	Primitive 45 (failureCode : all);
	Failed;
] : boolean
returns [at : type, bt : closureType |
	bt result;
] : type;



Abstract method "not_" for [boolean]->boolean;

Method "not_" is [a : trueType |
	false;
] : falseType;

Method "not_" is [a : falseType |
	true;
] : trueType;



Method "_xor_" is [a : boolean , b : boolean |
	not (a = b);
] : boolean
returns [at : type, bt : type |
	if at = boolean | bt = boolean then [
		boolean;
	] else [
		if at = bt then [falseType;] else [trueType;];
	];
];



/* General purpose... */

Method "_not=_" is [a : all, b : all |
	not a = b;
] : boolean;



/* Runtime assertions... */

Abstract method "Assert_" for [boolean]->void;

Method "Assert_" is [b : trueType |
	/* Do nothing - the assertion is true. */
];

Method "Assert_" is [b : falseType |
	Crash "A runtime assertion has failed";
];



