/**
 * .../Tier-0/Tier-0.avail
 * Copyright (c) 2010, Mark van Gulik.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Test"
Extends
	"Basics"
Uses
Names
Body


/* Test the basic bootstrap modules. */


Method "Assert_" is [b : trueType |
	/* Do nothing - the assertion is true. */
] : void;

Method "Assert_" is [b : boolean |
	Crash "A runtime assertion has failed";
] : void;


Method "_to string" is [x : all |
	Primitive 259;
	"Unprintable object";
] : string;


Method "«_‡then»" is [t : tuple |
	Primitive 136;
	Failed;
] : string;

Method "<«_‡,»>" is [t : tuple |
	t;
] : tuple;

Method "{«_‡,»}" is [t : tuple |
	Primitive 109;
	Failed;
] : set;

{"«_‡then»"} can't have <{"«_‡then»"}>;
{"_to string"} can't have <{"«_‡then»"}>;


Method "If_then_else_" is [
		condition : boolean,
		thenBlock : closure,
		elseBlock : closure |
	Primitive 43;
	Failed;
] : void;


Method "not_" is [
		b : boolean |
	Crash "Missing definition of not_";
] : boolean;

Method "not_" is [
		f : falseType |
	true;
] : trueType;

Method "not_" is [
		t : trueType |
	false;
] : falseType;


Method "Fail parse_" is [
		problem : string |
	Primitive 352;
	Failed;
] : terminates;


Macro "_first_" is [a : parseNode, b : parseNode | a;];
Macro "_second_" is [a : parseNode, b : parseNode | b;];

Assert 5 = 5;

Assert true first false;
Assert false second true;


Macro "_<-_" is [v : variableUseNode, e : parseNode |
	Primitive 353;
	Crash "Failed assignment creation";
];

x : integer;
x := 5;
x <- 10;
Assert x = 10;


Method "make assignment variable_expression_" is [
		v : variableUseNode,
		e : parseNode |
	Primitive 353;
	Crash "Failed to create assignment";
] : parseNode;


Method "_expression type" is [
		e : parseNode |
	Primitive 351;
	Crash "Failed to extract type of expression";
] : type;

Macro "_->_" is [e : parseNode, v : variableUseNode |
	If not e expression type <= v expression type then [
		Fail parse
			"expression type ("
			then e expression type to string
			then ") to agree with variable type "
			then v expression type to string;
	] else [];
	make assignment variable v expression e;
] : parseNode;

20 -> x;
Assert x = 20;

/* "cheese" -> x; */

If true then [
	w : integer := 14;
	Print w;
] else [];