/**
 * .../Tier-4/Pojo.avail
 * Copyright (c) 2010, Mark van Gulik.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @author Todd L Smith &lt;anarakul@gmail.com&gt;
 */

System Module "Pojo"
Extends
Uses
	"Tier-3"
Names
	"pojo",
	"null type",
	"null",
	"self type",
	
	"Java type_parameters_",
	"Java type_",
	"Java_[]",
	
	"jbyte",
	"jshort",
	"jint",
	"jlong",
	
	"constructor of_given_"
Body

privatePojo ::= Special Object 80;

Method "pojo" is
[
	privatePojo;
] : privatePojo type;

privateNullType ::= Special Object 81;

Method "null type" is
[
	privateNullType;
] : privateNullType type;

privateNull ::= Special Object 82;

Method "null" is
[
	privateNull;
] : privateNull type;

{"_type"} can't have <{"null"}>;

Assert pojo <= pojo;
Assert null type <= pojo;
Assert null type not = pojo;
Assert null type not = (null) type;
Assert (null) type <= null type;

privateSelfObject ::= Special Object 83;

Method "self type" is
[
	privateSelfObject;
] : privateSelfObject type;

"Java Class Not Available" is explicit subtype of Exception;
"Incorrect Number of Java Type Parameters" is explicit subtype of Exception;
"Incorrect Java Type Parameter" is explicit subtype of Exception;

Method "⊶Java type_parameters_" is
[
	typeName : string,
	typeParameters : tuple of type
|
	Primitive 500 (failureCode : whole number);
	if failureCode = 500 then
	[
		Raise Java Class Not Available with typeName;
	];
	if failureCode = 11 then
	[
		Raise Incorrect Number of Java Type Parameters with ||typeParameters||;
	];
	Assert failureCode = 12;
	Raise Incorrect Java Type Parameter with terminates;
] : pojo type;

Method "Java type_parameters_" is
[
	typeName : string,
	typeParameters : tuple of type
|
	⊶Java type typeName parameters typeParameters;
] : pojo type;

Restriction "Java type_parameters_" is
[
	typeNameType : string type,
	typeParametersType : (tuple of type) type
|
	typeNameEnum ::= cast typeNameType into [ e : enum | e; ]
		otherwise [
			Fail parse "Java type name is not statically known"; ];
	typeName ::= cast typeNameEnum instance into [ s : string | s; ];
	
	typeParametersTypeBounds ::= typeParametersType sizes;
	if
		typeParametersTypeBounds lower bound
		not = typeParametersTypeBounds upper bound
	then [
		Fail parse "argument tuple size must be statically known"; ];
	
	typeParametersSize ::= cast typeParametersTypeBounds upper bound into
		[ b : whole number | b; ];  
	args : tuple of type := <>;
	1 to typeParametersSize do [i : natural number |
		argType ::= cast typeParametersType[i] into [ e : enum | e; ]
			otherwise [
				Fail parse
					"argument type "
					then i as basic string
					then " is not statically known"; ];
		arg ::= cast argType instance into [ t : type | t; ];
		args := args then <arg>;
	];
	
	(⊶Java type typeName parameters args) type;
];

Method "Java type_" is
[
	typeName : string
|
	⊶Java type typeName parameters <>;
] : pojo type;

Restriction "Java type_" is
[
	typeNameType : string type
|
	typeNameEnum ::= cast typeNameType into [ e : enum | e; ]
		otherwise [
			Fail parse "Java type name is not statically known"; ];
	typeName ::= cast typeNameEnum instance into [ s : string | s; ];
	
	result : pojo type type;
	catch [ e : Incorrect Number of Java Type Parameters |
		Fail parse
			"incorrect number of Java type parameters for "
			then typeName; ]
	in [ result := (⊶Java type typeName parameters <>) type; ];
	result;
];

[
	jObject ::= Java type "java.lang.Object";
	Assert jObject = pojo;
	jString ::= Java type "java.lang.String";
	Assert jString <= jObject;
	jInteger ::= Java type "java.lang.Integer";
	Assert jInteger <= jObject;
	jComparableOfObject ::=
		Java type "java.lang.Comparable" parameters <jObject>;
	Assert jString <= jComparableOfObject;
	Assert jInteger <= jComparableOfObject;
	Assert type intersection of jString and jInteger = null type;
	jCloneable ::= Java type "java.lang.Cloneable";
	Assert type intersection of jString and jCloneable = null type;
	jSerializable ::= Java type "java.io.Serializable";
	intersect ::= type intersection
		of jObject
		and (type intersection of jComparableOfObject and jSerializable);
	union ::= type union of jString and jInteger;
	Assert union <= intersect;
	jListOfAny ::= Java type "java.util.List" parameters <any>;
	jArrayListOfInteger ::=
		Java type "java.util.ArrayList" parameters <jInteger>;
	Assert jArrayListOfInteger <= jListOfAny;
	jDequeOfTuple ::= Java type "java.util.Deque" parameters <tuple>;
	jLinkedListOfTupleOfString ::=
		Java type "java.util.LinkedList" parameters <tuple of string>;
	Assert jLinkedListOfTupleOfString <= jDequeOfTuple;
	jComparableOfComparableOfObject ::=
		Java type "java.lang.Comparable" parameters <jComparableOfObject>;
	Assert jString <= jComparableOfComparableOfObject;
	Assert jInteger <= jComparableOfComparableOfObject;
]();

Method "Java_[]" is
[
	aType : type
|
	Primitive 501;
] : pojo type;

Restriction "Java_[]" is
[
	aTypeType : type type
|
	cast aTypeType into [ e : enum |
		(Java (cast e instance into [ t : type | t; ]) []) type; ]
	otherwise [
		Fail parse "pojo type is not statically known"; ];
];

[
	jArrayOfAny ::= Java any[];
	jArrayOfObject ::= Java pojo[];
	Assert jArrayOfObject <= pojo;
	Assert jArrayOfObject <= jArrayOfAny;
	jString ::= Java type "java.lang.String";
	jArrayOfString ::= Java jString[];
	Assert jArrayOfString <= jArrayOfObject;
	jArrayOfTupleOfString ::= Java tuple of string[];
	Assert jArrayOfTupleOfString <= jArrayOfAny;
]();

Method "constructor of_given_" is
[
	aPojoType : pojo type,
	argTypes : tuple of type
|
	Primitive 502 (failureCode : whole number);
	Crash "Yikes!";
] : [...]->pojo;

Restriction "constructor of_given_" is
[
	aPojoTypeType : pojo type type,
	argTypesType : (tuple of type) type
|
	argTypesTypeBounds ::= argTypesType sizes;
	if argTypesTypeBounds lower bound not = argTypesTypeBounds upper bound then
	[
		Fail parse "argument tuple size must be statically known";
	];
	
	argTypesSize ::= cast argTypesTypeBounds upper bound into
		[ b : whole number | b; ];  
	args : tuple of type := <>;
	1 to argTypesSize do [i : natural number |
		argType ::= cast argTypesType[i] into [ e : enum | e; ]
			otherwise [
				Fail parse
					"argument type "
					then i as basic string
					then " is not statically known"; ];
		arg ::= cast argType instance into [ t : type | t; ];
		args := args then <arg>;
	];
	
	block type taking args and returning aPojoTypeType instance;
];

Method "jbyte" is [ [-2^7..2^7); ];
Method "jshort" is [ [-2^15..2^15); ];
Method "jint" is [ [-2^31..2^31); ];
Method "jlong" is [ [-2^63..2^63); ];

[
	jObjectC ::= constructor of pojo given <>;
	o ::= jObjectC();
	Print o;
	jStringC ::= constructor of Java type "java.lang.String" given <string>;
	o ::= jStringC("Hello, Java!");
	Print o;
	jList ::= Java type "java.util.ArrayList" parameters <jint>;
	jListC ::= constructor of jList given <jint>;
	o ::= jListC(100);
	Print o;
	jEnum ::= Java type "java.lang.Enum" parameters <self type>;
	Print jEnum;
]();
