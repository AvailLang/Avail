/**
 * .../Tier-4/Graph.avail
 * Copyright (c) 2010, Mark van Gulik.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Graph"
Extends
Uses
	"Tier-3",
	"Factory",
	"Iterator"
Names
	"Graph",
	"Graph of_",
	"_Factory",
	"new_",
	"_add node_",
	"_add edge from_to_",
	"_nodes"
Body


/* Define a Graph type.  A Graph has a set of nodes, a map from each node
   to a set of successors, and a map from each node to a set of predecessors.
   The second map is redundant, but must contain the inverse of the first map.
   Also define Graph Factory for constructing graphs.
*/

nodes ::= lookup "nodes";
successors ::= lookup "successors";
predecessors ::= lookup "predecessors";


"Graph" is explicit subtype of Object with
	nodes -> set,
	successors -> map from any to set,
	predecessors -> map from any to set;

Method "_nodes" is [g : Graph |
	g -> nodes;
];

Restriction "_nodes" is [gt : Graph type |
	gt -> nodes;
];


Rule [g : Graph |
	n ::= g-> nodes;
	s ::= g-> successors;
	p ::= g-> predecessors;

	s keys = n
	& p keys = n
	& n as tuple all [k : any |
		s[k] <= n
		& p[k] <= n
		& s[k] as tuple all [k2 : any | p[k2] includes k;]
		& p[k] as tuple all [k2 : any | s[k2] includes k;];
	];
];

/* Also define a type-specializing method... */

Method "Graph of_" is [nodeType : type |
	Graph altered with <
			<nodes, set of nodeType>,
			<successors, map from nodeType to set of nodeType>,
			<predecessors, map from nodeType to set of nodeType>>;
];

Restriction "Graph of_" is [ntt : meta |
	/* We can't be more specific, but we shouldn't need to be. */
	Graph type;
];



/* Define the type family Graph Factory. */

Forward "_Factory" for [Graph type]->Factory type;

Method "_Factory" is [graphType : Graph type |
	gft ::= Factory altered with <
			<resultType, []->graphType>,
			<nodes, & : set>,
			<successors, & : map from any to set>>;
	cast gft into [ft : Factory type | ft;];
] : Factory type;

Restriction "_Factory" is [gtt : Graph type type |
	/* This is not a recursive invocation, as it only applies after
	   the method definition has completed.  */
	(gtt instance Factory) type;
];

Method "new_" is [gft : Graph Factory type |
	graphType ::= gft -> resultType result;
	nodeType ::= graphType -> nodes content type;
	nodesVar : set := {};
	succVar : map from any to set := [->];
	graphTypeThunk ::= stub block taking <>
		and applying name of block invoker
		to [t : tuple | Halt;]
		and argument tuple returning graphType;
	gtt ::= cast graphTypeThunk into [gtt2 : []->Graph | gtt2;];
	gft new with <
		<resultType, gtt>,
		<nodes, &nodesVar>,
		<successors, &succVar>
	>;
];

Restriction "new_" is [gftt : Graph Factory type type |
	gftt instance;
];

Method "_add node_" is [gf : Graph Factory, node : any |
	*gf -> nodes := *gf -> nodes with node;
	* gf -> successors [node] := {};
] : void;

Restriction "_add node_" is [gft : Graph Factory type, nt : type |
	if not nt <= gft -> resultType result -> nodes content type then [
		Fail parse "new node to conform to graph's node type";];
	void;
];


Method "_add edge from_to_" is [gf : Graph Factory, source : any, destination : any |
	Assert *gf -> nodes includes source;
	Assert *gf -> nodes includes destination;
	s ::= gf -> successors;
	*s := *s[source -> *s[source] with destination];
] : void;

Restriction "_add edge from_to_" is [gft : Graph Factory type, srcT : type, destT : type |
	if not srcT <= gft -> resultType result -> nodes content type then [
		Fail parse "source node to conform to graph's node type";];
	if not destT <= gft -> resultType result -> nodes content type then [
		Fail parse "destination node to conform to graph's node type";];
	void;
];


Method "_result" is [gf : Graph Factory |
	preds : map from any to set := [->];
	*gf -> nodes do [n : any |
		preds := preds [n -> {}];
	];
	*gf -> successors do [src : any, dests : set |
		dests do [dest : any |
			*&preds [dest] := preds[dest] with src;
		];
	];
	Graph new with <
		<nodes, *gf->nodes>,
		<successors, *gf->successors>,
		<predecessors, preds>
	>;
] : Graph;

Restriction "_result" is [factoryType : Graph Factory type |
	factoryType -> resultType result;
] : Graph type;

