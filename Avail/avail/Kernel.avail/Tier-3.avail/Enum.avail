/**
 * .../Tier-3/Enum.avail
 * Copyright Â© 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Enum"
Extends
Uses
	"Tier-2"
Names
	"_instance",
	"_unsafe instances",
	"_unsafe instance"
Body



/* This method was defined earlier, but we couldn't add the restriction until
   now. */
Restriction "_instances" is [eT : enum type |
	cast eT into [uuT : enum |
		unionOfMembershipTypes : set type := terminates;
		anyTypes : boolean := false;
		anyNonTypes : boolean := false;
		commonElementType : type := terminates;
		uuT instances do [weakMembershipType : any |
			membershipType ::= cast weakMembershipType into [t : enum | t;];
			membershipType instances do [member : any |
				cast member into [memberAsType : type |
					commonElementType := type union of commonElementType and memberAsType;
					anyTypes := true;]
				otherwise [
					anyNonTypes := true;];];
			unionOfMembershipTypes := type union of unionOfMembershipTypes
				and membershipType instances type;];
		if anyTypes then [
			if anyNonTypes then [
				set;]
			else [
				set of (commonElementType type);];]
		else [
			if anyNonTypes then [
				unionOfMembershipTypes;]
			else [
				{} type;];];
	]
	otherwise [set;];
] : set type;


/*
P29 ::= [u : enum | Primitive 29; ] :set;
A ::= any type;
B ::= tuple type;
C ::= new atom "C";
X ::= type union of (A type) and (B type);
Y ::= C type;
Print "X = " then X as basic string;
Print "Y = " then Y as basic string;
Print "X instances = " then P29(X) as basic string;
Print "Y instances = " then P29(Y) as basic string;
B : boolean := true;
Print "(X or Y) instances = " then P29(if B then [X;] else [Y;]) as basic string;
Print "_instances returns (X) : " then ([X instances;] type result as basic string);
Print "_instances returns (Y) : " then ([Y instances;] type result as basic string);
Print "_instances returns (X or Y) : " then ([(if B then [X;] else [Y;]) instances;] type result as basic string);
Print "_instances returns (X) : " then ([X instances;] compiledCode as basic string);
Print "_instances returns (Y) : " then ([Y instances;] compiledCode as basic string);
Print "_instances returns (X or Y) : " then ([(if B then [X;] else [Y;]) instances;] compiledCode as basic string);
Print X instances as basic string;
Print Y instances as basic string;
Print (if B then [X;] else [Y;]) instances as basic string;
*/




Method "_instance" is [e : enum |
	instances ::= e instances;
	if ||instances|| not = 1 then [Crash "Too many elements in union";];
	instances as tuple [1];
] : any;

Restriction "_instance" is [eT : meta |
	if eT = enum then [
		any;
	] else [
		union : enum := terminates;
		cast eT into [uuT : enum |
			uuT instances do [weakMembershipType : any |
				membershipType ::= cast weakMembershipType into [t : enum | t;];
				union := type union of union and membershipType;];
			union;];
	];
] : type;


Method "_unsafe instances" is [t : type |
	cast t into [e : enum |
		e instances;];
] : set;


Method "_unsafe instance" is [t : type |
	cast t into [e : enum |
		e instance;];
] : any;

