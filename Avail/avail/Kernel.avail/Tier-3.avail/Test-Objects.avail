/**
 * .../Tier-3/Test-Objects.avail
 * Copyright Â© 1993-2013, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Test-Objects"
Extends
Uses
	"Tier-2",
	"Object"
Names
	"_name"
Body



/* Test objects. */

x ::= lookup "x";
y ::= lookup "y";
si ::= set of integer;


p : [x->integer][y->set of integer] as objectType;
p := Object new with <<x,1>,<y,{5,6,7}>>;


/* Now do the fruit example... */

ripeness ::= lookup "ripeness";
shade ::= lookup "shade";

"Fruit" is implicit subtype of Object with ripeness->integer;

"Apple" is implicit subtype of Fruit with shade->any;

Fruit has fields <"ripeness">;
Apple has fields <"shade">;


Method "_name" is [f : Fruit |
	"Fruit"
] : string;

Method "_name" is [a : Apple |
	"Apple"
] : string;

aFruit ::= Fruit new with <<ripeness, 3>>;
anApple ::= Apple new with <<ripeness, 123>,<shade, "green">>;

Assert aFruit ripeness = 3;
Assert anApple ripeness = 123;
Assert anApple shade = "green";

str ::= "The "
	then anApple name
	then "'s ripeness is "
	then anApple ripeness decimal
	then " or in hex, "
	then anApple ripeness hex;

Assert str = "The Apple's ripeness is 123 or in hex, 7B";

Assert Apple <= Fruit;

sameApple ::= anApple altered with <>;

Assert sameApple = anApple;

newApple ::= anApple altered with <<ripeness, 456>>;

Assert newApple ripeness = 456 & newApple shade = "green" & newApple type <= Apple;

ripeApple ::= anApple altered with <<ripeness, 789>, <shade, "red">>;

Assert ripeApple ripeness = 789 & ripeApple shade = "red" & ripeApple type <= Apple;

Print newApple as basic string then "\n";
Print newApple type names as basic string then "\n";
Print ripeApple as basic string then "\n";
Print ripeApple type names as basic string then "\n";

"Pear" is explicit subtype of Fruit;

"PearApple" is implicit subtype of Pear, Apple;

Print Pear names as basic string then "\n";
Print PearApple names as basic string then "\n";
Print (type intersection of Pear and Apple) names as basic string then "\n";
Print (type union of Pear and Apple) names as basic string then "\n";
Print "Fruit, Apple, Pear, PearApple, intersect(Pear,Apple), Pear+ripeness:byte\n";
Print Fruit as basic string then "\n";
Print Apple as basic string then "\n";
Print Pear as basic string then "\n";
Print PearApple as basic string then "\n";
Print (type intersection of Pear and Apple) as basic string then "\n";
Print (Pear altered with <<ripeness, byte>>) as basic string then "\n";