/**
 * .../Tier-3/Exception.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Exception"
Extends
Uses
	"Tier-2",
	"Object",
	"Enum"
Names
	"Exception",
	"catch«_‡,»in_",
	"_with_",
	"Raise_",
	"result"
Body


/*
 * Exception support.  The exception model is kept simple by only supporting
 * terminating exceptions.  This means that when an exception is thrown via
 * Raise_, the handler will be invoked in such a way that the Raise_ will not
 * return.  It's multi-threaded (continuation chains hold all exception
 * information).
 */


result ::= lookup "result";

_exception ::= Special Object 24;

Method "Private Exception" is [ _exception ];

"Exception" is explicit subtype of Private Exception with
	result->any;


Method "_result" is [ex : Exception |
	ex -> result
];

Restriction "_result" is [exType : Exception type |
	exType -> result
];



Method "_with_" is [et : Exception type, res : any |
	et new with <<result, res>>
] : Exception;

Restriction "_with_" is [ett : Exception type type, resT : type |
	if not (resT <= ett instance -> result) then [
		Fail parse "exception argument to conform"];
	ett instance
];


/* Helper primitive... */

Method "_evaluate with handler_" is [
		body : []->void,
		handler : [terminates]->void |

	/* Primitive 200 is a special primitive.  When the Raise_ primitive is
	   invoked, it scans the stack for a continuation whose function's
	   code is primitive 200, and it invokes this continuation's second
	   argument, the handler block, with the argument passed to Raise_.
	   Aside from that, primitive 200 always fails, so the backup code
	   should just invoke the body. */
	Primitive 200 (failureCode : 0 type);
	body();
] : void;

Restriction "_evaluate with handler_" is [
		bt : functionType,
		ht : functionType |
	/* We require the exception handler to accept some subtype of
	   Exception.  Only some handlers are applicable, therefore, based
	   on the Exception subtype, so a dynamic check determines which
	   handlers to skip over.  */
	if not ht [1] <= Exception then [
		Fail parse "handler capable of accepting an exception"];
	type union of bt result and ht result
];


Method "catch_in_" is [handler : [terminates]->void, body : []->void |
	body evaluate with handler handler;
];

Restriction "catch_in_" is [ht : functionType, bt : functionType |
	/* We require the exception handler to accept some subtype of
	   Exception.  Only some handlers are applicable, therefore, based
	   on the Exception subtype, so a dynamic check determines which
	   handlers to skip over.  */
	if not ht [1] <= Exception then [
		Fail parse "handler capable of accepting an exception"];
	type union of ht result and bt result
];



/* Helper method... */

Forward "handleTuple_do_" for [tuple of [terminates]->void, []->void]->void;
Forward "handleTuple_do_" for [tuple of [terminates]->any, []->any]->any;

Method "handleTuple_do_" is [
		handlers : tuple of [terminates]->void,
		body : []->void |
	/* Treat the last one as innermost. */
	if handlers = <> then
		body
	else [
		[
			handleTuple handlers[2..||handlers||] do body;
		] evaluate with handler handlers[1];
	];
] : void;

Method "handleTuple_do_" is [
		handlers : tuple of [terminates]->any,
		body : []->any |
	/* Treat the last one as innermost.  This is an override for the case
	   where the body and all handlers produce a result. */
	if handlers = <> then
		body
	else [
		[
			handleTuple handlers[2..||handlers||] do body
		] evaluate with handler handlers[1]
	]
] : any;


/**
 * Attach multiple handlers simultaneously.  Treat the last handler as the
 * innermost one.
 */
Method "catch«_‡,»in_" is [
		handlers : tuple of [terminates]->void,
		body : []->void |
	handleTuple handlers do body;
] : void;

Restriction "catch«_‡,»in_" is [handlersT : tupleType, bodyT : functionType |
	/* We require each exception handler to accept some subtype of
	   Exception.  Only some handlers are applicable, therefore, based
	   on the Exception subtype, so a dynamic check determines which
	   handlers to skip over.  */
	union ::= type union of handlersT default type and
		union of types in handlersT leading types;
	cast union into [ut : functionType |
		if not ut[1] <= Exception then [
			Fail parse "handler to accept an exception"];
	] otherwise [
		Fail parse "All the handler block types must be known statically."];
	merge : type := bodyT result;
	merge := type union of bodyT result and
		cast handlersT default type into [handlerT : functionType |
			handlerT
		] otherwise [
			void
		];
	handlersT leading types do [t : type |
		merge := type union of merge and
			cast t into [handlerT : functionType |
				handlerT
			] otherwise [
				void
			];
	];
	merge
];


Method "Raise_" is [exception : Exception |
	/* This primitive scans the stack for frames that are failed invocations
	   of primitive 200 (which always fails).  After finding one whose second
	   argument (a handler block of one argument) will accept the given
	   exception object, pop the stack to leave the primitive 200 method on
	   the top, and invoke the handler with the exception object. */
	Primitive 201 (failureCode : natural number);
	Crash "No suitable handler was found for the exception"
] : terminates;

