/**
 * .../Tier-3/Exception.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Exception"
Extends
Uses
	"Tier-2",
	"Object",
	"Enum"
Names
	"Exception",
	"catch«_‡,»in_",
	"_with_",
	"Raise_",
	"result"
Body


/*
 * Exception support.  The exception model is kept simple by only supporting
 * terminating exceptions.  This means that when an exception is thrown via
 * Raise_, the handler will be invoked in such a way that the Raise_ will not
 * return.  It's multi-threaded (continuation chains hold all exception
 * information).
 */


result ::= lookup "result";

_exception ::= Special Object 24;

Method "Private Exception" is [ _exception ];

"Exception" is explicit subtype of Private Exception with
	result->any;


Method "_result" is [ex : Exception |
	ex -> result
];

Restriction "_result" is [exType : Exception type |
	exType -> result
];



Method "_with_" is [et : Exception type, res : any |
	et new with <<result, res>>
] : Exception;

Restriction "_with_" is [ett : Exception type type, resT : type |
	if not (resT <= ett instance -> result) then [
		Fail parse "exception argument to conform"];
	ett instance
];

Method "run_and_" is [body : []->void, unwind : []->void |
	body();
	unwind();
] : void;

Method "run_and_" is [body : []->any, unwind : []->void |
	result ::= body();
	unwind();
	result
] : any;

Restriction "run_and_" is
[
	body : functionType,
	unwind : functionType
|
	body result
];

Method "do_handleTuple_ensure_" is
[
	body : []->void,
	handlers : tuple [1..INF) of [terminates]->void,
	ensure : tuple [0..1] of []->void
|
	Primitive 200 (failureCode : [0..16]);
	run body and if ||ensure|| > 0 then [ensure[1]] else [[]];
] : void;

Restriction "do_handleTuple_ensure_" is
[
	bodyT : functionType,
	handlersT : tupleType,
	ensure : tupleType
|
	/* We require each exception handler to accept some subtype of
	   Exception.  Only some handlers are applicable, therefore, based
	   on the Exception subtype, so a dynamic check determines which
	   handlers to skip over.  */
	union ::= type union of handlersT default type and
		union of types in handlersT leading types;
	cast union into [ut : functionType |
		if not ut[1] <= Exception then [
			Fail parse "handler to accept an exception"];
	] otherwise [
		Fail parse "All the handler block types must be known statically."];
	merge : type := bodyT result;
	merge := type union of bodyT result and
		cast handlersT default type into [handlerT : functionType |
			handlerT
		] otherwise [
			void
		];
	handlersT leading types do [t : type |
		merge := type union of merge and
			cast t into [handlerT : functionType |
				handlerT
			] otherwise [
				void
			];
	];
	merge
];

Method "catch«_‡,»in_" is
[
	handlers : tuple [1..INF) of [terminates]->void,
	body : []->void
|
	do body handleTuple handlers ensure <>;
] : void;

Restriction "catch«_‡,»in_" is [handlersT : tupleType, bodyT : functionType |
	/* We require each exception handler to accept some subtype of
	   Exception.  Only some handlers are applicable, therefore, based
	   on the Exception subtype, so a dynamic check determines which
	   handlers to skip over.  */
	union ::= type union of handlersT default type and
		union of types in handlersT leading types;
	cast union into [ut : functionType |
		if not ut[1] <= Exception then [
			Fail parse "handler to accept an exception"];
	] otherwise [
		Fail parse "All the handler block types must be known statically."];
	merge : type := bodyT result;
	merge := type union of bodyT result and
		cast handlersT default type into [handlerT : functionType |
			handlerT
		] otherwise [
			void
		];
	handlersT leading types do [t : type |
		merge := type union of merge and
			cast t into [handlerT : functionType |
				handlerT
			] otherwise [
				void
			];
	];
	merge
];


Method "Raise_" is [exception : Private Exception |
	/* This primitive scans the stack for frames that are failed invocations
	   of primitive 200 (which always fails).  After finding one whose second
	   argument (a handler block of one argument) will accept the given
	   exception object, pop the stack to leave the primitive 200 method on
	   the top, and invoke the handler with the exception object. */
	Primitive 201 (failureCode : Private Exception);
	Crash "No suitable handler was found for the exception"
] : terminates;

