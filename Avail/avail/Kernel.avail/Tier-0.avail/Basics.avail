/**
 * .../Tier-0/Tier-0.avail
 * Copyright (c) 2010, Mark van Gulik.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Basics"
Versions "dev"
Extends
	"Pragmas" ("dev") = ("Method_is_")
Uses
	"Pragmas"
Names
	"any", "atom",
	"boolean",
	"character", "character code points", "function", "functionType",
	"compiledCode", "container", "containerType", "continuation",
	"continuationType",
	"double",
	"extended integer",
	"falseType", "float",
	"integer", "integerType",
	"mapType", "meta",
	"number",
	"process",
	"set", "setType", "string",
	"terminates", "terminatesType", "trueType", "tuple",
	"tupleType", "type",
	"enum",
	"void",
	"whole number", "natural number",

	"parseNode",
	"markerNode",
	"expressionNode",
	"assignmentNode",
	"blockNode",
	"literalNode",
	"referenceNode",
	"sendNode",
	"superCastNode",
	"tupleNode",
	"variableUseNode",
	"declarationNode",
	"argumentNode",
	"labelNode",
	"localVariableNode",
	"localConstantNode",
	"moduleVariableNode",
	"moduleConstantNode",

	"true", "false",

	"Failed", "Crash_", "Print_", "Discard_",
	"Halt", "_can't have_", "_=_", "_<=_",

	"Assert_",

	"_as basic string"
Body

/* Define the private module variables.  These are here simply to allow the
   types to be strengthened by the 0-ary method definitions below them. */


privateAll                         ::= Special Object 1;
privateBoolean                     ::= Special Object 2;
privateCharacter                   ::= Special Object 3;
privateFunction                    ::= Special Object 4;
privateFunctionType                ::= Special Object 5;
privateCompiledCode                ::= Special Object 6;
privateContainer                   ::= Special Object 7;
privateContainerType               ::= Special Object 8;
privateContinuation                ::= Special Object 9;
privateContinuationType            ::= Special Object 10;
privateAtom                        ::= Special Object 11;
privateDouble                      ::= Special Object 12;
privateExtendedInteger             ::= Special Object 13;
privateFalseType                   ::= Special Object 14;
privateFloat                       ::= Special Object 15;
privateNumber                      ::= Special Object 16;
privateInteger                     ::= Special Object 17;
privateIntegerType                 ::= Special Object 18;
privateMapType                     ::= Special Object 19;
privateMeta                        ::= Special Object 20;
privateEnum                        ::= Special Object 21;
privateProcess                     ::= Special Object 25;
privateSet                         ::= Special Object 26;
privateSetType                     ::= Special Object 27;
privateString                      ::= Special Object 28;
privateTerminates                  ::= Special Object 29;
privateTerminatesType              ::= Special Object 30;
privateTrueType                    ::= Special Object 31;
privateTuple                       ::= Special Object 32;
privateTupleType                   ::= Special Object 33;
privateType                        ::= Special Object 34;
privateVoid                        ::= Special Object 35;

privateWholeNumber                 ::= Special Object 36;
privateNaturalNumber               ::= Special Object 37;
privateCharacterCodePoints         ::= Special Object 38;

privateParseNode                   ::= Special Object 50;
privateMarkerNode                  ::= Special Object 51;
privateExpressionNode              ::= Special Object 52;
privateAssignmentNode              ::= Special Object 53;
privateBlockNode                   ::= Special Object 54;
privateLiteralNode                 ::= Special Object 55;
privateReferenceNode               ::= Special Object 56;
privateSendNode                    ::= Special Object 57;
privateSuperCastNode               ::= Special Object 58;
privateTupleNode                   ::= Special Object 59;
privateVariableUseNode             ::= Special Object 60;
privateDeclarationNode             ::= Special Object 61;
privateArgumentNode                ::= Special Object 62;
privateLabelNode                   ::= Special Object 63;
privateLocalVariableNode           ::= Special Object 64;
privateLocalConstantNode           ::= Special Object 65;
privateModuleVariableNode          ::= Special Object 66;
privateModuleConstantNode          ::= Special Object 67;

privateTrue                        ::= Special Object 70;
privateFalse                       ::= Special Object 71;


/* First define all the primitive types... */
Method "any"                    is [privateAll;];
Method "atom"                   is [privateAtom;];
Method "boolean"                is [privateBoolean;];
Method "character"              is [privateCharacter;];
Method "function"               is [privateFunction;];
Method "compiledCode"           is [privateCompiledCode;];
Method "container"              is [privateContainer;];
Method "continuation"           is [privateContinuation;];
Method "double"                 is [privateDouble;];
Method "extended integer"       is [privateExtendedInteger;];
Method "falseType"              is [privateFalseType;];
Method "float"                  is [privateFloat;];
Method "integer"                is [privateInteger;];
Method "number"                 is [privateNumber;];
Method "process"                is [privateProcess;];
Method "set"                    is [privateSet;];
Method "string"                 is [privateString;];
Method "terminates"             is [privateTerminates;];
Method "trueType"               is [privateTrueType;];
Method "tuple"                  is [privateTuple;];
Method "void"                   is [privateVoid;];

Method "whole number"           is [privateWholeNumber;];
Method "natural number"         is [privateNaturalNumber;];
Method "character code points"  is [privateCharacterCodePoints;];

/* And the meta-types... */
Method "integerType"            is [privateIntegerType;];
Method "tupleType"              is [privateTupleType;];
Method "setType"                is [privateSetType;];
Method "mapType"                is [privateMapType;];
Method "functionType"            is [privateFunctionType;];
Method "containerType"          is [privateContainerType;];
Method "continuationType"       is [privateContinuationType;];
Method "terminatesType"         is [privateTerminatesType;];
Method "type"                   is [privateType;];
Method "enum"                   is [privateEnum;];

/* And the meta-meta-types... */
Method "meta"                   is [privateMeta;];


/* Parse node types... */
Method "parseNode"              is [privateParseNode;];
Method "markerNode"             is [privateMarkerNode;];
Method "expressionNode"         is [privateExpressionNode;];
Method "assignmentNode"         is [privateAssignmentNode;];
Method "blockNode"              is [privateBlockNode;];
Method "literalNode"            is [privateLiteralNode;];
Method "referenceNode"          is [privateReferenceNode;];
Method "sendNode"               is [privateSendNode;];
Method "superCastNode"          is [privateSuperCastNode;];
Method "tupleNode"              is [privateTupleNode;];
Method "variableUseNode"        is [privateVariableUseNode;];
Method "declarationNode"        is [privateDeclarationNode;];
Method "argumentNode"           is [privateArgumentNode;];
Method "labelNode"              is [privateLabelNode;];
Method "localVariableNode"      is [privateLocalVariableNode;];
Method "localConstantNode"      is [privateLocalConstantNode;];
Method "moduleVariableNode"     is [privateModuleVariableNode;];
Method "moduleConstantNode"     is [privateModuleConstantNode;];


/* Now the intrinsic constants... */
Method "true"                   is [privateTrue;];
Method "false"                  is [privateFalse;];


/* Totally raw bootstrap - deal with system failures. */

Method "Crash_" is [finalClue : any |
	Primitive 256;
	
	/*
	 * Special case - primitive 256 does not require failure code.  If it did,
	 * we could never build the primitive methods, because there is no direct
	 * language support other than primitives for bootstrapping the ability to
	 * terminate (by looping, killing a process, raising an exception, or
	 * resuming a continuation - these are all effectively implemented via
	 * primitives).
	 */
] : terminates;


Method "Failed" is [
	Crash "An Avail primitive has failed";
] : terminates;

Method "Assertion Failed:_" is [message : string |
	Primitive 360;
] : terminates;

tupleOfSetOfString ::= Special Object 74;
setOfString ::= Special Object 75;

/* Add support for defining precedence rules.  For example,
	"{op1,op2...} can't have <{op3,op4...},{op5,op6,...},...>"
   means that op1 and op2 aren't weakly binding enough to allow op3 or op4
   as the top-level operation for the first argument, nor either op5 or op6 for
   the second argument, etc.  To state, for example, that addition is to be
   parsed left-recursive, we say:  {"_+_"} can't have <{} , {"_+_"}>.   */

Method "_can't have_" is [names : setOfString, except : tupleOfSetOfString |
	Primitive 255 (failureCode : natural number);
	Failed;
] : void;

Method "Print_" is [something : string |
	Primitive 258;
] : void;


/* Explicitly disregard a return result */

Method "Discard_" is [somethingToIgnore : any |
] : void;


/* Pause the VM for debugging. */

Method "Halt" is [
	Primitive 257;
] : void;


/* General purpose primitive... */

Method "_=_" is [a : any, b : any |
	Primitive 60;
] : boolean;

/* The subtype relation... */
Method "_<=_" is [a : type, b : type |
	Primitive 33;
] : boolean;


/* Runtime assertions... */

Method "Assert_" is [b : boolean |
] : void;

Method "Assert_" is [b : falseType |
	Assertion Failed : "A runtime assertion has failed";
] : terminates;

Method "Assert_:_" is [b : boolean, message : string |
	/* Do nothing - the assertion is true. */
] : void;

Method "Assert_:_" is [b : falseType, message : string |
	Assertion Failed : message;
] : terminates;

Method "_as basic string" is [o : any |
	Primitive 259;
] : string;

Method "Print_" is [something : any |
	Print something as basic string;
] : void;
