/**
 * .../Tier-1/Declaration.avail
 * Copyright © 1993-2013, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Declaration"
Extends
Uses
	"Pragmas",
	"Basics"
Names
	"Restriction_is_",
	"Forward_for_",
	"Abstract method_for_",
	"Fail parse_",
	"_type",
	"(_)",
	"lookup_",
	"Assert_",
	"falseType", "trueType"
Body

/* This module defines declaration methods. */


Method "⊶[...]->_" is [result : type |
	Primitive 39;
] : functionType;



/**
 * Add a restriction function for a particular message.  When compiling a call
 * site for the message, the static types of the arguments are collected and
 * passed to all restriction functions that will accept them.  Each function
 * can reject the parse of the message invocation with a diagnostic message or
 * return a type to strengthen the return result that the methods themselves
 * provide.  The intersection is computed at call site compile time ("link
 * time"), and the return result's type is checked at run time when the call
 * completes.
 */
Method "Restriction_is_" is [
		name : string,
		restrictionBlock : ⊶[...]-> type |
	Primitive 248 (failureCode : natural number);
	Failed
] : void;


Method "Forward_for_" is [
		name : string,
		blockType : functionType |
	/* Declare method without body (for recursion / mutual recursion).  Must be
	   followed in same module by a legitimate definition. */
	Primitive 252 (failureCode : natural number);
	Failed
] : void;


Method "Abstract method_for_" is [
		name : string,
		bodyType : functionType |
	Primitive 251 (failureCode : natural number);
	Failed
] : void;


/**
 * Indicate that a parse has failed for some reason.
 */
Method "Fail parse_" is [
		problem : string |
	Primitive 352;
] : terminates;


Method "_type" is [x : any |
	Primitive 30;
] :  type;


Restriction "_type" is [xt : type |
	Primitive 30;
] : type;  /* Actually type's type, but it makes zero difference here */


/**
 * Define simple parentheses.  This is not part of the built-in syntax of Avail
 * because I want to emphasize the fact that things like function application
 * and array subscripting can be added dynamically to the syntax, and these
 * similar operations "_(_)" look so much like simple parentheses "(_)" that
 * doing them two different ways would be a shameful inconsistency.  Besides,
 * this is an excellent example of parametric result typing.
 */
Method "(_)" is [arg : any |
	arg
];

Restriction "(_)" is [argType : type |
	argType
];


/**
 * Method name lookup operation.  Looks up a given string in the current
 * module's namespace.
 */
Method "lookup_" is [t : string |
	Primitive 245 (failureCode : natural number);
	Failed
] : atom;

Method "falseType" is [ false type ] : false type type;
Method "trueType" is [ true type ] : true type type;


/* Runtime assertions... */

Method "Assert_" is [b : boolean |
] : void;

Method "Assert_" is [b : falseType |
	Crash "A runtime assertion has failed"
] : terminates;

Method "Assert_:_" is [b : boolean, message : string |
	/* Do nothing - the assertion is true. */
] : void;

Method "Assert_:_" is [b : falseType, message : string |
	Crash message
] : terminates;

