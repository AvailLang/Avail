/**
 * .../Tier-1/Integer.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Integer"
Extends
Uses
	"Tier-0"
Names
	"range from_inclusive_to_inclusive_",
	"[_.._]", "[_.._)", "(_.._]", "(_.._)",
	"_lower inclusive", "_lower bound",
	"_upper inclusive", "_upper bound",
	"∞", "INF", "_is finite", "_is infinite",
	"byte",
	"_as range"
Body

/* This module defines pre-arithmetic integer operations.  Start with
   definitions of range type operations, starting with some helpers... */


Method "⊶block type taking_and returning_" is [args : tupleOfAnyMeta, ret : type |
	Primitive 34;
] : functionType;

Method "⊶[«_‡,»]->_" is [types : tupleOfAnyMeta, result : type |
	⊶block type taking types and returning result;
] : functionType;




Method "_lower bound" is [range : integerType |
	Primitive 8;
] : extended integer;



Method "_upper bound" is [range : integerType |
	Primitive 9;
] : extended integer;



Method "_lower inclusive" is [range : integerType |
	/* The <= is the subtype relation. */
	range lower bound type <= range;
] : boolean;

Method "_upper inclusive" is [range : integerType |
	range upper bound type <= range;   /* The <= is the subtype relation. */
] : boolean;

Method "range from_inclusive_to_inclusive_" is [
		min : extended integer,
		inclusive1 : boolean,
		max : extended integer,
		inclusive2 : boolean |
	Primitive 7;
] : integerType;

Restriction "range from_inclusive_to_inclusive_" is [
		minT : extended integer type,
		inclusive1T : boolean type,
		maxT : extended integer type,
		inclusive2T : boolean type |
	range ::= range
		from minT lower bound
		inclusive minT lower inclusive
		to maxT upper bound
		inclusive maxT upper inclusive;
	range type;
];


Method "[_.._]" is [min : extended integer, max : extended integer |
	range from min inclusive true to max inclusive true;
] : integerType;

Restriction "[_.._]" is [
		minT : extended integer type,
		maxT : extended integer type |
	range ::= range
		from minT lower bound
		inclusive true
		to maxT upper bound
		inclusive true;
	range type;
];

Method "[_.._)" is [min : extended integer, max : extended integer |
	range from min inclusive true to max inclusive false;
] : integerType;

Restriction "[_.._)" is [
		minT : extended integer type,
		maxT : extended integer type |
	range ::= range
		from minT lower bound
		inclusive true
		to maxT upper bound
		inclusive false;
	range type;
];

Method "(_.._]" is [min : extended integer, max : extended integer |
	range from min inclusive false to max inclusive true;
] : integerType;

Restriction "(_.._]" is [
		minT : extended integer type,
		maxT : extended integer type |
	range ::= range
		from minT lower bound
		inclusive false
		to maxT upper bound
		inclusive true;
	range type;
];

Method "(_.._)" is [min : extended integer, max : extended integer |
	range from min inclusive false to max inclusive false;
] : integerType;

Restriction "(_.._)" is [
		minT : extended integer type,
		maxT : extended integer type |
	range ::= range
		from minT lower bound
		inclusive false
		to maxT upper bound
		inclusive false;
	range type;
];




/* Define public access to infinity ... */

privateInfinity ::= extended integer upper bound;

Method "∞" is [
	privateInfinity;
] : [privateInfinity..privateInfinity];

Method "INF" is [
	privateInfinity;
] : [privateInfinity..privateInfinity];


Method "_is finite" is [x : extended integer |
	false;
] : boolean;

Method "_is finite" is [x : integer |
	true;
] : trueType;


Method "_is infinite" is [x : extended integer |
	true;
] : boolean;

Method "_is infinite" is [x : integer |
	false;
] : falseType;


Method "byte" is [
	[0..255];
] : integerType;

/**
 * Convert the argument into an integer range.  It may already be a simple range
 * or it may be something more specific, such as a union type consisting
 * entirely of extended integers.  If the argument is terminates, answer
 * terminates, which isn't technically a mere range but is needed for the
 * degenerate cases.
 */
Method "_as range" is [inputRange : integerType |
	range
		from inputRange lower bound
		inclusive inputRange lower inclusive
		to inputRange upper bound
		inclusive inputRange upper inclusive;
];
