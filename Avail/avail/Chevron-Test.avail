/**
 * Chevron-Test.avail
 * Copyright (c) 2010, Mark van Gulik.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Chevron-Test"
Extends
Uses
	"Kernel"
Names
Body

Method "Start«_‡@»End" is [x : tuple |
	x;
];

Assert Start End = <>;
Assert Start 1 End = <1>;
Assert Start 1 @ 2 End = <1, 2>;
Assert Start 1 @ 2 @ 3 End = <1, 2, 3>;


/* Test no arguments. */
Method "«Spam»" is [x : tuple of tuple like <> |
	||x||;
];

Assert Spam = 1;
Assert Spam Spam Spam Spam = 4;


/* Test argument to the right of the double-dagger. */
Method "«!‡_»" is [x : tuple of (tuple [0..1] like <> default integer) |
	x;
];

Assert !10!20!30! = <<10>,<20>,<30>,<>>;
Assert !1!1!1!1!1! = <<1>,<1>,<1>,<1>,<1>,<>>;
Assert !0! = <<0>,<>>;
Assert ! = <<>>;


/* Test nullable content (chevron group occurrence with nothing inside). */
Method "««cat»«dog»»" is [
		t : tuple of tuple [2..2] of tuple [0..1] of tuple [0..0] of any |
	t collect [y : tuple [2..2] of tuple |
		if ||y[1]|| = 1 then [$"c";] else [$"d";];
	];
] : string
requires [xT : tupleType |
	limit ::= cast xT sizes upper bound into [lim : [0..INF) | lim;];
	(1 to limit) all [
			subscript : natural number |
		cast xT[subscript] into [pairT : tupleType |
			catCount ::= cast pairT[1] into [catT : tupleType |
				catT sizes upper bound;];
			dogCount ::= cast pairT[2] into [dogT : tupleType |
				dogT sizes upper bound;];
			catCount + dogCount = 1;
		];
	];
];

Assert cat = "c";
Assert dog = "d";
Assert cat cat = "cc";
Assert cat dog = "cd";
Assert dog cat = "dc";
Assert dog dog = "dd";
Assert cat cat cat = "ccc"; 
Assert cat cat dog = "ccd";
Assert cat dog cat = "cdc"; 
Assert cat dog dog = "cdd";
Assert dog cat cat = "dcc"; 
Assert dog cat dog = "dcd";
Assert dog dog cat = "ddc"; 
Assert dog dog dog = "ddd";
