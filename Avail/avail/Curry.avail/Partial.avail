/**
 * Curry/Curry.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Partial"
Extends
Uses
	"Kernel"
Names
	"_taking arguments tupled",
	"_curry_",
	"_curried"
Body



/* Partial function application... */

Method "_taking arguments tupled" is [f : function |
	/* Convert the function taking N arguments into a function taking one
	 * argument which is a tuple of a suitably strong type.
	 */
	stub block with function type
		[f type arguments type] -> f type result
	invoking
		[argsInOne : tuple | f apply argsInOne;]
] : [...]->void;


Restriction "_taking arguments tupled" is [ft : functionType |
	[ft arguments type]-> (ft result)
];

Print [a : integer, b : integer | a + b] taking arguments tupled (<10, 20>);


/* Partial function application... */

Method "_curry_" is [f : function, firstArg : any |
	/* Perform a partial application of the given block.  That is, apply one
	 * argument to the block, producing a block that requires one less
	 * argument.  This is a common built-in feature in functional languages, so
	 * adding it makes a good test of the sturdiness of Avail's type system.
	 */
	ft ::= f type;
	argTypes ::= 2 to ft argument count collect [i : natural number | ft[i]];
	newBlockType ::= block type taking argTypes and returning ft result;
	stub block with function type newBlockType
		invoking [t : tuple |
			f apply (<firstArg> then t);]
] : function;

Restriction "_curry_" is [ft : functionType, firstArgType : type |
	argumentsType ::= ft arguments type;
	if argumentsType sizes lower bound
			not = argumentsType sizes upper bound then [
		void
	] else [
		if ft argument count = 0 then [
			Fail parse "Cannot curry a nullary function."];
		if not firstArgType <= ft[1] then [
			Fail parse
				"First argument is not applicable to the function to be curried."];
		argTypes ::= 2 to ft argument count collect [i : natural number | ft[i]];
		block type taking argTypes and returning ft result
	]
];


Forward "curried type for argument types_and result_" for [
		tuple of (any type),
		type
	]->functionType;

Method "curried type for argument types_and result_" is [
		argTypes : tuple of (any type),
		result : type |
	cast ||argTypes|| into [n : [1..∞) |
		recursiveResult ::=
			curried type for argument types argTypes[2..n]
			and result result;
		[argTypes[1]] -> recursiveResult
	]
] : functionType;


Forward "_curried" for [function]->function;

Method "_curried" is [f : function |
	/* Convert the function taking N arguments into a function taking the first
	 * argument and returning a function taking the second argument and
	 * returning... the function taking the final argument and returning the
	 * result of evaluating the original function with all the provided
	 * arguments.
	 */
	ft ::= f type;
	argumentCount ::= ft argument count;
	Assert argumentCount > 0;
	tt ::= ft arguments type;
	if argumentCount = 1 then
	[
		f
	]
	else
	[
		argumentTypes ::= 1 to argumentCount collect [n : [1..∞) | tt[n]];
		newType ::= curried type for argument types argumentTypes
			and result (ft result);
		stub block with function type newType
			invoking [argument : any |
				(f curry argument) curried];
	]
];





Forward "_curry of tupled block" for [
		[terminates]->void
	] -> [terminates]->void;

Method "_curry of tupled block" is [f : [terminates]->void |
	/* Given a block that takes a tuple of arguments, convert it to a block
	 * that takes one argument A1, and answers a block that takes one
	 * argument A2,... a block that takes one argument A(n) and answers
	 * the result of calling the original block with the tuple <A1,A2...A(n)>.
	 */
	ft ::= f type;
	Assert ft argument count = 1;
	tt ::= cast ft[1] into [t : tupleType | t];
	innerCount ::= tt sizes lower bound;
	argumentTypes ::= 1 to innerCount collect [n : natural number | ft[n]];
	curriedType ::= curried type for argument types argumentTypes
		result ft result;
	if innerCount = 1 then
	[
		stub block with function type curriedType
		invoking [argsSizeOne : tuple | f apply argsSizeOne;]
	] else [
		Assert innerCount > 1;
		innerType ::= curried type for argument type
			***
		and result 
		stub block with function type
			(curried type for argument types<tt[1]> and result 
		
	
	result ::= cast tt[1] 
	
	ft ::= f type;
	argCount ::= ft argument count;
	argTypes ::= 1 to argCount collect [i : natural number | ft[i]];
	Assert argCount > 0;
	result ::= cast ft[1] into [tt : tupleType |
		size ::= tt sizes lower bound;
		cast size into [s : [2..INF) |
			stub block with function type (curried type for argument types ft)
			inoking [*]
			
			stub block taking <tt[1]>
				and applying name of block invoker
				to [firstAsTuple : tuple |
					inner ::= stub block taking <tuple like tt[2..s]>
						and applying name of block invoker
						to [otherArgs : tuple |
							cast otherArgs[1] into [others : tuple |
								blk apply <firstAsTuple then others>
							]
						]
						and argument tuple returning blk type result;
					cast inner into [in : [terminates]->any |
						in curry of tupled block
					]
				] and argument tuple returning
					curried type for argument types tt[2..s]
					and result blk type result
		] otherwise [
			/* Deal with terminal case of one item in the arg tuple.  This
			   is converted to a block expecting one arg, which is then
			   bundled into a singleton tuple and passed to blk. */
			stub block taking <tt[1]>
			and applying name of block invoker
			to [args : tuple | blk apply <args>]
			and argument tuple returning blk type result
		]
	];
	cast result into [res : [terminates]->void | res]
] : [terminates]->void
returns [blkType : functionType |
	cast blkType[1] into [argType : tupleType |
		if argType = terminates then [
			/* Exact type is unknown, but this is a helper method, so we leave
			   it up to the caller (in this module) to ensure a more specific type is
			   calculated. */
			[terminates]->void
		] else [
			curried type for argument types argType[1..argType sizes lower bound]
			and result blkType result
		]
	]
]
requires [blkType : functionType |
	||blkType|| = 1
		& [
			blkType[1] = terminates
			| [
				cast blkType[1] into [argType : tupleType |
					argType sizes lower bound = argType sizes upper bound
				] otherwise [
					/* Allow 'untyped' form to be used, in which it is known to
					   be a function of one argument, but the argument is typed
					   as something other than a tupleType.  This should still be
					   safe, as we're defining a private second-order method
					   here, which *defines* the type system. */
					true
				]
			]
		]
];


Method "_curried" is [blk : function |
	/* Convert the block taking N arguments into a block taking one argument
	   that returns a block taking one argument that returns... (N levels)... a block
	   that returns the result of applying any these arguments at once to the
	   original block... */
	blkTupled ::= blk taking arguments tupled;
	blkTupled curry of tupled block
] : [terminates]->void
requires [ct : functionType |
	/* Require static knowledge of the block's type, to statically prevent the
	   use of a 0-argument block. */
	cast ct into [ct2 : functionType |
		||ct2|| >= 1
	] otherwise [
		/* Static type of block was inadequate for currying. */
		false
	]
]
returns [ct : functionType |
	cast ct into [ct2 : functionType |
		blkType : type := ct2 result;
		count : integer := ||ct2||;
		Loop [
			cast count into [n : natural number |
				blkType := [ct2[n]]->blkType;
			] : void;
			count := count - 1;
		] until [
			count = 0
		];
		blkType
	]
];

