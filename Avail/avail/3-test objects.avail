/**
 * 3-test objects.avail
 * Copyright (c) 2010, Mark van Gulik.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "3-test objects"
Extends
Uses
	"2-main",
	"3-object"
Names
	"_name"
Body



/* Test objects. */

x ::= lookup "x";
y ::= lookup "y";
si ::= set of integer;


p : [x->integer][y->set of integer] as objectType;
p := Object new with <<x,1>,<y,{5,6,7}>>;


/* Now do the fruit example... */

ripeness ::= lookup "ripeness";
shade ::= lookup "shade";

"Fruit" is implicit subtype of Object with [ripeness->integer];

"Apple" is implicit subtype of Fruit with [shade->all];

Fruit has fields <"ripeness">;
Apple has fields <"shade">;

Method "_name" is [f : Fruit |
	"Fruit";
] : string;

Method "_name" is [a : Apple |
	"Apple";
] : string;

aFruit ::= Fruit new with <<ripeness, 3>>;
anApple ::= Apple new with <<ripeness, 123>,<shade, "green">>;


str ::= "The "
	then anApple name
	then "'s ripeness is "
	then (anApple ripeness) decimal
	then " or in hex, "
	then (anApple ripeness) hex;

Assert str = "The Apple's ripeness is 123 or in hex, 7B";

Assert Apple <= Fruit;

sameApple ::= anApple altered with <>;

Assert sameApple = anApple;

newApple ::= anApple altered with <<ripeness, 456>>;

Assert newApple ripeness = 456 & newApple shade = "green" & newApple type <= Apple;

ripeApple ::= anApple altered with <<ripeness, 789>, <shade, "red">>;

Assert ripeApple ripeness = 789 & ripeApple shade = "red" & ripeApple type <= Apple;