/**
 * Compiler/Parser.avail
 * Copyright (c) 2010, Mark van Gulik.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Parser"
Extends
Uses
	"Kernel",
	"Reflection",
	"Variables",
	"Tokens",
	"ParseNodes",
	"ParseTree"
Names
	"Avail Parser on_",
	"_parse and execute outer statement"
Body


/* This module defines the parsing rules of the metacircular Avail parser.  */

/* First, some field names... */
tokens ::= lookup "tokens";
position ::= lookup "position";
scope ::= lookup "scope";
bestDistance ::= lookup "bestDistance";
expectations ::= lookup "expectations";


"Avail Parser" is explicit subtype of Object with
	[tokens -> tuple of Token]
	[position -> & : natural number]
	[scope -> & : tuple of Declaration Node]
	[bestDistance -> & : whole number]
	[expectations -> & : set [1..INF) of string];


Method "Avail Parser on_" is [toks : tuple of Token |
	pos : natural number := 1;
	scp : tuple of Declaration Node := <>;
	bestDist : whole number := 0;
	exp : set [1..INF) of string;
	Avail Parser new with <
		<tokens, toks>,
		<position, &pos>,
		<scope, &scp>,
		<bestDistance, &bestDist>,
		<expectations, &exp>
	>;
] : Avail Parser;


Forward "_skip_then_" for [
		Avail Parser, Token, []->void]->void;
Forward "_skip_then_" for [
		Avail Parser, tuple of Token, []->void]->void;
Forward "_expected_" for [
		Avail Parser, string]->void;
Forward "primitive_is defined" for [
		[0..65535]]->boolean;

Forward "_parse and evaluate expression then_" for [
		Avail Parser, [terminates]->void]->void;
Forward "_parse assignment then_" for [
		Avail Parser, [Assignment Node]->void]->void;
Forward "_parse block argument then_" for [
		Avail Parser, [Argument Declaration Node]->void]->void;
Forward "_parse block arguments then_" for [
		Avail Parser, [tuple of Argument Declaration Node]->void]->void;
Forward "_parse block then_" for [
		Avail Parser, [Block Node]->void]->void;
Forward "_parse declaration then_" for [
		Avail Parser, [Declaration Node]->void]->void;
Forward "_parse expression then_" for [
		Avail Parser, [Parse Node]->void]->void;
Forward "_parse from_complete_incomplete_arguments so far_then_" for [
		Avail Parser, natural number,
		map from atom to messageBundle,
		map from string to messageBundleTree,
		tuple of Parse Node, [Send Node]->void]->void;
Forward "_parse label then_" for [
		Avail Parser, [Label Node]->void]->void;
Forward "_parse leading argument send after_then_" for [
		Avail Parser, Parse Node, [Parse Node]->void]->void;
Forward "_parse leading keyword send then_" for [
		Avail Parser, [Send Node]->void]->void;
Forward "_parse literal then_" for [
		Avail Parser, [Literal Node]->void]->void;
Forward "_parse optional leading argument send after_then_" for [
		Avail Parser, Parse Node, [Parse Node]->void]->void;
Forward "_parse optional return type after_then_" for [
		Avail Parser, tuple of Parse Node, [type]->void]->void;
Forward "_parse optional super cast after_then_" for [
		Avail Parser, Parse Node, [Parse Node]->void]->void;
Forward "_parse primitive then_" for [
		Avail Parser, [[0..65535]]->void]->void;
Forward "_parse reference then_" for [
		Avail Parser, [Reference Node]->void]->void;
Forward "_parse statement then_" for [
		Avail Parser, [Parse Node]->void]->void;
Forward "_parse statements then_" for [
		Avail Parser, [tuple of Parse Node]->void]->void;
Forward "_parse variable name then_" for [
		Avail Parser, [Token]->void]->void;
Forward "_parse variable use then_" for [
		Avail Parser, [Variable Use Node]->void]->void;


Method "_expected_" is [p : Avail Parser, str : string |
	if *p->position >= *p->bestDistance then [
		if *p->position = *p->bestDistance then [
			/* Alternative error text for the deepest parsing position yet. */
			*p->expectations := clearing *p->expectations with str;
		] else [
			/* New record for how far it parsed before failing. */
			*p->bestDistance := *p->position;
			*p->expectations := {str};
		];
	];
] : void;


Method "_skip_then_" is [p : Avail Parser, t : Token, c : [] -> void |
	token ::= p->tokens [*p->position];
	if token = t then [
		p->position++;
		c();
		p->position--;
	];
];

Method "_skip_then_" is [
		p : Avail Parser,
		token : tuple of Token,
		c : [] -> void |
	startPos ::= *p->position;
	[
		$escape : $[]->void;
		token do [tok : Token |
			if p->tokens [*p->position] = tok then [
				p->position++;
			] else [
				Exit escape;
			];
		];
		/* All the tokens matched.  Try this solution. */
		c();
	]();
	*p->position := startPos;
];



Method "complete messages starting with_" is [str : string |
	Primitive 209 (failureCode : natural number);
	Failed;
] : map from atom to messageBundle;


Method "incomplete messages starting with_" is [str : string |
	Primitive 210 (failureCode : natural number);
	Failed;
] : map from string to messageBundleTree;


Method "primitive_is defined" is [n : [0..65535] |
	Primitive 250 (failureCode : natural number);
	Failed;
] : boolean;


Method "_parse statement then_" is [
		p : Avail Parser,
		c : [Parse Node]->void |
	solutions : tuple of tuple like <
		Parse Node,
		natural number,
		tuple of Declaration Node>;
	solutions := <>;
	capture ::= [pn : Parse Node |
		p skip ";" then [
			solutions := solutions then <<pn, *p->position, *p->scope>>;
		];
	];
	p parse declaration then capture;
	p parse expression then capture;
	p parse assignment then capture;
	if solutions = <> then [
		p expected "any statement";
	] else [
		if ||solutions|| > 1 then [
			p expected "an unambiguous statement";
		] else [
			restorePosition ::= *p->position;
			restoreScope ::= *p->scope;
			*p->position := solutions[1][2];
			*p->scope := solutions[1][3];
			c(solutions[1][1]);
			*p->position := restorePosition;
			*p->scope := restoreScope;
		];
	];
];


Method "_parse label then_" is [
		p : Avail Parser,
		c : [Label Node]->void |
	p skip "$" then [
		p parse variable name then [t : Token |
			p skip ":" then [
				p parse expression then [expr : Parse Node |
					cast evaluate expr into [typeValue : continuationType |
						c(new Label Node variable
							new Label name t type typeValue);
					];
				];
			];
		];
	];
];


Method "_parse declaration then_" is [
		p : Avail Parser,
		c : [Declaration Node]->void |
	declareAndContinue ::= [decl : Declaration Node |
		*p->scope := <decl> then *p->scope;
		c(decl);
		*p->scope := *p->scope [2 .. ||*p->scope||];
	];
	p parse variable name then [name : string |
		p skip ":" then [
			p parse expression then [expr : Parse Node |
				cast evaluate expr into [typeValue : type |
					declareAndContinue(
						new Declaration Node variable
							new Local name name type typeValue);
					p skip ":", "=" then [
						p parse expression then [expr : Parse Node |
							declareAndContinue(
								new Initializing Declaration Node
									variable new Local
										name name
										type typeValue
									expression expr);
						];
					];
				] otherwise [
					p expected "compile-time expression to yield a type";
				];
			];
			p skip ":", "=" then [
				p parse expression then [expr : Parse Node |
					declareAndContinue(
						new Constant Declaration Node
							variable new Local
								name name
								type expr result type
							expression expr);
				];
			];
		];
	];
];


Method "_check block arguments_statements_result_" is [
		p : Avail Parser,
		args : tuple of Argument Declaration Node,
		stmts : tuple of Parse Node,
		result : type |
	||stmts|| > 0 & [
		cast stmts[1] into [stmt : Label Node |
			cast stmt variable variable type into [contType : continuationType |
				blockType ::=
					block type taking (args collect [a : Argument Declaration Node |
						a variable variable type;])
					and returning result;
				contType closureType = blockType;
			];
		] otherwise [true;];
	];
] : boolean;


Method "_parse block then_" is [
		p : Avail Parser,
		c : [Block Node]->void |
	p skip "[" then [
		p parse block arguments then [blkArgs : tuple of Argument Declaration Node |
			p parse primitive then [prim : [0..65535] |
				p parse statements then [stmts : tuple of Parse Node |
					p skip "]" then [
						p parse optional return type after stmts
						then [retType : type |
							if (p check block arguments blkArgs
									statements stmts
									result retType) then [
								blk ::= new Block Node
									arguments blkArgs
									primitive prim
									statements stmts
									return type retType;
								c(blk);
							] else [
								p expected "label type to agree with block type";
							];
						];
					];
				];
			];
		];
	];
];


Method "_parse block arguments then_" is [
		p : Avail Parser,
		c : [tuple of Argument Declaration Node]->void |
	/* Try no arguments (and no separator bar) */
	c(<>);
	tryMore : [tuple of Argument Declaration Node]->void;
	tryMore := [soFar : tuple of Argument Declaration Node |
		p parse block argument then [arg : Argument Declaration Node |
			p skip "|" then [
				c(soFar then <arg>);
			];
			tryMore(soFar then <arg>);
		];
	];
	tryMore(<>);
];


Method "_parse block argument then_" is [
		p : Avail Parser,
		c : [Argument Declaration Node]->void |
	p parse variable name then [name : string |
		p skip ":" then [
			p parse expression then [expr : Parse Node |
				cast evaluate expr into [typeValue : type |
					decl ::= new Argument Declaration Node variable
						new Argument name name type typeValue;
					*p->scope := <decl> then *p->scope;
					c(decl);
					*p->scope := *p->scope [2..||*p->scope||];
				] otherwise [
					p expected "compile-time expression to yield a type";
				];
			];
		];
	];
];


Method "_parse primitive then_" is [
		p : Avail Parser,
		c : [[0..65535]]->void |
	c(0);	/* Try it without a primitive first. */
	p skip "Primitive" then [
		p parse literal then [literalNode : Literal Node |
			cast literalNode value into [num : [0..65535] |
				if primitive num is defined then [
					c(num);
				] else [
					p expected "a supported primitive number";
				];
			] otherwise [
				p expected "a primitive number in the range [0..65535]";
			];
		];
	];
];


Method "_parse statements then_" is [
		p : Avail Parser,
		c : [tuple of Parse Node]->void |
	tryMore : [tuple of Parse Node]->void;
	tryMore := [soFar : tuple of Parse Node |
		c(soFar);
		p parse statement then [stmt : Parse Node |
			tryMore(soFar then <stmt>);
		];
	];
	p parse label then [label : Label Node |
		p skip ";" then [
			tryMore(<label>);
		];
	];
	tryMore(<>);
];


Method "_parse optional return type after_then_" is [
		p : Avail Parser,
		stmts : tuple of Parse Node,
		c : [type]->void |
	impliedType : type := if ||stmts|| = 0 then [
		/* No statements. */
		void;
	] else [
		stmt ::= stmts [||stmts|| max 1];
		cast stmt into [decl : Declaration Node |
			/* Last statement is a declaration. */
			void;
		] otherwise [
			stmt result type;
		];
	];
	/* If no return type is provided, use the last statement's type... */
	c(impliedType);
	p skip ":" then [
		p parse and evaluate expression then [retType : type |
			if impliedType <= retType then [
				c(retType);
			] else [
				p expected "explicit return type to be weaker than last statement's type";
			];
		];
	];
];


Method "_parse expression then_" is [
		p : Avail Parser,
		c : [Parse Node]->void |
	checkForPostfix ::= [expression : Parse Node |
		p parse optional leading argument send after expression then c;
	];
	p parse block then checkForPostfix;
	p parse leading keyword send then checkForPostfix;
	p parse literal then checkForPostfix;
	p parse reference then checkForPostfix;
	p parse variable use then checkForPostfix;
];


Method "_parse variable name then_" is [
		p : Avail Parser,
		continue : [Token]->void |
	token ::= p->tokens [*p->position];
	if #"a" <= code point of token[1] <= #"z" | [#"A" <= code point of token[1] <= #"Z";] then [
		p->position++;
		continue(token);
		p->position--;
	];
];


Method "_parse variable use then_" is [
		p : Avail Parser,
		c : [Variable Use Node]->void |
	p parse variable name then [tok : Token |
		found : boolean := false;
		innerDecl : Declaration Node;
		*p->scope do [decl : Declaration Node |
			if decl variable name = tok then [
				found := true;
				innerDecl := decl;
			];
		];
		if found then [
			c(new Variable Use Node from declaration innerDecl);
		] else [
/*			Crash "Globals are not yet supported"; */
		];
	];
];


Method "_parse literal then_" is [
		p : Avail Parser,
		c : [Literal Node]->void |
	token ::= p->tokens [*p->position];
	p->position++;
	if #"0" <= code point of token[1] <= #"9" then [
		/* Extract an integer literal */
		value ::= 10 r token;
		c(new Literal Node value value);
	] else [
		if token[1] = $"""" then [
			iter ::= token [2..(||token||-1) max 0] as Iterator;
			str : string := "";
			Until [
				iter is at end;
			] loop [
				chr : character := next iter;
				if chr = $"""" then [
					other ::= next iter;
					Assert other = $"""";
				];
				str := str then <chr>;
			];
			c(new Literal Node value str);
		];
	];
	p->position--;
];


Method "_parse assignment then_" is [
		p : Avail Parser,
		c : [Assignment Node]->void |
	p parse variable use then [var : Variable Use Node |
		p skip ":", "=" then [
			p parse expression then [expr : Parse Node |
				if expr result type <= var declaration variable myType then [
					if var declaration type <= Constant Declaration Node then [
						p expected "assignment to be to a non-constant";
					] else [
						c(new Assignment Node
							declaration var declaration
							value expr);
					];
				] else [
					p expected "assignment types to match";
				];
			];
		];
	];
];


Method "_parse reference then_" is [
		p : Avail Parser,
		c : [Reference Node]->void |
	p skip "&" then [
		p parse variable use then [var : Variable Use Node |
			c(new Reference Node declaration (var declaration));
		];
	];
];


Method "_parse and evaluate expression then_" is [
		p : Avail Parser,
		c : [terminates]->void |
	/* This method is kind of special.  We parse an expression outside of all
	   block scopes, make sure it will (statically) produce a value that c will
	   accept, then we evaluate it and pass the result into c.  */

	restoreScope ::= *p->scope;
	*p->scope := <>;
	p parse expression then [expr : Parse Node |
		if expr result type <= c type [1] then [
			c apply <evaluate expr>;
		] else [
			p expected "compile-time expression to yield appropriate type";
		];
	];
	*p->scope := restoreScope;
];


Method "_parse leading keyword send then_" is [
		p : Avail Parser,
		c : [Send Node]->void |
	token ::= p->tokens [*p->position];
	complete ::= complete messages starting with token;
	incomplete ::= incomplete messages starting with token;
	if ||complete|| > 0  |  ||incomplete|| > 0 then [
		p->position++;
		p parse from 2  /*We just parsed one keyword */
			complete complete
			incomplete incomplete
			arguments so far <>
			then c;
		p->position--;
	];
] : void;


Method "_parse optional leading argument send after_then_" is [
		p : Avail Parser,
		leadingArg : Parse Node,
		c : [Parse Node]->void |
	/* At this point we don't know if we're the leftmost argument of
	   a leading argument send.  Try not being one first, then try being
	   one.  When we try being one, we *must* parse an actual message
	   send, as the argument might be a cast.  Also, we have to
	   terminate the "left-recursion" of the grammar this way.  This
	   left-recursion is implemented as the (guarded) mutual recursion
	   between "...parse optional leading argument send..." and
	   "...parse leading argument message...". */
	c(leadingArg);
	p parse optional super cast after leadingArg then [
			maybeSuper : Parse Node |
		p parse leading argument send after maybeSuper then c;
	];
] : void;


Method "_parse leading argument send after_then_" is [
		p : Avail Parser,
		leadingArgument : Parse Node,
		c : [Parse Node]->void |
	/* At this point, leadingArgument could be a super cast expression,
	   so we *must* parse a leading argument send (starting with that
	   argument).  Answer this message send to the continuation, but
	   also attempt to treat this message send as the leftmost argument
	   to a leading argument send.  These two solutions are dealt with
	   by invoking "...parse optional leading argument send...". */

	complete ::= complete messages starting with "_";
	incomplete ::= incomplete messages starting with "_";
	if ||complete|| > 0  |  ||incomplete|| > 0 then [
		keep ::= cast leadingArgument into [innerSend : Send Node |
			[outerSend : Send Node |
				if outerSend bundle restrictions[1] includes innerSend bundle then [
					true;
				] else [
					p expected "different nesting";
					false;
				];
			];
		] otherwise [
			[outerSend : Send Node | true;];
		];
		p parse from 2   /* We already parsed the arg corresponding to "_". */
			complete complete
			incomplete incomplete
			arguments so far <leadingArgument>
			then [theSendNode : Send Node |
				/* Post-filter the message. */
				if keep(theSendNode) then [
					p parse optional leading argument send after theSendNode
					then c;
				];
			];
	];
] : void;


Method "_parse from_complete_incomplete_arguments so far_then_" is [
		p : Avail Parser,
		keywordIndex : natural number,
		complete : map from atom to messageBundle,
		incomplete : map from string to messageBundleTree,
		args : tuple of Parse Node,
		c : [Send Node]->void |
	/* We've already parsed up to keywordIndex - 1 of the message.
	   The accumulated arguments are in args.  The possible messages
	   that this could be without parsing any more are in complete.  The
	   possible messages that could be parsed if more keywords and/or
	   arguments are encountered are in incomplete.  Invoke c with the
	   Send Node that we parse (if any, or one by one if many). */

	if ||complete|| > 0 then [
		argTypes ::= args collect [arg : Parse Node | arg result type;];
		complete do [message : atom, bundle : messageBundle |
			$checkBundle : $[atom, messageBundle]->void;
			if ||bundle signatures|| > 0 then [
				/* We have tested for the case where there are no implementations,
				   and the bundle is only there to hold restrictions on *future*
				   definitions (even in other modules that can see this name). */
				returnType ::= validate types for message bundle
					argument types argTypes
					if fail [err : string |
						p expected err;
						Exit checkBundle;
					];
				c(new Send Node
					bundle bundle
					arguments args
					return type returnType);
			];
		];
	];

	if ||incomplete|| > 0 then [
		/* See if the next token in the stream matches the next token of
		   any of the messages we're parsing in parallel. */
		nextKeyword ::= p->tokens [*p -> position];
		p->position++;
		if incomplete [nextKeyword]? then [
			subtree ::= incomplete [nextKeyword];
			p parse from keywordIndex + 1
				complete subtree complete
				incomplete subtree incomplete
				arguments so far args
				then c;
		] else [
			p expected "another keyword at position " then keywordIndex decimal;
		];
		p->position--;

		/* Check if an argument could come next. */
		if incomplete ["_"]? then [
			subtree ::= incomplete ["_"];
			p parse expression then [innerExpr : Parse Node |
				/* Figure out whether to filter by restrictions on this argument
				   by determining which continuation block to invoke when the
				   outer send is complete.  Failing this late in the parse allows
				   the parallel message search to continue without iterating
				   over the possible messages. */
				filteredContinue ::= cast innerExpr into [innerSend : Send Node |
					/* Filter the outer send (the one this method is parsing),
					   once it's ready, by excluding solutions in which this
					   argument (known to be a send expression) uses a
					   selector that's disallowed in this argument position. */
					[outerSend : Send Node |
						if not (outerSend bundle restrictions [||args|| + 1]
								includes innerSend bundle message) then [
							/* Pass it out to the original continuation. */
							c(outerSend);
						];
					];
				] otherwise [
					/* Use the original continuation unfiltered (by this arg,
					   at least).  This argument isn't a message send or super
					   cast, so it can't affect precedence filtering. */
					c;
				];
				p parse optional super cast after innerExpr then [
						castOrSend : Parse Node |
					p parse from keywordIndex + 1
						complete subtree complete
						incomplete subtree incomplete
						arguments so far (args then <castOrSend>)
						then filteredContinue;
				];
			];
		];
	];
];


Method "_parse optional super cast after_then_" is [
		p : Avail Parser,
		arg : Parse Node,
		c : [Parse Node]->void |
	c(arg);  /* Try it without a cast */
	p skip ":", ":" then [
		p parse and evaluate expression then [exprValue : all |
			cast exprValue into [castType : type |
				if arg result type <= castType then [
					c(new Super Cast Node
						expression arg
						type castType);
				] else [
					p expected "cast type expression to yield a supertype";
				];
			] otherwise [
				p expected "cast type expression to yield a type";
			];
		];
	];
];


Method "_parse and execute outer statement" is [
		p : Avail Parser |
	/* Note - this method is *not* in continuation-passing form. */
	solution : tuple like <
		Parse Node,
		natural number,
		tuple of Declaration Node>;
	statement : Parse Node;
	p parse statement then [pn : Parse Node |
		solution := <pn, *p->position, *p->scope>;
	];
	if *&solution = nil then [
		Crash "Couldn't parse outer statement.";
	] else [
	/*	*<&statement, p->position, p->scope> := solution;    */
		statement := solution[1];
		*p->position := solution[2];
		*p->scope := solution[3];
	];
	if statement result type = void | statement result type = terminates then [
		execute statement;
	] else [
		Crash "Statement must have type void or terminates";
	];
];

