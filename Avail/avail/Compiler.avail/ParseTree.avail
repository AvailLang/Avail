/**
 * Compiler/ParseTree.avail
 * Copyright (c) 2010, Mark van Gulik.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "ParseTree"
Extends
Uses
	"Kernel",
	"Reflection",
	"Variables",
	"ParseNodes",
	"InstructionGenerator"
Names
	"_generate on_",
	"evaluate_",
	"execute_"

Body


/* This module deepens the semantics for the parse nodes of the Avail parser.  */


/* Instruction generation methods.  These methods use an Instruction Generator in
   a factory pattern to incrementally construct a block from a block node. */

Abstract method "_emit value on_" for [Parse Node, Instruction Generator] -> void;
Forward "_emit effect on_" for [Parse Node, Instruction Generator] -> void;



Method "_emit value on_" is [node : Assignment Node, gen : Instruction Generator |
	Crash "Assignments can no longer be embedded expressions";
];

Method "_emit value on_" is [node : Block Node, gen : Instruction Generator |
	stats ::= node statements;
	outerSet : set of Declaration Node := {};
	node accumulate needed outer variables in &outerSet;
	outers ::= outerSet as tuple collect [decl : Declaration Node | decl variable;];
	subGen ::= Instruction Generator
		for arguments (node arguments
			collect [decl : Argument Declaration Node | decl variable;])
		primitive node primitive
		locals (stats
			select [st : Parse Node |
				cast st into [d : Declaration Node | true;]
				otherwise [false;];]
			collect [st : Parse Node |
				cast st into [d : Declaration Node |
					cast d variable into [loc : Local | loc;];];])
		labels
			if ||stats|| > 0 & [stats[1] type <= Label Node;] then [
				cast stats[1] into [st : Label Node |
					<st variable>;
				];
			] else [<>;]
		outers outers
		result type (node result type result);
	1 to ||stats|| do [i : natural number |
		if i = ||stats|| then [
			/* Final statement leaves result on stack. */
			if stats[i] type <= Declaration Node
					| stats[i] type <= Assignment Node then [
				stats [i] emit effect on subGen;
				subGen push literal 0;  /* Nobody will find out it's not void. */
			] else [
				stats [i] emit value on subGen;
			];
		] else [
			stats [i] emit effect on subGen;
		];
	];
	if ||stats|| = 0 then [
		/* No statements, so push void. */
		subGen push literal 0;  /* Nobody will find out it's not void. */
	];
	code ::= subGen result;
	if ||outers|| = 0 then [
		/* Build the closure statically, and push it as a literal. */
		lit ::= closure from code outer variables <>;
		gen push literal lit;
	] else [
		outers do [outer : Variable |
			gen save variable outer;];
		gen close code code with outers ||outers||;
	];
];

Method "_emit value on_" is [node : List Node, gen : Instruction Generator |
	node expressions do [expr : Parse Node |
		expr emit value on gen;
	];
	gen make list ||node expressions||;
];

Method "_emit value on_" is [node : Literal Node, gen : Instruction Generator |
	gen push literal node value;
];

Method "_emit value on_" is [node : Reference Node, gen : Instruction Generator |
	gen reference variable node declaration variable;
];

Method "_emit value on_" is [node : Send Node, gen : Instruction Generator |
	args ::= node arguments;
	args do [arg : Parse Node |
		arg emit value on gen;
	];
	if (args any [arg : Parse Node | arg type <= Super Cast Node;]) then [
		/* Emit a super call... */
		args do [arg : Parse Node |
			cast arg into [sup : Super Cast Node |
				gen push literal sup myType;
			] otherwise [
				gen get type at depth (||args|| - 1 max 0);
			];
		];
		gen
			super call (node bundle message)
			arg count ||args||
			type node returnType;
	] else [
		/* Emit a regular message invocation... */
		gen
			call (node bundle message)
			arg count ||args||
			type node returnType;
	];
];

Method "_emit value on_" is [node : Super Cast Node, gen : Instruction Generator |
	/* Ignore for now that it's a Super Cast Node.  Use the expression inside. */
	node expression emit value on gen;
];

Method "_emit value on_" is [node : Variable Use Node, gen : Instruction Generator |
	gen use variable node declaration variable;
];

Method "_emit value on_" is [node : Declaration Node, gen : Instruction Generator |
	Crash "A declaration has no value";
];




Method "_emit effect on_" is [node : Parse Node, gen : Instruction Generator |
	node emit value on gen;
	gen pop;
];

Method "_emit effect on_" is [node : Assignment Node, gen : Instruction Generator |
	node expression emit value on gen;
	gen assign variable node declaration variable;
];

Method "_emit effect on_" is [node : Block Node, gen : Instruction Generator |
	Crash "A block by itself can't be a statement";
];

Method "_emit effect on_" is [node : Declaration Node, gen : Instruction Generator |
	/* Do nothing.  Ordinary declaration statements generate no instructions. */
];

Method "_emit effect on_" is [
		node : Initializing Declaration Node,
		gen : Instruction Generator |
	/* Generate code to perform the initializing assignment. */
	node expression emit value on gen;
	gen assign variable node variable;
];

Method "_emit effect on_" is [node : List Node, gen : Instruction Generator |
	Crash "A list by itself can't be a statement";
];

Method "_emit effect on_" is [node : Literal Node, gen : Instruction Generator |
	Crash "A literal by itself can't be a statement";
];

Method "_emit effect on_" is [node : Variable Use Node, gen : Instruction Generator |
	Crash "A variable use by itself can't be a statement";
];

Method "_emit effect on_" is [node : Reference Node, gen : Instruction Generator |
	Crash "A reference expression by itself can't be a statement";
];

Method "_emit effect on_" is [node : Super Cast Node, gen : Instruction Generator |
	Crash "A super cast expression by itself can't be a statement";
];




/* Evaluation operations.  There are two with different purposes.  Use "evaluate_"
   to compute a value, and use "execute_" to run a statement or declaration.  The
   helper method produces a block taking zero arguments, which, when executed
   or evaluated, produces the effect and/or result that the parse node represents. */

Method "generate zero argument block from_" is [node : Parse Node |
	gen ::= Instruction Generator
		for arguments <>
		primitive 0
		locals <>
		labels <>
		outers <>
		result type (node result type);
	node emit value on gen;
	code ::= gen result;
	block ::= closure from code outer variables <>;
	cast block into [b : []->void | b;];
] : []->void;



Method "evaluate_" is [node : Parse Node |
	block ::= generate zero argument block from node;
	cast block into [b : []->all |
		b();
	] otherwise [
		Crash "That expression has void or list type (unsupported for evaluation).";
	];
] : all;

Method "evaluate_" is [node : Declaration Node |
	Crash "A declaration node has no value.";
];



Method "execute_" is [node : Parse Node |
	block ::= generate zero argument block from node;
	if block type result = void then [
		block();
	] else [
		Crash <"That expression didn't have void type.  Use evaluate_, not execute_.",
			block type result>;
	];
] : void;

Method "execute_" is [node : Declaration Node |
	var ::= new container with content type node variable myType;
	Define module variable (node variable name) is var;
] : void;

Method "execute_" is [node : Initializing Declaration Node |
	var ::= new container with content type node variable myType;
	Define module variable (node variable name) is var;
	*var ?:= evaluate node expression;
] : void;

Method "execute_" is [node : Constant Declaration Node |
	val ::= evaluate node expression;
	Define module constant (node variable name) is val;
] : void;


