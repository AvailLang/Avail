/**
 * Decompiler-decompiler.avail
 * Copyright (c) 2010, Mark van Gulik.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Decompiler-decompiler"
Extends
Uses
	"Kernel",
	"Compiler-main",
	"Compiler-variables",
	"Compiler-parse nodes",
	"Compiler-nybblecode encoding"
Names
	"Decompiler",
	"_decompile_"
Body


/* This module is for decompiling compiledCode into parse trees. */

scopeType ::= tuple of map from string to Variable;

code ::= lookup "code";
nybbles ::= lookup "nybbles";
pc ::= lookup "pc";
outers ::= lookup "outers";
args ::= lookup "args";
locals ::= lookup "locals";
exprStack ::= lookup "exprStack";

"Decompiler" is explicit subtype of Object with
	[code -> compiledCode]
	[nybbles -> tuple of [0..15]]
	[pc -> & : natural number]
	[outers -> tuple of Variable]
	[args -> tuple of Argument]
	[locals -> tuple of Local]
	[exprStack -> & : tuple of Parse Node];


Method "new Decompiler for code_outers_" is [c : compiledCode, out : tuple of Variable |
	thePc : natural number := 1;
	theExprStack : tuple of Parse Node := <>;
	Decompiler new with <
		<code, c>,
		<nybbles, c nybbles>,
		<pc, &thePc>,
		<outers, out>,
		<args, 1 to c numArgs collect [i : natural number |
			new Argument
				name "arg" then i decimal
				type c closureType[i];]>,
		<locals, 1 to c numLocals collect [i : natural number |
			localType ::= c literals[((||c literals|| - c numLocals) max 0) + i];
			new Local
				name "temp" then c numArgs + i decimal
				type cast localType into [t : containerType | t readType;];]>,
		<exprStack, &theExprStack>
	>;
] : Decompiler;

Decompiler has fields <"code", "nybbles", "pc", "outers", "args", "locals", "exprStack">;


Method "_skip_" is [d : Decompiler, count : whole number |
	*d pc := clearing *d pc + count;
];

Method "_get nybble" is [d : Decompiler |
	result ::= d nybbles[*d pc];
	*d pc := clearing *d pc + 1;
	result;
];

Method "_get integer" is [d : Decompiler |
	n1 ::= d get nybble;
	if n1 < 10 then [n1;] else [
		if n1 <= 12 then [(n1 - 10) * 16 + 10 + d get nybble;] else [
			if n1 = 13 then [d get nybble * 16 + d get nybble + 58;] else [
				if n1 = 14 then [
					d get nybble * 4096 +
					d get nybble * 256 +
					d get nybble * 16 +
					d get nybble;]
				else [
					Assert n1 = 15;
					(((((((d get nybble) * 16
						+ d get nybble) * 16
						+ d get nybble) * 16
						+ d get nybble) * 16
						+ d get nybble) * 16
						+ d get nybble) * 16
						+ d get nybble) * 16
						+ d get nybble;];];];];
];


remainder ::= tuple of [0..15];

Abstract method "_dispatch_" for [Decompiler, remainder]->void;


Method "_dispatch_" is [
		d : Decompiler,
		nybs : concatenate tuple type callNybbles type and remainder |
	*d pc := clearing*d pc + ||callNybbles||;
	/* Do something here */
];



Method "_extract from_" is [decompiler : Decompiler, code : compiledCode |
	nybs ::= decompiler nybbles;
	limit ::= ||nybs||;
	pc ::= decompiler pc;
	While [
		*pc <= limit;
	] loop [
		decompiler dispatch nybs[*pc..||nybs||];
	];
	Assert ||*decompiler exprStack|| = 1;
	*decompiler exprStack[1];
];


