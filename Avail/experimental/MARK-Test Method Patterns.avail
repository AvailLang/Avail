/**
 * Test Method Patterns.avail
 * Copyright (c) 2010, Mark van Gulik.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Test Method Patterns"
Extends
Uses
	"Kernel"
Names
Body


/*
 * Method signatures should be able to use chevrons «» (Alt-0171, Alt-0187)
 * and optionally double-dagger ‡ (Alt-0135) to specify repeated sections.  The
 * sections between the open chevron and the double dagger can be repeated,
 * separated by occurrences of the section between the double dagger and the
 * close chevron.  Examples should be handy in fleshing out this idea.
 */


/* Optional parameters: */

Method "testMethod_is_«requires_»«returns_»" is [
        name : string,
        body : function,
        requires : tuple [0..1] of function,
        returns : tuple [0..1] of function |
    Halt;
] : void;


Repeated parameters:

Method "Add_«and_»" is [
        firstArg : integer,
        otherArgs : tuple [1..INF) of integer |
    ....
] : integer;


Repeated parameters with separators:

Method "Add«_‡and»" is [
        args : tuple [2..INF) of integer |
    ...
] : tuple;



Repeated parameters with nested repetitions:

Method "Graph«vertex_«edge to_‡and»»" is [
        pairs : tuple [0..INF) like <any, tuple> |
    ...
] : Graph;

g ::= Graph
    vertex "foo" edge to "foo" and edge to "bar"
    vertex "bar" edge to "foo"
    vertex "baz";

Underscores after the double dagger:

Method "_«join_«where«_=_‡and»»»" is [
        firstTable : table,
        joins : tuple [0..INF) of
            tuple like <
                table,
                tuple [0..INF) of
                    tuple like <column, column>> |
    ...
] : join;

Model
    join Pricing
        where Model.id = Pricing.modelId
            and Model.year = Pricing.modelYear
    join Sales
        where Sales.price = Pricing.price
            and Sales.modelId = Pricing.modelId
