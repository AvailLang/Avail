/*
 * Parser.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Parser"
Versions
	"dev"
Uses
	"Avail",
	"Definers",
	"IO",
	"Scanner"
Names
	"Read and execute the next command"
Body

/**
 * Report that the command parser didn't understand the player's input.
 *
 * @method "Didn't understand"
 */
Private method "Didn't understand" is
[
	Report: "I didn't understand that.\n";
];

/**
 * Report that the command parser didn't expect {@param "badToken"}, but was
 * instead expecting one of {@param "node"}'s viable next tokens.
 *
 * @method "Didn't understand_,expected a child of_"
 * @param "optionalBadToken" "<nonempty string…|0..1>"
 *        If specified, then the unexpected command token.
 * @param "node" "root command node"
 *        A {@type "root command node" node} in the command tree.
 */
Private method "«Didn't understand_,»Expected|expected a child of_" is
[
	optionalBadToken : <nonempty string…|0..1>,
	node : root command node
|
	badToken ::= optionalBadToken[1] else [""];
	goodTokens ::= quicksort map ↓node's child nodes's keys→tuple
		through [s : string | if s = "NUMBER" then ["a number"] else [“s”]];
	If goodTokens is empty then [Didn't understand;]
	else
	[
		Report:
			format "‘bad’I expected ‘how many’‘good’.\n"
			with
				bad := if badToken is empty
					then [""]
					else [format "Instead of “①”, " with badToken],
				"how many" := if |goodTokens| > 1 then ["one of "] else [""],
				good := “goodTokens” (as disjunctive list with serial comma);
	];
];

/**
 * Read and execute the player's next command. The allowed commands are those
 * declared with {@method "Command_is_"}.
 *
 * @method "Read and execute the next command"
 * @returns {@method "true"} if the command should consume the {@type "agent"}'s
 *          turn, {@method "false"} otherwise. An invalid command should never
 *          consumes the {@type "agent"}'s turn.
 */
Public method "Read and execute the next command" is
[
	$body : boolean;
	/* Read the next command. */
	command ::= next command;
	/* Split the command into tokens for parsing. If no tokens were provided,
	 * then immediately answer false.
	 */
	tokens ::= tokenize command;
	If tokens is empty then
	[
		Report: "Say again?\n";
		Exit body with false
	];
	/* These are the arguments that will be passed to the action (if the
	 * command is valid).
	 */
	args : tuple := <>;
	/* Try to match the command against the command tree. */
	node : root command node := command tree;
	For each of tokens do
	[
		commandToken : nonempty string
	|
		/* The player's commands should be construed case-insensitively. */
		canonicalToken : nonempty string := lowercase commandToken;
		/* If the token is numeric, then check to see if the special token
		 * "NUMBER" is permitted here. If so, then convert the value to an
		 * integer and arrange to make the transition to the next node by
		 * substituting the parsed token with "NUMBER".
		 */
		If canonicalToken[1] is an Arabic numeral then
		[
			If "NUMBER" ∈ ↓node's child nodes then
			[
				args := args ++ <canonicalToken→extended integer>;
				canonicalToken := "NUMBER";
			];
		];
		/* If no child is associated with the current token, then the command
		 * is invalid. Immediately answer false.
		 */
		If canonicalToken ∉ ↓node's child nodes then
		[
			Didn't understand canonicalToken, expected a child of node;
			Exit body with false
		];
		/* Traverse the link to the next node. */
		node := cast ↓node's child nodes[canonicalToken]
			into [n : command node | n];
	];
	/* The current node must be a command node. */
	commandNode ::= cast node into [n : command node | n];
	/* If the final node does not have an associated action, then the command
	 * is invalid. Immediately answer false.
	 */
	If commandNode's action is unassigned then
	[
		Expected a child of node;
		Exit body with false
	];
	/* The command is syntactically valid. Try to apply the associated
	 * action to the accumulated arguments. If the arguments don't conform to
	 * the parameter types, then the command is not semantically valid.
	 */
	guard [invoke ↓commandNode's action with <args>]
	intercept
	[
		e : incorrect-argument-type exception
	|
		Didn't understand;
		false
	]
] : boolean;
