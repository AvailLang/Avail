abstract class A<X extends Integer, Y>
{
	public abstract void W (X a);
	public abstract void Q (A<? super X, Y> a);
	public abstract void S (A<? extends X, Y> b);
}

((java.lang.reflect.WildcardType)
	((java.lang.reflect.ParameterizedType)
		A.class.getMethod("Q", A.class)
			.getGenericParameterTypes()[0]).getActualTypeArguments()[0])
		.getLowerBounds()


class IntMap extends java.util.HashMap<Integer, Integer> { }
class XIntMap<X extends Integer, Y extends X, Z extends Comparable<Y>> extends IntMap { }
java.lang.reflect.ParameterizedType pt = (java.lang.reflect.ParameterizedType)
	XIntMap.class.getTypeParameters()[2].getBounds()[0];
java.lang.reflect.TypeVariable varY = (java.lang.reflect.TypeVariable)
	pt.getActualTypeArguments()[0];
java.lang.reflect.TypeVariable varX = (java.lang.reflect.TypeVariable)
	varY.getBounds()[0];
varX.getBounds()

class A<X> { }
class B<X> extends A<X> { }
class C<X> extends B<A<C<X>>> { }

class QQ
{
	class A<X> { }
	class B extends A<C<B>> { }
	class C<X extends B> { }
}


class Y<X extends java.util.List<X>> { }
class Z<X extends java.util.List<X>> { }
recList ::= java.util.List<self type>;
Y<recList>;


class Gnum<G extends Gnum<G>> { }
class Hnum<H extends Hnum<H>> extends Gnum<H> { }

self type
hnum ::= scrappy.Hnum<>
scrappy.Gnum<hnum>;


e : java.lang.Enum<self type> := new x.y.z.Color();


Class.forName("java.lang.String")
	.getMethod("substring", Integer.TYPE, Integer.TYPE)
	.invoke("frog", 1, 3)

"frog".substring(1, 3)


class IntMap extends java.util.HashMap<Integer, Integer> { }
class XIntMap<X extends Integer, Y extends X, Z extends Comparable<Integer>> extends IntMap { }
java.lang.reflect.ParameterizedType pt = (java.lang.reflect.ParameterizedType)
	XIntMap.class.getTypeParameters()[2].getBounds()[0];
pt.getActualTypeArguments()

class Recursive<X extends Recursive<X>> { }
Recursive.class.getTypeParameters()[0].getBounds()


objectType ::= Jave type "java.lang.Object";
hashMapType ::= Java type "java.util.HashMap" parameterized by <integer..|2..2>;
hashMapConstructor ::= Java constructor for hashMapType accepting <integer|1..1>;
hashMap ::= hashMapConstructor(5);

Method "Java integer" is
[
	[-2**31..2**31-1];
] : [-2**31..2**31-1]'s type;
		
substring ::= Java function for stringType named "substring" given <Java integer, Java integer>'s type;
formatFunction ::= Java function for aPojoType named "format" given <string, any..|0..∞>;

Method "_._(«_‡,»)" is
[
	receiver : pojo,
	method : function,
	args : tuple of any
|
	apply method to receiver + args;
] : any;

substring("frog", 1, 3)
"frog".substring(1, 3)

o.hashCodeFunction();
o.formatFunction("I like %s", "goat pr0n");

Java method "_'s hash code" for aPojoType named "hashCode" given <>'s type;
o's hash code;


A -> B -> C -> D -> E -> F
C >= F:
	C[types] = {A,B,C}
	F[types] = {A,B,C,D,E,F}
	C ∩ F = {A,B,C}



class X<E extends java.util.List<E>> {}
list ::= java.util.List<self's type>;
X<hm>
java.lang.Enum<self's type>;

java.util.HashMap.class.getGenericSuperclass()


java.lang.reflect.Array.get(new int[] {1, 3}, 1);


int[][].class


String[].class.getSuperclass()
String[].class.getInterfaces()


class X
{
	public Object[] objectArray () { return new String[] { "foo " }; }
	public String[] stringArray () { return new String[] { "foo " }; }
	public void doObjectStuff (Object[] objectArray) { }
	public void doStringStuff (String[] stringArray) { }
	public void doOtherStuff () { doObjectStuff(stringArray()); }
//	public void doWrongStuff () { doStringStuff(objectArray()); }
}

java.util.List<Integer> list = new java.util.ArrayList<Integer>();
list.add(1);
list.add(2);
list.add(3);
(Integer[]) list.toArray()


class X<A, B>
{
	public X () { }
}
X.class.getConstructor()









([ i : integer, s : string | Crash "Yipe!"; ] : ⊤)'s type ≤ [integer, string]→⊤

([integer, string]→⊤)'s arguments' type = <integer, string..|2..2>
([integer, string]→⊤)'s return type = ⊤






