/*
 * Fallible Primitives.avail
 * Copyright (c) 2011, Mark van Gulik.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * GENERATED FILE
 * * Generator: com.avail.tools.bootstrap.BootstrapGenerator
 * * Last Generated On: 2012.01.08 12:38:40.750 -0600
 *
 * DO NOT MODIFY MANUALLY. ALL MANUAL CHANGES WILL BE LOST.
 */

System Module "Fallible Primitives"
Versions
	"dev"
Extends
Uses
	"Origin",
	"Primitives"
Names
	"Set primitive failure function to_",
	/* 188 */ "_#_:_(literals=_,#locals_,#outers_,stack depth=_)",
	/* 142 */ "_[_.._]",
	/* 132 */ "_[_]:=_",
	/*   3 */ "_×_",
	/*   4 */ "_÷_",
	/*  18 */ "eject_",
	/*  57 */ "exit_with_",
	/*  74 */ "function from_and_",
	/*  40 */ "invoke_with_",
	/* 201 */ "raise_",
	/*  24 */ "request termination of_",
	/*  58 */ "restart_",
	/*  56 */ "restart_with_",
	/*  15 */ "swap_and_",
	/*  23 */ "termination requested",
	/* 200 */ "try_catch_",
	/*  10 */ "↓_",
	/*  11 */ "↓_:=_",
	/* 143 */ "∪_[_.._]"
Body

Method "Private fail primitive with_" is 
[
	arg1 : any
|
	Primitive 256;
] : ⊥;

_fail_primitive : primitive failure function :=
	[
		arg1 : any
	|
		Private fail primitive with arg1;
	] : ⊥;

Method "Set primitive failure function to_" is 
[
	arg1 : primitive failure function
|
	_fail_primitive := arg1;
] : ⊤;

Method "Private invoke_with«_‡,»" is 
[
	aFunction : function,
	arguments : tuple
|
	Primitive 40 (failureCode : natural number);
	Private fail primitive with failureCode;
] : ⊥;

/**
 * Compute and answer the sum of the arguments.
 *
 * Parameters:
 *    augend - The augend.
 *    addend - The addend.
 * Returns:
 *    The sum of the augend and the addend.
 */
Method "_+_" is 
[
	augend : number,
	addend : number
|
	Primitive 1 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : number;

/**
 * Compute and answer the difference of the arguments.
 *
 * Parameters:
 *    minuend - The minuend.
 *    subtrahend - The subtrahend.
 * Returns:
 *    The difference of the minuend and the subtrahend.
 */
Method "_-_" is 
[
	minuend : number,
	subtrahend : number
|
	Primitive 2 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : number;

/**
 * Compute and answer the product of the arguments.
 *
 * Parameters:
 *    multiplicand - The multiplicand.
 *    multiplier - The multiplier.
 * Returns:
 *    The product of the multiplicand and the multiplier.
 */
Method "_×_" is 
[
	multiplicand : number,
	multiplier : number
|
	Primitive 3 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : number;

/**
 * Compute and answer the quotient of the arguments.
 *
 * Parameters:
 *    dividend - The dividend.
 *    divisor - The divisor.
 * Returns:
 *    The quotient of the dividend and the divisor.
 */
Method "_÷_" is 
[
	dividend : number,
	divisor : number
|
	Primitive 4 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : number;

/**
 * Answer the value contained within the specified variable.
 *
 * Parameters:
 *    var - A variable.
 * Returns:
 *    The value contained within the specified variable.
 */
Method "↓_" is 
[
	var : variable
|
	Primitive 10 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : any;

/**
 * Store `value` into the specified variable.
 *
 * Parameters:
 *    var - A variable.
 *    value - The value that should be stored into `var`.
 */
Method "↓_:=_" is 
[
	var : variable,
	value : any
|
	Primitive 11 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : ⊤;

/**
 * Exchange the contents of the two variables. This is more efficient than
 * using an intermediate variable, and permits additional optimizations by the
 * virtual machine.
 *
 * Parameters:
 *    arg1 - A variable.
 *    arg2 - A variable.
 */
Method "swap_and_" is 
[
	arg1 : variable,
	arg2 : variable
|
	Primitive 15 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : ⊤;

/**
 * Eject and answer the contents of the specified variable. The variable is
 * in the unassigned state after the primitive completes.
 *
 * Parameters:
 *    var - A variable.
 * Returns:
 *    The value ejected from the variable.
 */
Method "eject_" is 
[
	var : variable
|
	Primitive 18 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : any;

/**
 * Has termination of the current fiber been requested?
 *
 * Returns:
 *    `true` if termination of the current fiber has been requested, `false`
 *    otherwise.
 */
Method "termination requested" is 
[
	Primitive 23 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : boolean;

/**
 * Request termination of the specified fiber. Termination is consensual only;
 * cooperation of the fiber is required to affect termination.
 *
 * Parameters:
 *    victim - A fiber.
 */
Method "request termination of_" is 
[
	victim : fiber
|
	Primitive 24 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : ⊤;

/**
 * Answer the value bound to `key` in the specified fiber's environment. Since
 * the fiber's environment essentially contains fiber-local variables (i.e.
 * bindings from atoms to arbitrary values), this operation effectively reads a
 * fiber-local variable.
 *
 * Parameters:
 *    aFiber - The fiber whose environment should be consulted.
 *    key - The key whose value should be obtained.
 * Returns:
 *    The value bound to `key` within the fibers environment.
 */
Method "_[_]" is 
[
	aFiber : fiber,
	key : atom
|
	Primitive 26 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : any;

/**
 * Answer the `index`-th parameter type of the specified function type.
 *
 * Parameters:
 *    functionType - A function type.
 *    index - The one-based index of the desired parameter type.
 * Returns:
 *    The `index`-th parameter type of the argument.
 */
Method "_[_]" is 
[
	functionType : function meta,
	index : natural number
|
	Primitive 36 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : type;

/**
 * Invoke the function with the given arguments. Answer its result.
 *
 * Parameters:
 *    aFunction - A function.
 *    arguments - The tuple of arguments.
 * Returns:
 *    The value produced by applying the arguments to the function.
 */
Method "invoke_with_" is 
[
	aFunction : function,
	arguments : tuple
|
	Primitive 40 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : ⊤;

/**
 * Restart the continuation with the specified arguments. Execution proceeds as
 * though the continuation's caller had just invoked the continuation's current
 * function with the given arguments instead of the original arguments. The
 * current continuation (in which this primitive was invoked) is completely
 * replaced by the restarted continuation.
 *
 * Parameters:
 *    aContinuation - The continuation to restart.
 *    arguments - The new arguments with which to restart `aContinuation`.
 */
Method "restart_with_" is 
[
	aContinuation : continuation,
	arguments : tuple
|
	Primitive 56 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : ⊥;

/**
 * Exit the continuation and answer the specified value to the continuation's
 * caller. Execution proceeds as though the continuation's had just returned
 * from its current function with the supplied value. The current continuation
 * (in which this primitive was invoked) is completely replaced by the specified
 * continuation's resumed caller.
 *
 * Parameters:
 *    aContinuation - The continuation to exit.
 *    value - The value with which to exit `aContinuation`.
 */
Method "exit_with_" is 
[
	aContinuation : continuation,
	value : any
|
	Primitive 57 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : ⊥;

/**
 * Restart the continuation with its original arguments. Execution proceeds as
 * though the continuation's caller had just invoked the continuation's current
 * function with its original arguments. The current continuation (in which
 * this primitive was invoked) is completely replaced by the restarted
 * continuation.
 *
 * Parameters:
 *    aContinuation - The continuation to restart.
 */
Method "restart_" is 
[
	aContinuation : continuation
|
	Primitive 58 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : ⊥;

/**
 * Construct and answer a function given the specified compiled code and tuple
 * of captured variables.
 *
 * Parameters:
 *    implementation - The compiled code that describes the algorithm.
 *    outerVariables - The tuple of outer variables.
 * Returns:
 *    The requested function.
 */
Method "function from_and_" is 
[
	implementation : function implementation,
	outerVariables : tuple
|
	Primitive 74 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : function;

/**
 * Answer the value bound to `aMap` in `key`.
 *
 * Parameters:
 *    aMap - A map.
 *    key - The key whose bound value should be obtained.
 * Returns:
 *    The value bound to `key` in `aMap`.
 */
Method "_[_]" is 
[
	aMap : map,
	key : any
|
	Primitive 82 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : any;

/**
 * Assuming that `anAtom` has a property whose key is `key`, then answer
 * the property value associated with the `key`.
 *
 * Parameters:
 *    anAtom - An atom.
 *    key - The property key.
 * Returns:
 *    The property value bound to the key.
 */
Method "_[_]" is 
[
	anAtom : atom,
	key : atom
|
	Primitive 123 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : any;

/**
 * Answer the `index`-th element of `aTuple`.
 *
 * Parameters:
 *    aTuple - A tuple.
 *    index - The index of the desired element.
 * Returns:
 *    The requested element.
 */
Method "_[_]" is 
[
	aTuple : tuple,
	index : natural number
|
	Primitive 131 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : any;

/**
 * Construct and answer a tuple based on the one provided but such that its
 * `index`-th element is `value`.
 *
 * Parameters:
 *    aTuple - A tuple.
 *    index - The one-based index of the element that should (potentially) differ
 *       in the resultant tuple.
 *    value - The "replacement" value.
 * Returns:
 *    The requested tuple.
 */
Method "_[_]:=_" is 
[
	aTuple : tuple,
	index : natural number,
	value : any
|
	Primitive 132 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : tuple;

/**
 * Construct and answer a slice (i.e. subtuple) of the specified tuple.
 *
 * Parameters:
 *    aTuple - A tuple.
 *    sliceStart - The one-based start index (inclusive) of the desired slice.
 *    sliceEnd - The one-based end index (inclusive) of the desired slice.
 * Returns:
 *    The requested tuple.
 */
Method "_[_.._]" is 
[
	aTuple : tuple,
	sliceStart : natural number,
	sliceEnd : whole number
|
	Primitive 135 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : tuple;

/**
 * Compute and answer a tuple containing the requested element types. Indices
 * that are out of bounds report ⊥ as their element type.
 *
 * Parameters:
 *    aTupleType - A tuple type.
 *    sliceStart - The one-based index (inclusive) of the start of the slice.
 *    sliceEnd - The one-based index (inclusive) of the end of the slice.
 * Returns:
 *    The requested slice of element types.
 */
Method "_[_.._]" is 
[
	aTupleType : tuple meta,
	sliceStart : natural number,
	sliceEnd : whole number
|
	Primitive 142 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : tuple of type;

/**
 * Compute and answer the type union of the indicated range of element types.
 *
 * Parameters:
 *    aTupleType - A tuple type.
 *    startIndex - The one-based index (inclusive) of the start of the range.
 *    endIndex - The one-based index (inclusive) of the end of the range.
 * Returns:
 *    The type union of all element types in the specified range.
 */
Method "∪_[_.._]" is 
[
	aTupleType : tuple meta,
	startIndex : natural number,
	endIndex : whole number
|
	Primitive 143 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : type;

/**
 * Construct and answer a function implementation from the specified arguments.
 *
 * Parameters:
 *    nybblecodes - The Level One instructions as a tuple of nybblecodes.
 *    primitiveNumber - The primitive number, or `0` if the result should
 *       not have primitive linkage.
 *    aFunctionType - The function type of any function able to close the
 *       result.
 *    literals - The literals used by the algorithm.
 *    localsCount - The number of local variables used by the algorithm.
 *    outersCount - The number of outer variables used by the algorithm.
 *    maximumStackDepth - The maximum stack depth.
 * Returns:
 *    The requested function implementation.
 */
Method "_#_:_(literals=_,#locals_,#outers_,stack depth=_)" is 
[
	nybblecodes : tuple of nybble,
	primitiveNumber : unsigned short,
	aFunctionType : function meta,
	literals : tuple,
	localsCount : whole number,
	outersCount : whole number,
	maximumStackDepth : whole number
|
	Primitive 188 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : function implementation;

/**
 * Execute `body`. If an exception is raised, the virtual machine will scan the
 * current fiber's chain of continuations to identify invocations of this
 * primitive. The handler nearest to the end of the continuation chain, i.e.
 * closest to the raise of the exception, that accepts an argument of the
 * correct type is invoked with the exception. So `handler` will potentially
 * run if code run (directly or indirectly) by `body` throws an exception of
 * the correct type.
 *
 * Parameters:
 *    body - The protected function.
 *    handler - The exception handler.
 */
Method "try_catch_" is 
[
	body : nullary procedure,
	handler : unary procedure
|
	Primitive 200 (failureCode : zero's type);
	Private invoke body with empty tuple;
] : ⊤;

/**
 * Raise `exception` as an exception. The virtual machine scans the current
 * fiber's chain of continuations to identify an invocation of `try_catch_`
 * (primitive 200). Extract the second argument from that continuation. This is
 * an arity-one exception handling function. If it accepts `exception`, then
 * discard all continuations after this one and then invoke the handler with
 * `exception`. If the handler does not accept the argument, then the
 * virtual machine continues scanning the chain of continuations for correctly
 * typed exception handling functions. If no suitable exception handling
 * function is found, then the primitive fails.
 *
 * Parameters:
 *    exception - An exception.
 * Returns:
 *    ⊥.
 */
Method "raise_" is 
[
	exception : any
|
	Primitive 201 (failureCode : natural number);
	Private invoke _fail_primitive with failureCode;
] : ⊥;

