/*
 * Special Objects.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * GENERATED FILE
 * * Generator: com.avail.tools.bootstrap.BootstrapGenerator
 * * Last Generated On: 2012.04.20 10:36:10.805 -0500
 *
 * DO NOT MODIFY MANUALLY. ALL MANUAL CHANGES WILL BE LOST.
 */

System Module "Special Objects"
Versions
	"dev"
Extends
	"Origin"
Uses
Names
	/*  78 */ "-∞",
	/* 111 */ "Euler number",
	/*  42 */ "abstract signature",
	/*   1 */ "any",
	/*  69 */ "any meta",
	/*  62 */ "argument",
	/*  53 */ "assignment",
	/*  11 */ "atom",
	/*  54 */ "block",
	/*   2 */ "boolean",
	/*   3 */ "character",
	/*  38 */ "code point",
	/*   9 */ "continuation",
	/*  10 */ "continuation meta",
	/*  92 */ "continuation variable",
	/*  61 */ "declaration",
	/*  12 */ "double",
	/*  96 */ "empty map",
	/* 104 */ "empty tuple",
	/*  52 */ "expression",
	/*  13 */ "extended integer",
	/*  18 */ "extended integer meta",
	/*  71 */ "false",
	/*  25 */ "fiber",
	/*  93 */ "field map",
	/*  94 */ "field type map",
	/*  15 */ "float",
	/*  43 */ "forward signature",
	/*   4 */ "function",
	/*   6 */ "function implementation",
	/*   5 */ "function meta",
	/*  17 */ "integer",
	/*  95 */ "key-value tuple",
	/*  63 */ "label",
	/*  59 */ "list",
	/*  55 */ "literal",
	/* 116 */ "literal token",
	/*  65 */ "local constant",
	/*  64 */ "local variable",
	/* 109 */ "macro function",
	/*  39 */ "map",
	/*  19 */ "map meta",
	/*  40 */ "message bundle",
	/*  45 */ "message bundle tree",
	/*  46 */ "method",
	/*  44 */ "method signature",
	/*  67 */ "module constant",
	/*  66 */ "module variable",
	/*  37 */ "natural number",
	/*  97 */ "non-empty map",
	/*  99 */ "non-empty set",
	/* 118 */ "nonnegative integer",
	/*  81 */ "null",
	/*  90 */ "nullary procedure",
	/*  16 */ "number",
	/* 101 */ "nybble",
	/*  22 */ "object",
	/*  23 */ "object meta",
	/*  50 */ "phrase",
	/* 113 */ "phrase meta",
	/*  80 */ "pojo",
	/*  87 */ "pojo array",
	/*  85 */ "pojo array meta",
	/*  86 */ "pojo constructor",
	/*  89 */ "pojo exception",
	/*  84 */ "pojo meta",
	/*  88 */ "pojo self",
	/*  83 */ "pojo self type",
	/*  82 */ "pojo⊥",
	/*  91 */ "predicate function",
	/*  76 */ "primitive failure function",
	/*  68 */ "primitive failure reason",
	/* 107 */ "semantic restriction function",
	/*  57 */ "send",
	/*  26 */ "set",
	/*  27 */ "set meta",
	/* 114 */ "set of atom",
	/*  75 */ "set of string",
	/*  41 */ "signature",
	/*  28 */ "string",
	/*  58 */ "super cast",
	/* 115 */ "token",
	/*  70 */ "true",
	/*  32 */ "tuple",
	/*  33 */ "tuple meta",
	/* 117 */ "tuple of any meta",
	/* 102 */ "tuple of nybble",
	/* 108 */ "tuple of semantic restriction function",
	/*  74 */ "tuple of set of string",
	/*  72 */ "tuple of string",
	/* 100 */ "tuple of tuple",
	/*  73 */ "tuple of type",
	/*  34 */ "type",
	/* 112 */ "type of Euler number",
	/* 110 */ "type of two",
	/* 106 */ "type of zero",
	/* 105 */ "unary procedure",
	/* 103 */ "unsigned short",
	/*   7 */ "variable",
	/*   8 */ "variable meta",
	/*  56 */ "variable reference",
	/*  60 */ "variable use",
	/*  36 */ "whole number",
	/*  98 */ "whole number meta",
	/*  77 */ "∅",
	/*  79 */ "∞",
	/*  35 */ "⊤",
	/*  29 */ "⊥",
	/*  30 */ "⊥meta"
Body

_any                                    ::= special object 1;
_boolean                                ::= special object 2;
_character                              ::= special object 3;
_function                               ::= special object 4;
_function_meta                          ::= special object 5;
_function_implementation                ::= special object 6;
_variable                               ::= special object 7;
_variable_meta                          ::= special object 8;
_continuation                           ::= special object 9;
_continuation_meta                      ::= special object 10;
_atom                                   ::= special object 11;
_double                                 ::= special object 12;
_extended_integer                       ::= special object 13;
_float                                  ::= special object 15;
_number                                 ::= special object 16;
_integer                                ::= special object 17;
_extended_integer_meta                  ::= special object 18;
_map_meta                               ::= special object 19;
_object                                 ::= special object 22;
_object_meta                            ::= special object 23;
_fiber                                  ::= special object 25;
_set                                    ::= special object 26;
_set_meta                               ::= special object 27;
_string                                 ::= special object 28;
_bottom                                 ::= special object 29;
_bottom_meta                            ::= special object 30;
_tuple                                  ::= special object 32;
_tuple_meta                             ::= special object 33;
_type                                   ::= special object 34;
_top                                    ::= special object 35;
_whole_number                           ::= special object 36;
_natural_number                         ::= special object 37;
_code_point                             ::= special object 38;
_map                                    ::= special object 39;
_message_bundle                         ::= special object 40;
_signature                              ::= special object 41;
_abstract_signature                     ::= special object 42;
_forward_signature                      ::= special object 43;
_method_signature                       ::= special object 44;
_message_bundle_tree                    ::= special object 45;
_method                                 ::= special object 46;
_phrase                                 ::= special object 50;
_expression                             ::= special object 52;
_assignment                             ::= special object 53;
_block                                  ::= special object 54;
_literal                                ::= special object 55;
_variable_reference                     ::= special object 56;
_send                                   ::= special object 57;
_super_cast                             ::= special object 58;
_list                                   ::= special object 59;
_variable_use                           ::= special object 60;
_declaration                            ::= special object 61;
_argument                               ::= special object 62;
_label                                  ::= special object 63;
_local_variable                         ::= special object 64;
_local_constant                         ::= special object 65;
_module_variable                        ::= special object 66;
_module_constant                        ::= special object 67;
_primitive_failure_reason               ::= special object 68;
_any_meta                               ::= special object 69;
_true                                   ::= special object 70;
_false                                  ::= special object 71;
_tuple_of_string                        ::= special object 72;
_tuple_of_type                          ::= special object 73;
_tuple_of_set_of_string                 ::= special object 74;
_set_of_string                          ::= special object 75;
_primitive_failure_function             ::= special object 76;
_empty_set                              ::= special object 77;
_negative_infinity                      ::= special object 78;
_positive_infinity                      ::= special object 79;
_pojo                                   ::= special object 80;
_null                                   ::= special object 81;
_pojo_bottom                            ::= special object 82;
_pojo_self_type                         ::= special object 83;
_pojo_meta                              ::= special object 84;
_pojo_array_meta                        ::= special object 85;
_pojo_constructor                       ::= special object 86;
_pojo_array                             ::= special object 87;
_pojo_self                              ::= special object 88;
_pojo_exception                         ::= special object 89;
_nullary_procedure                      ::= special object 90;
_predicate_function                     ::= special object 91;
_continuation_variable                  ::= special object 92;
_field_map                              ::= special object 93;
_field_type_map                         ::= special object 94;
_key_value_tuple                        ::= special object 95;
_empty_map                              ::= special object 96;
_non_empty_map                          ::= special object 97;
_whole_number_meta                      ::= special object 98;
_non_empty_set                          ::= special object 99;
_tuple_of_tuple                         ::= special object 100;
_nybble                                 ::= special object 101;
_tuple_of_nybble                        ::= special object 102;
_unsigned_short                         ::= special object 103;
_empty_tuple                            ::= special object 104;
_unary_procedure                        ::= special object 105;
_type_of_zero                           ::= special object 106;
_semantic_restriction_function          ::= special object 107;
_tuple_of_semantic_restriction_function ::= special object 108;
_macro_function                         ::= special object 109;
_type_of_two                            ::= special object 110;
_Euler_number                           ::= special object 111;
_type_of_Euler_number                   ::= special object 112;
_phrase_meta                            ::= special object 113;
_set_of_atom                            ::= special object 114;
_token                                  ::= special object 115;
_literal_token                          ::= special object 116;
_tuple_of_any_meta                      ::= special object 117;
_nonnegative_integer                    ::= special object 118;

/**
 * The practical abstract root of the Avail type lattice. `any` is the second
 * most senior type, inferior only to `⊤`. It includes every value available
 * to an Avail program, i.e., every Avail value except for the unexposed special
 * value nil.
 *
 * `any` is made extremely useful by the interaction of polymorphism and
 * semantic restrictions. Many algorithms can be codified once in terms of `any`
 * and then strengthened via a semantic restriction that extrapolates a
 * stronger result subtype from the static input types.
 *
 * `any` is the most general type that may appear in the following contexts:
 *
 *    - As a parameter type of a function type.
 *    - As the read type of a variable type.
 *    - As a leading type or the default type of a tuple type.
 *    - As the element type of a set type.
 *    - As the key type or value type of a map type.
 *    - As the field type of an object type.
 *    - As the type parameter of a pojo type.
 */
Method "any" is
[
	_any;
];

/**
 * The enumeration of the special atoms `true` and `false`. All primitive
 * interrogatives use classical (Boolean) bivalence and obey the three classical
 * (Aristotelian) laws of thought.
 *
 * Bivalent logic assigns either `true` or `false` as the unique truth value of
 * every proposition. Every primitive interrogative, i.e. `boolean`-valued
 * primitive, stably answers either `true` or `false` for a given set of
 * arguments.
 *
 * The three classical laws of thought are:
 *
 *    - The law of identity: P → P.
 *      For every primitive interrogative "prim_,_,_", then
 *      "prim A, B, C = prim A, B, C". (All primitive interrogatives are
 *      stable.)
 *    - The law of noncontradiction: ¬(P ∧ ¬P).
 *      For every primitive interrogative "prim_,_,_", then
 *      "(prim A, B, C ∧ ¬prim A, B, C) = false".
 *    - The law of excluded middle: P ∨ ¬P.
 *      For every primitive interrogative "prim_,_,_", then
 *      "((prim A, B, C = true) ∨ (prim A, B, C = false)) = true".
 *
 * Therefore the primitive interrogatives satisfy classical logic.
 *
 * Note that values may be instances of many enumerations. This means that Avail
 * directly supports other logical systems, such as Kleene's three-valued logic
 * of indeterminacy, whose truth values are `true`, `false`, and "unknown".
 * Implementation of this system would proceed directly from creation of an atom
 * to represent "unknown" and the formation of a new enumeration that contained
 * the standard `true` and `false` atoms and also the "unknown" atom. New
 * logical operations could then be written in terms of this new enumeration.
 */
Method "boolean" is
[
	_boolean;
];

Method "character" is
[
	_character;
];

Method "function" is
[
	_function;
];

Method "function meta" is
[
	_function_meta;
];

Method "function implementation" is
[
	_function_implementation;
];

Method "variable" is
[
	_variable;
];

Method "variable meta" is
[
	_variable_meta;
];

Method "continuation" is
[
	_continuation;
];

Method "continuation meta" is
[
	_continuation_meta;
];

Method "atom" is
[
	_atom;
];

Method "double" is
[
	_double;
];

Method "extended integer" is
[
	_extended_integer;
];

Method "float" is
[
	_float;
];

Method "number" is
[
	_number;
];

Method "integer" is
[
	_integer;
];

Method "extended integer meta" is
[
	_extended_integer_meta;
];

Method "map meta" is
[
	_map_meta;
];

Method "object" is
[
	_object;
];

Method "object meta" is
[
	_object_meta;
];

Method "fiber" is
[
	_fiber;
];

Method "set" is
[
	_set;
];

Method "set meta" is
[
	_set_meta;
];

Method "string" is
[
	_string;
];

Method "⊥" is
[
	_bottom;
];

Method "⊥meta" is
[
	_bottom_meta;
];

Method "tuple" is
[
	_tuple;
];

Method "tuple meta" is
[
	_tuple_meta;
];

Method "type" is
[
	_type;
];

/**
 * The true abstract root of the Avail type lattice. It is pronounced "top" and
 * written as the down tack (⊤) character. Every Avail value is an instance
 * of `⊤`, and every Avail type is a subtype of `⊤`.
 *
 * `⊤` is distinct from `any` in that it includes exactly one additional value:
 * the special value nil. This value does not satisfy any public protocol and
 * is not available to an Avail programmer. It is, however, implicitly returned
 * from every procedure, i.e., function whose return type is `⊤`. Thus nil is
 * the value produced iff no value is produced. The virtual machine uses nil to
 * simplify several core algorithms, but exposure of nil to an Avail programmer
 * would not yield a net good.
 *
 * `⊤` typically appears in Avail code in only a few select contexts:
 *
 *    - As the return type of a function type. In this context, it signifies
 *      that the function does not produce a value, i.e., it produces the
 *      unexposed value nil.
 *    - As the return type of a continuation type. In this context, it
 *      signifies that the continuation will not produce a value, i.e., it
 *      produces the unexposed value nil.
 *    - As the read type of a variable type. In this context, it signifies
 *      that no value may be read from the variable, i.e., the variable is
 *      write-only.
 *    - As the idempotent initial value of an accumulator variable whose
 *      intermediate and final results represent a chain of type intersections.
 *      (Note that the type intersection of `⊤` with some type X is always X.)
 *    - As the result of a semantic restriction on a procedure that serves only
 *      to reject parses based on the static types of the arguments (but does
 *      not strengthen the return type).
 *    - As the result type of a phrase. In this context, it signifies that the
 *      phrase serves as a statement (and not merely as an expression).
 *
 * A function whose declared return type is `⊤` is still permitted to answer an
 * actual (non-nil) value. This is consistent with the type lattice, since every
 * value is an instance of `⊤`. It is useful, moreover, because a semantic
 * restriction may strengthen the return type of a `⊤`-valued function at a
 * particular call site to a subtype of `⊤`.
 *
 * `⊤` is expressly forbidden from occurring in most contexts, including the
 * following:
 *
 *    - As a parameter type of a function type.
 *    - As the write type of a variable type. This also implies that it cannot
 *      be the type of an actual variable.
 *    - As a leading type or the default type of a tuple type.
 *    - As the element type of a set type.
 *    - As the key type or value type of a map type.
 *    - As the field type of an object type.
 *    - As the type parameter of a pojo type.
 *
 * Note that these prohibitions, when considered in aggregate, negate any
 * possible value that could be gleaned from exposing the special value nil to
 * an Avail program. They conspire together to ensure that nil could never be
 * retained by an Avail value. It may therefore only exist as a temporary within
 * a continuation, i.e., an item on the local stack of a function call. A
 * reflective query of a continuation''s temporaries that would answer nil will
 * instead produce a variable whose read type is `⊥`.
 */
Method "⊤" is
[
	_top;
];

Method "whole number" is
[
	_whole_number;
];

Method "natural number" is
[
	_natural_number;
];

Method "code point" is
[
	_code_point;
];

Method "map" is
[
	_map;
];

Method "message bundle" is
[
	_message_bundle;
];

Method "signature" is
[
	_signature;
];

Method "abstract signature" is
[
	_abstract_signature;
];

Method "forward signature" is
[
	_forward_signature;
];

Method "method signature" is
[
	_method_signature;
];

Method "message bundle tree" is
[
	_message_bundle_tree;
];

Method "method" is
[
	_method;
];

Method "phrase" is
[
	_phrase;
];

Method "expression" is
[
	_expression;
];

Method "assignment" is
[
	_assignment;
];

Method "block" is
[
	_block;
];

Method "literal" is
[
	_literal;
];

Method "variable reference" is
[
	_variable_reference;
];

Method "send" is
[
	_send;
];

Method "super cast" is
[
	_super_cast;
];

Method "list" is
[
	_list;
];

Method "variable use" is
[
	_variable_use;
];

Method "declaration" is
[
	_declaration;
];

Method "argument" is
[
	_argument;
];

Method "label" is
[
	_label;
];

Method "local variable" is
[
	_local_variable;
];

Method "local constant" is
[
	_local_constant;
];

Method "module variable" is
[
	_module_variable;
];

Method "module constant" is
[
	_module_constant;
];

Method "primitive failure reason" is
[
	_primitive_failure_reason;
];

Method "any meta" is
[
	_any_meta;
];

/** * The special atom that represents truth. `true` is an instance of `boolean`.
 */
Method "true" is
[
	_true;
];

Method "false" is
[
	_false;
];

Method "tuple of string" is
[
	_tuple_of_string;
];

Method "tuple of type" is
[
	_tuple_of_type;
];

Method "tuple of set of string" is
[
	_tuple_of_set_of_string;
];

Method "set of string" is
[
	_set_of_string;
];

Method "primitive failure function" is
[
	_primitive_failure_function;
];

Method "∅" is
[
	_empty_set;
];

Method "-∞" is
[
	_negative_infinity;
];

Method "∞" is
[
	_positive_infinity;
];

Method "pojo" is
[
	_pojo;
];

Method "null" is
[
	_null;
];

Method "pojo⊥" is
[
	_pojo_bottom;
];

Method "pojo self type" is
[
	_pojo_self_type;
];

Method "pojo meta" is
[
	_pojo_meta;
];

Method "pojo array meta" is
[
	_pojo_array_meta;
];

Method "pojo constructor" is
[
	_pojo_constructor;
];

Method "pojo array" is
[
	_pojo_array;
];

Method "pojo self" is
[
	_pojo_self;
];

Method "pojo exception" is
[
	_pojo_exception;
];

Method "nullary procedure" is
[
	_nullary_procedure;
];

Method "predicate function" is
[
	_predicate_function;
];

Method "continuation variable" is
[
	_continuation_variable;
];

Method "field map" is
[
	_field_map;
];

Method "field type map" is
[
	_field_type_map;
];

Method "key-value tuple" is
[
	_key_value_tuple;
];

Method "empty map" is
[
	_empty_map;
];

Method "non-empty map" is
[
	_non_empty_map;
];

Method "whole number meta" is
[
	_whole_number_meta;
];

Method "non-empty set" is
[
	_non_empty_set;
];

Method "tuple of tuple" is
[
	_tuple_of_tuple;
];

Method "nybble" is
[
	_nybble;
];

Method "tuple of nybble" is
[
	_tuple_of_nybble;
];

Method "unsigned short" is
[
	_unsigned_short;
];

Method "empty tuple" is
[
	_empty_tuple;
];

Method "unary procedure" is
[
	_unary_procedure;
];

Method "type of zero" is
[
	_type_of_zero;
];

Method "semantic restriction function" is
[
	_semantic_restriction_function;
];

Method "tuple of semantic restriction function" is
[
	_tuple_of_semantic_restriction_function;
];

Method "macro function" is
[
	_macro_function;
];

Method "type of two" is
[
	_type_of_two;
];

Method "Euler number" is
[
	_Euler_number;
];

Method "type of Euler number" is
[
	_type_of_Euler_number;
];

Method "phrase meta" is
[
	_phrase_meta;
];

Method "set of atom" is
[
	_set_of_atom;
];

Method "token" is
[
	_token;
];

Method "literal token" is
[
	_literal_token;
];

Method "tuple of any meta" is
[
	_tuple_of_any_meta;
];

Method "nonnegative integer" is
[
	_nonnegative_integer;
];

