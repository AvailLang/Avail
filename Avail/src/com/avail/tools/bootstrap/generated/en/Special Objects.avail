/*
 * Special Objects.avail
 * Copyright (c) 2011, Mark van Gulik.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * GENERATED FILE
 * * Generator: com.avail.tools.bootstrap.BootstrapGenerator
 * * Last Generated On: 2012.01.04 18:34:57.328 -0600
 *
 * DO NOT MODIFY MANUALLY. ALL MANUAL CHANGES WILL BE LOST.
 */

System Module "Special Objects"
Versions
	"dev"
Extends
	"Origin"
Uses
Names
	/* 78 */ "-∞",
	/* 42 */ "abstract signature",
	/*  1 */ "any",
	/* 62 */ "argument node",
	/* 53 */ "assignment node",
	/* 11 */ "atom",
	/* 54 */ "block node",
	/*  2 */ "boolean",
	/*  3 */ "character",
	/* 38 */ "code point",
	/*  6 */ "compiled code",
	/*  9 */ "continuation",
	/* 10 */ "continuation meta",
	/* 92 */ "continuation variable",
	/* 61 */ "declaration node",
	/* 12 */ "double",
	/* 21 */ "enumeration meta",
	/* 24 */ "enumeration meta meta",
	/* 52 */ "expression node",
	/* 13 */ "extended integer",
	/* 18 */ "extended integer meta",
	/* 71 */ "false",
	/* 14 */ "false type",
	/* 25 */ "fiber",
	/* 93 */ "field map",
	/* 94 */ "field type map",
	/* 15 */ "float",
	/* 43 */ "forward signature",
	/*  4 */ "function",
	/*  5 */ "function meta",
	/* 46 */ "implementation set",
	/* 17 */ "integer",
	/* 63 */ "label node",
	/* 55 */ "literal node",
	/* 65 */ "local constant node",
	/* 64 */ "local variable node",
	/* 19 */ "map meta",
	/* 51 */ "marker node",
	/* 40 */ "message bundle",
	/* 45 */ "message bundle tree",
	/* 20 */ "meta",
	/* 44 */ "method signature",
	/* 67 */ "module constant node",
	/* 66 */ "module variable node",
	/* 37 */ "natural number",
	/* 81 */ "null",
	/* 82 */ "null type",
	/* 90 */ "nullary procedure",
	/* 16 */ "number",
	/* 22 */ "object",
	/* 23 */ "object meta",
	/* 50 */ "parse node",
	/* 80 */ "pojo",
	/* 91 */ "predicate function",
	/* 76 */ "primitive failure function",
	/* 68 */ "primitive failure reason node",
	/* 56 */ "reference node",
	/* 83 */ "self type",
	/* 57 */ "send node",
	/* 26 */ "set",
	/* 27 */ "set meta",
	/* 75 */ "set of string",
	/* 41 */ "signature",
	/* 28 */ "string",
	/* 58 */ "super cast node",
	/* 70 */ "true",
	/* 31 */ "true type",
	/* 32 */ "tuple",
	/* 33 */ "tuple meta",
	/* 59 */ "tuple node",
	/* 74 */ "tuple of set of string",
	/* 72 */ "tuple of string",
	/* 73 */ "tuple of type",
	/* 34 */ "type",
	/*  7 */ "variable",
	/*  8 */ "variable meta",
	/* 60 */ "variable use node",
	/* 36 */ "whole number",
	/* 77 */ "∅",
	/* 79 */ "∞",
	/* 35 */ "⊤",
	/* 29 */ "⊥",
	/* 30 */ "⊥ meta"
Body

_any                           ::= special object 1;
_boolean                       ::= special object 2;
_character                     ::= special object 3;
_function                      ::= special object 4;
_function_meta                 ::= special object 5;
_compiled_code                 ::= special object 6;
_variable                      ::= special object 7;
_variable_meta                 ::= special object 8;
_continuation                  ::= special object 9;
_continuation_meta             ::= special object 10;
_atom                          ::= special object 11;
_double                        ::= special object 12;
_extended_integer              ::= special object 13;
_false_type                    ::= special object 14;
_float                         ::= special object 15;
_number                        ::= special object 16;
_integer                       ::= special object 17;
_extended_integer_meta         ::= special object 18;
_map_meta                      ::= special object 19;
_meta                          ::= special object 20;
_enumeration_meta              ::= special object 21;
_object                        ::= special object 22;
_object_meta                   ::= special object 23;
_enumeration_meta_meta         ::= special object 24;
_fiber                         ::= special object 25;
_set                           ::= special object 26;
_set_meta                      ::= special object 27;
_string                        ::= special object 28;
_bottom                        ::= special object 29;
_bottom_meta                   ::= special object 30;
_true_type                     ::= special object 31;
_tuple                         ::= special object 32;
_tuple_meta                    ::= special object 33;
_type                          ::= special object 34;
_top                           ::= special object 35;
_whole_number                  ::= special object 36;
_natural_number                ::= special object 37;
_code_point                    ::= special object 38;
_message_bundle                ::= special object 40;
_signature                     ::= special object 41;
_abstract_signature            ::= special object 42;
_forward_signature             ::= special object 43;
_method_signature              ::= special object 44;
_message_bundle_tree           ::= special object 45;
_implementation_set            ::= special object 46;
_parse_node                    ::= special object 50;
_marker_node                   ::= special object 51;
_expression_node               ::= special object 52;
_assignment_node               ::= special object 53;
_block_node                    ::= special object 54;
_literal_node                  ::= special object 55;
_reference_node                ::= special object 56;
_send_node                     ::= special object 57;
_super_cast_node               ::= special object 58;
_tuple_node                    ::= special object 59;
_variable_use_node             ::= special object 60;
_declaration_node              ::= special object 61;
_argument_node                 ::= special object 62;
_label_node                    ::= special object 63;
_local_variable_node           ::= special object 64;
_local_constant_node           ::= special object 65;
_module_variable_node          ::= special object 66;
_module_constant_node          ::= special object 67;
_primitive_failure_reason_node ::= special object 68;
_true                          ::= special object 70;
_false                         ::= special object 71;
_tuple_of_string               ::= special object 72;
_tuple_of_type                 ::= special object 73;
_tuple_of_set_of_string        ::= special object 74;
_set_of_string                 ::= special object 75;
_primitive_failure_function    ::= special object 76;
_empty_set                     ::= special object 77;
_negative_infinity             ::= special object 78;
_positive_infinity             ::= special object 79;
_pojo                          ::= special object 80;
_null                          ::= special object 81;
_null_type                     ::= special object 82;
_self_type                     ::= special object 83;
_nullary_procedure             ::= special object 90;
_predicate_function            ::= special object 91;
_continuation_variable         ::= special object 92;
_field_map                     ::= special object 93;
_field_type_map                ::= special object 94;

Method "any" is 
[
	_any;
];

Method "boolean" is 
[
	_boolean;
];

Method "character" is 
[
	_character;
];

Method "function" is 
[
	_function;
];

Method "function meta" is 
[
	_function_meta;
];

Method "compiled code" is 
[
	_compiled_code;
];

Method "variable" is 
[
	_variable;
];

Method "variable meta" is 
[
	_variable_meta;
];

Method "continuation" is 
[
	_continuation;
];

Method "continuation meta" is 
[
	_continuation_meta;
];

Method "atom" is 
[
	_atom;
];

Method "double" is 
[
	_double;
];

Method "extended integer" is 
[
	_extended_integer;
];

Method "false type" is 
[
	_false_type;
];

Method "float" is 
[
	_float;
];

Method "number" is 
[
	_number;
];

Method "integer" is 
[
	_integer;
];

Method "extended integer meta" is 
[
	_extended_integer_meta;
];

Method "map meta" is 
[
	_map_meta;
];

Method "meta" is 
[
	_meta;
];

Method "enumeration meta" is 
[
	_enumeration_meta;
];

Method "object" is 
[
	_object;
];

Method "object meta" is 
[
	_object_meta;
];

Method "enumeration meta meta" is 
[
	_enumeration_meta_meta;
];

Method "fiber" is 
[
	_fiber;
];

Method "set" is 
[
	_set;
];

Method "set meta" is 
[
	_set_meta;
];

Method "string" is 
[
	_string;
];

Method "⊥" is 
[
	_bottom;
];

Method "⊥ meta" is 
[
	_bottom_meta;
];

Method "true type" is 
[
	_true_type;
];

Method "tuple" is 
[
	_tuple;
];

Method "tuple meta" is 
[
	_tuple_meta;
];

Method "type" is 
[
	_type;
];

/**
 * The abstract root of the Avail type lattice, pronounced "top". When
 * appearing as the return type of a function type, it indicates that the
 * function is a procedure (i.e. it does not produce a value).Method "⊤" is 
[
	_top;
];

Method "whole number" is 
[
	_whole_number;
];

Method "natural number" is 
[
	_natural_number;
];

Method "code point" is 
[
	_code_point;
];

Method "message bundle" is 
[
	_message_bundle;
];

Method "signature" is 
[
	_signature;
];

Method "abstract signature" is 
[
	_abstract_signature;
];

Method "forward signature" is 
[
	_forward_signature;
];

Method "method signature" is 
[
	_method_signature;
];

Method "message bundle tree" is 
[
	_message_bundle_tree;
];

Method "implementation set" is 
[
	_implementation_set;
];

Method "parse node" is 
[
	_parse_node;
];

Method "marker node" is 
[
	_marker_node;
];

Method "expression node" is 
[
	_expression_node;
];

Method "assignment node" is 
[
	_assignment_node;
];

Method "block node" is 
[
	_block_node;
];

Method "literal node" is 
[
	_literal_node;
];

Method "reference node" is 
[
	_reference_node;
];

Method "send node" is 
[
	_send_node;
];

Method "super cast node" is 
[
	_super_cast_node;
];

Method "tuple node" is 
[
	_tuple_node;
];

Method "variable use node" is 
[
	_variable_use_node;
];

Method "declaration node" is 
[
	_declaration_node;
];

Method "argument node" is 
[
	_argument_node;
];

Method "label node" is 
[
	_label_node;
];

Method "local variable node" is 
[
	_local_variable_node;
];

Method "local constant node" is 
[
	_local_constant_node;
];

Method "module variable node" is 
[
	_module_variable_node;
];

Method "module constant node" is 
[
	_module_constant_node;
];

Method "primitive failure reason node" is 
[
	_primitive_failure_reason_node;
];

Method "true" is 
[
	_true;
];

Method "false" is 
[
	_false;
];

Method "tuple of string" is 
[
	_tuple_of_string;
];

Method "tuple of type" is 
[
	_tuple_of_type;
];

Method "tuple of set of string" is 
[
	_tuple_of_set_of_string;
];

Method "set of string" is 
[
	_set_of_string;
];

Method "primitive failure function" is 
[
	_primitive_failure_function;
];

Method "∅" is 
[
	_empty_set;
];

Method "-∞" is 
[
	_negative_infinity;
];

Method "∞" is 
[
	_positive_infinity;
];

Method "pojo" is 
[
	_pojo;
];

Method "null" is 
[
	_null;
];

Method "null type" is 
[
	_null_type;
];

Method "self type" is 
[
	_self_type;
];

Method "nullary procedure" is 
[
	_nullary_procedure;
];

Method "predicate function" is 
[
	_predicate_function;
];

Method "continuation variable" is 
[
	_continuation_variable;
];

Method "field map" is 
[
	_field_map;
];

Method "field type map" is 
[
	_field_type_map;
];

