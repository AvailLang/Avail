/*
 * Infallible Primitives.avail
 * Copyright (c) 2011, Mark van Gulik.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * GENERATED FILE
 * * Generator: com.avail.tools.bootstrap.BootstrapGenerator
 * * Last Generated On: 2012.01.04 17:34:06.974 -0600
 *
 * DO NOT MODIFY MANUALLY. ALL MANUAL CHANGES WILL BE LOST.
 */

System Module "Infallible Primitives"
Versions
	"dev"
Extends
	"Origin"
Uses
Names
	/*  51 */ "$_",
	/*  49 */ "$_@pc=_stack=_[_]caller=_",
	/*  39 */ "[…]→_",
	/*  52 */ "_'s caller",
	/*  72 */ "_'s compiled code",
	/*  53 */ "_'s function",
	/*  50 */ "_'s function type",
	/*  29 */ "_'s instances",
	/*   8 */ "_'s lower bound",
	/*  68 */ "_'s name:=_",
	/*  69 */ "_'s names",
	/*  73 */ "_'s outer variables",
	/*  35 */ "_'s parameters' type",
	/*  54 */ "_'s program counter",
	/*  14 */ "_'s read type",
	/*  37 */ "_'s return type",
	/*  59 */ "_'s stack",
	/*  55 */ "_'s stack pointer",
	/*  30 */ "_'s type",
	/*   9 */ "_'s upper bound",
	/*  19 */ "_'s write type",
	/*   5 */ "_<_",
	/*  60 */ "_=_",
	/*  27 */ "_[_]:=_",
	/*  64 */ "_as map",
	/*  61 */ "_as object",
	/*  63 */ "_as object type",
	/*  17 */ "_is unassigned",
	/*  32 */ "_∩_",
	/*  31 */ "_∪_",
	/*  33 */ "_≤_",
	/*  12 */ "clear_",
	/*  25 */ "current fiber",
	/*  66 */ "enumeration of_",
	/*  34 */ "function type accepting_and returning_",
	/*  44 */ "if_then_",
	/*  43 */ "if_then_else_",
	/*  45 */ "ignore_and evaluate_",
	/*   7 */ "integer range from_(inclusive=_)to_(inclusive=_)",
	/*  20 */ "milliseconds since the Epoch",
	/*  16 */ "new ↑_",
	/*  13 */ "↑_",
	/*  38 */ "∪_"
Body

/**
 * Is the first argument strictly less than the second argument?
 *
 * Parameters:
 *    arg1 - A number.
 *    arg2 - A number.
 * Returns:
 *    `true` if the first argument is strictly less than the second argument,
 *    `false` otherwise.
 */
Method "_<_" is 
[
	arg1 : number,
	arg2 : number
|
	Primitive 5;
] : boolean;

/**
 * Is the first argument less than or equal to the second argument?
 *
 * Parameters:
 *    arg1 - A number.
 *    arg2 - A number.
 * Returns:
 *    `true` if the first argument is less than or equal to the second
 *    argument, `false` otherwise.
 */
Method "_≤_" is 
[
	arg1 : number,
	arg2 : number
|
	Primitive 6;
] : boolean;

/**
 * Construct and answer an integral range type whose lower bound is `lowerBound`
 * and whose upper bound is `upperBound`.
 *
 * Parameters:
 *    lowerBound - The lower bound.
 *    lowerBoundInclusive -
 *       `true` if the lower bound should be adjudged inclusive, `false`
 *       otherwise.
 *    upperBound - The upper bound.
 *    upperBoundInclusive -
 *       `true` if the upper bound should be adjudged inclusive, `false`
 *       otherwise.
 * Returns:
 *    The requested integral range type.
 */
Method "integer range from_(inclusive=_)to_(inclusive=_)" is 
[
	lowerBound : extended integer,
	lowerBoundInclusive : boolean,
	upperBound : extended integer,
	upperBoundInclusive : boolean
|
	Primitive 7;
] : extended integer meta;

/**
 * Answer the lower bound of the specified integral range type.
 *
 * Parameters:
 *    range - An integral range type.
 * Returns:
 *    The lower bound of the argument.
 */
Method "_'s lower bound" is 
[
	range : extended integer meta
|
	Primitive 8;
] : extended integer;

/**
 * Answer the upper bound of the specified integral range type.
 *
 * Parameters:
 *    range - An integral range type.
 * Returns:
 *    The upper  bound of the argument.
 */
Method "_'s upper bound" is 
[
	range : extended integer meta
|
	Primitive 9;
] : extended integer;

/**
 * Clear the specified variable. This resets it to the unassigned state.
 *
 * Parameters:
 *    var - A variable.
 */
Method "clear_" is 
[
	var : variable
|
	Primitive 12;
] : ⊤;

/**
 * Construct and answer a variable type with the specified containment type.
 *
 * Parameters:
 *    containmentType - The containment type.
 * Returns:
 *    The requested variable type.
 */
Method "↑_" is 
[
	containmentType : type
|
	Primitive 13;
] : variable meta;

/**
 * Answer the read type of the specified variable type. All values read from
 * instances of the variable type are at least as specific as the answer.
 *
 * Parameters:
 *    varType - A variable type.
 * Returns:
 *    The most general type that describes values that can be read from
 *    instances of `varType`.
 */
Method "_'s read type" is 
[
	varType : variable meta
|
	Primitive 14;
] : type;

/**
 * Construct and answer a new variable with the specified containment type.
 *
 * Parameters:
 *    containmentType - The containment type.
 * Returns:
 *    A new variable capable of retrieving and storing values of the specified
 *    containment type.
 */
Method "new ↑_" is 
[
	containmentType : type
|
	Primitive 16;
] : variable;

/**
 * Does the specified variable contain a value?
 *
 * Parameters:
 *    var - A variable.
 * Returns:
 *    `true` if the variable contains a value (i.e. because it has previously
 *    been assigned), `false` otherwise.
 */
Method "_is unassigned" is 
[
	var : variable
|
	Primitive 17;
] : boolean;

/**
 * Answer the write type of the specified variable type. All values written to
 * instances of the variable type are at least as specific as the answer.
 *
 * Parameters:
 *    varType - A variable type.
 * Returns:
 *    The most general type that describes values that can be written to
 *    instances of `varType`.
 */
Method "_'s write type" is 
[
	varType : variable meta
|
	Primitive 19;
] : type;

/**
 * Answer the number of milliseconds which have elapsed since midnight
 * Coordinated Universal Time (UTC) of Thursday, January 1, 1970 (i.e. the Unix
 * Epoch).
 *
 * Returns:
 *    The current time as the number of milliseconds which have elapsed since
 *    the Unix Epoch.
 */
Method "milliseconds since the Epoch" is 
[
	Primitive 20;
] : whole number;

/**
 * Answer the current fiber.
 *
 * Returns:
 *    The current fiber.
 */
Method "current fiber" is 
[
	Primitive 25;
] : fiber;

/**
 * Set the value bound to `key` in the specified fiber's environment,
 * overwriting any previous value. Since the fiber's environment essentially
 * contains fiber-local variables (i.e. bindings from atoms to arbitrary
 * values), this operation effectively writes a fiber-local variable.
 *
 * Parameters:
 *    aFiber - The fiber whose environment should be consulted.
 *    key - The key whose value should be (over)written.
 *    value - The new value.
 */
Method "_[_]:=_" is 
[
	aFiber : fiber,
	key : atom,
	value : any
|
	Primitive 27;
] : ⊤;

/**
 * Answer the instances of the enumeration.
 *
 * Parameters:
 *    enum - An enumeration.
 * Returns:
 *    A set whose members are the instances of the enumeration.
 */
Method "_'s instances" is 
[
	enum : enumeration meta
|
	Primitive 29;
] : set;

/**
 * Answer the precise instance type of the supplied value. This is the most
 * specific possible type that describes the value.
 *
 * Parameters:
 *    value - An arbitrary value.
 * Returns:
 *    The precise instance type of the supplied value.
 */
Method "_'s type" is 
[
	value : any
|
	Primitive 30;
] : enumeration meta;

/**
 * Compute and answer the type union of the two types. This is the most
 * specific type that is a supertype of both types.
 *
 * Parameters:
 *    arg1 - A type.
 *    arg2 - A type.
 * Returns:
 *    The type union of the arguments.
 */
Method "_∪_" is 
[
	arg1 : type,
	arg2 : type
|
	Primitive 31;
] : type;

/**
 * Compute and answer the type intersection of the two types. This is the most
 * general type that is a subtype of both types.
 *
 * Parameters:
 *    arg1 - A type.
 *    arg2 - A type.
 * Returns:
 *    The type intersection of the arguments.
 */
Method "_∩_" is 
[
	arg1 : type,
	arg2 : type
|
	Primitive 32;
] : type;

/**
 * Is the first argument a subtype of the second argument? This does not
 * implement the proper subtype relation, so the first argument is considered
 * a subtype of the second argument also if it is equal to the second argument.
 *
 * Parameters:
 *    arg1 - A type.
 *    arg2 - A type.
 * Returns:
 *    `true` if the first argument is a subtype of, or the same type as, the
 *    second argument, `false` otherwise.
 */
Method "_≤_" is 
[
	arg1 : type,
	arg2 : type
|
	Primitive 33;
] : boolean;

/**
 * Construct and answer a function type with the specified parameter types and
 * return type.
 *
 * Parameters:
 *    parameterTypes - The parameter types.
 *    returnType - The return type.
 * Returns:
 *    The requested function type. Instances of this type accept arguments
 *    whose types conform to the parameter types and whose return value
 *    conforms to the return type.
 */
Method "function type accepting_and returning_" is 
[
	parameterTypes : tuple of type,
	returnType : type
|
	Primitive 34;
] : function meta;

/**
 * Answer a tuple type that describes the parameter types of the specified
 * function type.
 *
 * Parameters:
 *    functionType - A function type.
 * Returns:
 *    A fixed-size tuple type whose element types correspond to the parameter
 *    types of the argument.
 */
Method "_'s parameters' type" is 
[
	functionType : function meta
|
	Primitive 35;
] : tuple meta;

/**
 * Answer the return type of the specified function type.
 *
 * Parameters:
 *    functionType - A function type.
 * Returns:
 *    The return type of the argument.
 */
Method "_'s return type" is 
[
	functionType : function meta
|
	Primitive 37;
] : type;

/**
 * Compute and answer the type union of the elements of the given tuple of
 * types.
 *
 * Parameters:
 *    tupleOfTypes - A tuple of types.
 * Returns:
 *    The type union of the elements of the argument.
Method "∪_" is 
[
	tupleOfTypes : tuple of type
|
	Primitive 38;
] : type;

/**
 * Construct and answer a function type with the specified return type.
 * Instances of this type include any function that returns a value of the
 * specified return type, irrespective of the number or types of its parameters.
 *
 * Parameters:
 *    returnType - A type.
 * Returns:
 *    The requested function type. Instances of this type answer values of the
 *    specified return type.
 */
Method "[…]→_" is 
[
	returnType : type
|
	Primitive 39;
] : function meta;

/**
 * Given a predicate value and two functions, invoke one of them and answer its
 * result.
 *
 * Parameters:
 *    predicate - A predicate value.
 *    trueFunction - The function to invoke if `predicate` is `true`.
 *    falseFunction - The function to invoke if `trueFunction` is `false`.
 * Returns:
 *    If `predicate` is `true`, then the value produced by invoking
 *    `trueFunction`; otherwise, the value produced by invoking `falseFunction`.
 */
Method "if_then_else_" is 
[
	predicate : boolean,
	trueFunction : nullary procedure,
	falseFunction : nullary procedure
|
	Primitive 43;
] : ⊤;

/**
 * Given a predicate value and a function, conditionally invoke the specified
 * function.
 *
 * Parameters:
 *    predicate - A predicate value.
 *    trueBlock - The function to invoke if `predicate` is `true`.
 */
Method "if_then_" is 
[
	predicate : boolean,
	trueBlock : nullary procedure
|
	Primitive 44;
] : ⊤;

Method "ignore_and evaluate_" is 
[
	arg1 : boolean,
	arg2 : predicate function
|
	Primitive 45;
] : boolean;

/**
 * Construct and answer a continuation whose current function, Level One
 * program counter, local stack, local stack pointer, and calling continuation
 * are specified by the arguments.
 *
 * Parameters:
 *    aFunction - The new continuation's current function.
 *    programCounter - `aFunction`'s program counter. This is the index of the
 *       next Level One instruction to execute when the new continuation is
 *       resumed.
 *    stack - `aFunction`'s stack. This tuple contains the arguments, local
 *       variables, and temporaries.
 *    stackPointer - `aFunction`'s stack pointer. This is the index of the
 *       top of the stack.
 *    caller - A variable holding the new continuation's calling continuation.
 *       If the variable is unassigned, then create a root continuation (i.e.
 *       one without a caller).
 * Returns:
 *    The requested continuation.
 */
Method "$_@pc=_stack=_[_]caller=_" is 
[
	aFunction : function,
	programCounter : natural number,
	stack : tuple,
	stackPointer : natural number,
	caller : continuation variable
|
	Primitive 49;
] : continuation;

/**
 * Answer the type of the function represented by the specified continuation.
 *
 * Parameters:
 *    aContinuation - A continuation.
 * Returns:
 *    The argument's current function's type.
 */
Method "_'s function type" is 
[
	aContinuation : continuation meta
|
	Primitive 50;
] : function meta;

/**
 * Compute and answer a continuation type capable of representing a current
 * function of the specified type.
 *
 * Parameters:
 *    functionType - A function type.
 * Returns:
 *    The requested continuation type.
 */
Method "$_" is 
[
	functionType : function meta
|
	Primitive 51;
] : continuation meta;

/**
 * Construct and answer a variable that holds the caller of the specified
 * continuation. This variable will be unassigned if the continuation has no
 * caller.
 *
 * Parameters:
 *    aContinuation - A continuation.
 * Returns:
 *    A variable that, if assigned, holds the argument's caller. If unassigned,
 *    then the argument has no caller.
 */
Method "_'s caller" is 
[
	aContinuation : continuation
|
	Primitive 52;
] : continuation variable;

/**
 * Answer the current function of the specified continuation.
 *
 * Parameters:
 *    aContinuation - A continuation.
 * Returns:
 *    The argument's current function. This is the function whose execution
 *    will be resumed if the continuation is resumed.
 */
Method "_'s function" is 
[
	aContinuation : continuation
|
	Primitive 53;
] : function;

/**
 * Answer the program counter of the specified continuation. Using the current
 * function's tuple of Level One nybblecodes, this is the index of the next
 * instruction to be performed (if the continuation is resumed).
 *
 * Parameters:
 *    aContinuation - A continuation.
 * Returns:
 *    The argument's Level One program counter.
 */
Method "_'s program counter" is 
[
	aContinuation : continuation
|
	Primitive 54;
] : natural number;

/**
 * Answer the stack pointer of the specified continuation. This is the index of
 * the top of the local stack. For an empty stack, this value equals the size of
 * the stack plus one. The stack grows downward.
 *
 * Parameters:
 *    aContinuation - A continuation.
 * Returns:
 *    The argument's stack pointer.
 */
Method "_'s stack pointer" is 
[
	aContinuation : continuation
|
	Primitive 55;
] : natural number;

/**
 * Answer the stack of the specified continuation. This tuple contains the
 * arguments, local variables, and temporaries. Any null values, forbidden to
 * leak through into observable Avail macrostate, are replaced with an
 * unassigned variable whose containment type is ⊥. Note that such a variable
 * cannot be constructed either syntactically nor through a variable
 * construction primitive.
 *
 * Parameters:
 *    aContinuation - A continuation.
 * Returns:
 *    The argument's stack.
 */
Method "_'s stack" is 
[
	aContinuation : continuation
|
	Primitive 59;
] : tuple;

/**
 * Are the arguments equal?
 *
 * Parameters:
 *    arg1 - A value.
 *    arg2 - A value.
 * Returns:
 *    `true` if the arguments are equal, `false` otherwise.
 */
Method "_=_" is 
[
	arg1 : any,
	arg2 : any
|
	Primitive 60;
] : boolean;

/**
 * Construct and answer an object based on the supplied map.
 *
 * Parameters:
 *    fieldsToValues - A map whose keys are the fields of the new object and whose values
 *       are the corresponding field values.
 * Returns:
 *    The requested object.
 */
Method "_as object" is 
[
	fieldsToValues : field map
|
	Primitive 61;
] : object;

/**
 * Construct and answer a map based on the supplied object.
 *
 * Parameters:
 *    anObject - An object whose fields should be the keys of the new map and whose
 *       values are the corresponding values.
 * Returns:
 *    The requested map.
 */
Method "_as map" is 
[
	anObject : object
|
	Primitive 62;
] : field map;

/**
 * Construct and answer an object type based on the supplied map.
 *
 * Parameters:
 *    fieldsToTypes - A map whose keys are the fields of the new object and whose values
 *       are the corresponding field types.
 * Returns:
 *    The requested object type.
 */
Method "_as object type" is 
[
	fieldsToTypes : field map
|
	Primitive 63;
] : object meta;

/**
 * Construct and answer a map based on the supplied object type.
 *
 * Parameters:
 *    anObjectType - An object type whose fields should be the keys of the new map and
 *       whose values are the corresponding values.
 * Returns:
 *    The requested map.
 */
Method "_as map" is 
[
	anObjectType : object meta
|
	Primitive 64;
] : field type map;

/**
 * Construct and answer an enumeration whose instances are fully determined by
 * the membership of the specified set.
 *
 * Parameters:
 *    instances - The complete set of instances of the enumeration.
 * Returns:
 *    The requested enumeration.
 */
Method "enumeration of_" is 
[
	instances : set
|
	Primitive 65;
] : enumeration meta;

/**
 * Construct and answer an enumeration meta whose instances instances are
 * universally subtypes of `{0}`.
 *
 * Parameters:
 *    {0} - The complete set of instances of the enumeration.
 * Returns:
 *    The requested enumeration meta.
 */
Method "enumeration of_" is 
[
	instanceType : type
|
	Primitive 66;
] : enumeration meta meta;

/**
 * For the purpose of debugging, bind a name to an object type. This name will
 * be used for subtypes that do not bind a more specific name to describe their
 * own subtypes.
 *
 * Parameters:
 *    anObjectType - An object type.
 *    name - The name that should be bound to the object type. This will replace
 *       a previously bound name.
 */
Method "_'s name:=_" is 
[
	anObjectType : object meta,
	name : string
|
	Primitive 68;
] : ⊤;

/**
 * Answer the set of locally most-specific names bound to the specified object
 * type.
 *
 * Parameters:
 *    anObjectType - An object type.
 * Returns:
 *    The set of locally most-specific names bound to the specified object
 *    type.
 */
Method "_'s names" is 
[
	anObjectType : object meta
|
	Primitive 69;
] : set of string;

Method "_'s compiled code" is 
[
	arg1 : function
|
	Primitive 72;
] : compiled code;

Method "_'s outer variables" is 
[
	arg1 : function
|
	Primitive 73;
] : tuple;

