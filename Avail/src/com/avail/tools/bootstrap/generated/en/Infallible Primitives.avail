/*
 * Infallible Primitives.avail
 * Copyright (c) 2011, Mark van Gulik.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * GENERATED FILE
 * * Generator: com.avail.tools.bootstrap.BootstrapGenerator
 * * Last Generated On: 2011.12.21 18:22:44.589 -0600
 *
 * DO NOT MODIFY MANUALLY. ALL MANUAL CHANGES WILL BE LOST.
 */

System Module "Infallible Primitives"
Versions
	"dev"
Extends
	"Origin"
Uses
Names
	/*  51 */ "$_",
	/*  72 */ "_'s compiled code",
	/*  50 */ "_'s function type",
	/*  29 */ "_'s instances",
	/*   8 */ "_'s lower bound",
	/*  67 */ "_'s name",
	/*  69 */ "_'s names",
	/*  73 */ "_'s outer variables",
	/*  35 */ "_'s parameters' type",
	/*  14 */ "_'s read type",
	/*  37 */ "_'s return type",
	/*  30 */ "_'s type",
	/*   9 */ "_'s upper bound",
	/*  19 */ "_'s write type",
	/*   5 */ "_<_",
	/*  60 */ "_=_",
	/*  27 */ "_[_]:=_",
	/*  64 */ "_as map",
	/*  63 */ "_as object type",
	/*  61 */ "_as private unvalidated object",
	/*  17 */ "_is unassigned",
	/*  32 */ "_∩_",
	/*  31 */ "_∪_",
	/*  33 */ "_≤_",
	/*  12 */ "clear_",
	/*  25 */ "current fiber",
	/*  66 */ "enum of_",
	/*  34 */ "function type accepting_and returning_",
	/*  68 */ "give type_the name_",
	/*  44 */ "if_then_",
	/*  43 */ "if_then_else_",
	/*  45 */ "ignore_and evaluate_",
	/*   7 */ "integer range from_(inclusive=_)to_(inclusive=_)",
	/*  16 */ "new ↑_",
	/*  38 */ "union of types in_",
	/*  13 */ "↑_",
	/*  39 */ "⊶[…]→_"
Body

/**
 * Is the first argument strictly less than the second argument?
 *
 * Parameters:
 *    arg1 - A number.
 *    arg2 - A number.
 * Returns:
 *    `true` if the first argument is strictly less than the second argument,
 *    `false` otherwise.
 */
Method "_<_" is 
[
	arg1 : extended integer,
	arg2 : extended integer
|
	Primitive 5;
] : boolean;

/**
 * Is the first argument less than or equal to the second argument?
 *
 * Parameters:
 *    arg1 - A number.
 *    arg2 - A number.
 * Returns:
 *    `true` if the first argument is less than or equal to the second
 *    argument, `false` otherwise.
 */
Method "_≤_" is 
[
	arg1 : extended integer,
	arg2 : extended integer
|
	Primitive 6;
] : boolean;

/**
 * Construct and answer an integral range type whose lower bound is `lowerBound`
 * and whose upper bound is `upperBound`.
 *
 * Parameters:
 *    lowerBound - The lower bound.
 *    lowerBoundInclusive -
 *       `true` if the lower bound should be adjudged inclusive, `false`
 *       otherwise.
 *    upperBound - The upper bound.
 *    upperBoundInclusive -
 *       `true` if the upper bound should be adjudged inclusive, `false`
 *       otherwise.
 * Returns:
 *    The requested integral range type.
 */
Method "integer range from_(inclusive=_)to_(inclusive=_)" is 
[
	lowerBound : extended integer,
	lowerBoundInclusive : boolean,
	upperBound : extended integer,
	upperBoundInclusive : boolean
|
	Primitive 7;
] : extended integer meta;

/**
 * Answer the lower bound of the specified integral range type.
 *
 * Parameters:
 *    range - An integral range type.
 * Returns:
 *    The lower bound of the argument.
 */
Method "_'s lower bound" is 
[
	range : extended integer meta
|
	Primitive 8;
] : extended integer;

/**
 * Answer the upper bound of the specified integral range type.
 *
 * Parameters:
 *    range - An integral range type.
 * Returns:
 *    The upper  bound of the argument.
 */
Method "_'s upper bound" is 
[
	range : extended integer meta
|
	Primitive 9;
] : extended integer;

/**
 * Clear the specified variable. This resets it to the unassigned state.
 *
 * Parameters:
 *    var - A variable.
 */
Method "clear_" is 
[
	var : variable
|
	Primitive 12;
] : ⊤;

/**
 * Construct and answer a variable type with the specified containment type.
 *
 * Parameters:
 *    containmentType - The containment type.
 * Returns:
 *    The requested variable type.
 */
Method "↑_" is 
[
	containmentType : type
|
	Primitive 13;
] : variable meta;

/**
 * Answer the read type of the specified variable type. All values read from
 * instances of the variable type are at least as specific as the answer.
 *
 * Parameters:
 *    varType - A variable type.
 * Returns:
 *    The most general type that describes values that can be read from
 *    instances of `varType`.
 */
Method "_'s read type" is 
[
	varType : variable meta
|
	Primitive 14;
] : type;

/**
 * Construct and answer a new variable with the specified containment type.
 *
 * Parameters:
 *    containmentType - The containment type.
 * Returns:
 *    A new variable capable of retrieving and storing values of the specified
 *    containment type.
 */
Method "new ↑_" is 
[
	containmentType : type
|
	Primitive 16;
] : variable;

/**
 * Does the specified variable contain a value?
 *
 * Parameters:
 *    var - A variable.
 * Returns:
 *    `true` if the variable contains a value (i.e. because it has previously
 *    been assigned), `false` otherwise.
 */
Method "_is unassigned" is 
[
	var : variable
|
	Primitive 17;
] : boolean;

/**
 * Answer the write type of the specified variable type. All values written to
 * instances of the variable type are at least as specific as the answer.
 *
 * Parameters:
 *    varType - A variable type.
 * Returns:
 *    The most general type that describes values that can be written to
 *    instances of `varType`.
 */
Method "_'s write type" is 
[
	varType : variable meta
|
	Primitive 19;
] : type;

/**
 * Answer the current fiber.
 *
 * Returns:
 *    The current fiber.
 */
Method "current fiber" is 
[
	Primitive 25;
] : fiber;

/**
 * Set the value bound to `key` in the specified fiber's environment,
 * overwriting any previous value. Since the fiber's environment essentially
 * contains fiber-local variables (i.e. bindings from atoms to arbitrary
 * values), this operation effectively writes a fiber-local variable.
 *
 * Parameters:
 *    aFiber - The fiber whose environment should be consulted.
 *    key - The key whose value should be (over)written.
 *    value - The new value.
 */
Method "_[_]:=_" is 
[
	aFiber : fiber,
	key : atom,
	value : any
|
	Primitive 27;
] : ⊤;

/**
 * Answer the instances of the enumeration.
 *
 * Parameters:
 *    enum - An enumeration.
 * Returns:
 *    A set whose members are the instances of the enumeration.
 */
Method "_'s instances" is 
[
	enum : enumeration meta
|
	Primitive 29;
] : set;

/**
 * Answer the precise instance type of the supplied value. This is the most
 * specific possible type that describes the value.
 *
 * Parameters:
 *    value - An arbitrary value.
 * Returns:
 *    The precise instance type of the supplied value.
 */
Method "_'s type" is 
[
	value : any
|
	Primitive 30;
] : enumeration meta;

/**
 * Compute and answer the type union of the two types. This is the most
 * specific type that is a supertype of both types.
 *
 * Parameters:
 *    arg1 - A type.
 *    arg2 - A type.
 * Returns:
 *    The type union of the arguments.
 */
Method "_∪_" is 
[
	arg1 : type,
	arg2 : type
|
	Primitive 31;
] : type;

/**
 * Compute and answer the type intersection of the two types. This is the most
 * general type that is a subtype of both types.
 *
 * Parameters:
 *    arg1 - A type.
 *    arg2 - A type.
 * Returns:
 *    The type intersection of the arguments.
 */
Method "_∩_" is 
[
	arg1 : type,
	arg2 : type
|
	Primitive 32;
] : type;

/**
 * Is the first argument a subtype of the second argument? This does not
 * implement the proper subtype relation, so the first argument is considered
 * a subtype of the second argument also if it is equal to the second argument.
 *
 * Parameters:
 *    arg1 - A type.
 *    arg2 - A type.
 * Returns:
 *    `true` if the first argument is a subtype of, or the same type as, the
 *    second argument, `false` otherwise.
 */
Method "_≤_" is 
[
	arg1 : type,
	arg2 : type
|
	Primitive 33;
] : boolean;

/**
 * Construct and answer a function type with the specified parameter types and
 * return type.
 *
 * Parameters:
 *    parameterTypes - The parameter types.
 *    returnType - The return type.
 * Returns:
 *    The requested function type. Instances of this type accept arguments
 *    whose types conform to the parameter types and whose return value
 *    conforms to the return type.
 */
Method "function type accepting_and returning_" is 
[
	parameterTypes : tuple of type,
	returnType : type
|
	Primitive 34;
] : function meta;

Method "_'s parameters' type" is 
[
	arg1 : function meta
|
	Primitive 35;
] : tuple meta;

Method "_'s return type" is 
[
	arg1 : function meta
|
	Primitive 37;
] : type;

Method "union of types in_" is 
[
	arg1 : tuple of type
|
	Primitive 38;
] : type;

Method "⊶[…]→_" is 
[
	arg1 : type
|
	Primitive 39;
] : function meta;

Method "if_then_else_" is 
[
	arg1 : boolean,
	arg2 : null,
	arg3 : null
|
	Primitive 43;
] : ⊤;

Method "if_then_" is 
[
	arg1 : boolean,
	arg2 : null
|
	Primitive 44;
] : ⊤;

Method "ignore_and evaluate_" is 
[
	arg1 : boolean,
	arg2 : null
|
	Primitive 45;
] : boolean;

Method "_'s function type" is 
[
	arg1 : continuation meta
|
	Primitive 50;
] : function meta;

Method "$_" is 
[
	arg1 : function meta
|
	Primitive 51;
] : continuation meta;

Method "_=_" is 
[
	arg1 : any,
	arg2 : any
|
	Primitive 60;
] : boolean;

Method "_as private unvalidated object" is 
[
	arg1 : null
|
	Primitive 61;
] : object;

Method "_as map" is 
[
	arg1 : object
|
	Primitive 62;
] : null;

Method "_as object type" is 
[
	arg1 : null
|
	Primitive 63;
] : object meta;

Method "_as map" is 
[
	arg1 : object meta
|
	Primitive 64;
] : null;

Method "enum of_" is 
[
	arg1 : type
|
	Primitive 66;
] : null;

Method "_'s name" is 
[
	arg1 : type
|
	Primitive 67;
] : string;

Method "give type_the name_" is 
[
	arg1 : object meta,
	arg2 : string
|
	Primitive 68;
] : ⊤;

Method "_'s names" is 
[
	arg1 : object meta
|
	Primitive 69;
] : set of string;

Method "_'s compiled code" is 
[
	arg1 : function
|
	Primitive 72;
] : compiled code;

Method "_'s outer variables" is 
[
	arg1 : function
|
	Primitive 73;
] : tuple;

