/*
 * Infallible Primitives.avail
 * Copyright © 1993-2014, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * GENERATED FILE
 * * Generator: com.avail.tools.bootstrap.BootstrapGenerator
 * * Last Versioned As: $$Revision$$
 *
 * DO NOT MODIFY MANUALLY. ALL MANUAL CHANGES WILL BE LOST.
 */

Module "Infallible Primitives"
Versions
	"dev"
Extends
Uses
	"Origin",
	"Special Objects",
	"Primitives" =
	(
		"$_",
		"<_,_`…`|_>",
		"Assert:_(_)",
		"Breakpoint",
		"Crash:_",
		"Error:_",
		"If_then_",
		"If|if_then_else_",
		"Park current fiber",
		"Print:_",
		"Request termination of_",
		"Restart_",
		"Resume_",
		"Sleep for_millisecond|milliseconds",
		"Terminate current fiber",
		"Unpark_",
		"Yield current fiber",
		"[`…]→_",
		"_'s⁇arguments",
		"_'s⁇arity",
		"_'s⁇atom",
		"_'s⁇bindings",
		"_'s⁇caller",
		"_'s⁇code point",
		"_'s⁇declaration",
		"_'s⁇declared exceptions",
		"_'s⁇declared type",
		"_'s⁇default type",
		"_'s⁇element type",
		"_'s⁇element|member type",
		"_'s⁇expressions",
		"_'s⁇function",
		"_'s⁇function type",
		"_'s⁇genuine lower bound",
		"_'s⁇genuine upper bound",
		"_'s⁇implementation",
		"_'s⁇key type",
		"_'s⁇keys",
		"_'s⁇leading types",
		"_'s⁇leading whitespace",
		"_'s⁇lexeme",
		"_'s⁇line number",
		"_'s⁇literals",
		"_'s⁇maximum stack depth",
		"_'s⁇method",
		"_'s⁇name",
		"_'s⁇name:=_",
		"_'s⁇names",
		"_'s⁇nybblecodes",
		"_'s⁇outer variables",
		"_'s⁇parameters'type",
		"_'s⁇primitive number",
		"_'s⁇priority",
		"_'s⁇priority:=_",
		"_'s⁇program counter",
		"_'s⁇public names",
		"_'s⁇read type",
		"_'s⁇referent",
		"_'s⁇result type",
		"_'s⁇return type",
		"_'s⁇seals",
		"_'s⁇semantic type",
		"_'s⁇stack",
		"_'s⁇stack pointer",
		"_'s⁇starting position",
		"_'s⁇statements",
		"_'s⁇target",
		"_'s⁇token",
		"_'s⁇trailing whitespace",
		"_'s⁇type",
		"_'s⁇value",
		"_'s⁇value type",
		"_'s⁇values",
		"_'s⁇write type",
		"_++_",
		"_+_",
		"_+_→_",
		"_-_",
		"_<_",
		"_=_",
		"_[_]",
		"_\\_",
		"_^_",
		"_bit∧_",
		"_bit∨_",
		"_bit⊕_",
		"_has result",
		"_has terminated",
		"_is a primitive",
		"_is unassigned",
		"_mod_",
		"_reversed",
		"_→/→_",
		"_→block phrase",
		"_→character",
		"_→double",
		"_→float",
		"_→list phrase",
		"_→map",
		"_→object",
		"_→object type",
		"_→set",
		"_→tuple",
		"_⇒_",
		"_∈_",
		"_∩_",
		"_∪_",
		"_≤_",
		"_⊆_",
		"_⨉_^_",
		"``_``(_)",
		"`|_'s⁇local variables`|",
		"`|_'s⁇outer variables`|",
		"`|_'s⁇parameters`|",
		"`|_`|",
		"`|`|_`|`|",
		"`«$_:_`»",
		"`«_::=_`»",
		"`«_:_:=_`»",
		"`«_:_`»",
		"`«↓_`»(_)",
		"arg`«_:_`»",
		"concatenate_",
		"current fiber",
		"current fiber is applying a semantic restriction",
		"enumeration of_",
		"fiber→_",
		"function accepting_and returning_",
		"high-precision timer value",
		"integer range from_(inclusive=_)to_(inclusive=_)",
		"literal token⇒_",
		"ln_",
		"method exists named_",
		"milliseconds since the Epoch",
		"new atom named_",
		"new_[_]",
		"new_applying_",
		"new↑_",
		"primfail`«_:_`»",
		"primitive description of_",
		"semantic restrictions for_given_",
		"special atoms",
		"termination requested",
		"{_`|_}",
		"{_→_`|_}",
		"‘_’",
		"↑_",
		"↓_`?=_'s⁇initialization",
		"∪_",
		"∪_[_.._]",
		"⎡_⎤",
		"⎣_⎦"
	)
Names
Body

/**
 * Is the first argument strictly less than the second argument?
 *
 * @category "Primitives"
 * @method "_<_"
 * @param "arg1" "number"
 *        A number.
 * @param "arg2" "number"
 *        A number.
 * @returns "boolean"
 *    `true` if the first argument is strictly less than the second argument,
 *    `false` otherwise.
 */
Primitive "_<_" is
[
	arg1 : number,
	arg2 : number
|
	Primitive 5;
] : boolean;

/**
 * Is the first argument less than or equal to the second argument?
 *
 * @category "Primitives"
 * @method "_≤_"
 * @param "arg1" "number"
 *        A number.
 * @param "arg2" "number"
 *        A number.
 * @returns "boolean"
 *    `true` if the first argument is less than or equal to the second
 *    argument, `false` otherwise.
 */
Primitive "_≤_" is
[
	arg1 : number,
	arg2 : number
|
	Primitive 6;
] : boolean;

/**
 * Construct and answer an integral range type whose lower bound is {@param "lowerBound"}
 * and whose upper bound is {@param "upperBound"}.
 *
 * @category "Primitives"
 * @method "integer range from_(inclusive=_)to_(inclusive=_)"
 * @param "lowerBound" "extended integer"
 *        The lower bound.
 * @param "lowerBoundInclusive" "boolean"
 *        `true` if the lower bound should be adjudged inclusive, `false`
 *        otherwise.
 * @param "upperBound" "extended integer"
 *        The upper bound.
 * @param "upperBoundInclusive" "boolean"
 *        `true` if the upper bound should be adjudged inclusive, `false`
 *        otherwise.
 * @returns "([-∞..∞])'s type"
 *    The requested integral range type.
 */
Primitive "integer range from_(inclusive=_)to_(inclusive=_)" is
[
	lowerBound : extended integer,
	lowerBoundInclusive : boolean,
	upperBound : extended integer,
	upperBoundInclusive : boolean
|
	Primitive 7;
] : extended integer meta;

/**
 * Answer the lower bound of the specified integral range type.
 *
 * @category "Primitives"
 * @method "_'s⁇genuine lower bound"
 * @param "range" "extended integer meta"
 *        An integral range type.
 * @returns "[-∞..∞]"
 *    The lower bound of the argument.
 */
Primitive "_'s⁇genuine lower bound" is
[
	range : extended integer meta
|
	Primitive 8;
] : extended integer;

/**
 * Answer the upper bound of the specified integral range type.
 *
 * @category "Primitives"
 * @method "_'s⁇genuine upper bound"
 * @param "range" "extended integer meta"
 *        An integral range type.
 * @returns "[-∞..∞]"
 *    The upper bound of the argument.
 */
Primitive "_'s⁇genuine upper bound" is
[
	range : extended integer meta
|
	Primitive 9;
] : extended integer;

/**
 * Construct and answer a variable type with the specified containment type.
 *
 * @category "Primitives"
 * @method "↑_"
 * @param "containmentType" "any meta"
 *        The containment type.
 * @returns "(⊤→/→⊥)'s type"
 *    The requested variable type.
 */
Primitive "↑_" is
[
	containmentType : any meta
|
	Primitive 13;
] : variable meta;

/**
 * Answer the read type of the specified variable type. All values read from
 * instances of the variable type are at least as specific as the answer.
 *
 * @category "Primitives"
 * @method "_'s⁇read type"
 * @param "varType" "variable meta"
 *        A variable type.
 * @returns "(⊤)'s type"
 *    The most general type that describes values that can be read from
 *    instances of {@param "varType"}.
 */
Primitive "_'s⁇read type" is
[
	varType : variable meta
|
	Primitive 14;
] : type;

/**
 * Construct and answer a new variable with the specified containment type.
 *
 * @category "Primitives"
 * @method "new↑_"
 * @param "containmentType" "any meta"
 *        The containment type.
 * @returns "⊤→/→⊥"
 *    A new variable capable of retrieving and storing values of the specified
 *    containment type.
 */
Primitive "new↑_" is
[
	containmentType : any meta
|
	Primitive 16;
] : variable;

/**
 * Is the specified variable unassigned?
 *
 * @category "Primitives"
 * @method "_is unassigned"
 * @param "var" "variable"
 *        A variable.
 * @returns "boolean"
 *    `true` if the variable does not contain a value (i.e. because it has
 *    never previously been assigned), `false` otherwise.
 */
Primitive "_is unassigned" is
[
	var : variable
|
	Primitive 17;
] : boolean;

/**
 * Answer the write type of the specified variable type. All values written to
 * instances of the variable type are at least as specific as the answer.
 *
 * @category "Primitives"
 * @method "_'s⁇write type"
 * @param "varType" "variable meta"
 *        A variable type.
 * @returns "(⊤)'s type"
 *    The most general type that describes values that can be written to
 *    instances of {@param "varType"}.
 */
Primitive "_'s⁇write type" is
[
	varType : variable meta
|
	Primitive 19;
] : type;

/**
 * Answer the number of milliseconds which have elapsed since midnight
 * Coordinated Universal Time (UTC) of Thursday, January 1, 1970 (i.e. the Unix
 * Epoch).
 *
 * @returns "[0..∞)"
 *    The current time as the number of milliseconds which have elapsed since
 *    the Unix Epoch.
 */
Primitive "milliseconds since the Epoch" is
[
	Primitive 27;
] : whole number;

/**
 * Answer the number of instances of the specified type. This is `∞` for all
 * types except for enumerations.
 *
 * @category "Primitives"
 * @method "`|_`|"
 * @param "aType" "type"
 *        A type.
 * @returns "[0..∞]"
 *    The cardinality of the membership of the type.
 */
Primitive "`|_`|" is
[
	aType : type
|
	Primitive 28;
] : nonnegative extended integer;

/**
 * Answer the precise instance type of the supplied value. This is the most
 * specific possible type that describes the value.
 *
 * @category "Primitives"
 * @method "_'s⁇type"
 * @param "value" "any"
 *        An arbitrary value.
 * @returns "(⊤)'s type"
 *    The precise instance type of the supplied value.
 */
Primitive "_'s⁇type" is
[
	value : any
|
	Primitive 30;
] : type;

/**
 * Compute and answer the type union of the two types. This is the most
 * specific type that is a supertype of both types.
 *
 * @category "Primitives"
 * @method "_∪_"
 * @param "arg1" "type"
 *        A type.
 * @param "arg2" "type"
 *        A type.
 * @returns "(⊤)'s type"
 *    The type union of the arguments.
 */
Primitive "_∪_" is
[
	arg1 : type,
	arg2 : type
|
	Primitive 31;
] : type;

/**
 * Compute and answer the type intersection of the two types. This is the most
 * general type that is a subtype of both types.
 *
 * @category "Primitives"
 * @method "_∩_"
 * @param "arg1" "type"
 *        A type.
 * @param "arg2" "type"
 *        A type.
 * @returns "(⊤)'s type"
 *    The type intersection of the arguments.
 */
Primitive "_∩_" is
[
	arg1 : type,
	arg2 : type
|
	Primitive 32;
] : type;

/**
 * Is the first argument a subtype of the second argument? This does not
 * implement the proper subtype relation, so the first argument is considered
 * a subtype of the second argument also if it is equal to the second argument.
 *
 * @category "Primitives"
 * @method "_⊆_"
 * @param "arg1" "type"
 *        A type.
 * @param "arg2" "type"
 *        A type.
 * @returns "boolean"
 *    `true` if the first argument is a subtype of, or the same type as, the
 *    second argument, `false` otherwise.
 */
Primitive "_⊆_" is
[
	arg1 : type,
	arg2 : type
|
	Primitive 33;
] : boolean;

/**
 * Construct and answer a function type with the specified parameter types and
 * return type.
 *
 * @category "Primitives"
 * @method "function accepting_and returning_"
 * @param "parameterTypes" "tuple of any meta"
 *        The parameter types.
 * @param "returnType" "type"
 *        The return type.
 * @returns "([…]→⊤)'s type"
 *    The requested function type. Instances of this type accept arguments
 *    whose types conform to the parameter types and whose return value
 *    conforms to the return type.
 */
Primitive "function accepting_and returning_" is
[
	parameterTypes : tuple of any meta,
	returnType : type
|
	Primitive 34;
] : function meta;

/**
 * Answer a tuple type that describes the parameter types of the specified
 * function type.
 *
 * @category "Primitives"
 * @method "_'s⁇parameters'type"
 * @param "functionType" "function meta"
 *        A function type.
 * @returns "(tuple)'s type"
 *    A fixed-size tuple type whose element types correspond to the parameter
 *    types of the argument.
 */
Primitive "_'s⁇parameters'type" is
[
	functionType : function meta
|
	Primitive 35;
] : tuple meta;

/**
 * Answer the {@param "index"}-th parameter type of the specified function type.
 *
 * @category "Primitives"
 * @method "_[_]"
 * @param "functionType" "function meta"
 *        A function type.
 * @param "index" "natural number"
 *        The one-based index of the desired parameter type.
 * @returns "(any)'s type"
 *    The {@param "index"}-th parameter type of the argument.
 */
Primitive "_[_]" is
[
	functionType : function meta,
	index : natural number
|
	Primitive 36;
] : any meta;

/**
 * Answer the return type of the specified function type.
 *
 * @category "Primitives"
 * @method "_'s⁇return type"
 * @param "functionType" "function meta"
 *        A function type.
 * @returns "(⊤)'s type"
 *    The return type of the argument.
 */
Primitive "_'s⁇return type" is
[
	functionType : function meta
|
	Primitive 37;
] : type;

/**
 * Compute and answer the type union of the elements of the given tuple of
 * types.
 *
 * @category "Primitives"
 * @method "∪_"
 * @param "tupleOfTypes" "tuple of type"
 *        A tuple of types.
 * @returns "(⊤)'s type"
 *    The type union of the elements of the argument.
 */
Primitive "∪_" is
[
	tupleOfTypes : tuple of type
|
	Primitive 38;
] : type;

/**
 * Construct and answer a function type with the specified return type.
 * Instances of this type include any function that returns a value of the
 * specified return type, irrespective of the number or types of its parameters.
 *
 * @category "Primitives"
 * @method "[`…]→_"
 * @param "returnType" "type"
 *        A type.
 * @returns "([…]→⊤)'s type"
 *    The requested function type. Instances of this type answer values of the
 *    specified return type.
 */
Primitive "[`…]→_" is
[
	returnType : type
|
	Primitive 39;
] : function meta;

/**
 * Given a predicate value and two functions, invoke one of them and answer its
 * result.
 *
 * @category "Primitives"
 * @method "If|if_then_else_"
 * @param "predicate" "boolean"
 *        A predicate value.
 * @param "trueFunction" "nullary procedure"
 *        The function to invoke if {@param "predicate"} is `true`.
 * @param "falseFunction" "nullary procedure"
 *        The function to invoke if {@param "trueFunction"} is `false`.
 * @returns "⊤"
 *    If {@param "predicate"} is `true`, then the value produced by invoking
 *    {@param "trueFunction"}; otherwise, the value produced by invoking {@param "falseFunction"}.
 */
Primitive "If|if_then_else_" is
[
	predicate : boolean,
	trueFunction : nullary procedure,
	falseFunction : nullary procedure
|
	Primitive 43;
] : ⊤;

/**
 * Given a predicate value and a function, conditionally invoke the specified
 * function.
 *
 * @category "Primitives"
 * @method "If_then_"
 * @param "predicate" "boolean"
 *        A predicate value.
 * @param "trueBlock" "nullary procedure"
 *        The function to invoke if {@param "predicate"} is `true`.
 */
Primitive "If_then_" is
[
	predicate : boolean,
	trueBlock : nullary procedure
|
	Primitive 44;
] : ⊤;

/**
 * Answer the current value of the high-precision timer. The answer has
 * nanosecond precision, but not necessarily nanosecond resolution; the actual
 * resolution is implementation-dependent. The high-precision timer does not
 * have a fixed reference frame, so it should generally only be used to measure
 * the time elapsed between two invocations.
 *
 * @returns "[0..∞)"
 *    The current value of the high-precision timer, in nanoseconds.
 */
Primitive "high-precision timer value" is
[
	Primitive 46;
] : whole number;

/**
 * Construct and answer a variable type from the specified read and write types.
 *
 * @category "Primitives"
 * @method "_→/→_"
 * @param "readType" "type"
 *        The read type of the variable type.
 * @param "writeType" "type"
 *        The write type of the variable type.
 * @returns "⊤→/→⊥"
 *    The requested variable type.
 */
Primitive "_→/→_" is
[
	readType : type,
	writeType : type
|
	Primitive 47;
] : variable;

/**
 * Resume the specified continuation. The current continuation (in which this
 * primitive was invoked) is completely replaced by the resumed continuation.
 *
 * @category "Primitives"
 * @method "Resume_"
 * @param "aContinuation" "continuation"
 *        A continuation.
 * @returns "⊥"
 */
Primitive "Resume_" is
[
	aContinuation : continuation
|
	Primitive 48;
] : ⊥;

/**
 * Answer the type of the function represented by the specified continuation.
 *
 * @category "Primitives"
 * @method "_'s⁇function type"
 * @param "aContinuation" "continuation meta"
 *        A continuation.
 * @returns "([…]→⊤)'s type"
 *    The argument's current function's type.
 */
Primitive "_'s⁇function type" is
[
	aContinuation : continuation meta
|
	Primitive 50;
] : function meta;

/**
 * Compute and answer a continuation type capable of representing a current
 * function of the specified type.
 *
 * @category "Primitives"
 * @method "$_"
 * @param "functionType" "function meta"
 *        A function type.
 * @returns "($[…]→⊥)'s type"
 *    The requested continuation type.
 */
Primitive "$_" is
[
	functionType : function meta
|
	Primitive 51;
] : continuation meta;

/**
 * Construct and answer a variable that holds the caller of the specified
 * continuation. This variable will be unassigned if the continuation has no
 * caller.
 *
 * @category "Primitives"
 * @method "_'s⁇caller"
 * @param "aContinuation" "continuation"
 *        A continuation.
 * @returns "↑$[…]→⊥"
 *    A variable that, if assigned, holds the argument's caller. If unassigned,
 *    then the argument has no caller.
 */
Primitive "_'s⁇caller" is
[
	aContinuation : continuation
|
	Primitive 52;
] : continuation variable;

/**
 * Answer the current function of the specified continuation.
 *
 * @category "Primitives"
 * @method "_'s⁇function"
 * @param "aContinuation" "continuation"
 *        A continuation.
 * @returns "[…]→⊤"
 *    The argument's current function. This is the function whose execution
 *    will be resumed if the continuation is resumed.
 */
Primitive "_'s⁇function" is
[
	aContinuation : continuation
|
	Primitive 53;
] : function;

/**
 * Answer the program counter of the specified continuation. Using the current
 * function's tuple of Level One nybblecodes, this is the index of the next
 * instruction to be performed (if the continuation is resumed).
 *
 * @category "Primitives"
 * @method "_'s⁇program counter"
 * @param "aContinuation" "continuation"
 *        A continuation.
 * @returns "[1..∞)"
 *    The argument's Level One program counter.
 */
Primitive "_'s⁇program counter" is
[
	aContinuation : continuation
|
	Primitive 54;
] : natural number;

/**
 * Answer the stack pointer of the specified continuation. This is the index of
 * the top of the local stack. For an empty stack, this value equals the size of
 * the stack plus one. The stack grows downward.
 *
 * @category "Primitives"
 * @method "_'s⁇stack pointer"
 * @param "aContinuation" "continuation"
 *        A continuation.
 * @returns "[1..∞)"
 *    The argument's stack pointer.
 */
Primitive "_'s⁇stack pointer" is
[
	aContinuation : continuation
|
	Primitive 55;
] : natural number;

/**
 * Restart the continuation with its original arguments. Execution proceeds as
 * though the continuation's caller had just invoked the continuation's current
 * function with its original arguments. The current continuation (in which
 * this primitive was invoked) is completely replaced by the restarted
 * continuation.
 *
 * @category "Primitives"
 * @method "Restart_"
 * @param "aContinuation" "continuation"
 *        The continuation to restart.
 */
Primitive "Restart_" is
[
	aContinuation : continuation
|
	Primitive 58;
] : ⊥;

/**
 * Answer the stack of the specified continuation. This tuple contains the
 * arguments, local variables, and temporaries. Any null values, forbidden to
 * leak through into observable Avail macrostate, are replaced with an
 * unassigned variable whose containment type is ⊥. Note that such a variable
 * cannot be constructed either syntactically nor through a variable
 * construction primitive.
 *
 * @category "Primitives"
 * @method "_'s⁇stack"
 * @param "aContinuation" "continuation"
 *        A continuation.
 * @returns "tuple"
 *    The argument's stack.
 */
Primitive "_'s⁇stack" is
[
	aContinuation : continuation
|
	Primitive 59;
] : tuple;

/**
 * Are the arguments equal?
 *
 * @category "Primitives"
 * @method "_=_"
 * @param "arg1" "any"
 *        A value.
 * @param "arg2" "any"
 *        A value.
 * @returns "boolean"
 *    `true` if the arguments are equal, `false` otherwise.
 */
Primitive "_=_" is
[
	arg1 : any,
	arg2 : any
|
	Primitive 60;
] : boolean;

/**
 * Construct and answer an object based on the supplied map.
 *
 * @category "Primitives"
 * @method "_→object"
 * @param "fieldsToValues" "field map"
 *        A map whose keys are the fields of the new object and whose values are
 *        the corresponding field values.
 * @returns "Unnamed object type"
 *    The requested object.
 */
Primitive "_→object" is
[
	fieldsToValues : field map
|
	Primitive 61;
] : object;

/**
 * Construct and answer a map based on the supplied object.
 *
 * @category "Primitives"
 * @method "_→map"
 * @param "anObject" "object"
 *        An object whose fields should be the keys of the new map and whose
 *        values are the corresponding values.
 * @returns "{atom→any|}"
 *    The requested map.
 */
Primitive "_→map" is
[
	anObject : object
|
	Primitive 62;
] : field map;

/**
 * Construct and answer an object type based on the supplied map.
 *
 * @category "Primitives"
 * @method "_→object type"
 * @param "fieldsToTypes" "field type map"
 *        A map whose keys are the fields of the new object and whose values are
 *        the corresponding field types.
 * @returns "(Unnamed object type)'s type"
 *    The requested object type.
 */
Primitive "_→object type" is
[
	fieldsToTypes : field type map
|
	Primitive 63;
] : object meta;

/**
 * Construct and answer a map based on the supplied object type.
 *
 * @category "Primitives"
 * @method "_→map"
 * @param "anObjectType" "object meta"
 *        An object type whose fields should be the keys of the new map and
 *        whose values are the corresponding values.
 * @returns "{atom→(any)'s type|}"
 *    The requested map.
 */
Primitive "_→map" is
[
	anObjectType : object meta
|
	Primitive 64;
] : field type map;

/**
 * Construct and answer an enumeration whose instances are fully determined by
 * the membership of the specified set.
 *
 * @category "Primitives"
 * @method "enumeration of_"
 * @param "instances" "set"
 *        The complete set of instances of the enumeration.
 * @returns "(⊤)'s type"
 *    The requested enumeration.
 */
Primitive "enumeration of_" is
[
	instances : set
|
	Primitive 65;
] : type;

/**
 * For the purpose of debugging, bind a name to an object type. This name will
 * be used for subtypes that do not bind a more specific name to describe their
 * own subtypes.
 *
 * @category "Primitives"
 * @method "_'s⁇name:=_"
 * @param "anObjectType" "object meta"
 *        An object type.
 * @param "name" "string"
 *        The name that should be bound to the object type. This will replace
 *        a previously bound name.
 */
Primitive "_'s⁇name:=_" is
[
	anObjectType : object meta,
	name : string
|
	Primitive 68;
] : ⊤;

/**
 * Answer the set of locally most-specific names bound to the specified object
 * type.
 *
 * @category "Primitives"
 * @method "_'s⁇names"
 * @param "anObjectType" "object meta"
 *        An object type.
 * @returns "{string|}"
 *    The set of locally most-specific names bound to the specified object
 *    type.
 */
Primitive "_'s⁇names" is
[
	anObjectType : object meta
|
	Primitive 69;
] : set of string;

/**
 * Construct and answer a function that is an instance of {@param "aFunctionType"}
 * and applies {@param "functionToApply"} when itself applied with the appropriate
 * number and types of arguments. The new function answers whatever
 * {@param "functionToApply"} answers.
 *
 * @category "Primitives"
 * @method "new_applying_"
 * @param "aFunctionType" "function meta"
 *        The desired function type.
 * @param "functionToApply" "function"
 *        The function that the new function will apply when itself applied with
 *        the correct number and types of arguments.
 * @returns "[…]→⊤"
 *    The requested function.
 */
Primitive "new_applying_" is
[
	aFunctionType : function meta,
	functionToApply : function
|
	Primitive 71;
] : function;

/**
 * Answer the implementation of the specified function. A function's
 * implementation comprises its nybblecodes, its literals, its primitive
 * linkage (if any), its function type, and various statistics.
 *
 * @category "Primitives"
 * @method "_'s⁇implementation"
 * @param "aFunction" "function"
 *        A function.
 * @returns "¢[…]→⊤"
 *    The argument's implementation.
 */
Primitive "_'s⁇implementation" is
[
	aFunction : function
|
	Primitive 72;
] : function implementation;

/**
 * Answer all variables captured by the specified function. For functions
 * compiled directly from source code (i.e. the vast majority of them), these
 * variables are lexically captured.
 *
 * @category "Primitives"
 * @method "_'s⁇outer variables"
 * @param "aFunction" "function"
 *        A function.
 * @returns "tuple"
 *    The argument's outer variables.
 */
Primitive "_'s⁇outer variables" is
[
	aFunction : function
|
	Primitive 73;
] : tuple;

/**
 * Answer the cardinality of the specified map.
 *
 * @category "Primitives"
 * @method "`|_`|"
 * @param "aMap" "map"
 *        A map.
 * @returns "[0..∞)"
 *    The argument's cardinality.
 */
Primitive "`|_`|" is
[
	aMap : map
|
	Primitive 80;
] : whole number;

/**
 * Is {@param "key"} a member of the set of keys of {@param "aMap"}?
 *
 * @category "Primitives"
 * @method "_∈_"
 * @param "key" "any"
 *        The key whose membership should be queried.
 * @param "aMap" "map"
 *        A map.
 * @returns "boolean"
 *    `true` if {@param "key"} if a key of {@param "aMap"}, `false`
 *    otherwise.
 */
Primitive "_∈_" is
[
	key : any,
	aMap : map
|
	Primitive 81;
] : boolean;

/**
 * Construct and answer a map that is based on the supplied map. The answer
 * (potentially) differs from the argument in that it contains a binding from
 * {@param "key"} to {@param "value"}; any value previously bound to {@param "key"} is "forgotten" in the
 * new map.
 *
 * @category "Primitives"
 * @method "_+_→_"
 * @param "aMap" "map"
 *        A map.
 * @param "key" "any"
 *        A key.
 * @param "value" "any"
 *        The new value for the key.
 * @returns "{any→any|1..∞}"
 *    The requested map.
 */
Primitive "_+_→_" is
[
	aMap : map,
	key : any,
	value : any
|
	Primitive 83;
] : non-empty map;

/**
 * Construct and answer a map that is based on the supplied map. The answer
 * (potentially) differs from the argument in that it does not contain a
 * binding for {@param "key"}; any such previous binding is "forgotten" in the new map.
 *
 * @category "Primitives"
 * @method "_-_"
 * @param "aMap" "map"
 *        A map.
 * @param "key" "any"
 *        A key whose binding should be omitted.
 * @returns "map"
 *    The requested map.
 */
Primitive "_-_" is
[
	aMap : map,
	key : any
|
	Primitive 84;
] : map;

/**
 * Construct and answer a map from the supplied tuple of bindings.
 *
 * @category "Primitives"
 * @method "_→map"
 * @param "bindings" "key-value tuple"
 *        A tuple of bindings. Each element of the argument is a
 *       2-tuple that represents a binding. The first element of each 2-tuple is
 *       a key, the second element is the value that should be bound to that key
 *       in the resultant map.
 * @returns "map"
 *    The requested map.
 */
Primitive "_→map" is
[
	bindings : key-value tuple
|
	Primitive 85;
] : map;

/**
 * Answer the set of keys of the specified map.
 *
 * @category "Primitives"
 * @method "_'s⁇keys"
 * @param "aMap" "map"
 *        A map.
 * @returns "set"
 *    The argument's keys.
 */
Primitive "_'s⁇keys" is
[
	aMap : map
|
	Primitive 86;
] : set;

/**
 * Construct and answer a map type with the specified key type, value type, and
 * range of cardinalities.
 *
 * @category "Primitives"
 * @method "{_→_`|_}"
 * @param "keyType" "any meta"
 *        A type to which all keys of instances must conform.
 * @param "valueType" "any meta"
 *        A type to which all values of instances must conform.
 * @param "cardinalityType" "whole number meta"
 *        The range of cardinalities to which all instances must
 *       conform.
 * @returns "(map)'s type"
 *    The requested map type.
 */
Primitive "{_→_`|_}" is
[
	keyType : any meta,
	valueType : any meta,
	cardinalityType : whole number meta
|
	Primitive 87;
] : map meta;

/**
 * Answer the acceptable range of cardinalities for instances of the specified
 * map type.
 *
 * @category "Primitives"
 * @method "`|`|_`|`|"
 * @param "aMapType" "map meta"
 *        A map type.
 * @returns "([0..∞))'s type"
 *    The argument's cardinality requirement.
 */
Primitive "`|`|_`|`|" is
[
	aMapType : map meta
|
	Primitive 88;
] : whole number meta;

/**
 * Answer the most specific type to which the keys of all instances must
 * conform.
 *
 * @category "Primitives"
 * @method "_'s⁇key type"
 * @param "aMapType" "map meta"
 *        A map type.
 * @returns "(any)'s type"
 *    The argument's key type.
 */
Primitive "_'s⁇key type" is
[
	aMapType : map meta
|
	Primitive 89;
] : any meta;

/**
 * Answer the most specific type to which the values of all instances must
 * conform.
 *
 * @category "Primitives"
 * @method "_'s⁇value type"
 * @param "aMapType" "map meta"
 *        A map type.
 * @returns "(any)'s type"
 *    The argument's value type.
 */
Primitive "_'s⁇value type" is
[
	aMapType : map meta
|
	Primitive 90;
] : any meta;

/**
 * Answer a tuple containing the values of the specified map. The values are
 * arranged in no particular order.
 *
 * @category "Primitives"
 * @method "_'s⁇values"
 * @param "aMapType" "map"
 *        A map.
 * @returns "tuple"
 *    The argument's values.
 */
Primitive "_'s⁇values" is
[
	aMapType : map
|
	Primitive 91;
] : tuple;

/**
 * Answer a tuple containing the bindings of the specified map. A binding is a
 * 2-tuple of key and value.
 *
 * @category "Primitives"
 * @method "_'s⁇bindings"
 * @param "aMapType" "map"
 *        A map.
 * @returns "<<any…|2>…|>"
 *    The argument's bindings.
 */
Primitive "_'s⁇bindings" is
[
	aMapType : map
|
	Primitive 92;
] : key-value tuple;

/**
 * Compute and answer the bitwise AND of the arguments.
 *
 * @category "Primitives"
 * @method "_bit∧_"
 * @param "arg1" "integer"
 *        An integer.
 * @param "arg2" "integer"
 *        An integer.
 * @returns "(-∞..∞)"
 *    The bitwise AND of {@param "arg1"} and {@param "arg2"}.
 */
Primitive "_bit∧_" is
[
	arg1 : integer,
	arg2 : integer
|
	Primitive 97;
] : integer;

/**
 * Compute and answer the bitwise OR of the arguments.
 *
 * @category "Primitives"
 * @method "_bit∨_"
 * @param "arg1" "integer"
 *        An integer.
 * @param "arg2" "integer"
 *        An integer.
 * @returns "(-∞..∞)"
 *    The bitwise OR of {@param "arg1"} and {@param "arg2"}.
 */
Primitive "_bit∨_" is
[
	arg1 : integer,
	arg2 : integer
|
	Primitive 98;
] : integer;

/**
 * Compute and answer the bitwise XOR of the arguments.
 *
 * @category "Primitives"
 * @method "_bit⊕_"
 * @param "arg1" "integer"
 *        An integer.
 * @param "arg2" "integer"
 *        An integer.
 * @returns "(-∞..∞)"
 *    The bitwise XOR of {@param "arg1"} and {@param "arg2"}.
 */
Primitive "_bit⊕_" is
[
	arg1 : integer,
	arg2 : integer
|
	Primitive 99;
] : integer;

/**
 * Answer the cardinality of the specified set.
 *
 * @category "Primitives"
 * @method "`|_`|"
 * @param "aSet" "set"
 *        A set.
 * @returns "[0..∞)"
 *    The argument's cardinality.
 */
Primitive "`|_`|" is
[
	aSet : set
|
	Primitive 100;
] : whole number;

/**
 * Is {@param "element"} an element of {@param "aSet"}?
 *
 * @category "Primitives"
 * @method "_∈_"
 * @param "element" "any"
 *        An arbitrary value.
 * @param "aSet" "set"
 *        A set.
 * @returns "boolean"
 *    `true` if {@param "element"} is an element of {@param "aSet"}, `false`
 *    otherwise.
 */
Primitive "_∈_" is
[
	element : any,
	aSet : set
|
	Primitive 101;
] : boolean;

/**
 * Compute and answer the set union of the arguments. This is a set that
 * contains the elements of both sets.
 *
 * @category "Primitives"
 * @method "_∪_"
 * @param "arg1" "set"
 *        A set.
 * @param "arg2" "set"
 *        A set.
 * @returns "set"
 *    The set union of the arguments.
 */
Primitive "_∪_" is
[
	arg1 : set,
	arg2 : set
|
	Primitive 102;
] : set;

/**
 * Compute and answer the set intersection of the arguments. This is a set that
 * contains only those elements present in each set.
 *
 * @category "Primitives"
 * @method "_∩_"
 * @param "arg1" "set"
 *        A set.
 * @param "arg2" "set"
 *        A set.
 * @returns "set"
 *    The set intersection of the arguments.
 */
Primitive "_∩_" is
[
	arg1 : set,
	arg2 : set
|
	Primitive 103;
] : set;

/**
 * Compute and answer the asymmetric set difference of {@param "minuend"} and
 * {@param "subtrahend"} (also the relative complement of {@param "subtrahend"} in {@param "minuend"}).
 * This is a set that contains only those elements present in {@param "minuend"}
 * but not in {@param "subtrahend"}.
 *
 * @category "Primitives"
 * @method "_\\_"
 * @param "minuend" "set"
 *        The minuend.
 * @param "subtrahend" "set"
 *        The subtrahend.
 * @returns "set"
 *    The asymmetric set difference of {@param "minuend"} and {@param "subtrahend"}.
 */
Primitive "_\\_" is
[
	minuend : set,
	subtrahend : set
|
	Primitive 104;
] : set;

/**
 * Compute and answer the set union of the specified set and a set containing
 * the supplied element.
 *
 * @category "Primitives"
 * @method "_+_"
 * @param "aSet" "set"
 *        A set.
 * @param "newElement" "any"
 *        The element that must be present in the resultant set.
 * @returns "{any|1..∞}"
 *    A set that contains the same elements as {@param "aSet"} but also
 *    contains {@param "newElement"}.
 */
Primitive "_+_" is
[
	aSet : set,
	newElement : any
|
	Primitive 105;
] : non-empty set;

/**
 * Compute and answer the asymmetric set difference of the specified set and a
 * set containing the supplied element.
 *
 * @category "Primitives"
 * @method "_-_"
 * @param "aSet" "set"
 *        A set.
 * @param "oldElement" "any"
 *        The element that must not be present in the resultant set.
 * @returns "set"
 *    A set that contains the same elements as {@param "aSet"} except that
 *    it does not contain {@param "oldElement"}.
 */
Primitive "_-_" is
[
	aSet : set,
	oldElement : any
|
	Primitive 106;
] : set;

/**
 * Is {@param "arg1"} a subset of or equal to {@param "arg2"}?
 *
 * @category "Primitives"
 * @method "_⊆_"
 * @param "arg1" "set"
 *        A set.
 * @param "arg2" "set"
 *        A set.
 * @returns "boolean"
 *    `true` if {@param "arg1"} is a subset of or equal to {@param "arg2"},
 *    `false` otherwise.
 */
Primitive "_⊆_" is
[
	arg1 : set,
	arg2 : set
|
	Primitive 107;
] : boolean;

/**
 * Construct and answer a set that uniquely (by definition) contains the same
 * elements as the specified tuple.
 *
 * @category "Primitives"
 * @method "_→set"
 * @param "aTuple" "tuple"
 *        A tuple.
 * @returns "set"
 *    The requested set.
 */
Primitive "_→set" is
[
	aTuple : tuple
|
	Primitive 109;
] : set;

/**
 * Construct and answer a tuple that arbitrarily orders the elements of the
 * specified set. The conversion is unstable, and thus different calls given
 * the same argument may produce different orderings.
 *
 * @category "Primitives"
 * @method "_→tuple"
 * @param "aSet" "set"
 *        A set.
 * @returns "tuple"
 *    The requested tuple.
 */
Primitive "_→tuple" is
[
	aSet : set
|
	Primitive 110;
] : tuple;

/**
 * Construct and answer a set type with the specified element type and range of
 * cardinalities.
 *
 * @category "Primitives"
 * @method "{_`|_}"
 * @param "elementType" "any meta"
 *        The element type.
 * @param "cardinalityType" "whole number meta"
 *        The range of allowed cardinalities.
 * @returns "(set)'s type"
 *    The requested set type. Instances have elements that conform to
 *    {@param "elementType"} and cardinalities that conform to {@param
 *    "cardinalityType"}.
 */
Primitive "{_`|_}" is
[
	elementType : any meta,
	cardinalityType : whole number meta
|
	Primitive 111;
] : set meta;

/**
 * Answer the acceptable range of cardinalities for instances of the specified
 * set type.
 *
 * @category "Primitives"
 * @method "`|`|_`|`|"
 * @param "aSetType" "set meta"
 *        A set type.
 * @returns "([0..∞))'s type"
 *    The argument's cardinality requirement.
 */
Primitive "`|`|_`|`|" is
[
	aSetType : set meta
|
	Primitive 112;
] : whole number meta;

/**
 * Answer the element type of the specified set type. This is the most specific
 * type to which all elements of instances must conform.
 *
 * @category "Primitives"
 * @method "_'s⁇element|member type"
 * @param "aSetType" "set meta"
 *        A set type.
 * @returns "(any)'s type"
 *    The argument's element type.
 */
Primitive "_'s⁇element|member type" is
[
	aSetType : set meta
|
	Primitive 113;
] : any meta;

/**
 * Construct and answer a new atom. Associate with the atom the supplied string,
 * which should be a name used for debugging purposes only. Atoms have identity
 * and all atoms are distinct, regardless of whether their debug names are
 * equal.
 *
 * @category "Primitives"
 * @method "new atom named_"
 * @param "debugName" "string"
 *        A name to associate with the atom for debugging purposes. This name
 *        does not participate in atom comparison.
 * @returns "atom"
 *    A new atom, distinct from every other atom answered by a different
 *    invocation of this primitive.
 */
Primitive "new atom named_" is
[
	debugName : string
|
	Primitive 120;
] : atom;

/**
 * Answer the debug name of the specified atom.
 *
 * @category "Primitives"
 * @method "_'s⁇name"
 * @param "anAtom" "atom"
 *        An atom.
 * @returns "string"
 *    The argument's debug name.
 */
Primitive "_'s⁇name" is
[
	anAtom : atom
|
	Primitive 121;
] : string;

/**
 * Answer a set containing all atoms well-known to the Avail virtual machine.
 * These atoms cannot serve as properties, nor have properties added, queried,
 * modified, or removed.
 *
 * @returns "{atom|}"
 *    The special atoms.
 */
Primitive "special atoms" is
[
	Primitive 126;
] : set of atom;

/**
 * Answer the cardinality of the specified tuple.
 *
 * @category "Primitives"
 * @method "`|_`|"
 * @param "aTuple" "tuple"
 *        A tuple.
 * @returns "[0..∞)"
 *    The argument's cardinality.
 */
Primitive "`|_`|" is
[
	aTuple : tuple
|
	Primitive 130;
] : whole number;

/**
 * Construct and answer a tuple that is the left-to-right concatenation of all
 * elements (i.e. tuples) of the specified tuple.
 *
 * @category "Primitives"
 * @method "concatenate_"
 * @param "tupleOfTuples" "tuple of tuple"
 *        A tuple of tuples.
 * @returns "tuple"
 *    The requested tuple.
 */
Primitive "concatenate_" is
[
	tupleOfTuples : tuple of tuple
|
	Primitive 136;
] : tuple;

/**
 * Construct and answer a tuple type with the specified leading element types,
 * default element type, and range of cardinalities.
 *
 * @category "Primitives"
 * @method "<_,_`…`|_>"
 * @param "leadingTypes" "tuple of any meta"
 *        The leading types.
 * @param "defaultType" "any meta"
 *        The default type.
 * @param "cardinalityType" "whole number meta"
 *        The range of allowed cardinalities.
 * @returns "(tuple)'s type"
 *    The requested tuple type.
 */
Primitive "<_,_`…`|_>" is
[
	leadingTypes : tuple of any meta,
	defaultType : any meta,
	cardinalityType : whole number meta
|
	Primitive 137;
] : tuple meta;

/**
 * Answer the range of allowed cardinalities of instances of the specified type.
 *
 * @category "Primitives"
 * @method "`|`|_`|`|"
 * @param "aTupleType" "tuple meta"
 *        A tuple type.
 * @returns "([0..∞))'s type"
 *    The argument's cardinality requirement.
 */
Primitive "`|`|_`|`|" is
[
	aTupleType : tuple meta
|
	Primitive 138;
] : whole number meta;

/**
 * Answer a tuple containing the leading element types of instances of the
 * specified type.
 *
 * @category "Primitives"
 * @method "_'s⁇leading types"
 * @param "aTupleType" "tuple meta"
 *        A tuple type.
 * @returns "<(any)'s type…|>"
 *    The argument's leading element types.
 */
Primitive "_'s⁇leading types" is
[
	aTupleType : tuple meta
|
	Primitive 139;
] : tuple of any meta;

/**
 * Answer the default element type of instances of the specified type.
 *
 * @category "Primitives"
 * @method "_'s⁇default type"
 * @param "aTupleType" "tuple meta"
 *        A tuple type.
 * @returns "(any)'s type"
 *    The argument's default element type.
 */
Primitive "_'s⁇default type" is
[
	aTupleType : tuple meta
|
	Primitive 140;
] : any meta;

/**
 * Answer the element type of the {@param "index"}-th element of instances of the
 * specified type. If {@param "index"} is out of bounds, then answer ⊥.
 *
 * @category "Primitives"
 * @method "_[_]"
 * @param "aTupleType" "tuple meta"
 *        A tuple type.
 * @param "index" "natural number"
 *        The index of the desired element type.
 * @returns "(any)'s type"
 *    The requested element type, or ⊥ if {@param "index"} is out of bounds.
 */
Primitive "_[_]" is
[
	aTupleType : tuple meta,
	index : natural number
|
	Primitive 141;
] : any meta;

/**
 * Compute and answer the type union of the indicated range of element types.
 *
 * @category "Primitives"
 * @method "∪_[_.._]"
 * @param "aTupleType" "tuple meta"
 *        A tuple type.
 * @param "startIndex" "natural number"
 *        The one-based index (inclusive) of the start of the range.
 * @param "endIndex" "nonnegative extended integer"
 *        The one-based index (inclusive) of the end of the range.
 * @returns "(any)'s type"
 *    The type union of all element types in the specified range.
 */
Primitive "∪_[_.._]" is
[
	aTupleType : tuple meta,
	startIndex : natural number,
	endIndex : nonnegative extended integer
|
	Primitive 143;
] : any meta;

/**
 * Compute and answer the concatenation of the specified tuple types. This is
 * the most specific type that encompasses all possible concatenations of the
 * instances of the two types.
 *
 * @category "Primitives"
 * @method "_++_"
 * @param "arg1" "tuple meta"
 *        A tuple type.
 * @param "arg2" "tuple meta"
 *        A tuple type.
 * @returns "(tuple)'s type"
 *    The requested tuple type.
 */
Primitive "_++_" is
[
	arg1 : tuple meta,
	arg2 : tuple meta
|
	Primitive 144;
] : tuple meta;

/**
 * Construct and answer an object type based on the supplied tuple.
 *
 * @category "Primitives"
 * @method "_→object type"
 * @param "fieldDefinitions" "field type tuple"
 *        A tuple whose elements are 2-tuples. Each 2-tuple's first element is
 *        an atom (i.e., the field identifier) and its second element is the
 *        value type permitted by the field.
 * @returns "(Unnamed object type)'s type"
 *    The requested object type.
 */
Primitive "_→object type" is
[
	fieldDefinitions : field type tuple
|
	Primitive 150;
] : object meta;

/**
 * Construct and answer a tuple based on the supplied object type.
 *
 * @category "Primitives"
 * @method "_→tuple"
 * @param "anObjectType" "object meta"
 *        An object type.
 * @returns "<<atom, (any)'s type…|2>…|>"
 *    A tuple that represents the composition of the object type. Its elements
 *    are 2-tuples. Each 2-tuple's first element is an atom (i.e., the field
 *    identifier) and its second element is the value type permitted by the
 *    field.
 */
Primitive "_→tuple" is
[
	anObjectType : object meta
|
	Primitive 151;
] : field type tuple;

/**
 * Construct and answer an object based on the supplied tuple.
 *
 * @category "Primitives"
 * @method "_→object"
 * @param "fieldAssignments" "field tuple"
 *        A tuple whose elements are 2-tuples. Each 2-tuple's first element is
 *        an atom (i.e., the field identifier) and its second element is
 *        associated value.
 * @returns "Unnamed object type"
 *    The requested object.
 */
Primitive "_→object" is
[
	fieldAssignments : field tuple
|
	Primitive 152;
] : object;

/**
 * Construct and answer a tuple based on the supplied object.
 *
 * @category "Primitives"
 * @method "_→tuple"
 * @param "anObject" "object"
 *        An object.
 * @returns "<<atom, any…|2>…|>"
 *    A tuple that represents the composition of the object. Its elements are
 *    2-tuples. Each 2-tuple's first element is an atom (i.e., the field
 *    identifier) and its second element is associated value.
 */
Primitive "_→tuple" is
[
	anObject : object
|
	Primitive 153;
] : field tuple;

/**
 * Answer the arity of a function implementation. This is the number of
 * parameters accepted by the function implementation.
 *
 * @category "Primitives"
 * @method "_'s⁇arity"
 * @param "aFunctionImplementation" "function implementation"
 *        A function implementation.
 * @returns "[0..∞)"
 *    The argument's arity.
 */
Primitive "_'s⁇arity" is
[
	aFunctionImplementation : function implementation
|
	Primitive 180;
] : whole number;

/**
 * Answer the number of local variables used by a function implementation.
 *
 * @category "Primitives"
 * @method "`|_'s⁇local variables`|"
 * @param "aFunctionImplementation" "function implementation"
 *        A function implementation.
 * @returns "[0..∞)"
 *    The number of locals used by the argument.
 */
Primitive "`|_'s⁇local variables`|" is
[
	aFunctionImplementation : function implementation
|
	Primitive 181;
] : whole number;

/**
 * Answer the number of outer variables used by a function implementation.
 *
 * @category "Primitives"
 * @method "`|_'s⁇outer variables`|"
 * @param "aFunctionImplementation" "function implementation"
 *        A function implementation.
 * @returns "[0..∞)"
 *    The number of outers used by the argument.
 */
Primitive "`|_'s⁇outer variables`|" is
[
	aFunctionImplementation : function implementation
|
	Primitive 182;
] : whole number;

/**
 * Answer the maximum stack depth of a function implementation. This does not
 * account for arguments and local variables (which occupy the "bottom" stack
 * slots).
 *
 * @category "Primitives"
 * @method "_'s⁇maximum stack depth"
 * @param "aFunctionImplementation" "function implementation"
 *        A function implementation.
 * @returns "[0..∞)"
 *    The argument's maximum stack depth.
 */
Primitive "_'s⁇maximum stack depth" is
[
	aFunctionImplementation : function implementation
|
	Primitive 183;
] : whole number;

/**
 * Answer the Level One instructions that describe a function implementation's
 * algorithm as a tuple of nybblecodes.
 *
 * @category "Primitives"
 * @method "_'s⁇nybblecodes"
 * @param "aFunctionImplementation" "function implementation"
 *        A function implementation.
 * @returns "<[0..15]…|>"
 *    The argument's nybblecodes.
 */
Primitive "_'s⁇nybblecodes" is
[
	aFunctionImplementation : function implementation
|
	Primitive 184;
] : tuple of nybble;

/**
 * Answer the function type of any function that could close the specified
 * function implementation.
 *
 * @category "Primitives"
 * @method "_'s⁇function type"
 * @param "aFunctionImplementation" "function implementation"
 *        A function implementation.
 * @returns "([…]→⊤)'s type"
 *    The argument's function type.
 */
Primitive "_'s⁇function type" is
[
	aFunctionImplementation : function implementation
|
	Primitive 185;
] : function meta;

/**
 * Answer the primitive number of the primitive linked to the specified
 * function implementation. If the function implementation does not have
 * primitive linkage, then answer `0`.
 *
 * @category "Primitives"
 * @method "_'s⁇primitive number"
 * @param "aFunctionImplementation" "function implementation"
 *        A function implementation.
 * @returns "[0..65535]"
 *    The argument's primitive number, or `0` if the argument does not have
 *    primitive linkage.
 */
Primitive "_'s⁇primitive number" is
[
	aFunctionImplementation : function implementation
|
	Primitive 186;
] : unsigned short;

/**
 * Answer the literals that support a function implementation's algorithm.
 *
 * @category "Primitives"
 * @method "_'s⁇literals"
 * @param "aFunctionImplementation" "function implementation"
 *        A function implementation.
 * @returns "tuple"
 *    A tuple containing the argument's supporting literals.
 */
Primitive "_'s⁇literals" is
[
	aFunctionImplementation : function implementation
|
	Primitive 187;
] : tuple;

/**
 * Answer the specified definition's function type.
 *
 * @category "Primitives"
 * @method "_'s⁇function type"
 * @param "aDefinition" "definition"
 *        Any definition (method, macro, abstract, forward).
 * @returns "([…]→⊤)'s type"
 *    The requested function type.
 */
Primitive "_'s⁇function type" is
[
	aDefinition : definition
|
	Primitive 216;
] : function meta;

/**
 * Answer the specified method definition's function.
 *
 * @category "Primitives"
 * @method "_'s⁇function"
 * @param "aDefinition" "method definition"
 *        A method definition.
 * @returns "[…]→⊤"
 *    The requested function.
 */
Primitive "_'s⁇function" is
[
	aDefinition : method definition
|
	Primitive 217;
] : function;

/**
 * Answer the atom that uniquely identifies the specified message bundle.
 *
 * @category "Primitives"
 * @method "_'s⁇atom"
 * @param "aMessageBundle" "message bundle"
 *        A message bundle for some method.
 * @returns "atom"
 *    The requested atom.
 */
Primitive "_'s⁇atom" is
[
	aMessageBundle : message bundle
|
	Primitive 221;
] : atom;

/**
 * Answer the number of parameters required by the specified method.
 *
 * @category "Primitives"
 * @method "`|_'s⁇parameters`|"
 * @param "aMessageBundle" "message bundle"
 *        A method.
 * @returns "[0..∞)"
 *    The number of parameters required by the specified method.
 */
Primitive "`|_'s⁇parameters`|" is
[
	aMessageBundle : message bundle
|
	Primitive 223;
] : whole number;

/**
 * Is there a method bound to the specified name?
 *
 * @category "Primitives"
 * @method "method exists named_"
 * @param "trueName" "atom"
 *        An atom.
 * @returns "boolean"
 *    `true` if {@param "trueName"} names a method, `false` otherwise.
 */
Primitive "method exists named_" is
[
	trueName : atom
|
	Primitive 230;
] : boolean;

/**
 * Answer all seals applied to the specified method.
 *
 * @category "Primitives"
 * @method "_'s⁇seals"
 * @param "aMethod" "method"
 *        A method.
 * @returns "<<(any)'s type…|>…|>"
 *    A tuple comprising the seals applied to {@param "aMethod"}.
 */
Primitive "_'s⁇seals" is
[
	aMethod : method
|
	Primitive 239;
] : tuple of tuple of any meta;

/**
 * Answer the public names introduced by the specified module.
 *
 * @category "Primitives"
 * @method "_'s⁇public names"
 * @param "aModule" "module"
 *        A module.
 * @returns "{string|}"
 *    A set containing the public names introduced by {@param "aModule"}.
 */
Primitive "_'s⁇public names" is
[
	aModule : module
|
	Primitive 242;
] : set of string;

/**
 * Answer the fully qualified name of the specified module.
 *
 * @category "Primitives"
 * @method "_'s⁇name"
 * @param "aModule" "module"
 *        A module.
 * @returns "string"
 *    The fully qualified name of {@param "aModule"}.
 */
Primitive "_'s⁇name" is
[
	aModule : module
|
	Primitive 243;
] : string;

/**
 * Compute and answer the semantic restrictions that would run at a call site
 * of {@param "aMethod"} applied with the specified tuple of arguments.
 *
 * @category "Primitives"
 * @method "semantic restrictions for_given_"
 * @param "aMethod" "method"
 *        A method.
 * @param "arguments" "tuple of any meta"
 *        The tuple of arguments that should be used to filter the semantic
 *        restrictions.
 * @returns "<[…]→(⊤)'s type…|>"
 *    The requested semantic restrictions.
 */
Primitive "semantic restrictions for_given_" is
[
	aMethod : method,
	arguments : tuple of any meta
|
	Primitive 247;
] : tuple of semantic restriction function;

/**
 * Does the argument denote a valid primitive?
 *
 * @category "Primitives"
 * @method "_is a primitive"
 * @param "primitiveNumber" "unsigned short"
 *        A potential primitive number.
 * @returns "boolean"
 *    `true` if the argument denotes a valid primitive, `false` otherwise.
 */
Primitive "_is a primitive" is
[
	primitiveNumber : unsigned short
|
	Primitive 250;
] : boolean;

/**
 * Crash the current fiber. Use the specified value to provide contextual
 * debugging information.
 *
 * This method must not leak beyond the bootstrap package. Termination of
 * fibers is dangerous because it avoids cleaning up active continuations and
 * ergo promotes deadlock (by failing to relinquish held locks). Only
 * cooperative termination, e.g. interrupt queues, is supported in ordinary
 * system or application code. This method is provided only for early detection
 * of serious failures in bootstrap code. Real failures in system code outside
 * of the bootstrap package use Avail's usual exception handling machinery.
 *
 * @category "Primitives"
 * @method "Crash:_"
 * @param "value" "any"
 *        A value, provided to establish context for debugging.
 */
Primitive "Crash:_" is
[
	value : any
|
	Primitive 256;
] : ⊥;

/**
 * Cause the Avail virtual machine to raise an
 * `org.availlang.exceptions.AvailBreakpointException` that a Java debugger
 * can trap upon raise.
 * 
 * This method exists to facilitate debugging of the Avail virtual machine, and
 * will be withdrawn once the implementation is considered sufficiently stable.
 */
Primitive "Breakpoint" is
[
	Primitive 257;
] : ⊤;

/**
 * Print the argument to the application's standard output stream.
 *
 * @category "Primitives"
 * @method "Print:_"
 * @param "text" "string"
 *        A string.
 */
Primitive "Print:_" is
[
	text : string
|
	Primitive 258;
] : ⊤;

/**
 * Produce a primitive description of the argument. This description is
 * mechanically constructed by the Avail virtual machine. It may not contain
 * appropriately localized text, and is intended to provide
 * implementation-specific information that serves only to assist the
 * Avail virtual machine developers in debugging the implementation.
 *
 * @category "Primitives"
 * @method "primitive description of_"
 * @param "value" "any"
 *        A value.
 * @returns "string"
 *    A mechanically constructed, possibly non-localized,
 *    implementation-specific description of the argument.
 */
Primitive "primitive description of_" is
[
	value : any
|
	Primitive 259;
] : string;

/**
 * Early assertion mechanism. This is obsolete once exceptions are available.
 * Raise a special exception in the virtual machine that may be trapped to
 * facilitate debugging. This exception will provided access to {@param "message"}.
 *
 * @category "Primitives"
 * @method "Assert:_(_)"
 * @param "predicate" "boolean"
 *        A boolean, usually derived from a more complex predicate expression.
 * @param "message" "string"
 *        Text describing the assertion failure, ignored unless {@param
 *        "predicate"} is `false`.
 */
Primitive "Assert:_(_)" is
[
	predicate : boolean,
	message : string
|
	Primitive 260;
] : ⊤;

/**
 * Print the argument to the application's standard error stream.
 *
 * @category "Primitives"
 * @method "Error:_"
 * @param "text" "string"
 *        A string.
 */
Primitive "Error:_" is
[
	text : string
|
	Primitive 265;
] : ⊤;

/**
 * Compute and answer the numeric argument as a single-precision floating point
 * number.
 *
 * @category "Primitives"
 * @method "_→float"
 * @param "aNumber" "number"
 *        A number.
 * @returns "float"
 *    A `float` whose value approximates the argument.
 */
Primitive "_→float" is
[
	aNumber : number
|
	Primitive 280;
] : float;

/**
 * Compute and answer the numeric argument as a double-precision floating point
 * number.
 *
 * @category "Primitives"
 * @method "_→double"
 * @param "aNumeric" "number"
 *        A number.
 * @returns "double"
 *    A `double` whose value approximates the argument.
 */
Primitive "_→double" is
[
	aNumeric : number
|
	Primitive 281;
] : double;

/**
 * Compute and answer an approximation of the natural logarithm of the argument,
 * i.e., ln {@param "x"}.
 *
 * @category "Primitives"
 * @method "ln_"
 * @param "x" "float"
 *        A single-precision floating point number.
 * @returns "float"
 *    An approximation of ln {@param "x"}.
 */
Primitive "ln_" is
[
	x : float
|
	Primitive 286;
] : float;

/**
 * Compute and answer an approximation of the natural exponential function for
 * the given exponent, i.e., e^{@param "x"}.
 *
 * @category "Primitives"
 * @method "_^_"
 * @param "eulerNumber" "type of Euler number"
 *        Euler's number.
 * @param "x" "float"
 *        The exponent.
 * @returns "float"
 *    An approximation of e^{@param "x"}.
 */
Primitive "_^_" is
[
	eulerNumber : type of Euler number,
	x : float
|
	Primitive 287;
] : float;

/**
 * Compute and answer an approximation of {@param "dividend"} modulo {@param "divisor"}, i.e. the
 * remainder produced by dividing the arguments.
 *
 * @category "Primitives"
 * @method "_mod_"
 * @param "dividend" "float"
 *        The dividend.
 * @param "divisor" "float"
 *        The divisor.
 * @returns "float"
 *    An approximation of {@param "dividend"} mod {@param "divisor"}.
 */
Primitive "_mod_" is
[
	dividend : float,
	divisor : float
|
	Primitive 288;
] : float;

/**
 * Compute and answer {@param "a"}⨉(2^{@param "two"}) without loss of precision or
 * intermediate overflow. This scales {@param "a"} by a power of two (`2`).
 *
 * @category "Primitives"
 * @method "_⨉_^_"
 * @param "a" "float"
 *        A single-precision floating point number.
 * @param "two" "type of two"
 *        The number two (`2`).
 * @param "b" "integer"
 *        The scaling factor.
 * @returns "float"
 *    The requested value.
 */
Primitive "_⨉_^_" is
[
	a : float,
	two : type of two,
	b : integer
|
	Primitive 291;
] : float;

/**
 * Compute and answer the largest integral single-precision floating point
 * number less than or equal to the argument, i.e., the floor of {@param "x"}.
 *
 * @category "Primitives"
 * @method "⎣_⎦"
 * @param "x" "float"
 *        A single-precision floating point number.
 * @returns "float"
 *    If the `0` is ±∞ or not-a-number, then {@param "x"}, otherwise the
 *    floor of {@param "x"}.
 */
Primitive "⎣_⎦" is
[
	x : float
|
	Primitive 292;
] : float;

/**
 * Compute and answer the smallest integral single-precision floating point
 * number greater than or equal to the argument, i.e., the ceiling of {@param "x"}.
 *
 * @category "Primitives"
 * @method "⎡_⎤"
 * @param "x" "float"
 *        A single-precision floating point number.
 * @returns "float"
 *    If the `0` is ±∞ or not-a-number, then {@param "x"}, otherwise the
 *    ceiling of {@param "x"}.
 */
Primitive "⎡_⎤" is
[
	x : float
|
	Primitive 293;
] : float;

/**
 * Compute and answer an approximation of the natural logarithm of the argument,
 * i.e., ln {@param "x"}.
 *
 * @category "Primitives"
 * @method "ln_"
 * @param "x" "double"
 *        A double-precision floating point number.
 * @returns "double"
 *    An approximation of ln {@param "x"}.
 */
Primitive "ln_" is
[
	x : double
|
	Primitive 316;
] : double;

/**
 * Compute and answer an approximation of the natural exponential function for
 * the given exponent, i.e., e^{@param "x"}.
 *
 * @category "Primitives"
 * @method "_^_"
 * @param "eulerNumber" "type of Euler number"
 *        Euler's number.
 * @param "x" "double"
 *        The exponent.
 * @returns "double"
 *    An approximation of e^{@param "x"}.
 */
Primitive "_^_" is
[
	eulerNumber : type of Euler number,
	x : double
|
	Primitive 317;
] : double;

/**
 * Compute and answer an approximation of {@param "dividend"} modulo {@param "divisor"}, i.e. the
 * remainder produced by dividing the arguments.
 *
 * @category "Primitives"
 * @method "_mod_"
 * @param "dividend" "double"
 *        The dividend.
 * @param "divisor" "double"
 *        The divisor.
 * @returns "double"
 *    An approximation of `0` mod {@param "divisor"}.
 */
Primitive "_mod_" is
[
	dividend : double,
	divisor : double
|
	Primitive 318;
] : double;

/**
 * Compute and answer {@param "a"}⨉(2^{@param "two"}) without loss of
 * precision or intermediate overflow. This scales {@param "a"} by a power
 * of two (`2`).
 *
 * @category "Primitives"
 * @method "_⨉_^_"
 * @param "a" "double"
 *        A single-precision floating point number.
 * @param "two" "type of two"
 *        The number two (`2`).
 * @param "b" "integer"
 *        The scaling factor.
 * @returns "double"
 *    The requested value.
 */
Primitive "_⨉_^_" is
[
	a : double,
	two : type of two,
	b : integer
|
	Primitive 321;
] : double;

/**
 * Compute and answer the largest integral double-precision floating point
 * number less than or equal to the argument, i.e., the floor of {@param
 * "x"}.
 *
 * @category "Primitives"
 * @method "⎣_⎦"
 * @param "x" "double"
 *        A double-precision floating point number.
 * @returns "double"
 *    If the `0` is ±∞ or not-a-number, then {@param "x"}, otherwise the
 *    floor of {@param "x"}.
 */
Primitive "⎣_⎦" is
[
	x : double
|
	Primitive 322;
] : double;

/**
 * Compute and answer the smallest integral double-precision floating point
 * number greater than or equal to the argument, i.e., the ceiling of {@param "x"}.
 *
 * @category "Primitives"
 * @method "⎡_⎤"
 * @param "x" "double"
 *        A double-precision floating point number.
 * @returns "double"
 *    If the `0` is ±∞ or not-a-number, then {@param "x"}, otherwise the ceiling of
 *    {@param "x"}.
 */
Primitive "⎡_⎤" is
[
	x : double
|
	Primitive 323;
] : double;

/**
 * Answer the argument's Unicode code point.
 *
 * @category "Primitives"
 * @method "_'s⁇code point"
 * @param "aCharacter" "character"
 *        A character.
 * @returns "[0..1114111]"
 *    The Unicode code point that encodes the argument.
 */
Primitive "_'s⁇code point" is
[
	aCharacter : character
|
	Primitive 330;
] : code point;

/**
 * Answer the argument as a character.
 *
 * @category "Primitives"
 * @method "_→character"
 * @param "codePoint" "code point"
 *        A Unicode code point.
 * @returns "character"
 *    The character encoded by the argument.
 */
Primitive "_→character" is
[
	codePoint : code point
|
	Primitive 331;
] : character;

/**
 * Answer the whitespace that appeared immediately before this token in the
 * source text. Comments are not reckoned as whitespace.
 *
 * @category "Primitives"
 * @method "_'s⁇leading whitespace"
 * @param "aToken" "token"
 *        A token.
 * @returns "string"
 *    The whitespace that appeared before this token in the source text.
 */
Primitive "_'s⁇leading whitespace" is
[
	aToken : token
|
	Primitive 347;
] : string;

/**
 * Answer the whitespace that appeared immediately after this token in the
 * source text. Comments are not reckoned as whitespace.
 *
 * @category "Primitives"
 * @method "_'s⁇trailing whitespace"
 * @param "aToken" "token"
 *        A token.
 * @returns "string"
 *    The whitespace that appeared after this token in the source text.
 */
Primitive "_'s⁇trailing whitespace" is
[
	aToken : token
|
	Primitive 348;
] : string;

/**
 * Answer the semantic type of the specified phrase type.
 *
 * @category "Primitives"
 * @method "_'s⁇semantic type"
 * @param "phraseType" "phrase meta"
 *        A phrase type.
 * @returns "(⊤)'s type"
 *    The requested semantic type.
 */
Primitive "_'s⁇semantic type" is
[
	phraseType : phrase meta
|
	Primitive 349;
] : type;

/**
 * Answer the semantic type of the specified phrase. This is the type of value
 * produced when the content of the phrase is evaluated (by the compiler and/or
 * runtime).
 *
 * @category "Primitives"
 * @method "_'s⁇semantic type"
 * @param "node" "phrase"
 *        A phrase.
 * @returns "(⊤)'s type"
 *    A type that describes all values producible by evaluations of the
 *    argument.
 */
Primitive "_'s⁇semantic type" is
[
	node : phrase
|
	Primitive 351;
] : type;

/**
 * Construct and answer a phrase type with the specified semantic type.
 *
 * @category "Primitives"
 * @method "_⇒_"
 * @param "aPhrase" "phrase meta"
 *        A phrase type.
 * @param "semanticType" "type"
 *        The semantic type of values producible by phrases that are instances
 *        of the answer.
 * @returns "(phrase⇒⊤)'s type"
 *    The requested phrase type.
 */
Primitive "_⇒_" is
[
	aPhrase : phrase meta,
	semanticType : type
|
	Primitive 355;
] : phrase meta;

/**
 * Answer the lexeme of the specified token. This is the source text that
 * produced the token.
 *
 * @category "Primitives"
 * @method "_'s⁇lexeme"
 * @param "aToken" "token"
 *        A token.
 * @returns "<character…|1..∞>"
 *    The source text of {@param "aToken"}.
 */
Primitive "_'s⁇lexeme" is
[
	aToken : token
|
	Primitive 356;
] : nonempty string;

/**
 * Answer the zero-based starting position of the specified token within the
 * module that supplied it.
 *
 * @category "Primitives"
 * @method "_'s⁇starting position"
 * @param "aToken" "token"
 *        A token.
 * @returns "[1..∞)"
 *    The zero-based starting position of {@param "aToken"}.
 */
Primitive "_'s⁇starting position" is
[
	aToken : token
|
	Primitive 357;
] : natural number;

/**
 * Answer the one-based line number of the specified token within the module
 * that supplied it.
 *
 * @category "Primitives"
 * @method "_'s⁇line number"
 * @param "aToken" "token"
 *        A token.
 * @returns "[1..∞)"
 *    The one-based line number of {@param "aToken"}.
 */
Primitive "_'s⁇line number" is
[
	aToken : token
|
	Primitive 358;
] : natural number;

/**
 * Answer the literal value associated with the specified token.
 *
 * @category "Primitives"
 * @method "_'s⁇value"
 * @param "aLiteralToken" "literal token"
 *        A literal token.
 * @returns "any"
 *    The literal value produced by {@param "aLiteralToken"}.
 */
Primitive "_'s⁇value" is
[
	aLiteralToken : literal token
|
	Primitive 359;
] : any;

/**
 * Construct and answer a (synthetic) literal token.
 *
 * @category "Primitives"
 * @method "``_``(_)"
 * @param "value" "any"
 *        The value of the literal.
 * @param "fakeText" "string"
 *        The "source" text of the literal.
 * @returns "literal token⇒any"
 *    The requested literal token.
 */
Primitive "``_``(_)" is
[
	value : any,
	fakeText : string
|
	Primitive 360;
] : literal token;

/**
 * Answer the arguments of the specified block.
 *
 * @category "Primitives"
 * @method "_'s⁇arguments"
 * @param "aBlock" "block phrase"
 *        A block.
 * @returns "<argument phrase⇒⊤…|>"
 *    A tuple of argument declarations.
 */
Primitive "_'s⁇arguments" is
[
	aBlock : block phrase
|
	Primitive 363;
] : argument tuple;

/**
 * Answer the primitive linkage number of the specified block.
 *
 * @category "Primitives"
 * @method "_'s⁇primitive number"
 * @param "aBlock" "block phrase"
 *        A block.
 * @returns "[0..∞)"
 *    The block's primitive linkage number, or {@code "0"} if the block has
 *    no primitive linkage.
 */
Primitive "_'s⁇primitive number" is
[
	aBlock : block phrase
|
	Primitive 364;
] : whole number;

/**
 * Answer the statements of the specified block.
 *
 * @category "Primitives"
 * @method "_'s⁇statements"
 * @param "aBlock" "block phrase"
 *        A block.
 * @returns "<phrase⇒⊤…|>"
 *    A tuple of statements. These are either assignments, declarations, labels,
 *    sequences, or ⊤-valued sends.
 */
Primitive "_'s⁇statements" is
[
	aBlock : block phrase
|
	Primitive 365;
] : phrase tuple;

/**
 * Answer the return type of the specified block.
 *
 * @category "Primitives"
 * @method "_'s⁇return type"
 * @param "aBlock" "block phrase"
 *        A block.
 * @returns "(⊤)'s type"
 *    The block's return type.
 */
Primitive "_'s⁇return type" is
[
	aBlock : block phrase
|
	Primitive 366;
] : type;

/**
 * Answer the declared exceptions of the specified block.
 *
 * @category "Primitives"
 * @method "_'s⁇declared exceptions"
 * @param "aBlock" "block phrase"
 *        A block.
 * @returns "set"
 *    The block's set of declared exceptions.
 */
Primitive "_'s⁇declared exceptions" is
[
	aBlock : block phrase
|
	Primitive 367;
] : set;

/**
 * Answer the specified block's outer variables.
 *
 * @category "Primitives"
 * @method "_'s⁇outer variables"
 * @param "aBlock" "block phrase"
 *        A block.
 * @returns "<declaration phrase⇒⊤…|>"
 *    A tuple of declarations of outer variables required to complete the
 *    meaning of the block.
 */
Primitive "_'s⁇outer variables" is
[
	aBlock : block phrase
|
	Primitive 368;
] : declaration tuple;

/**
 * Answer the specified assignment's target variable.
 *
 * @category "Primitives"
 * @method "_'s⁇target"
 * @param "anAssignment" "assignment phrase"
 *        An assignment.
 * @returns "variable use phrase⇒any"
 *    The assignment's target variable.
 */
Primitive "_'s⁇target" is
[
	anAssignment : assignment phrase
|
	Primitive 369;
] : variable use phrase;

/**
 * Answer the specified assignment's value expression.
 *
 * @category "Primitives"
 * @method "_'s⁇value"
 * @param "anAssignment" "assignment phrase"
 *        An assignment.
 * @returns "expression phrase⇒any"
 *    The assignment's value expression.
 */
Primitive "_'s⁇value" is
[
	anAssignment : assignment phrase
|
	Primitive 370;
] : expression yielding any;

/**
 * Answer the specified variable reference's referent.
 *
 * @category "Primitives"
 * @method "_'s⁇referent"
 * @param "aReference" "variable reference phrase"
 *        A variable reference.
 * @returns "variable use phrase⇒any"
 *    The variable use referenced by the argument.
 */
Primitive "_'s⁇referent" is
[
	aReference : variable reference phrase
|
	Primitive 371;
] : variable use phrase;

/**
 * Construct and answer an argument declaration.
 *
 * @category "Primitives"
 * @method "arg`«_:_`»"
 * @param "name" "token"
 *        The name of the new constant.
 * @param "declaredType" "any meta"
 *        The declared type of the named constant.
 * @returns "argument phrase⇒⊤"
 *    The requested argument declaration.
 */
Primitive "arg`«_:_`»" is
[
	name : token,
	declaredType : any meta
|
	Primitive 372;
] : argument phrase;

/**
 * Construct and answer a label declaration.
 *
 * @category "Primitives"
 * @method "`«$_:_`»"
 * @param "name" "token"
 *        The name of the new constant.
 * @param "declaredType" "continuation"
 *        The declared type of the named constant.
 * @returns "label phrase⇒⊤"
 *    The requested label declaration.
 */
Primitive "`«$_:_`»" is
[
	name : token,
	declaredType : continuation
|
	Primitive 373;
] : label phrase;

/**
 * Construct and answer a local constant declaration.
 *
 * @category "Primitives"
 * @method "`«_::=_`»"
 * @param "name" "token"
 *        The name of the new constant.
 * @param "declaredType" "expression yielding any"
 *        The initialization expression for the new constant.
 * @returns "local constant phrase⇒⊤"
 *    The requested local constant declaration.
 */
Primitive "`«_::=_`»" is
[
	name : token,
	declaredType : expression yielding any
|
	Primitive 374;
] : local constant phrase;

/**
 * Construct and answer a primitive failure local constant declaration.
 *
 * @category "Primitives"
 * @method "primfail`«_:_`»"
 * @param "name" "token"
 *        The name of the new constant.
 * @param "declaredType" "any meta"
 *        The declared type of the named constant.
 * @returns "primitive failure reason phrase⇒⊤"
 *    The requested primitive failure local constant declaration.
 */
Primitive "primfail`«_:_`»" is
[
	name : token,
	declaredType : any meta
|
	Primitive 375;
] : primitive failure reason phrase;

/**
 * Construct and answer a local variable declaration.
 *
 * @category "Primitives"
 * @method "`«_:_`»"
 * @param "name" "token"
 *        The name of the new variable.
 * @param "declaredType" "any meta"
 *        The declared type of the named variable.
 * @returns "local variable phrase⇒⊤"
 *    The requested local variable declaration.
 */
Primitive "`«_:_`»" is
[
	name : token,
	declaredType : any meta
|
	Primitive 376;
] : local variable phrase;

/**
 * Construct and answer an initialized local variable declaration.
 *
 * @category "Primitives"
 * @method "`«_:_:=_`»"
 * @param "name" "token"
 *        The name of the new variable.
 * @param "declaredType" "any meta"
 *        The declared type of the named variable.
 * @param "initializer" "expression yielding any"
 *        The initialization expression.
 * @returns "local variable phrase⇒⊤"
 *    The requested initialized local variable declaration.
 */
Primitive "`«_:_:=_`»" is
[
	name : token,
	declaredType : any meta,
	initializer : expression yielding any
|
	Primitive 377;
] : local variable phrase;

/**
 * Answer the token that names the entity introduced by the specified
 * declaration.
 *
 * @category "Primitives"
 * @method "_'s⁇token"
 * @param "aDeclaration" "declaration phrase"
 *        A declaration.
 * @returns "token"
 *    The requested token.
 */
Primitive "_'s⁇token" is
[
	aDeclaration : declaration phrase
|
	Primitive 378;
] : token;

/**
 * Answer the declared type of the entity introduced by the specified
 * declaration.
 *
 * @category "Primitives"
 * @method "_'s⁇declared type"
 * @param "aDeclaration" "declaration phrase"
 *        A declaration.
 * @returns "(any)'s type"
 *    The requested type.
 */
Primitive "_'s⁇declared type" is
[
	aDeclaration : declaration phrase
|
	Primitive 379;
] : any meta;

/**
 * If the specified declaration has an initialization expression, then store it
 * into {@param "var"}.
 *
 * @category "Primitives"
 * @method "↓_`?=_'s⁇initialization"
 * @param "var" "write-only expression variable"
 *        A variable.
 * @param "aDeclaration" "declaration phrase"
 *        A declaration.
 * @returns "boolean"
 *    `true` if {@param "aDeclaration"} has an initialization expression and it was
 *    written into {@param "var"}, `false` otherwise.
 */
Primitive "↓_`?=_'s⁇initialization" is
[
	var : write-only expression variable,
	aDeclaration : declaration phrase
|
	Primitive 380;
] : boolean;

/**
 * Construct and answer a literal expression.
 *
 * @category "Primitives"
 * @method "‘_’"
 * @param "aLiteralToken" "literal token"
 *        A literal token.
 * @returns "literal phrase⇒any"
 *    The requested literal expression.
 */
Primitive "‘_’" is
[
	aLiteralToken : literal token
|
	Primitive 381;
] : literal phrase;

/**
 * Answer the specified literal expression's defining token.
 *
 * @category "Primitives"
 * @method "_'s⁇token"
 * @param "aLiteral" "literal phrase"
 *        A literal expression.
 * @returns "literal token⇒any"
 *    The requested literal token.
 */
Primitive "_'s⁇token" is
[
	aLiteral : literal phrase
|
	Primitive 382;
] : literal token;

/**
 * Answer the target method of the specified message send.
 *
 * @category "Primitives"
 * @method "_'s⁇method"
 * @param "aSend" "send phrase"
 *        A message send.
 * @returns "method"
 *    The requested method.
 */
Primitive "_'s⁇method" is
[
	aSend : send phrase
|
	Primitive 384;
] : method;

/**
 * Answer the specified message send's list of argument expressions.
 *
 * @category "Primitives"
 * @method "_'s⁇arguments"
 * @param "aSend" "send phrase"
 *        A message send.
 * @returns "list phrase⇒tuple"
 *    The requested list of argument expressions.
 */
Primitive "_'s⁇arguments" is
[
	aSend : send phrase
|
	Primitive 385;
] : list phrase;

/**
 * Answer the specified message send's expected return type.
 *
 * @category "Primitives"
 * @method "_'s⁇return type"
 * @param "aSend" "send phrase"
 *        A message send.
 * @returns "(⊤)'s type"
 *    The requested type.
 */
Primitive "_'s⁇return type" is
[
	aSend : send phrase
|
	Primitive 386;
] : type;

/**
 * Answer the tuple of statements that constitute the specified sequence.
 *
 * @category "Primitives"
 * @method "_'s⁇statements"
 * @param "aSequence" "sequence phrase"
 *        A sequence.
 * @returns "<phrase⇒⊤…|>"
 *    The requested tuple of statements.
 */
Primitive "_'s⁇statements" is
[
	aSequence : sequence phrase
|
	Primitive 388;
] : phrase tuple;

/**
 * Construct and answer a list from the specified tuple of expressions.
 *
 * @category "Primitives"
 * @method "_→list phrase"
 * @param "aTuple" "tuple of expressions yielding any"
 *        A tuple of expressions.
 * @returns "list phrase⇒tuple"
 *    The requested list.
 */
Primitive "_→list phrase" is
[
	aTuple : tuple of expressions yielding any
|
	Primitive 392;
] : list phrase;

/**
 * Answer the tuple of expressions that constitute the specified list.
 *
 * @category "Primitives"
 * @method "_'s⁇expressions"
 * @param "aList" "list phrase"
 *        A list.
 * @returns "<expression phrase⇒any…|>"
 *    The requested tuple of expressions.
 */
Primitive "_'s⁇expressions" is
[
	aList : list phrase
|
	Primitive 393;
] : tuple of expressions yielding any;

/**
 * Create a variable use expression from the specified token and declaration.
 *
 * @category "Primitives"
 * @method "`«↓_`»(_)"
 * @param "aDeclaration" "declaration phrase"
 *        The declaration that created the referenced entity.
 * @param "aToken" "token"
 *        A token that names the entity at the point of use.
 * @returns "variable use phrase⇒any"
 *    The requested variable use expression.
 */
Primitive "`«↓_`»(_)" is
[
	aDeclaration : declaration phrase,
	aToken : token
|
	Primitive 394;
] : variable use phrase;

/**
 * Answer the specified variable use expression's token.
 *
 * @category "Primitives"
 * @method "_'s⁇token"
 * @param "use" "variable use phrase"
 *        A variable use expression.
 * @returns "token"
 *    The token that names the referenced entity at the point of use.
 */
Primitive "_'s⁇token" is
[
	use : variable use phrase
|
	Primitive 395;
] : token;

/**
 * Answer the declaration that introduced the entity referenced by the specified
 * variable use expression.
 *
 * @category "Primitives"
 * @method "_'s⁇declaration"
 * @param "use" "variable use phrase"
 *        A variable use expression.
 * @returns "declaration phrase⇒⊤"
 *    The requested declaration.
 */
Primitive "_'s⁇declaration" is
[
	use : variable use phrase
|
	Primitive 396;
] : declaration phrase;

/**
 * Construct a suitably parameterized literal token type.
 *
 * @category "Primitives"
 * @method "literal token⇒_"
 * @param "literalValue" "any meta"
 *        The literal value's type
 * @returns "(literal token⇒any)'s type"
 *    A literal token type.
 */
Primitive "literal token⇒_" is
[
	literalValue : any meta
|
	Primitive 397;
] : literal token meta;

/**
 * Extract this literal token type's value type. That's the type of value
 * that a conforming literal token can produce.
 *
 * @category "Primitives"
 * @method "_'s⁇value type"
 * @param "literalTokenType" "literal token meta"
 *        The literal token type.
 * @returns "(any)'s type"
 *    The type of value that such a literal token can produce.
 */
Primitive "_'s⁇value type" is
[
	literalTokenType : literal token meta
|
	Primitive 398;
] : any meta;

/**
 * Compute and answer a block phrase that represents the decompilation of the
 * specified function. Outer variables are treated as literals.
 *
 * @category "Primitives"
 * @method "_→block phrase"
 * @param "aFunction" "function"
 *        A function.
 * @returns "block phrase⇒[…]→⊤"
 *    A block phrase.
 */
Primitive "_→block phrase" is
[
	aFunction : function
|
	Primitive 399;
] : block phrase;

/**
 * Construct and answer a pojo array type whose element type is {@param "elementType"}
 * and whose cardinality requirement is {@param "cardinalityRequirement"}.
 *
 * @category "Primitives"
 * @method "_[_]"
 * @param "elementType" "any meta"
 *        The type of the elements of instances.
 * @param "cardinalityRequirement" "whole number meta"
 *        The range of sizes of instances.
 * @returns "(any[])'s type"
 *    The requested pojo array type.
 */
Primitive "_[_]" is
[
	elementType : any meta,
	cardinalityRequirement : whole number meta
|
	Primitive 501;
] : pojo array meta;

/**
 * Compute and answer a pojo array with the specified element type and length.
 *
 * @category "Primitives"
 * @method "new_[_]"
 * @param "elementType" "any meta"
 *        The element type.
 * @param "length" "whole number"
 *        The number of elements.
 * @returns "any[]"
 *    A new pojo array that can store and answer {@param "length"} elements conforming
 *    to {@param "elementType"}.
 */
Primitive "new_[_]" is
[
	elementType : any meta,
	length : whole number
|
	Primitive 510;
] : pojo array;

/**
 * Answer the number of elements contained by the specified pojo array.
 *
 * @category "Primitives"
 * @method "`|_`|"
 * @param "anArray" "pojo array"
 *        A pojo array.
 * @returns "[0..∞)"
 *    The size of the argument.
 */
Primitive "`|_`|" is
[
	anArray : pojo array
|
	Primitive 511;
] : whole number;

/**
 * Answer the cardinality restriction of the specified pojo array type.
 *
 * @category "Primitives"
 * @method "`|`|_`|`|"
 * @param "pojoArrayType" "pojo array meta"
 *        A pojo array type.
 * @returns "([0..∞))'s type"
 *    The cardinality restriction of {@param "pojoArrayType"}.
 */
Primitive "`|`|_`|`|" is
[
	pojoArrayType : pojo array meta
|
	Primitive 514;
] : whole number meta;

/**
 * Answer the element type of the specified pojo array type.
 *
 * @category "Primitives"
 * @method "_'s⁇element type"
 * @param "pojoArrayType" "pojo array meta"
 *        A pojo array type.
 * @returns "(any)'s type"
 *    The element type of {@param "pojoArrayType"}.
 */
Primitive "_'s⁇element type" is
[
	pojoArrayType : pojo array meta
|
	Primitive 515;
] : any meta;

/**
 * Construct and answer a tuple whose elements are sourced from the specified
 * pojo array.
 *
 * @category "Primitives"
 * @method "_→tuple"
 * @param "aPojoArray" "pojo array"
 *        A pojo array.
 * @returns "tuple"
 *    The requested tuple.
 */
Primitive "_→tuple" is
[
	aPojoArray : pojo array
|
	Primitive 516;
] : tuple;

/**
 * Answer the current fiber.
 *
 * @returns "fiber→⊤"
 *    The current fiber.
 */
Primitive "current fiber" is
[
	Primitive 600;
] : fiber;

/**
 * Extract the priority of a fiber. A fiber with higher priority may receive a
 * larger share of the available CPU time than one with a low priority.
 *
 * @category "Primitives"
 * @method "_'s⁇priority"
 * @param "aFiber" "fiber"
 *        The fiber from which to extract the priority.
 * @returns "[0..255]"
 *    A whole number representing the priority of the fiber.
 */
Primitive "_'s⁇priority" is
[
	aFiber : fiber
|
	Primitive 601;
] : byte;

/**
 * Modify the priority of a fiber. A fiber with higher priority may receive a
 * larger share of the available CPU time than one with a low priority.
 *
 * @category "Primitives"
 * @method "_'s⁇priority:=_"
 * @param "aFiber" "fiber"
 *        The fiber to prioritize.
 * @param "priority" "byte"
 *        The new priority.
 */
Primitive "_'s⁇priority:=_" is
[
	aFiber : fiber,
	priority : byte
|
	Primitive 602;
] : ⊤;

/**
 * Has termination of the current fiber been requested? Answer the current value
 * of the appropriate interrupt request flag and simultaneously clear it.
 *
 * @returns "boolean"
 *    `true` if termination of the current fiber has been requested, `false`
 *    otherwise.
 */
Primitive "termination requested" is
[
	Primitive 607;
] : boolean;

/**
 * Request termination of the specified fiber, unparking the fiber at the same
 * time. Termination is consensual only; cooperation of the fiber is required to
 * affect actual termination.
 *
 * @category "Primitives"
 * @method "Request termination of_"
 * @param "victim" "fiber"
 *        A fiber.
 */
Primitive "Request termination of_" is
[
	victim : fiber
|
	Primitive 608;
] : ⊤;

/**
 * Terminate the current fiber.
 */
Primitive "Terminate current fiber" is
[
	Primitive 609;
] : ⊥;

/**
 * Attempt to acquire the permit associated with the current fiber. If the
 * permit is available, then consume it and return immediately. If the permit is
 * not available, then park the current fiber. A fiber suspended in this fashion
 * may be resumed only by calling `Unpark_`. A newly unparked fiber should
 * always recheck the basis for its having parked, to see if it should park
 * again. Low-level synchronization mechanisms may require the ability to
 * spuriously unpark in order to ensure correctness.
 */
Primitive "Park current fiber" is
[
	Primitive 610;
] : ⊤;

/**
 * Unpark the specified fiber. If the permit associated with the fiber is
 * available, then simply continue. If the permit is not available, then restore
 * the permit and schedule resumption of the fiber. A newly unparked fiber
 * should always recheck the basis for its having parked, to see if it should
 * park again. Low-level synchronization mechanisms may require the ability to
 * spuriously unpark in order to ensure correctness.
 *
 * @category "Primitives"
 * @method "Unpark_"
 * @param "aFiber" "fiber"
 *        A fiber.
 */
Primitive "Unpark_" is
[
	aFiber : fiber
|
	Primitive 611;
] : ⊤;

/**
 * Yield the current fiber. That is, give up the fiber's time slice so that
 * other processes of higher or equal priority may run.
 */
Primitive "Yield current fiber" is
[
	Primitive 612;
] : ⊤;

/**
 * Answer the name of the specified fiber.
 *
 * @category "Primitives"
 * @method "_'s⁇name"
 * @param "aFiber" "fiber"
 *        A fiber.
 * @returns "string"
 *    The fiber's name.
 */
Primitive "_'s⁇name" is
[
	aFiber : fiber
|
	Primitive 613;
] : string;

/**
 * Set the name of the specified fiber.
 *
 * @category "Primitives"
 * @method "_'s⁇name:=_"
 * @param "aFiber" "fiber"
 *        A fiber.
 * @param "name" "string"
 *        The fiber's new name.
 */
Primitive "_'s⁇name:=_" is
[
	aFiber : fiber,
	name : string
|
	Primitive 614;
] : ⊤;

/**
 * Has the specified fiber terminated?
 *
 * @category "Primitives"
 * @method "_has terminated"
 * @param "aFiber" "fiber"
 *        A fiber.
 * @returns "boolean"
 *    `true` if the fiber has terminated, `false` otherwise.
 */
Primitive "_has terminated" is
[
	aFiber : fiber
|
	Primitive 618;
] : boolean;

/**
 * Does the specified fiber have a result ready?
 *
 * @category "Primitives"
 * @method "_has result"
 * @param "aFiber" "fiber"
 *        A fiber.
 * @returns "boolean"
 *    `true` if the fiber has terminated and produced a result, `false`
 *    otherwise.
 */
Primitive "_has result" is
[
	aFiber : fiber
|
	Primitive 619;
] : boolean;

/**
 * Cause the current fiber to sleep for the specified number of milliseconds.
 * The fiber will sleep for at least the specified amount of time, and a best
 * effort will be made to awaken the fiber as soon as the delay has expired.
 * No real-time guarantees are made.
 *
 * @category "Primitives"
 * @method "Sleep for_millisecond|milliseconds"
 * @param "delayMillis" "nonnegative extended integer"
 *        The minimum number of milliseconds to sleep.
 */
Primitive "Sleep for_millisecond|milliseconds" is
[
	delayMillis : nonnegative extended integer
|
	Primitive 621;
] : ⊤;

/**
 * Ascertain whether the current fiber was forked (by the compiler) in order to
 * evaluate a semantic restriction.
 *
 * @returns "boolean"
 *    `true` if the current fiber is applying a semantic restriction, `false`
 *    otherwise.
 */
Primitive "current fiber is applying a semantic restriction" is
[
	Primitive 625;
] : boolean;

/**
 * Construct and answer a fiber type whose result type is {@param "resultType"}.
 *
 * @category "Primitives"
 * @method "fiber→_"
 * @param "resultType" "type"
 *        A type.
 * @returns "(fiber→⊤)'s type"
 *    The requested fiber type.
 */
Primitive "fiber→_" is
[
	resultType : type
|
	Primitive 626;
] : fiber meta;

/**
 * Answer the result type of the specified fiber type.
 *
 * @category "Primitives"
 * @method "_'s⁇result type"
 * @param "fiberType" "fiber meta"
 *        A fiber type.
 * @returns "(⊤)'s type"
 *    The argument's result type.
 */
Primitive "_'s⁇result type" is
[
	fiberType : fiber meta
|
	Primitive 627;
] : type;

/**
 * Reverses the order of the given tuple.
 *
 * @category "Primitives"
 * @method "_reversed"
 * @param "aTuple" "tuple"
 *        A tuple.
 * @returns "tuple"
 *    A tuple that is the reverse of the original tuple
 */
Primitive "_reversed" is
[
	aTuple : tuple
|
	Primitive 702;
] : tuple;

