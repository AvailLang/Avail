#
# SpecialObjectNames_en.properties
# Copyright © 1993-2013, Mark van Gulik and Todd L Smith.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of the copyright holder nor the names of the contributors
#   may be used to endorse or promote products derived from this software
#   without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#

#
# GENERATED FILE
# * Generator: com.avail.tools.bootstrap.SpecialObjectNamesGenerator
# * Last Versioned As: $$Revision$$
#
# Property assignments, BUT NOT THE COPYRIGHT OR THIS NOTICE, may safely be
# modified manually.
#

# any
specialObject1=any
specialObject1_comment=\
/**\n\
\ * The practical abstract root of the Avail type lattice. `any` is the second\n\
\ * most senior type, inferior only to `⊤`. It includes every value available\n\
\ * to an Avail program, i.e., every Avail value except for the unexposed special\n\
\ * value nil.\n\
\ *\n\
\ * `any` is made extremely useful by the interaction of polymorphism and\n\
\ * semantic restrictions. Many algorithms can be codified once in terms of `any`\n\
\ * and then strengthened via a semantic restriction that extrapolates a\n\
\ * stronger result subtype from the static input types.\n\
\ *\n\
\ * `any` is the most general type that may appear in the following contexts:\n\
\ *\n\
\ *    - As a parameter type of a function type.\n\
\ *    - As the read type of a variable type.\n\
\ *    - As a leading type or the default type of a tuple type.\n\
\ *    - As the element type of a set type.\n\
\ *    - As the key type or value type of a map type.\n\
\ *    - As the field type of an object type.\n\
\ *    - As the type parameter of a pojo type.\n\
\ */\n
# boolean
specialObject2=boolean
specialObject2_comment=\
/**\n\
\ * The enumeration of the special atoms `true` and `false`. All primitive\n\
\ * interrogatives use classical (Boolean) bivalence and obey the three classical\n\
\ * (Aristotelian) laws of thought.\n\
\ *\n\
\ * Bivalent logic assigns either `true` or `false` as the unique truth value of\n\
\ * every proposition. Every primitive interrogative, i.e. `boolean`-valued\n\
\ * primitive, stably answers either `true` or `false` for a given set of\n\
\ * arguments.\n\
\ *\n\
\ * The three classical laws of thought are:\n\
\ *\n\
\ *    - The law of identity: P → P.\n\
\ *      For every primitive interrogative "prim_,_,_", then\n\
\ *      "prim A, B, C = prim A, B, C". (All primitive interrogatives are\n\
\ *      stable.)\n\
\ *    - The law of noncontradiction: ¬(P ∧ ¬P).\n\
\ *      For every primitive interrogative "prim_,_,_", then\n\
\ *      "(prim A, B, C ∧ ¬prim A, B, C) = false".\n\
\ *    - The law of excluded middle: P ∨ ¬P.\n\
\ *      For every primitive interrogative "prim_,_,_", then\n\
\ *      "((prim A, B, C = true) ∨ (prim A, B, C = false)) = true".\n\
\ *\n\
\ * Therefore the primitive interrogatives satisfy classical logic.\n\
\ *\n\
\ * Note that values may be instances of many enumerations. This means that Avail\n\
\ * directly supports other logical systems, such as Kleene's three-valued logic\n\
\ * of indeterminacy, whose truth values are `true`, `false`, and "unknown".\n\
\ * Implementation of this system would proceed directly from creation of an atom\n\
\ * to represent "unknown" and the formation of a new enumeration that contained\n\
\ * the standard `true` and `false` atoms and also the "unknown" atom. New\n\
\ * logical operations could then be written in terms of this new enumeration.\n\
\ */\n
# character
specialObject3=character
specialObject3_comment=
# […]→⊤
specialObject4=function
specialObject4_comment=
# ([…]→⊤)'s type
specialObject5=function meta
specialObject5_comment=
# ¢[…]→⊤
specialObject6=function implementation
specialObject6_comment=
# ↑<--(⊤)/(⊥)-->
specialObject7=variable
specialObject7_comment=
# (↑<--(⊤)/(⊥)-->)'s type
specialObject8=variable meta
specialObject8_comment=
# $[…]→⊥
specialObject9=continuation
specialObject9_comment=
# ($[…]→⊥)'s type
specialObject10=continuation meta
specialObject10_comment=
# atom
specialObject11=atom
specialObject11_comment=
# double
specialObject12=double
specialObject12_comment=
# [-∞..∞]
specialObject13=extended integer
specialObject13_comment=
# (<(any)'s type…|>)'s type
specialObject14=type of tuple of type of any
specialObject14_comment=
# float
specialObject15=float
specialObject15_comment=
# number
specialObject16=number
specialObject16_comment=
# (-∞..∞)
specialObject17=integer
specialObject17_comment=
# ([-∞..∞])'s type
specialObject18=extended integer meta
specialObject18_comment=
# (map)'s type
specialObject19=map meta
specialObject19_comment=
# module
specialObject20=module
specialObject20_comment=
# <
#	1,
#	2,
#	3,
#	4,
#	5,
#	6,
#	7,
#	8,
#	9,
#	10,
#	11,
#	12,
#	13,
#	14,
#	15,
#	17,
#	18,
#	19,
#	20,
#	21,
#	22,
#	23,
#	24,
#	25,
#	26,
#	27,
#	28,
#	29,
#	30,
#	31,
#	32,
#	33,
#	34,
#	35,
#	36,
#	37,
#	38,
#	39,
#	40,
#	41,
#	42,
#	43,
#	44,
#	45,
#	46,
#	47,
#	48,
#	49,
#	50,
#	51,
#	52,
#	53,
#	54,
#	55,
#	56,
#	57,
#	58,
#	70,
#	71,
#	72,
#	73,
#	80,
#	81,
#	82,
#	83,
#	100,
#	101,
#	102,
#	103,
#	105,
#	500,
#	501,
#	502,
#	504,
#	505,
#	506,
#	507,
#	508>
specialObject21=VM error codes
specialObject21_comment=
# Unnamed object type
specialObject22=object
specialObject22_comment=
# (Unnamed object type)'s type
specialObject23=object meta
specialObject23_comment=
# exception
specialObject24=exception
specialObject24_comment=
# fiber
specialObject25=fiber
specialObject25_comment=
# set
specialObject26=set
specialObject26_comment=
# (set)'s type
specialObject27=set meta
specialObject27_comment=
# string
specialObject28=string
specialObject28_comment=
# ⊥
specialObject29=⊥
specialObject29_alphabetic=bottom
specialObject29_comment=
# (⊥)'s type
specialObject30=⊥meta
specialObject30_alphabetic=bottom meta
specialObject30_comment=
# nontype
specialObject31=nontype
specialObject31_comment=
# tuple
specialObject32=tuple
specialObject32_comment=
# (tuple)'s type
specialObject33=tuple meta
specialObject33_comment=
# (⊤)'s type
specialObject34=type
specialObject34_comment=
# ⊤
specialObject35=⊤
specialObject35_alphabetic=top
specialObject35_comment=\
/**\n\
\ * The true abstract root of the Avail type lattice. It is pronounced "top" and\n\
\ * written as the down tack (⊤) character. Every Avail value is an instance\n\
\ * of `⊤`, and every Avail type is a subtype of `⊤`.\n\
\ *\n\
\ * `⊤` is distinct from `any` in that it includes exactly one additional value:\n\
\ * the special value nil. This value does not satisfy any public protocol and\n\
\ * is not available to an Avail programmer. It is, however, implicitly returned\n\
\ * from every procedure, i.e., function whose return type is `⊤`. Thus nil is\n\
\ * the value produced iff no value is produced. The virtual machine uses nil to\n\
\ * simplify several core algorithms, but exposure of nil to an Avail programmer\n\
\ * would not yield a net good.\n\
\ *\n\
\ * `⊤` typically appears in Avail code in only a few select contexts:\n\
\ *\n\
\ *    - As the return type of a function type. In this context, it signifies\n\
\ *      that the function does not produce a value, i.e., it produces the\n\
\ *      unexposed value nil.\n\
\ *    - As the return type of a continuation type. In this context, it\n\
\ *      signifies that the continuation will not produce a value, i.e., it\n\
\ *      produces the unexposed value nil.\n\
\ *    - As the read type of a variable type. In this context, it signifies\n\
\ *      that no value may be read from the variable, i.e., the variable is\n\
\ *      write-only.\n\
\ *    - As the idempotent initial value of an accumulator variable whose\n\
\ *      intermediate and final results represent a chain of type intersections.\n\
\ *      (Note that the type intersection of `⊤` with some type X is always X.)\n\
\ *    - As the result of a semantic restriction on a procedure that serves only\n\
\ *      to reject parses based on the static types of the arguments (but does\n\
\ *      not strengthen the return type).\n\
\ *    - As the result type of a phrase. In this context, it signifies that the\n\
\ *      phrase serves as a statement (and not merely as an expression).\n\
\ *\n\
\ * A function whose declared return type is `⊤` is still permitted to answer an\n\
\ * actual (non-nil) value. This is consistent with the type lattice, since every\n\
\ * value is an instance of `⊤`. It is useful, moreover, because a semantic\n\
\ * restriction may strengthen the return type of a `⊤`-valued function at a\n\
\ * particular call site to a subtype of `⊤`.\n\
\ *\n\
\ * `⊤` is expressly forbidden from occurring in most contexts, including the\n\
\ * following:\n\
\ *\n\
\ *    - As a parameter type of a function type.\n\
\ *    - As the write type of a variable type. This also implies that it cannot\n\
\ *      be the type of an actual variable.\n\
\ *    - As a leading type or the default type of a tuple type.\n\
\ *    - As the element type of a set type.\n\
\ *    - As the key type or value type of a map type.\n\
\ *    - As the field type of an object type.\n\
\ *    - As the type parameter of a pojo type.\n\
\ *\n\
\ * Note that these prohibitions, when considered in aggregate, negate any\n\
\ * possible value that could be gleaned from exposing the special value nil to\n\
\ * an Avail program. They conspire together to ensure that nil could never be\n\
\ * retained by an Avail value. It may therefore only exist as a temporary within\n\
\ * a continuation, i.e., an item on the local stack of a function call. A\n\
\ * reflective query of a continuation''s temporaries that would answer nil will\n\
\ * instead produce a variable whose read type is `⊥`.\n\
\ */\n
# [0..∞)
specialObject36=whole number
specialObject36_comment=
# [1..∞)
specialObject37=natural number
specialObject37_comment=
# [0..1114111]
specialObject38=code point
specialObject38_comment=
# map
specialObject39=map
specialObject39_comment=
# message bundle
specialObject40=message bundle
specialObject40_comment=
# message bundle tree
specialObject41=message bundle tree
specialObject41_comment=
# method
specialObject42=method
specialObject42_comment=
# definition
specialObject43=definition
specialObject43_comment=
# abstract definition
specialObject44=abstract definition
specialObject44_comment=
# forward definition
specialObject45=forward definition
specialObject45_comment=
# method definition
specialObject46=method definition
specialObject46_comment=
# macro definition
specialObject47=macro definition
specialObject47_comment=
# phrase→⊤
specialObject50=phrase
specialObject50_comment=
# sequence phrase→⊤
specialObject51=sequence phrase
specialObject51_comment=
# expression phrase→⊤
specialObject52=expression phrase
specialObject52_comment=
# assignment phrase→⊤
specialObject53=assignment phrase
specialObject53_comment=
# block phrase→[…]→⊤
specialObject54=block phrase
specialObject54_comment=
# literal phrase→any
specialObject55=literal phrase
specialObject55_comment=
# reference phrase→↑<--(⊤)/(⊥)-->
specialObject56=variable reference phrase
specialObject56_comment=
# send phrase→⊤
specialObject57=send phrase
specialObject57_comment=
# (literal token⇒any)'s type
specialObject58=literal token meta
specialObject58_comment=\
/**\n\
\ * The type (meta) of the most general literal token type.\n\
\ */\n
# list phrase→tuple
specialObject59=list phrase
specialObject59_comment=
# variable use phrase→any
specialObject60=variable use phrase
specialObject60_comment=
# declaration phrase→⊤
specialObject61=declaration phrase
specialObject61_comment=
# argument phrase→⊤
specialObject62=argument phrase
specialObject62_comment=
# label phrase→⊤
specialObject63=label phrase
specialObject63_comment=
# local variable phrase→⊤
specialObject64=local variable phrase
specialObject64_comment=
# local constant phrase→⊤
specialObject65=local constant phrase
specialObject65_comment=
# module variable phrase→⊤
specialObject66=module variable phrase
specialObject66_comment=
# module constant phrase→⊤
specialObject67=module constant phrase
specialObject67_comment=
# primitive failure reason phrase→⊤
specialObject68=primitive failure reason phrase
specialObject68_comment=
# (any)'s type
specialObject69=any meta
specialObject69_comment=
# true
specialObject70=true
specialObject70_comment=\
/**\n\
\ * The special atom that represents truth. `true` is an instance of `boolean`.\n\
\ */\n
# false
specialObject71=false
specialObject71_comment=\
/**\n\
\ * The special atom that represents falsehood. `false` is an instance of\n\
\ * `boolean`.\n\
\ */\n
# <string…|>
specialObject72=tuple of string
specialObject72_comment=
# <(⊤)'s type…|>
specialObject73=tuple of type
specialObject73_comment=
# <{string|}…|>
specialObject74=tuple of set of string
specialObject74_comment=
# {string|}
specialObject75=set of string
specialObject75_comment=
# [[1..∞)]→⊥
specialObject76=primitive failure function
specialObject76_comment=
# ∅
specialObject77=∅
specialObject77_alphabetic=empty set
specialObject77_comment=
# -∞
specialObject78=-∞
specialObject78_alphabetic=negative infinity
specialObject78_comment=
# ∞
specialObject79=∞
specialObject79_alphabetic=positive infinity
specialObject79_comment=
# java.lang.Object
specialObject80=pojo
specialObject80_comment=
# pojo ⊥
specialObject81=null
specialObject81_comment=
# null ∈ pojo ⊥
specialObject82=pojo⊥
specialObject82_alphabetic=pojo bottom
specialObject82_comment=
# (pojo self)'s type
specialObject83=pojo self type
specialObject83_comment=
# (java.lang.Object)'s type
specialObject84=pojo meta
specialObject84_comment=
# (any[])'s type
specialObject85=pojo array meta
specialObject85_comment=
# […]→java.lang.Object
specialObject86=pojo constructor
specialObject86_comment=
# any[]
specialObject87=pojo array
specialObject87_comment=
# pojo self
specialObject88=pojo self
specialObject88_comment=
# java.lang.Throwable
specialObject89=pojo exception
specialObject89_comment=
# []→⊤
specialObject90=nullary procedure
specialObject90_comment=
# []→boolean
specialObject91=predicate function
specialObject91_comment=
# ↑$[…]→⊥
specialObject92=continuation variable
specialObject92_comment=
# {atom→any|}
specialObject93=field map
specialObject93_comment=
# {atom→(any)'s type|}
specialObject94=field type map
specialObject94_comment=
# <<any…|2>…|>
specialObject95=key-value tuple
specialObject95_alphabetic=key value tuple
specialObject95_comment=
# {}
specialObject96=empty map
specialObject96_comment=
# {any→any|1..∞}
specialObject97=non-empty map
specialObject97_alphabetic=non empty map
specialObject97_comment=
# ([0..∞))'s type
specialObject98=whole number meta
specialObject98_comment=
# {any|1..∞}
specialObject99=non-empty set
specialObject99_alphabetic=non empty set
specialObject99_comment=
# <tuple…|>
specialObject100=tuple of tuple
specialObject100_comment=
# [0..15]
specialObject101=nybble
specialObject101_comment=
# <[0..15]…|>
specialObject102=tuple of nybble
specialObject102_comment=
# [0..65535]
specialObject103=unsigned short
specialObject103_comment=
# <>
specialObject104=empty tuple
specialObject104_comment=
# [⊥]→⊤
specialObject105=unary procedure
specialObject105_comment=
# (0)'s type
specialObject106=type of zero
specialObject106_comment=
# […]→(⊤)'s type
specialObject107=semantic restriction function
specialObject107_comment=
# <[…]→(⊤)'s type…|>
specialObject108=tuple of semantic restriction function
specialObject108_comment=
# […]→phrase→⊤
specialObject109=macro function
specialObject109_comment=
# (2)'s type
specialObject110=type of two
specialObject110_comment=
# 2.718281828459045d
specialObject111=Euler's number
specialObject111_alphabetic=Euler number
specialObject111_comment=
# (2.718281828459045d)'s type
specialObject112=type of Euler number
specialObject112_comment=
# (phrase→⊤)'s type
specialObject113=phrase meta
specialObject113_comment=
# {atom|}
specialObject114=set of atom
specialObject114_comment=
# token
specialObject115=token
specialObject115_comment=
# literal token⇒any
specialObject116=literal token
specialObject116_comment=\
/**\n\
\ * The most general literal token type.\n\
\ */\n
# <(any)'s type…|>
specialObject117=tuple of any meta
specialObject117_comment=
# [0..∞]
specialObject118=nonnegative extended integer
specialObject118_comment=
# <<atom, (any)'s type…|2>…|>
specialObject119=field type tuple
specialObject119_comment=
# <<atom, any…|2>…|>
specialObject120=field tuple
specialObject120_comment=
# <phrase→⊤…|>
specialObject121=phrase tuple
specialObject121_comment=
# <argument phrase→⊤…|>
specialObject122=argument tuple
specialObject122_comment=
# <declaration phrase→⊤…|>
specialObject123=declaration tuple
specialObject123_comment=
# ↑<--(⊤)/(expression phrase→⊥)-->
specialObject124=write-only expression variable
specialObject124_alphabetic=write only expression variable
specialObject124_comment=
# <expression phrase→any…|>
specialObject125=tuple of expressions yielding any
specialObject125_comment=
# expression phrase→any
specialObject126=expression yielding any
specialObject126_comment=
# [java.lang.Throwable]→⊥
specialObject127=pojo failure function
specialObject127_comment=
# <{atom|}…|>
specialObject128=tuple of set of atom
specialObject128_comment=
# [0..255]
specialObject129=byte
specialObject129_comment=
# <<(any)'s type…|>…|>
specialObject130=tuple of tuple of any meta
specialObject130_comment=
# ↑<--([-∞..∞])/(⊥)-->
specialObject131=readable extended integer variable
specialObject131_comment=
