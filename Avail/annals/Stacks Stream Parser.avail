/*
 * Stacks Stream Parser.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Stacks Stream Parser"
Versions
"Dev"
Extends

Uses
	"Avail",
	"Annals Class Definitions",
	"Stacks Lexer"
Names
	"identify comment from_",
	"Parse the Avail document_",
	"Print comment map's tokens"

Body

/* Special parse characters */
keyCharacters ::= {¢/, ¢@, ¢*, ¢"\n"};

/* Special keywords using @ symbols */
keywords ::= 
	{"@type","@supertype","@field","@category","@param","@raises","@restricts",
	"@returns","@forbids","@public","@method","@see","@author",
	"@link","@code","@global"};

/* Global Variables */
openCommentCount : whole number := 0;
lineCount : natural number := 1;
buffer : <character…|> := <>;
inAnnalsType : boolean := false; 
annalsType : string := "";
annalsObjectName : string := "";
fileCommentMapsTuple : <{string→{<stacks token, <stacks token…|>…|>|}|}…|> := <>;

/* This will eventually be the name of the file being processed */
fileName : string : = "test file.avail";

/* Does current comment being parsed contain an error */
commentError: boolean := false;

/* Where all error comments go */
errorComments : <erroneous comment…|>  := <>;


classMap : {string→class|} := {};
methodMap : {string→method container|} := {};



/**
 * Checks to see if the input character is one of the key characters defined
 * in the global variable set, keyCharacters.
 * @method "_is a key character"
 * @category "Stacks"
 * @param "char" character
 * @returns boolean
 * @raises
 */
Private method "_is a key character" is
[
 	char : character
 |
 	char ∈ keyCharacters
]:boolean;

/**
 * Creates the enumeration of the global variable keywords.
 * @method "comment keywords"
 * @category "Stacks"
 * @returns enumeration of keywords
 * @raises
 */
Private method "comment keywords" is [enumeration of keywords];

/**
 * Creates the enumeration of open comment strings.
 * @method "open comment strings"
 * @category "Stacks"
 * @returns enumeration of open comment strings
 * @raises
 */
Private method "open comment strings" is [enumeration of {"/*","/**"}];

/**
 * Updates the globla variable, openCommentCount.  It adds one to the count.
 * @method "Increment the open comment count"
 * @category "Stacks"
 * @returns ⊤
 * @raises
 */
Private method "Increment the open comment count" is
[
 	↑openCommentCount++;
]:⊤;

/**
 * Updates the globla variable, openCommentCount.  It subtracts one from the 
 * count.
 * @method "Decrement the open comment count"
 * @category "Stacks"
 * @returns ⊤
 * @raises
 */
Private method "Decrement the open comment count" is
[
 	 	openCommentCount := cast (openCommentCount - 1) into 
 	 		[w : whole number | w];
]:⊤;

/**
 * Updates the globla variable, lineCount.  It adds one to the line count.
 * @method "Increment the line count"
 * @category "Stacks"
 * @returns ⊤
 * @raises
 */
Private method "Increment the line count" is
[
	↑lineCount++;
]:⊤;

/**
 * Checks to see if the iterator of character is not exhausted.
 * @method "_is not exhausted"
 * @category "Annals"
 * @param "iter" iterator of character
 * @returns boolean
 * @raises
 */
Private method "_is not exhausted" is
[
 	iter : iterator of character
 |
 	¬iter is exhausted
]:boolean;

/**
 * Clears the global variable, buffer, of all its contents.
 * @method "Clear the buffer"
 * @category Stacks""
 * @returns ⊤
 * @raises
 */
Private method "Clear the buffer" is
[
	buffer := <>;
]:⊤;

/**
 * Update the global variable, buffer, with the current element on the iterator of character.
 * Proceed to advance the iterator of character.
 * @method "Buffer_"
 * @category "Stacks"
 * @param "iter" iterator of character
 * @returns ⊤
 * @raises
 */
Private method "Buffer_" is
[
	iter : iterator of character
 |
	buffer := buffer ++ 
		<iter's current element>;
	Advance iter;
]:⊤;

/**
 * Given an iterator of character at the start of a comment, collect all the 
 * characters until the open comment count is 0.
 * @method "buffer comment from_"
 * @category "Stacks"
 * @param "iter" iterator of character
 * @returns "string"  The entire comment less the opening * on a new line.
 */
Private method "buffer comment from_" is
[
 	iter : iterator of character
 |

	While 
	[
	 	iter is not exhausted ∧ 
	 		[openCommentCount ≠ 0]
	]
	do
	[
	 	prevChar : character := iter's current element;
	 	/* Simply buffer characters that are not special */
		While 
		[
		 	iter's current element ∉ {¢*,¢/}
		]
		do
		[
		 	/* Preserve the current element of the iterator of character. */
		 	prevChar := iter's current element;
		 	Buffer iter;
		];
		/* The * is a special character that has multiple implications */
		if iter's current element = ¢* then
		[
		 	prevChar := iter's current element;
		 	Buffer iter;
	 	 	/* This indicates a closing of a comment */
	 		if iter's current element = ¢/ then
	 		[
	 		 	/* The closing of a nested comment */
	 		 	if openCommentCount > 1 then
	 		 	[
	 		 	 	/*Capture everything from the nested comment*/
	 		 	 	Decrement the open comment count;
	 		 	 	Buffer iter;
	 		 	]
	 		 	/* Closing the top level comment, all loops will end.*/
	 		 	else
	 		 	[
	 		 	 	Decrement the open comment count;
	 		 	 	Buffer iter;
	 		 	];
	 		]
	 		/* The * character isn't doing anything special but is actually
	 		 * part of text.  Buffer it.*/
	 		else
	 		[
	 		 	buffer := buffer ++ <prevChar, 
	 		 	iter's current element>;
	 		 	Advance iter;
	 		];
		]
		else if [iter's current element = ¢/] then
		[
		 	Buffer iter;
			/* If open of a nested comment.  Capture open comment syntax*/
			If iter is not exhausted ∧ 
	 			[iter's current element = ¢*] then 
			[
			 	Increment the open comment count;
			 	Buffer iter;
			];
		]
		else [/* Only get here if iterator is exhausted before comment closed*/];	
	];
]:⊤;

/**
 * Divide the comment buffer into parts designated by `@ tag keywords.  If `@
 * tag is escaped or preceded by a {, then ignore tag.
 *
 * @method "split_"
 * @category "Stacks"
 * @param "<stacks token…|1..>" "tokens" 
 * 	a tuple of stacks tokens
 * @returns "{stacks token→{<stacks token…|>|1..}|}"
 *		a map of a set of stacks token tuples keyed by special stacks tokens 
 * @author "Richard Arriaga"
 */
Private method "split stacks tuple_" is
[
 	tokens : <stacks token…|1..>
 |
 	parsedTokenMap : {string→{<stacks token, <stacks token…|>…|>|}|} := {};
 	
 	/* Partition stacks tuple into map keyed by special stacks token type */
 	generalComment : <stacks token…|> := <>;
 	If ¬(tokens[1]'s isSpecial) ∨ [tokens[1]'s lexeme = "@general"] then 
 	[
 	 	generalKey ::= if ¬(tokens[1]'s isSpecial) then
 	 	[
 	 	 	a stacks token with
				lexeme := "@general",
				line := tokens[1]'s line,
				position := 0,
				isSpecial := true
		] else [tokens[1]];
		generalComment := generalComment ++ take from tokens until 
 	 	[
 	 	 	st : stacks token
 	 	 |
 	 		st's isSpecial
 	 	];
 	 	parsedTokenMap := parsedTokenMap + 
 	 		generalKey's lexeme→{<generalKey,generalComment>};
 	];
	/* Take remaining portion of unconsumed tuple */
	remainder : <stacks token…|> := <>;
	remainder := if |generalComment| = 0 then [remainder ++ tokens]
		else [remainder ++ tokens[|generalComment|+1..]];
 	While
 	[
 	 	|remainder| ≠ 0
 	]
 	do
 	[
		genericStacks ::= take from remainder[2..] until 
		[
		 	st : stacks token
		 |
			st's isSpecial
		];
		parsedTokenMap := parsedTokenMap + 
			remainder[1]'s lexeme→({<remainder[1],genericStacks>} 
			∪ parsedTokenMap[remainder[1]'s lexeme] else [∅]);
 	 	remainder := if |remainder| = |genericStacks|+1 then [<>]
 	 		else [remainder[|genericStacks|+2..]];
 	];
 	parsedTokenMap
]:{string→{<stacks token, <stacks token…|>…|>|}|};

















/* TODO write funtions to process @keywords in map.  Complete error file
 * handling for erroneous comments.*/


/**
 * Locate Stacks comment from iterator of character
 * @method "identify comment from_"
 * @category "Stacks"
 * @param "iter" iterator of character
 * @returns ⊤
 * @raises
 */
Public method "identify comment from_" is
[
 	iter : iterator of character
 |
 	keyBuffer : <character…|> := <>;
 	
 	While
 	[
 	 	iter is not exhausted
 	]
 	do
 	[
	 	While
	 	[
	 	 	iter is not exhausted ∧ [iter's current element ∉ {¢/}]
	 	]
	 	do
	 	[
	 	 	If iter's current element ∈ {¢"\n"} then 
	 	 		[Increment the line count;];
	 	 	Advance iter;
	 	];
	 	While 
		[
		 	iter is not exhausted ∧ [iter's current element ∉ {¢" ",¢"\n"}]
		]
		do
	 	[
	 	 	keyBuffer:= keyBuffer ++ 
	 	 		<iter's current element>;
	 	 	Advance iter;
	 	];
		if keyBuffer = "/**" ∧ [openCommentCount = 0] then 
		[
		 	/* Process Stacks Comment */
		 	Increment the open comment count;
		 	buffer := buffer ++ keyBuffer;
		 	buffer comment from iter;
		 	mp1 ::= split stacks tuple tokenize buffer;

		 	fileCommentMapsTuple := fileCommentMapsTuple ++ <mp1>;
		 	Clear the buffer;
		 	keyBuffer := <>;
		 ]
		else if [keyBuffer = "/*"] then 
		[
		 	/* Entering basic comment.  Increment open comment count. */
		 	Increment the open comment count;
		 	keyBuffer := <>;
		 	If iter's current element ∈ {¢"\n"} then 
 	 		[Increment the line count;];
		 	While
		 	[
		 	 	iter is not exhausted ∧ [openCommentCount ≠ 0]
		 	]
		 	do
		 	[
		 	 	if iter's current element ∈ {¢*} then
		 	 	[
		 	 	 	Advance iter;
		 	 	 	if iter is not exhausted ∧ [iter's current element ∈ {¢/}]
		 	 	 	then
		 	 	 	[
		 	 	 	 	Advance iter;
		 	 	 	 	Decrement the open comment count;
		 	 	 	] else if [iter's current element ∈ {¢"\n"}] then 
		 	 		[Increment the line count;]
		 	 		else [/*Do nothing*/];
		 	 	]
		 	 	else 
		 	 	[
		 	 	 	Advance iter;
		 	 	 	If iter's current element ∈ {¢"\n"} then 
		 	 	 		[Increment the line count;];
		 	 	];
		 	];
		 ]
		else [keyBuffer := <>;];
	];
]:⊤;

/**
 * A print method for fileCommentMapsTuple to test tokenizer
 *
 * @method "Print comment maps tokens"
 * @public
 * @categories "Stacks"
 * @param "tokenMap" "<{string→{<stacks token, <stacks token…|>…|>|}|}…|>" 
 *		A
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Public method "Print comment map's tokens" is
[
	For each of fileCommentMapsTuple do
	[
	 	mps : {string→{<stacks token, <stacks token…|>…|>|}|}
	 |
	 	Print: "==================================================================\n";
	 	Print: "==================================================================\n";
	 	Print: "==================================================================\n\n";
	 	For each of mps do
	 	[
	 	 	k : string,
	 	 	vs : {<stacks token, <stacks token…|>…|>|}
	 	 |
	 	 	Print: k;  Print: " ";
	 	 	For each of vs do
	 	 	[
	 	 	 	v : <stacks token, <stacks token…|>…|>
	 	 	 |
	 	 	 	Print: concatenate v[2] separated by " ";
	 	 		Print: "\n";
	 	 	];
	 	 	Print: "\n";
	 	];
	];
]:⊤;




