/*
 * Stacks Stream Parser.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Stacks Stream Parser"
Versions
"Dev"
Extends

Uses
	"Avail",
	"Annals Class Definitions"
Names
	"Parse the Avail document_"

Body

/* Special parse characters */
keyCharacters ::= {¢/, ¢@, ¢*, ¢"\n"};

/* Special keywords using @ symbols */
keywords ::= 
	{"@type","@supertype","@field","@category","@param","@raises","@restricts",
	"@returns","@forbids","@pubilc","@method","@see","@author",
	"@link","@code"};

/* Global Variables */
openCommentCount : whole number := 0;
lineCount : natural number := 1;
buffer : <character…|> := <>;
inAnnalsType : boolean := false; 
annalsType : string := "";
annalsObjectName : string := "";

/* This will eventually be the name of the file being processed */
fileName : string : = "test file.avail";

/* Does current comment being parsed contain an error */
commentError: boolean := false;

/* Where all error comments go */
errorComments : <erroneous comment…|>  := <>;


classMap : {string→class|} := {};
methodMap : {string→methodContainer|} := {};

/**
 * Checks to see if the input character is one of the key characters defined
 * in the global variable set, keyCharacters.
 * @method "_is a key character"
 * @categories "Stacks"
 * @param "char" character
 * @returnType boolean
 * @raises
 */
Private method "_is a key character" is
[
 	char : character
 |
 	char ∈ keyCharacters
]:boolean;

/**
 * Creates the enumeration of the global variable keywords.
 * @method "comment keywords"
 * @categories "Stacks"
 * @returnType enumeration of keywords
 * @raises
 */
Private method "comment keywords" is [enumeration of keywords];

/**
 * Creates the enumeration of open comment strings.
 * @method "open comment strings"
 * @categories "Stacks"
 * @returnType enumeration of open comment strings
 * @raises
 */
Private method "open comment strings" is [enumeration of {"/*","/**"}];

/**
 * Updates the globla variable, openCommentCount.  It adds one to the count.
 * @method "Increment the open comment count"
 * @categories "Stacks"
 * @returnType ⊤
 * @raises
 */
Private method "Increment the open comment count" is
[
 	openCommentCount := openCommentCount + 1;
]:⊤;

/**
 * Updates the globla variable, openCommentCount.  It subtracts one from the 
 * count.
 * @method "Decrement the open comment count"
 * @categories "Stacks"
 * @returnType ⊤
 * @raises
 */
Private method "Decrement the open comment count" is
[
 	 	openCommentCount := cast (openCommentCount - 1) into 
 	 		[w : whole number | w];
]:⊤;

/**
 * Updates the globla variable, lineCount.  It adds one to the line count.
 * @method "Increment the line count"
 * @categories "Stacks"
 * @returnType ⊤
 * @raises
 */
Private method "Increment the line count" is
[
	lineCount := lineCount + 1;
]:⊤;

/**
 * Checks to see if the iterator is not exhausted.
 * @method "_is not exhausted"
 * @categories "Annals"
 * @param "iter" iterator
 * @returnType boolean
 * @raises
 */
Private method "_is not exhausted" is
[
 	iter : iterator
 |
 	¬iter is exhausted
]:boolean;

/**
 * Clears the global variable, buffer, of all its contents.
 * @method "Clear the buffer"
 * @categories Stacks""
 * @returnType ⊤
 * @raises
 */
Private method "Clear the buffer" is
[
	buffer := <>;
]:⊤;

/**
 * Update the global variable, buffer, with the current element on the iterator.
 * Proceed to advance the iterator.
 * @method "Buffer_"
 * @categories "Stacks"
 * @param "iter" iterator
 * @returnType ⊤
 * @raises
 */
Private method "Buffer_" is
[
	iter : iterator
 |
	buffer := buffer ++ 
		<cast (iter's current element) into [c : character | c]>;
	Advance iter;
]:⊤;

/**
 * Given an iterator at the start of a comment, collect all the characters until
 * the open comment count is 0.
 * @method "buffer comment from_"
 * @categories "Stacks"
 * @param "iter" iterator
 * @returnType "string"  The entire comment less the opening * on a new line.
 */
Private method "buffer comment from_" is
[
 	iter : iterator
 |
 	atNewLine : boolean := true;
	While 
	[
	 	iter is not exhausted ∧ 
	 		[openCommentCount ≠ 0]
	]
	do
	[
	 	prevChar : character := cast (iter's current element) 
	 		into [c : character | c];
	 	/* Simply buffer characters that are not special */
		While 
		[
		 	iter's current element ∉ {¢*,¢/,¢"\n"}
		]
		do
		[
		 	/* Set appropriate at new line condition.  No longer at a new line
		 	 * once a non-blank character is reached. */
		 	If atNewLine ∧ [prevChar ≠ ¢" "] then [atNewLine := false;];
		 	/* Preserve the current element of the iterator. */
		 	prevChar := cast (iter's current element) into [c : character | c];
		 	Buffer iter;
		];
		/* The * is a special character that has multiple implications */
		if iter's current element = ¢* then
		[
		 	prevChar := cast (iter's current element) into [c : character | c];
		 	Advance iter;
			/* The * is not the first non-blank character on this line.*/
		 	if atNewLine = false then
		 	[
		 	 	/* This indicates a closing of a comment */
		 		if iter's current element = ¢/ then
		 		[
		 		 	/* The closing of a nested comment */
		 		 	if openCommentCount > 1 then
		 		 	[
		 		 	 	/*Capture everything from the nested comment*/
		 		 	 	Decrement the open comment count;
		 		 	 	buffer := buffer ++ <prevChar,
		 		 	 		cast (iter's current element) 
		 		 	 		into [c : character | c]>;
		 		 	 	Advance iter;
		 		 	]
		 		 	/* Closing the top level comment, all loops will end.*/
		 		 	else
		 		 	[Decrement the open comment count;];
		 		]
		 		/* The * character isn't doing anything special but is actually
		 		 * part of text.  Buffer it.*/
		 		else
		 		[
		 		 	buffer := buffer ++ <prevChar, 
		 		 	cast (iter's current element) into [c : character | c]>;
		 		 	Advance iter;
		 		];
		 	]
		 	/* The * is the first non-blank char on the line 
		 	 * Don't buffer it if it is not closing a nested comment */
		 	else
		 	[
	 	 	 	/* A comment is being closed*/
				if iter's current element = ¢/ then
				[
				 	/*Nested comment being closed preserve entire comment*/ 
				 	if openCommentCount > 1 then
				 	[
				 	 	Decrement the open comment count;
				 	 	buffer := buffer ++ <prevChar,
				 	 		cast (iter's current element) 
				 	 		into [c : character | c]>;
				 	 	Advance iter;
				 	]
				 	/* Closing the top level comment, all loops will end.*/
				 	else
				 	[Decrement the open comment count;];
				]
				/* Nothing special about next charThe * does not get captured 
				 * as it is the first non-blank character in the new line*/
				else
				[
				 	/* Do nothing, let loop run*/
				];
		 	];
		]
		else if [iter's current element = ¢/] then
		[
		 	prevChar := cast (iter's current element) into [c : character | c];
		 	Advance iter;
			/* Open of a nested comment.  Capture open comment syntax*/
			if iter's current element = ¢* then 
			[
			 	Increment the open comment count;
			 	buffer := buffer ++ <prevChar,
		 	 		cast (iter's current element) 
		 	 		into [c : character | c]>;
		 	 	Advance iter;
			]
			/* Nothing special about character,/, buffer it.*/
			else [buffer := buffer ++ <prevChar>;];
		]
		/* Start of a new line, indicate this here. */
		else if [iter's current element = ¢"\n"] then
		[
		 	atNewLine := true;
			/* Capture the new line character */
			buffer := buffer ++ <cast (iter's current element) 
				into [c : character | c]>;
			Advance iter;
		]
		else [/* Outer loop will end, do nothing.*/];	
	];
]:⊤;

/**
 * Locate Stacks comment from iterator
 * @method "identify comment from_"
 * @categories "Stacks"
 * @param "iter" iterator
 * @returnType ⊤
 * @raises
 */
Private method "identify comment from_" is
[
 	iter : iterator
 |
 	keyBuffer : <character…|> := <>;
 	
 	While
 	[
 	 	iter is not exhausted
 	]
 	do
 	[
	 	While
	 	[
	 	 	iter is not exhausted ∧ [iter's current element ∉ {¢/}]
	 	]
	 	do
	 	[
	 	 	If iter's current element ∈ {¢"\n"} then 
	 	 		[Increment the line count;];
	 	 	Advance iter;
	 	];
	 	While 
		[
		 	iter is not exhausted ∧ [iter's current element ∉ {¢" ",¢"\n"}]
		]
		do
	 	[
	 	 	keyBuffer:= keyBuffer ++ 
	 	 		<cast (iter's current element) into [c : character | c]>;
	 	 	Advance iter;
	 	];
		if keyBuffer = "/**" ∧ [openCommentCount = 0] then 
		[
		 	/* Process Stacks Comment */
		 	Increment the open comment count; 
		 	buffer comment from iter;
		 	keyBuffer := <>;
		 	/* TODO Still need to create 2nd pass parser */
		 ]
		else if [keyBuffer = "/*"] then 
		[
		 	/* Entering basic comment.  Increment open comment count. */
		 	Increment the open comment count;
		 	keyBuffer := <>;
		 ]
		else [keyBuffer := <>;];
	];
]:⊤;

/**
 * Divide the comment buffer into parts designated by `@ tag keywords.  If `@
 * tag is escaped or preceded by a {, then ignore tag.
 *
 * @method "Split comment buffer"
 * @categories "Stacks"
 * @returnType "<string…|1..>"
 *		a tuple of strings
 * @author "Richard Arriaga"
 */
Private method "Split buffer" is
[
 	parseAtTag : boolean := true;
	atTags : <natural number…|0..∞> := <>;
	returnTuple : <string…|> := <>;
	/* Locate each `@ symbol and determine if intended to be keyword */
	For each of (all indices of buffer where [c : character | c = ¢@]) do
	[
	 	i : natural number
	 |
	 	If i ≠ 1 then 
	 	[
	 	 	k : [2..∞) := cast i into [l : [2..∞) | l];
	 	 	if buffer [k-1] ∉ {¢{, ¢`} then 
	 	 	[
	 	 	 	atTags := atTags ++ <k>;
	 	 	] else if [buffer [k-1] = ¢{] then
	 	 	[
	 	 	 	endTag ::= first index of buffer[k..] where 
	 	 	 		[c: character | c = ¢" "];
	 	 	    if endTag ≠ 0 then 
	 	 	    [
	 	 	     	
	 	 	     	if buffer [k..(endTag+k)] ∉ keywords then 
	 	 	     	[
	 	 	     	 	commentError := true;
	 	 	     		/*TODO Create Comment Error object -not key word***/
	 	 	     	] else
	 	 	     	[
	 	 	     	 	/*TODO Check close bracket exists before next keyword***/
	 	 	     	];
	 	 	    ] else
	 	 	    [
	 	 	     	if buffer [k..] ∈ keywords then 
	 	 	     	[
	 	 	     	 	commentError := true;
	 	 	     		/*TODO Create Comment Error object -nothing following key word***/
	 	 	     	] else
	 	 	     	[
	 	 	     	 	commentError := true;
	 	 	     		/*TODO Create Comment Error object -not key word***/
	 	 	     	];
	 	 	    ];
	 	 	] else [/* Escaped `@ character; do nothing */];
	 	];
	];
	if |atTags| = 0 then
	[
    	if buffer ∉ keywords then 
    	[
    	 	commentError := true;
    		/*TODO Create Comment Error object -no key word***/
    	] else
        [
     	 	commentError := true;
     		/*TODO Create Comment Error object - key word deficient***/
     	];
	] else
	[
	 	at : <natural number…|1..∞> := 
	 		cast atTags into [t : <natural number…|1..∞> | t ];
	 	/* Split up buffer at pertinant `@ tag boundaries. */
	 	From 1 to |at| do
	 	[
	 	 	j : natural number
	 	 |
	 	 	if j = 1 then 
	 	 	[
	 	 	 	returnTuple := returnTuple ++ <buffer[..at[1]]>;
	 		]
	 	 	else if [j = |at|] then
	 	 	[
	 	 	 	returnTuple := returnTuple ++ <buffer[(at's last)..]>;
	 	 	]
	 	 	else
	 	 	[
	 	 	 	m : [2..∞) := cast j into [n : [2..∞) | n];
	 	 	 	returnTuple := returnTuple ++ <buffer[at[m-1]..at[m]]>;
	 	 	];
	 	];
	];
	returnTuple
]:<string…|>;

/**
 * Consume the buffer characters starting from the start index provided through
 * end index provided.  Place text in provided map with key of tag provided.  
 * If no tag provided, then place in general description slot of map.
 *
 * @method "Process_from_to_in_«for tag_»"
 * @categories "Stacks"
 * @param "subBuffer" "string" 
 *		The initial index to start processing from in the buffer.
 * @param "start" "natural number" 
 *		The initial index to start processing from in the buffer.
 * @param "end" "natural number" 
 *		The final index to stop processing from in the buffer.
 * @param "aMap" "{string→{<naturalNumber,string…|2>|1..}|}"
 * 		The map containing all the components of the comment.
 * @param "tag" "<string…|0..1>"
 *  	The tag associated with this block of text.
 * @returnType "{string→{string|1..}|}"
 *		Updated map containing Stacks comment components
 * @author "Richard Arriaga"
 */
Private method "Process_from_to_in_«for tag_»" is
[
	subBuffer : string,
 	start : natural number,
 	end : natural number,
 	aMap : {string→{<natural number,string…|2>|1..}|},
 	tag : <string…|0..1>
 |
 	startLineNumber ::= lineCount;
 	lineCount := lineCount + 
 		|all indices of subBuffer where [c : character | c = ¢"\n"]|;
 	sub ::= map subBuffer[start..end] through
 	[
 	 	c : character
 	 |
 	 	if c = ¢"\n" then [¢" "] else [c]
 	];
 	mapKeys ::= aMap's keys;
 	if |tag| = 0 then
 	[
 	 	/* Update general description */
 	 	if "@generalDescription" ∈ mapKeys then
 	 	[
 	 	 	aMap + "@generalDescription"→aMap["@generalDescription"] ∪ 
 	 	 		{<startLineNumber,sub>}
 	 	] else
 	 	[
 	 	 	aMap + "@generalDescription"→{<startLineNumber,sub>}
 	 	]
 	] else
 	[
	 	/* Update general description */
	 	if tag[1] ∈ mapKeys then
	 	[
	 	 	aMap + tag[1]→aMap[tag[1]] ∪ {<startLineNumber,sub>}
	 	]else
	 	[
	 	 	aMap + tag[1]→{<startLineNumber,sub>}
	 	]
 	]

 ]:{string→{<natural number,string…|2>|1..}|};

/**
 * Determine what tag is being used.  If the tag is invalid, add entire comment
 * to error log.
 *
 * @method "Identify tag at_"
 * @categories "Stacks"
 * @param "subBuffer" "string" 
 *		Start of string with keyword denoted by `@ character.
 * @returnType "string"
 *		Stacks comment tag
 * @raises "No-such-tag exception" 
 *		If the tag is not a valid tag.
 * @author "Richard Arriaga"
 */
Private method "Identify tag in_" is
[
 	subBuffer : string
 |
 	if subBuffer[1] = ¢@ then
 	[
	 	/* identify the tag index range*/
	 	firstBlankIndex ::= first index of subBuffer where
	 	[
	 	 	c : character
	 	 |
	 	 	c = ¢" "
	 	];
		if firstBlankIndex ≠ 0 then
		[
		 	fbi : [1..∞) := cast firstBlankIndex into [i : [1..∞)| i];
		 	if subBuffer[..fbi-1] ∈ keywords then
		 	[
		 	 	/*TODO Add to comment temporary map of components***/
		 	 	/* Using "Process_from_to_in_«for tag_»"***/
		 	 	/*If only blanks and new lines past keyword, Create***/
		 	 	/*Comment Error object - empty***/
		 	] else
		 	[
		 	 	commentError := true;
		 		/*TODO Create Comment Error object -not key word***/
		 	];
		] else
		[    
		    if buffer ∉ keywords then 
	    	[
	    	 	commentError := true;
	    		/*TODO Create Comment Error object -no key word***/
	    	] else
	        [
	     	 	commentError := true;
	     		/*TODO Create Comment Error object - empty***/
	     	];
		];
	] else
	[
	 /*TODO Openning Description***/
	];
	/*TODO Return the keyword*/
	"I'm gonna be the keyword!"
 ]:string;


/* TODO write funtions to process @keywords in map.  Complete error file
 * handling for erroneous comments.*/












test ::=
"
 Sucker /**
 * Given an iterator at the start of a comment, collect all the characters until 
 * the open comment count is 0. 
 * @method \"buffer comment from_\"
 * @categories \"Stacks\"
 * @param \"iter\" \"iterator\" an iterator over a string
 * @returnType \"string\"  The entire comment less the opening * on a new line. 
 */ yo";
 Print: test; Print: "\n";
 it : iterator := an iterator over test;
identify comment from it;
Print: buffer;
Print: "\n";
Print: format "lineCount=“①”\n" with lineCount;
Print: “buffer”;

Print: format "new lines count in buffer =“①”\n" with (all indices of buffer where [c : character | c = ¢"\n"]);