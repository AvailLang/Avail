/*
 * Stacks Stream Parser.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Stacks Stream Parser"
Versions
"Dev"
Extends

Uses
	"Avail",
	"Annals Class Definitions",
	"Stacks Lexer"
Names
	"identify comment from_",
	"Parse the Avail document_"

Body

/* Special parse characters */
keyCharacters ::= {¢/, ¢@, ¢*, ¢"\n"};

/* Special keywords using @ symbols */
keywords ::= 
	{"@type","@supertype","@field","@category","@param","@raises","@restricts",
	"@returns","@forbids","@public","@method","@see","@author",
	"@link","@code","@global"};

/* Global Variables */
openCommentCount : whole number := 0;
lineCount : natural number := 1;
buffer : <character…|> := <>;
inAnnalsType : boolean := false; 
annalsType : string := "";
annalsObjectName : string := "";
fileCommentMapsTuple : <{string→{<natural number,string…|2>|1..}|}…|> := <>;

/* This will eventually be the name of the file being processed */
fileName : string : = "test file.avail";

/* Does current comment being parsed contain an error */
commentError: boolean := false;

/* Where all error comments go */
errorComments : <erroneous comment…|>  := <>;


classMap : {string→class|} := {};
methodMap : {string→method container|} := {};



/**
 * Checks to see if the input character is one of the key characters defined
 * in the global variable set, keyCharacters.
 * @method "_is a key character"
 * @category "Stacks"
 * @param "char" character
 * @returns boolean
 * @raises
 */
Private method "_is a key character" is
[
 	char : character
 |
 	char ∈ keyCharacters
]:boolean;

/**
 * Creates the enumeration of the global variable keywords.
 * @method "comment keywords"
 * @category "Stacks"
 * @returns enumeration of keywords
 * @raises
 */
Private method "comment keywords" is [enumeration of keywords];

/**
 * Creates the enumeration of open comment strings.
 * @method "open comment strings"
 * @category "Stacks"
 * @returns enumeration of open comment strings
 * @raises
 */
Private method "open comment strings" is [enumeration of {"/*","/**"}];

/**
 * Updates the globla variable, openCommentCount.  It adds one to the count.
 * @method "Increment the open comment count"
 * @category "Stacks"
 * @returns ⊤
 * @raises
 */
Private method "Increment the open comment count" is
[
 	↑openCommentCount++;
]:⊤;

/**
 * Updates the globla variable, openCommentCount.  It subtracts one from the 
 * count.
 * @method "Decrement the open comment count"
 * @category "Stacks"
 * @returns ⊤
 * @raises
 */
Private method "Decrement the open comment count" is
[
 	 	openCommentCount := cast (openCommentCount - 1) into 
 	 		[w : whole number | w];
]:⊤;

/**
 * Updates the globla variable, lineCount.  It adds one to the line count.
 * @method "Increment the line count"
 * @category "Stacks"
 * @returns ⊤
 * @raises
 */
Private method "Increment the line count" is
[
	↑lineCount++;
]:⊤;

/**
 * Checks to see if the iterator of character is not exhausted.
 * @method "_is not exhausted"
 * @category "Annals"
 * @param "iter" iterator of character
 * @returns boolean
 * @raises
 */
Private method "_is not exhausted" is
[
 	iter : iterator of character
 |
 	¬iter is exhausted
]:boolean;

/**
 * Clears the global variable, buffer, of all its contents.
 * @method "Clear the buffer"
 * @category Stacks""
 * @returns ⊤
 * @raises
 */
Private method "Clear the buffer" is
[
	buffer := <>;
]:⊤;

/**
 * Update the global variable, buffer, with the current element on the iterator of character.
 * Proceed to advance the iterator of character.
 * @method "Buffer_"
 * @category "Stacks"
 * @param "iter" iterator of character
 * @returns ⊤
 * @raises
 */
Private method "Buffer_" is
[
	iter : iterator of character
 |
	buffer := buffer ++ 
		<iter's current element>;
	Advance iter;
]:⊤;

/**
 * Given an iterator of character at the start of a comment, collect all the characters until
 * the open comment count is 0.
 * @method "buffer comment from_"
 * @category "Stacks"
 * @param "iter" iterator of character
 * @returns "string"  The entire comment less the opening * on a new line.
 */
Private method "buffer comment from_" is
[
 	iter : iterator of character
 |
 	atNewLine : boolean := true;
	While 
	[
	 	iter is not exhausted ∧ 
	 		[openCommentCount ≠ 0]
	]
	do
	[
	 	prevChar : character := iter's current element;
	 	/* Simply buffer characters that are not special */
		While 
		[
		 	iter's current element ∉ {¢*,¢/,¢"\n"}
		]
		do
		[
		 	/* Set appropriate at new line condition.  No longer at a new line
		 	 * once a non-blank character is reached. */
		 	If atNewLine ∧ [prevChar ≠ ¢" "] then [atNewLine := false;];
		 	/* Preserve the current element of the iterator of character. */
		 	prevChar := iter's current element;
		 	Buffer iter;
		];
		/* The * is a special character that has multiple implications */
		if iter's current element = ¢* then
		[
		 	prevChar := iter's current element;
		 	Advance iter;
			/* The * is not the first non-blank character on this line.*/
		 	if atNewLine = false then
		 	[
		 	 	/* This indicates a closing of a comment */
		 		if iter's current element = ¢/ then
		 		[
		 		 	/* The closing of a nested comment */
		 		 	if openCommentCount > 1 then
		 		 	[
		 		 	 	/*Capture everything from the nested comment*/
		 		 	 	Decrement the open comment count;
		 		 	 	buffer := buffer ++ <prevChar,iter's current element>;
		 		 	 	Advance iter;
		 		 	]
		 		 	/* Closing the top level comment, all loops will end.*/
		 		 	else
		 		 	[Decrement the open comment count;];
		 		]
		 		/* The * character isn't doing anything special but is actually
		 		 * part of text.  Buffer it.*/
		 		else
		 		[
		 		 	buffer := buffer ++ <prevChar, 
		 		 	iter's current element>;
		 		 	Advance iter;
		 		];
		 	]
		 	/* The * is the first non-blank char on the line 
		 	 * Don't buffer it if it is not closing a nested comment */
		 	else
		 	[
	 	 	 	/* A comment is being closed*/
				if iter's current element = ¢/ then
				[
				 	/*Nested comment being closed preserve entire comment*/ 
				 	if openCommentCount > 1 then
				 	[
				 	 	Decrement the open comment count;
				 	 	buffer := buffer ++ <prevChar,iter's current element>;
				 	 	Advance iter;
				 	]
				 	/* Closing the top level comment, all loops will end.*/
				 	else
				 	[Decrement the open comment count;];
				]
				/* Nothing special about next charThe * does not get captured 
				 * as it is the first non-blank character in the new line*/
				else
				[
				 	While 
				 	[
				 	 	iter is not exhausted ∧ 
				 	 		[iter's current element ∈ {¢" "}]
				 	]
				 	do
				 	[
				 	 	Advance iter;
				 	];
				];
		 	];
		]
		else if [iter's current element = ¢/] then
		[
		 	prevChar := iter's current element;
		 	Advance iter;
			/* Open of a nested comment.  Capture open comment syntax*/
			if iter's current element = ¢* then 
			[
			 	Increment the open comment count;
			 	Advance iter;
			 	While
			 	[
			 	 	iter is not exhausted ∧ 
		 	 			[openCommentCount > 1]
			 	]
			 	do
			 	[
			 	 	if iter's current element = ¢* then
			 	 	[
						prevChar := iter's current element;
						Advance iter;
						If iter is not exhausted ∧ 
							[iter's current element = ¢/] then
						[
						 	Decrement the open comment count;
						 	Advance iter;
						];
			 	 	]
			 	 	else
			 	 	[Advance iter;];
			 	];
			]
			/* Nothing special about character,/, buffer it.*/
			else [buffer := buffer ++ <prevChar>;];
		]
		/* Start of a new line, indicate this here. */
		else if [iter's current element = ¢"\n"] then
		[
		 	atNewLine := true;
			/* Capture the new line character */
			buffer := buffer ++ <iter's current element>;
			Advance iter;
			While 
			[
		 	 	iter is not exhausted ∧ 
		 	 		[iter's current element ∈ {¢" "}]
		 	]
		 	do
		 	[
		 	 	Advance iter;
		 	];
		]
		else [/* Outer loop will end, do nothing.*/];	
	];
]:⊤;

/**
 * Divide the comment buffer into parts designated by `@ tag keywords.  If `@
 * tag is escaped or preceded by a {, then ignore tag.
 *
 * @method "Split comment buffer"
 * @category "Stacks"
 * @returns "<string…|1..>"
 *		a tuple of strings
 * @author "Richard Arriaga"
 */
Private method "Split buffer" is
[
	atTags : <natural number…|0..∞> := <>;
	returnTuple : <string…|> := <>;
	commentErrors : <<string,natural number,string…|3>…|0..> := <>;
	
	/* Locate each `@ symbol and determine if intended to be keyword */
	For each of (all indices of buffer where [c : character | c = ¢@]) do
	[
	 	i : natural number
	 | 
	 	If i ≠ 1 then 
	 	[
	 	 	k : [2..∞) := cast i into [l : [2..∞) | l];
	 	 	if buffer [k-1] ∉ {¢{, ¢`} then 
	 	 	[
	 	 	 	atTags := atTags ++ <k>;
	 	 	] else if [buffer [k-1] = ¢{] then
	 	 	[
	 	 	 	endTag ::= first index of buffer[k..] where 
	 	 	 		[c: character | c = ¢}];
	 	 	    if endTag ≠ 0 then 
	 	 	    [
	 	 	     	endKeyWord::= first index of buffer[k..] where 
	 	 	     		[c: character | c ∈ {¢" ", ¢"\n"}];
	 	 	     	if endKeyWord ≠ 0 then
	 	 	     	[
	 	 	     	 	ekw : [2..∞) := cast endKeyWord into [l : [2..∞) | l];
		 	 	     	if buffer [k..(endKeyWord+k-2)] ∉ keywords then 
		 	 	     	[
		 	 	     	 	commentError := true;
		 	 	     		errorLine ::= lineCount + count of all indices of 
		 	 	     			buffer where [c : character | c = ¢"\n"] where 
		 	 	     				[n : natural number | n < i];
		 	 	     		/*TODO Create Comment Error object -not key word***/
		 	 	     		commentErrors := commentErrors ++
		 	 	     			<<"Not a key word",errorLine,
		 	 	     				buffer [k..(ekw+k-2)]>>;
		 	 	     	
		 	 	     		Print: "Split buffer - not keyword\n";
		 	 	     		Print: format "commentErrors=“①”\n\n" with commentErrors;
		 	 	     	] else
		 	 	     	[
		 	 	     	 	If buffer[ekw] = ¢"\n" then 
		 	 	     	 	[
		 	 	     	 	 	Increment the line count;
		 	 	     	 	];
		 	 	     	 	/*TODO Check close bracket exists before next keyword***/
		 	 	     	];
	 	 	     	/**/] else [/* TODO No data following keyword*/];
	 	 	    ] else
	 	 	    [
	 	 	     	if buffer [k..] ∈ keywords then 
	 	 	     	[
	 	 	     	 	commentError := true;
	 	 	     		/*TODO Create Comment Error object -nothing following key word***/
	 	 	     		Print: "Got Here3\n";
	 	 	     	] else
	 	 	     	[
	 	 	     	 	commentError := true;
	 	 	     		/*TODO Create Comment Error object -not key word***/
	 	 	     		errorLine ::= lineCount + count of all indices of 
	 	 	     			buffer where [c : character | c = ¢"\n"] where 
	 	 	     				[n : natural number | n < i];
	 	 	     		commentErrors := commentErrors ++
	 	 	     			<<"Not a key word",errorLine,
	 	 	     				buffer [k..]>>;
	 	 	     	
	 	 	     		Print: "Split buffer - not keyword\n";
	 	 	     		Print: format "commentErrors=“①”\n\n" with commentErrors;
	 	 	     		Print: "Got Here4\n";
	 	 	     	];
	 	 	    ];
	 	 	] else [/* Escaped `@ character; do nothing */Print: "Got Here5\n";];
	 	];
	];
	if |atTags| = 0 then
	[
    	if buffer ∉ keywords then 
    	[
    	 	commentError := true;
    		/*TODO Create Comment Error object -no key word
    		 * Need to take whole comment and put it in erroneous comment object*/
 			commentError ::= <"No keyword",lineCount,buffer>;
     	
 			Print: "Split buffer - no keyword\n";
 			Print: format "commentError=“①”\n\n" with commentError;
    		Print: "Got Here6\n";
    	] else
        [
     	 	commentError := true;
     		/*TODO Create Comment Error object - key word deficient***/
    		Print: "Got Here7\n";
     	];
	] else
	[
	 	at : <natural number…|1..∞> := 
	 		cast atTags into [t : <natural number…|1..∞> | t ];
	 	/* Split up buffer at pertinant `@ tag boundaries. */
	 	From 1 to |at| do
	 	[
	 	 	j : natural number
	 	 |
	 	 	if j = 1 then 
	 	 	[
	 	 	 	/* Do not include the `@ tag at the end by capturing up through
	 	 	 	 * the character just before the `@ character */ 
	 	 	 	returnTuple := returnTuple ++ <buffer[..(at[1]-1)]>;
	 	 	 	If |at| > 1 then
	 	 	 	[
		 	 	 	returnTuple := returnTuple ++ <buffer[at[j]..(at[j+1]-1)]>;
	 	 	 	];
	 	 	 	If |at| = 1 then
	 	 	 	[
		 	 	 	returnTuple := returnTuple ++ <buffer[at[j]..]>;
	 	 	 	];
	 		]
	 	 	else if [j = |at|] then
	 	 	[
	 	 	 	returnTuple := returnTuple ++ <buffer[(at's last)..]>;
	 	 	]
	 	 	else
	 	 	[
	 	 	 	/* Do not include the `@ tag at the end by capturing up through
	 	 	 	 * the character just before the `@ character */ 
	 	 	 	m : [2..∞) := cast j into [n : [2..∞) | n];
	 	 	 	returnTuple := returnTuple ++ <buffer[at[m]..(at[m+1]-1)]>;
	 	 	];
	 	];
	];
	returnTuple
]:<string…|>;

/**
 * Consume the buffer characters starting from the start index provided through
 * end index provided.  Place text in provided map with key of tag provided.  
 * If no tag provided, then place in general description slot of map.
 *
 * @method "Process_from_to_in_«for tag_»"
 * @category "Stacks"
 * @param "subBuffer" "string" 
 *		The initial index to start processing from in the buffer.
 * @param "start" "natural number" 
 *		The initial index to start processing from in the buffer.
 * @param "end" "natural number" 
 *		The final index to stop processing from in the buffer.
 * @param "aMap" "{string→{<naturalNumber,string…|2>|1..}|}"
 * 		The map containing all the components of the comment.
 * @param "tag" "<string…|0..1>"
 *  	The tag associated with this block of text.
 * @returns "{string→{string|1..}|}"
 *		Updated map containing Stacks comment components
 * @author "Richard Arriaga"
 */
Private method "Process_from_to_in_«for tag_»" is
[
	subBuffer : string,
 	start : natural number,
 	end : natural number,
 	aMap : {string→{<natural number,string…|2>|1..}|},
 	tag : <string…|0..1>
 |
 	startLineNumber ::= lineCount;
 	lineCount := lineCount + 
 		|all indices of subBuffer where [c : character | c = ¢"\n"]|; 
 	sub ::= map subBuffer[start..end] through
 	[
 	 	c : character
 	 |
 	 	if c = ¢"\n" then [¢" "] else [c]
 	];
 	mapKeys ::= aMap's keys;
 	if |tag| = 0 then
 	[
 	 	/* Update general description */
 	 	if "@generalDescription" ∈ mapKeys then
 	 	[
 	 	 	aMap + "@generalDescription"→aMap["@generalDescription"] ∪ 
 	 	 		{<startLineNumber,sub>}
 	 	] else
 	 	[
 	 	 	aMap + "@generalDescription"→{<startLineNumber,sub>}
 	 	]
 	] else
 	[
	 	/* Update general description */
	 	if tag[1] ∈ mapKeys then
	 	[
	 	 	aMap + tag[1]→aMap[tag[1]] ∪ {<startLineNumber,sub>}
	 	]else
	 	[
	 	 	aMap + tag[1]→{<startLineNumber,sub>}
	 	]
 	]

 ]:{string→{<natural number,string…|2>|1..}|};

/**
 * Determine what tag is being used.  If the tag is invalid, add entire comment
 * to error log.
 *
 * @method "Identify tag at_"
 * @category "Stacks"
 * @param "subBuffer" "string" 
 *		Start of string with keyword denoted by `@ character.
 * @returns "string"
 *		Stacks comment tag
 * @raises "No-such-tag exception" 
 *		If the tag is not a valid tag.
 * @author "Richard Arriaga"
 */
Private method "Identify tag in_" is
[
 	subBuffer : string
 |
 	if subBuffer[1] = ¢@ then
 	[
	 	/* identify the tag index range*/
	 	endOfKeywordIndex ::= first index of subBuffer where
	 	[
	 	 	c : character
	 	 |
	 	 	c ∈ {¢" ",¢"\n"}
	 	] - 1;
		if (subBuffer[..endOfKeywordIndex] else [subBuffer]) ∈ keywords then
		[
		 	subBuffer[..endOfKeywordIndex] else [subBuffer]
		] 
		else
		[
	 	 	commentError := true;
	
	 		/*TODO Create Comment Error object -not key word***/
	
	 		commentError ::= <"Not a keyword",lineCount,
	 			subBuffer[..endOfKeywordIndex] else [subBuffer]>;
	 	
	 		Print: "Identify tag in_ - not keyword\n";
	 		Print: format "commentError=“①”\n\n" with commentError;
	 		subBuffer
		]
	] else
	[
	 	/*TODO Openning Description***/
	 	"@generalDescription"
	]
 ]:string;


/* TODO write funtions to process @keywords in map.  Complete error file
 * handling for erroneous comments.*/


/**
 * Locate Stacks comment from iterator of character
 * @method "identify comment from_"
 * @category "Stacks"
 * @param "iter" iterator of character
 * @returns ⊤
 * @raises
 */
Public method "identify comment from_" is
[
 	iter : iterator of character
 |
 	keyBuffer : <character…|> := <>;
 	
 	While
 	[
 	 	iter is not exhausted
 	]
 	do
 	[
	 	While
	 	[
	 	 	iter is not exhausted ∧ [iter's current element ∉ {¢/}]
	 	]
	 	do
	 	[
	 	 	If iter's current element ∈ {¢"\n"} then 
	 	 		[Increment the line count;];
	 	 	Advance iter;
	 	];
	 	While 
		[
		 	iter is not exhausted ∧ [iter's current element ∉ {¢" ",¢"\n"}]
		]
		do
	 	[
	 	 	keyBuffer:= keyBuffer ++ 
	 	 		<iter's current element>;
	 	 	Advance iter;
	 	];
		if keyBuffer = "/**" ∧ [openCommentCount = 0] then 
		[
		 	/* Process Stacks Comment */
		 	Increment the open comment count; 
		 	buffer comment from iter;
		 	
		 	mp1 : {string→{<natural number,string…|2>|1..}|} := {};
		 	
		 	For each of Split buffer do
		 	[
		 	 	st : string
		 	 |
		 	 	tg ::= Identify tag in st;
		 		if tg ≠ "@generalDescription" then [
		 		mp1:=Process st from (|tg| + 1) to 
		 			(cast |st| into [n : natural number | n]) in mp1 for tag tg;
		 		] else [mp1:=Process st from 1 to 
		 			(cast |st| into [n : natural number | n]) in mp1;];

		 	];
		 	fileCommentMapsTuple := fileCommentMapsTuple ++ <mp1>;
		 	Clear the buffer;
		 	keyBuffer := <>;
		 ]
		else if [keyBuffer = "/*"] then 
		[
		 	/* Entering basic comment.  Increment open comment count. */
		 	Increment the open comment count;
		 	keyBuffer := <>;
		 	If iter's current element ∈ {¢"\n"} then 
 	 		[Increment the line count;];
		 	While
		 	[
		 	 	iter is not exhausted ∧ [openCommentCount ≠ 0]
		 	]
		 	do
		 	[
		 	 	if iter's current element ∈ {¢*} then
		 	 	[
		 	 	 	Advance iter;
		 	 	 	if iter is not exhausted ∧ [iter's current element ∈ {¢/}]
		 	 	 	then
		 	 	 	[
		 	 	 	 	Advance iter;
		 	 	 	 	Decrement the open comment count;
		 	 	 	] else if [iter's current element ∈ {¢"\n"}] then 
		 	 		[Increment the line count;]
		 	 		else [/*Do nothing*/];
		 	 	]
		 	 	else 
		 	 	[
		 	 	 	Advance iter;
		 	 	 	If iter's current element ∈ {¢"\n"} then 
		 	 	 		[Increment the line count;];
		 	 	];
		 	];
		 ]
		else [keyBuffer := <>;];
	];
	Print: format "fileCommentMapsTuple=“①”\n" with fileCommentMapsTuple;
	Print: format "lineCount=“①”\n\n\n" with lineCount;
]:⊤;










test ::=
"Sucker /**
 * Given an iterator of character at the start of a comment, collect all the characters until 
 * the open comment count is 0. /*Puprplee*/
 * @method \"buffer comment from_\"
 * @category \"Stacks\" 
 * @param \"iter\" \"iterator of character\" an iterator of character over a string
 * @param turkey buzzard in space
 * yes, turkey master!
 * @returns \"string\"  The entire comment less the opening * on a new line. 
 */ yo
 e
/**
 * Butt-licking great time!
 * 
 * Ew...
 */

 Private method \"methodName\" is
 [
  parameter : parameterType
  |
  
  ]:returnType;

 /**
  * Consume the buffer characters starting from the start index provided through
  * end index provided.  Place text in provided map with key of tag provided.  
  * If no tag provided, then place in general description slot of map.
  *
  * @method \"Process_from_to_in_«for tag_»\"
  * @category \"Stacks\"
  * @param \"subBuffer\" \"string\" 
  *		The initial index to start processing from in the buffer.
  * @param \"start\" \"natural number\" 
  *		The initial index to start processing from in the buffer.
  * @param \"end\" \"natural number\" 
  *		The final index to stop processing from in the buffer.
  * @param \"aMap\" \"{string→{<naturalNumber,string…|2>|1..}|}\"
  * 		The map containing all the components of the comment.
  * @param \"tag\" \"<string…|0..1>\"
  *  	The tag associated with this block of text.
  * @returns \"{string→{string|1..}|}\"
  *		Updated map containing Stacks comment components
  * @author Richard Arriaga
  */ peace
  out!
  /**
   * A subtype of /*{@type \"library component\" library component}*/ that contains 
   * information on Avail methods.
   * 
   * @type \"method\"
   * @supertype {@type \"library component\" library component}
   * @public
   * @category Annals
   * 
   * @field \"parameters\" \"<<string…|2>…|>\"
   *  the inputs of the method<br>
   *   1) input name<br>
   *   2) input description<br>
   * @field \"raises\" \"<string…|>\",
   *  exceptions the method uses
   * @field \"methodImplemenations\" \"<library method implementation…|1..>\"
   *  All the implemenations of the method in the library.
   * @field \"semanticRestrictions\" \"<library semantic restriction…|>\"
   *  All the semantic restrictions of the method in the library.
   * @field \"grammaticalRestrictions\" \"<library grammatical restrictions…|>\"
   *  All the grammatical restrictions of the method in the library.
   *  
   * @author Richard Arriaga
   */";



/* Print: test; Print: "\n";*/
 it : iterator of character := an iterator over test;
identify comment from it;
/*
Print: buffer;
Print: "\n";
Print: format "lineCount=“①”\n\n" with lineCount;
Print: “buffer”;

Print: format "\n\nnew lines count in buffer =“①”\n" with (all indices of buffer where [c : character | c = ¢"\n"]);
Print: "\n\n";
Print: format "Split buffer=“①”\n" with Split buffer;
Print: "\n\n";
Print: "Split Buffer=\n\n";

mp1 : {string→{<natural number,string…|2>|1..}|} := {};
For each of Split buffer do
[
 	st : string
 |
 	tg ::= Identify tag in st;
	if tg ≠ "@generalDescription" then [
mp1:=Process st from (|tg| + 1) to (cast |st| into [n : natural number | n]) in mp1 for tag tg;
	] else [mp1:=Process st from 1 to (cast |st| into [n : natural number | n]) in mp1;];
 	Print: "tag=";
 	Print: tg;
 	Print: "\n";
	Print: st;
 	Print: "\n~\n";
];
Print: "\n\nMap:\n";
Print: format "mp1=“arg”\n\n" with arg:=mp1;*/
Print: format "lineCount=“①”\n\n\n" with lineCount;
Print: format "fileCommentMapsTuple=“①”\n" with fileCommentMapsTuple;

