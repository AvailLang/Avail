/*
 * Stacks Stream Parser.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Stacks Scanner"
Versions
	"Dev"
Extends

Uses
	"Avail",
	"Avail Scanner"

Names
	"@author",
	"@category",
	"@code",
	"@field",
	"@forbids",
	"@general",
	"@global",
	"@link",
	"@method",
	"@param",
	"@public",
	"@raises",
	"@restricts",
	"@returns",
	"@see",
	"@supertype",
	"@type",
	"concatenate_separated by_",
	"erroneous stacks token",
	"generic stacks token",
	"special flag",
	"stacks scanner",
	"special stacks token",
	"stacks token",
	"tokenize_",
	"_'s⁇comments",
	"_'s⁇error flag",
	"_'s⁇position",
	"_'s⁇special flag"

Body

"character buffer" is a new field atom;
"comments" is a new field atom;
"quoted flag" is a new field atom;
"special flag" is a new field atom;
"error flag" is a new field atom;
"open comment count" is a new field atom;

/**
 * A class that defines a token for the stacks lexor.  
 * 
 * @type "stacks token"
 * @supertype {@type "scanner token" scanner token}
 * @category Stacks
 * @field "lexeme" "string"
 * 	string representation of token
 * @field "line" "natural number"
 * 	line number on which token appears 
 * @field "position" "natural number"
 * 	column position where token begins
 * @author Richard Arriaga
 */
Public class "stacks token" extends scanner token
	with fields
		public special flag : boolean,
		public error flag : boolean;

/**
 * A class that defines a generic token for the stacks lexor.  
 * 
 * @type "@generic stacks token"
 * @supertype {@type "element" element}
 * @category Stacks
 * @field "special flag" "false's type"
 * 	this token is not a token of note.
 */
Public explicit class "generic stacks token" extends stacks token
	with fields
		special flag : false's type,
		error flag : false's type;

/**
 * A class that defines a token that resembles a special token but is not
 * representative of any of the special tokens.
 * 
 * @type "@special stacks token"
 * @supertype {@type "element" element}
 * @category "Stacks"
 * @field "lexeme" "string"
 * 	this token is an erroneous token of note.
 */
Public explicit class "erroneous stacks token" extends stacks token
	with fields
	special flag : false's type,
	error flag : true's type;

/**
 * A class that defines a special token for the stacks lexor.
 * 
 * @type "@special stacks token"
 * @supertype {@type "element" element}
 * @category "Stacks"
 * @field "lexeme" "string"
 * 	this token is a token of note.
 */
Public explicit class "special stacks token" extends stacks token
	with fields
	special flag : true's type,
	error flag : false's type;

/**
 * A method that constructs a subtype of stacks token class.
 *
 * @method "_ is a stacks token"
 * @categories "Stacks"
 * @param "name" "string" 
 *		name of new token type
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "_is a stacks token" is
[
 	tokenName : <character…|1..>
 |Print: "here\n";
 	Class tokenName extends special stacks token
 		with fields
 			lexeme : tokenName's type;
 			Print: "2";
 ]:⊤;
 
 Class "@field" extends special stacks token;

/* All keywords that will ultimately be special stacks tokens */

stacksTokenTypeNames::= {"@type","@supertype","@category","@param",
	"@raises","@restricts","@returns","@forbids","@public","@method","@see",
	"@author","@link","@code","@global","@general"};
	
For each stacksTokenTypeNames do
[
	tokenTypeName : <character…|1..>
 |
 	Print: tokenTypeName;  Print: "\n";
 	tokenTypeName is a stacks token;
];

/* Special characters that could result in token delimiter */
tokenDelimiter ::= {¢@,¢" ",¢"\t",¢"\"",¢{,¢`,¢/,¢*,¢"\n"};


/* Strings that should not be tokenized */
doNotTokenize ::= {"/*","/**","*/"," ","","\t"};

/**
 * A class that defines a Stacks lexical scanner.  This is a concrete class.
 * 
 * @type "stacks scanner"
 * @supertype {@type "Avail scanner" object}
 * @category "Stacks"
 * @field "comments" "<<stacks token…|>…|>"
 * 	an a tuple of stacks token tuples.  Each tuple represents a comment.
 * @field "character buffer" "<character…|>"
 * 	buffer that temporarily retains characters awaiting tokenization
 * @field "token buffer" "<character…|>"
 * 	buffer that temporarily retains tokens of a common comment awaiting to be
 * 	added to comments.
 * @field "open comment count" "whole number"
 * 	number of comments currently opened
 * @author Richard Arriaga
 */
Public class "stacks scanner" extends Avail scanner
	with fields
		public comments : ↑<<stacks token…|>…|>,
		character buffer : ↑<character…|>,
		token buffer : ↑<stacks token…|>,
		open comment count : ↑whole number,
		quoted flag : ↑boolean;

/**
 * A method that creates a single stacks token object
 *
 * @method "tokenize_"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a tuple <token lexeme,token line number,token column position>
 * @returnType "stacks token"
 *		a stacks token of the input string
 * @author "Richard Arriaga"
 */
Method "tokenize_" is
[
	scanner : stacks scanner
 |
	if scanner's character buffer ∉ stacksTokenTypeNames then
	[
		if scanner's character buffer[1] ≠ ¢@ then
		[
		 	 a generic stacks token with
				lexeme := scanner's character buffer,
				line := scanner's line number,
				position := scanner's token start
		] else
		[
			an erroneous stacks token token with
				lexeme := scanner's character buffer,
				line := scanner's line number,
				position := scanner's token start
		]
	] else
	[
		a special stacks token with
			lexeme := scanner's character buffer,
			line := scanner's line number,
			position := scanner's token start
	]
] : stacks token;

/**
 * A method that accepts a stacks scanner and tokenizes its character buffer if
 * the buffer does not meet the do not tokenize criteria
 * 
 * @method "Buffer_'s⁇ current token"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a stacks lexical scanner
 * @param "wordStart" "natural number"
 * 		the column number where the characters to be tokenized started
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "Buffer_'s⁇current token at_" is
[
 	scanner : stacks scanner,
 	wordStart : natural number
 |
	If scanner's token buffer ∉ doNotTokenize then 
	[
	 	↓scanner's token buffer ?= ↑scanner's token buffer ++ 
	 		tokenize scanner;
	];
 	↓scanner's chracter buffer ?= <>;
]:⊤;

/**
 * A method that accepts a stacks scanner and stores a completely tokenized 
 * comment into its comment buffer.
 *
 * @method "Buffer_'s⁇ current comment"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a stacks lexical scanner
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "Buffer_'s⁇current comment" is
[
	scanner : stacks scanner
|
	↓scanner's comments ?= ↑scanner's comments ++ <scanner's token buffer>;
	
	↓scanner's token buffer ?= <>;
]:⊤;

Private abstract method "Process_comment" is [stacks scanner]→⊤;
Private forward method "_is at new comment" is [stacks scanner]→boolean;

/**
 * Determine if a scanner comment is at the start of a new stacks comment.
 *
 * @method "_is at new comment"
 * @categories "stacks"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returnType "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Private method "_is at new comment" is
[
	scanner : stacks scanner
 |
	Next character from scanner;
	if scanner's source's current element = ¢/ then
	[
		scanner is at new comment
	]
	else
	[
		buffer ::= "/" ++ 
			read from scanner while [scanner's source's current element = ¢*];
		buffer[1..2] else [0] = "/*"
	]
] : boolean;

/**
 * Consume the scanners nested comment without tokenizing any elements
 *
 * @method "Consume_'s⁇nested comment;"
 * @categories "stacks"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returnType "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Private method "Consume_'s⁇nested comment;" is
[
	scanner : stacks scanner
 |
	While scanner's open comment count > 1 then
	[
		read from scanner while
		[
			scanner's source's current element ∉ {¢/,¢*}
		];
		if scanner's source's current element = ¢/ then
		[
			Next character from scanner;
			If scanner's source is not exhausted ∧ 
				[scanner's source's current element = ¢*] then
			[↑scanner's open comment count++;];
		]
		else
		[
			/* current element is `* */
			Next character from scanner;
			If scanner's source is not exhausted ∧ 
				[scanner's source's current element = ¢/] then
			[↑scanner's open comment count--;];
		];
	];
]:⊤;

/**
 * Handle a forward slash in a stacks scanner.
 *
 * @method "_process forward slash"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returnType "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Private method "Process forward slash from_" is
[
	scanner : stacks scanner
 |
	If scanner is at new comment then
	[
		if scanner's open comment count = 0 then
		[
		 	↓scanner's open comment count ?= ↑scanner's open comment count + 1;
			Process scanner comment;
		] else
		[
			Consume scanner's nested comment;
		];
	]
	else
	[/*TODO what should happen as a default.  Probably nothing?*/]
]:⊤;



/**
 * Handle case where scanner's current element is a forward slash while in a
 * comment
 *
 * @method "Process forward slash in comment from_"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a stacks scanner
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "" +
		"Process forward slash in comment from_" is
[
 	scanner : stacks scanner
 |
/*TODO create method*/
 ]:⊤;

/**
 * Tokenize all characters in double quotes including white space.
 *
 * @method "Process double quote in comment from_"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a stacks scanner
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "Process double quote in comment from_" is
[
 	scanner : stacks scanner
 |
		wordStart ::= scanner's column number;
		word ::= <¢"\""> ++ read from scanner 
			while
			[
/*TODO Figure out condition to stop scanning*/
			 	scanner's source's current element ∈ tokenDelimiter
			];

		↓scanner's chracter buffer ?= word;
		Buffer scanner's current token at wordStart;
 ]:⊤;

/**
 * Tokenize all characters in buffer up to white space.
 *
 * @method "Process white space in comment from_"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a stacks scanner
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "Process white space in comment from_" is
[
	scanner : stacks scanner
|
		
		wordStart ::= scanner's column number;
		word ::= read from scanner 
			while
			[
/*TODO Figure out condition to stop scanning*/
			 	scanner's source's current element ∈ tokenDelimiter
			];

		↓scanner's chracter buffer ?= word;
		Buffer scanner's current token at wordStart;
]:⊤;
		
/**
 * Tokenize all characters in buffer up to newline character.
 *
 * @method "Process new line in comment from_"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a stacks scanner
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "Process new line in comment from_" is
[
	scanner : stacks scanner
|
		
		wordStart ::= scanner's column number;
		word ::= read from scanner 
			while
			[
/*TODO Figure out condition to stop scanning*/
			 	scanner's source's current element ∈ tokenDelimiter
			];

		↓scanner's chracter buffer ?= word;
		Buffer scanner's current token at wordStart;
]:⊤;

inCommentDispatchTable : {character→[Avail scanner]→⊤|} := {};

For each tokenDelimeter do
[
 	c : character
 |
	if c = ¢/ then
	[
	 	inCommentDispatchTable := inCommentDispatchTable + 
	 		c→ [
			 	 	scanner : Avail scanner
			 	 |
			 	 	Process forward slash in comment from scanner;
			 	];
	]
	else if [c = ¢"\n"] then
	[
	 	inCommentDispatchTable := inCommentDispatchTable + 
	 		c→ [
			 	 	s : Avail scanner
			 	 |
			 	 	Process new line in comment from scanner;
			 	];
	]
	else if [c = ¢"\""] then
	[
	 	inCommentDispatchTable := inCommentDispatchTable + 
	 		c→ [
			 	 	s : Avail scanner
			 	 |
			 	 	Process double quote in comment from scanner;
			 	];
	]
	else if [c = ¢{] then
	[
	 	inCommentDispatchTable := inCommentDispatchTable  + 
	 		c→ [
			 	 	s : Avail scanner
			 	 |
			 	 	Process left curly brace in comment from scanner;
			 	];
	]
	else if [c = ¢`] then
	[
	 	inCommentDispatchTable := inCommentDispatchTable  + 
	 		c→ [
			 	 	s : Avail scanner
			 	 |
			 	 	Process grave accent in comment from scanner;
			 	];
	]
	else if [c is whitespace] then
	[
	 	inCommentDispatchTable := inCommentDispatchTable  + 
	 		c→ [
			 	 	s : Avail scanner
			 	 |
			 	 	Process white space in comment from scanner;
			 	];
	]
	else if [c = ¢@] then
	[
	 	inCommentDispatchTable := inCommentDispatchTable  + 
	 		c→ [
			 	 	s : Avail scanner
			 	 |
			 	 	Process at sign in comment from scanner;
			 	];
	]
	else /* c = ¢* */
	[
	 	inCommentDispatchTable := inCommentDispatchTable + 
	 		c→ [
			 	 	s : Avail scanner
			 	 |
			 	 	Process asterick in comment from scanner;
			 	];
	];
];

/**
 * Tokenize all elements of the stacks scanner comment
 *
 * @method "Process_comment"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a stacks scanner
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "Process_comment" is
[
 	scanner : stacks scanner
 |
	Until
	[
		scanner's source is not exhausted ∨
			[scanner's character buffer = "*/" ∧ 
				[scanner's open comment count = 1]]
	]
	do
	[
		c ::= scanner's source's current element; 
		f ::= inCommentDispatchTable[c] else
			[
			 	[
			 	 	s : stacks scanner
			 	 |
			 	 	/* Unimportant character, let scanner proceed */
			 	]
			];
		f(scanner);
		Next character from scanner;
	]; 
]:⊤;

/**
 * Take a tuple of stacks tokens and concatenate the lexemes seperated by
 * provided character
 *
 * @method "Concatenate_separated by_"
 * @public
 * @categories "Stacks"
 * @param "tokens" "<stacks token…|1..>" 
 *      a tuple of stacks tokens
 * @param "delimeter" "string" 
 *      the string to separate the tokens' lexems in the string
 * @returnType "string"
 *      a string sentence of the tokens' lexemes
 * @author "authorName"
 */
Public method "concatenate_separated by_" is
[
 	tokens : <stacks token…|>,
 	delimeter : string
 |
 	if |tokens| = 0 then [""]
 	else if [|tokens| = 1] then [tokens[1]'s lexeme]
 	else
 	[
 	 	i : natural number := 1;
 	 	lexemeAndSpace : <string…|> := <>;
 	 	Do 
 	 	[
 	 	 	lexemeAndSpace := lexemeAndSpace ++ <tokens[i]'s lexeme>;
 	 	 	↑i++;
 	 	]
 	 	until [i > |tokens|]
 	 	alternate with [lexemeAndSpace := lexemeAndSpace ++ <delimeter>;];
 	 	cast flatten lexemeAndSpace into [s : string | s]
 	]
 ]:string;


/* All work that follows is old work*/

/**
 * Tokenize all elements of a string.
 *
 * @method "tokenize comment_"
 * @public
 * @categories "Stacks"
 * @param "comment" "string" 
 *		a qualifying stacks comment
 * @returnType "<stacks token…|>"
 *		a tuple of stacks tokens.  Excludes astericks.
 * @author "Richard Arriaga"
 */
Public method "tokenize comment_" is
[
 	comment : string
 |
 	lineCount : natural number := 1;
 	openComment : whole number := 0;
	openQuote : whole number := 0;
	stacksTokens : <stacks token…|> := <>;
	
	/* delimiting characters for tokenization */
	keyCharacters ::= {¢@,¢" ",¢"\"",¢{,¢},¢`,¢/,¢*,¢"\t",¢"\n"};
 
	doNotTokenize ::= {"/*","/**","*/"," ","","\t"};
	
	newLinePositions ::= all indices of comment where 
		[c : character | c = ¢"\n"];

	priorNewLine : natural number := 1;
	bufferMap : {natural number→string|} := {};
	
	/* Break up comment by new lines.  Map key is line count, value is line *
	 * less the new line character at the end of the line                   */
	For each newLinePositions do
	[
	 	i : natural number
	 |
	 	if priorNewLine = 1 then
	 	[
	 	 	bufferMap := bufferMap + lineCount→comment[priorNewLine..i-1];
	 	] else
	 	[
	 	 	bufferMap := bufferMap + lineCount→comment[priorNewLine + 1..i-1];
	 	];
	 
	 	priorNewLine := i;
		↑lineCount++;
	];
	
	/* Tokenize comment lines */
	For each bufferMap do
	[
	 	lineNumber : natural number,
	 	commentLine : string
	 |
	 	columnPosition : natural number := 1;
		charCounter : whole number := 0;

		/* Is the new line a continuation of a nested comment, if so consume *
		 * without tokenizing the contents                                   */

		While
		[
		 	charCounter < |commentLine|
		]
		do
		[
			If openComment > 1 then
			[
			 	While
			 	[
			 	 	openComment > 1 ∧ [charCounter < |commentLine|]
			 	]
			 	do
			 	[
	
			 	 	/* Consume nested comment without tokenizing but moving *
			 	 	 * column pointer										*/
			 	 	If charCounter = 0 then [↑charCounter++;];
			 	 	
					word : <character…|> := take from commentLine[charCounter+1..] 
					until 
					[
					 	c : character 
					 |
	
						If charCounter ≠ |commentLine| then [↑charCounter++;];
					 	c ∈ {¢/,¢*}  ∨ [charCounter = |commentLine|]
					];
			 	 	
			 	 	j : natural number := cast charCounter into 
						[n : natural number | n];
	
			 	 	If charCounter < |commentLine| +1 ∧ [commentLine[j] ∈ {¢/,¢*}] then  
					[
						Cast commentLine[j] into
						[
						 	c : enumeration of {¢/,¢*}
						 |
							Choose c from enumeration of {¢/,¢*}
							where
							¢* is
							[
							 	If commentLine[j+1] = ¢/ then
							 	[
							 	 	/*Close nested comment*/
							 	 	↑openComment--;
							 	 	↑charCounter++;
							 	];
							],
							¢/ is
							[
								If commentLine[j+1] = ¢* then
								[
								 	/*Open new nested comment*/
									↑openComment++;
									↑charCounter++;
								];
							];
						];
					];
			 	 	
			 	];
			];
			While
			[
			 	charCounter < |commentLine| ∧ [openComment < 2]
			]
			do
			[
			 	wordStart : natural number := charCounter + 1;
				word : <character…|> := take from commentLine[charCounter+1..] until 
				[
				 	c : character 
				 |
				 	↑charCounter++;
				 	c ∈ keyCharacters  ∨ [charCounter = |commentLine|+1]
				];
	
				j : natural number := cast charCounter into 
					[n : natural number | n];
	
				if charCounter < |commentLine| then
				[
					Cast commentLine[j] into
					[
					 	c : enumeration of 
					 		{¢@,¢" ",¢"\"",¢{,¢},¢`,¢/,¢*,¢"\t",¢"\n"}
					 |
						Choose c from enumeration of keyCharacters
						where
						¢"\t" is
						[
						 	If word ∉ doNotTokenize then 
						 	[
						 	 	stacksTokens := stacksTokens ++ 
						 	 		<token <word,lineNumber,wordStart>>;
						 	];
						],
						¢@ is
						[
						 	If word ∉ doNotTokenize then 
						 	[
						 	 	stacksTokens := stacksTokens ++ 
						 	 		<token <word,lineNumber,wordStart>>;
						 	];
			 				wordStart := j;
			 				word := take from commentLine[j..] until 
			 				[
			 					ch : character 
			 				 |
			 				 	↑charCounter++;
			 					ch = ¢" " ∨ [ch =  ¢"\n"]
			 				];
				 			stacksTokens := stacksTokens ++ 
				 				<token <word,lineNumber,wordStart>>;
						 	/* Counter will be re-incremented above.*/
						 	↑charCounter--;
						],
						¢" " is
						[
						 	If word ∉ doNotTokenize then 
						 	[
						 	 	stacksTokens := stacksTokens ++ 
						 	 		<token <word,lineNumber,wordStart>>;
						 	];
						],
						¢"\"" is
						[
						 	If word ∉ doNotTokenize then 
						 	[
						 	 	stacksTokens := stacksTokens ++ 
						 	 		<token <word,lineNumber,wordStart>>;
						 	];
				 			wordStart := j;
			 				word := take from commentLine[j+1..] until 
			 				[
			 					ch : character 
			 				 |
			 					↑charCounter++;
			 					ch = ¢"\"" ∨ [charCounter = |commentLine|]
			 				];
						 	if charCounter < |commentLine| + 1 then
						 	[
						 		word := <¢"\""> ++ word ++ <¢"\"">;
						 		stacksTokens := stacksTokens ++ 
						 			<token <word,lineNumber,wordStart>>;
						 	] else
						 	[
						 	 	/* TODO some sort of Error handling of missing close quote*/
						 	];
						],
						¢{ is
						[/* TODO Better handling of this, want entire thing in one token if followed by @ tag*/
						 	If word ∉ doNotTokenize then 
						 	[
						 	 	stacksTokens := stacksTokens ++ 
						 	 		<token <word,lineNumber,wordStart>>;
						 	];
							stacksTokens := stacksTokens ++ 
								<token <"{",lineNumber,j>>;
						],
						¢} is
						[/* TODO Don't actually need this once { is handled correctly*/
						 	If word ∈ doNotTokenize then 
						 	[
						 	 	stacksTokens := stacksTokens ++ 
						 	 		<token <word,lineNumber,wordStart>>;
						 	];
				 			stacksTokens := stacksTokens ++ 
				 				<token <"}",lineNumber,j>>;
						],
						¢` is
						[
						 /* Check for following escaped special characters */
						 	if charCounter < |commentLine| then
						 	[
							  	if commentLine[j+1] ∈ {¢@,¢"\"",¢`,¢*} then
							  	[
							  	 	word := word ++ commentLine[j..j+1];
							  		↑charCounter++;
							  		If charCounter ≠ |commentLine| then
							  		[
								  		word := word ++ 
								  			take from commentLine[j+2..] until 
						 				[
						 					ch : character 
						 				 |
						 					↑charCounter++;
						 					ch ∈ keyCharacters  
						 				];
									 	If word ∉ doNotTokenize then 
									 	[
									 	 	stacksTokens := stacksTokens ++ 
									 	 		<token <word,lineNumber,wordStart>>;
									 	];
									];
							  	]
							  	else 
							  	[
							  	 	word := word ++ <commentLine[j]>;
							  		↑charCounter++;
							  		word := word ++ take from commentLine[j+1..] until 
					 				[
					 					ch : character 
					 				 |
					 					↑charCounter++;
					 					ch ∈ keyCharacters ∨ 
				 							[charCounter = |commentLine|]
					 				];
								 	If word ∉ doNotTokenize then 
								 	[
								 	 	stacksTokens := stacksTokens ++ 
								 	 		<token <word,lineNumber,wordStart>>;
								 	];
							  	];
							] else
							[
							 	word := word ++ <commentLine[j]>;
							 	If word ∉ doNotTokenize then 
							 	[
							 	 	stacksTokens := stacksTokens ++ 
							 	 		<token <word,lineNumber,wordStart>>;
							 	];
							];
						],
						¢/ is
						[
						 	/*Check to see if open nested comment*/
						 	if commentLine[j+1] = ¢* then
					 		[
			 		 	 		↑charCounter++;
					 		 	if openComment = 0 ∧ [|commentLine| ≤ j + 2] then
					 		 	[
					 		 	 	/*Open new comment*/
					 		 	 	↑openComment++;
					 		 	 	If commentLine[j+2] = ¢* then
					 		 	 	[
					 		 	 	 	/* Start of main comment*/
					 		 	 	 	↑charCounter++;
					 		 	 	];
					 		 	] else
					 		 	[
					 		 	 	/*Open new nested comment*/
					 		 	 	↑openComment++;
					 		 	 	↑charCounter++;
					 		 	];
							] else
							[
						  	 	word := word ++ <commentLine[j]>;
						  		↑charCounter++;
						  		word := word ++ take from commentLine[j+1..] until 
				 				[
				 					ch : character 
				 				 |
				 					↑charCounter++;
				 					ch ∈ keyCharacters ∨ 
			 							[charCounter = |commentLine|]
				 				];
							];
						 	If word ∉ doNotTokenize then 
						 	[
						 	 	stacksTokens := stacksTokens ++ 
						 	 		<token <word,lineNumber,wordStart>>;
						 	];
						],
						¢* is
						[
						 /*Do nothing special here.  If closing comment, it will *
						  * end the buffer.  If not, `* will not be converted 	 *
						  * into a token.  Tokenize prior word if applicable.	 */
						 	If word ∉ doNotTokenize then 
						 	[
						 	 	stacksTokens := stacksTokens ++ 
						 	 		<token <word,lineNumber,wordStart>>;
						 	];
						 ],
						 ¢"\n" is
						 [
						 	If word ∉ doNotTokenize then 
						 	[
						 	 	stacksTokens := stacksTokens ++ 
						 	 		<token <word,lineNumber,wordStart>>;
						 	];
						 ];
					];
				] else
				[
				 	If word ∉ doNotTokenize then 
				 	[
				 	 	stacksTokens := stacksTokens ++ 
				 	 		<token <word,lineNumber,wordStart>>;
				 	];
				];
			];
		];
	];
	stacksTokens
]:<stacks token…|>;

/**
 *
 * @method "tokenize_"
 * @public
 * @categories "Stacks"
 * @param "comment" "string's type" 
 *		a qualifying stacks comment type
 *		a tuple of stacks tokens.  Excludes astericks.
 * @author "Richard Arriaga"
 */
Semantic restriction "tokenize_" is
[
 	comment : string's type
 |
 	if comment ≠ <>'s type then 
 	[
 	 	<stacks token…|1..>
	] 
	else
	[
	 	<stacks token…|0>
	]
 ];


