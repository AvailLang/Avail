/*
 * Stacks Stream Parser.avail
 * Copyright © 1993-2014, The Avail Foundation, LLC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

Module "Stacks Scanner" 
Versions
	"Dev"
Extends

Uses
	"Avail",
	"Avail Scanner"
	
Names
	"@author",
	"@category",
	"@code",
	"@field",
	"@forbids",
	"@general",
	"@global",
	"@link",
	"@method",
	"@param",
	"@public",
	"@raises",
	"@restricts",
	"@returns",
	"@see",
	"@supertype",
	"@type",
	"a stacks scanner with_",
	"bracketed stacks token",
	"Buffer_'s⁇current bracketed token",
	"Buffer_'s⁇current«quoted»?token",
	"comment tokens",
	"comment type",
	"concatenate_separated by_",
	"erroneous comment",
	"erroneous stacks token",
	"generic stacks token",
	"header tokens",
	"Increment_'s⁇buffer index",
	"Increment_'s⁇comment buffer index",
	"«Increment|Decrement»!_'s⁇open comment count",
	"open comment count",
	"quoted stacks token",
	"raw comment",
	"raw header",
	"read from_'s⁇comment buffer while_",
	"Reset_'s⁇comment processing structure",
	"special region stacks token",
	"stacks scanner",
	"special stacks token",
	"special token regions",
	"stacks token",
	"Toggle_'s⁇new line",
	"Toggle_'s⁇special region flag",
	"Toggle_'s⁇special comment",
	"Toggle_'s⁇tokenize",
	"_in erroneous comment",
	"_'s⁇character buffer",
	"_'s⁇character buffer:=_",
	"_'s⁇comment buffer",
	"_'s⁇comment buffer:=_",
	"_'s⁇comment buffer index",
	"_'s⁇comment buffer index:=_",
	"_'s⁇comment buffer is exhausted",
	"_'s⁇comment buffer is not exhausted",
	"_'s⁇comment tokens",
	"_'s⁇comment tokens:=_",
	"_'s⁇comment type",
	"_'s⁇comment type:=_",
	"_'s⁇comments",
	"_'s⁇comments:=_",
	"_'s⁇contents",
	"_'s⁇current buffer character",
	"_'s⁇erroneous comment",
	"_'s⁇erroneous comment:=_",
	"_'s⁇error flag",
	"_'s⁇header tokens",
	"_'s⁇module header",
	"_'s⁇module header:=_",
	"_'s⁇module header read",
	"_'s⁇module header read:=_",
	"_'s⁇module name",
	"_'s⁇new line",
	"_'s⁇open comment count",
	"_'s⁇position",
	"_'s⁇previous buffer character",
	"_'s⁇special flag",
	"_'s⁇special region flag",
	"_'s⁇special comment",
	"_'s⁇special token regions",
	"_'s⁇special token regions:=_",
	"_'s⁇subtokens buffer",
	"_'s⁇subtokens buffer:=_",
	"_'s⁇tokenize",
	"↑_'s⁇comment buffer index"
	
Body

"character buffer" is a new field atom;
"comment buffer" is a new field atom;
"comment buffer index" is a new field atom;
"comment tokens" is a new field atom;
"comment type" is a new field atom;
"comments" is a new field atom;
"error flag" is a new field atom;
"erroneous comment" is a new field atom;
"erroneous comment flag" is a new field atom;
"header tokens" is a new field atom;
"module header" is a new field atom;
"module header read" is a new field atom;
"module name" is a new field atom;
"new line" is a new field atom;
"open comment count" is a new field atom;
"quoted" is a new field atom;
"special region flag" is a new field atom;
"special comment" is a new field atom;
"special flag" is a new field atom;
"special token regions" is a new field atom;
"subtokens" is a new field atom;
"subtokens buffer" is a new field atom;
"tokenize" is a new field atom;

/**
 * A class that defines a token for the stacks lexor.  
 * 
 * @type "stacks token"
 * @supertype {@type "scanner token" scanner token}
 * @category Stacks
 * @field "lexeme" "string"
 * 	string representation of token
 * @field "line" "natural number"
 * 	line number on which token appears 
 * @field "position" "natural number"
 * 	column position where token begins
 * @author Richard Arriaga
 */
Public class "stacks token" extends scanner token
	with fields
		special flag : boolean,
		error flag : boolean,
		special region flag : boolean;

/**
 * A class that defines a generic token for the stacks lexor.  
 * 
 * @type "generic stacks token"
 * @supertype {@type "stacks token" stacks token}
 * @category Stacks
 * @field "special flag" "false's type"
 * 	this token is not a token of note.
 */
Public explicit class "generic stacks token" extends stacks token
	with fields
		special flag : false's type,
		error flag : false's type,
		special region flag : false's type;

/**
 * A class that defines a token that resembles a special token but is not
 * representative of any of the special tokens.
 * 
 * @type "erroneous stacks token"
 * @supertype {@type "stacks token" stacks token}
 * @category "Stacks"
 * @field "lexeme" "string"
 * 	this token is an erroneous token of note.
 */
Public explicit class "erroneous stacks token" extends stacks token
	with fields
		special flag : false's type,
		error flag : true's type,
		special region flag : false's type;

/**
 * A class that defines a special token for the stacks lexor.
 * 
 * @type "special stacks token"
 * @supertype {@type "stacks token" stacks token}
 * @category "Stacks"
 * @field "lexeme" "string"
 * 	this token is a token of note.
 */
Public explicit class "special stacks token" extends stacks token
	with fields
		special flag : true's type,
		error flag : false's type,
		special region flag : false's type;

/**
 * A class that defines a region occupying special token for the stacks lexor.
 * 
 * @type "special region stacks token"
 * @supertype {@type "special stacks token" special stacks token}
 * @category "Stacks"
 * @field "lexeme" "string"
 * 	this token is a token of note.
 */
Public explicit class "special region stacks token" extends stacks token
	with fields
		special flag : false's type,
		error flag : false's type,
		special region flag : true's type;

/**
 * A class that defines a special token for the stacks lexor.
 * 
 * @type "quoted stacks token"
 * @supertype {@type "special region stacks token" special region stacks token}
 * @category "Stacks"
 * @field "lexeme" "string"
 * 	this token is a token of note.
 */
Public explicit class "quoted stacks token" extends special region stacks token
	with fields
		quoted : true's type;
		
/**
 * methodDescription
 *
 * @method "_'scontents"
 * @categories "Stacks"
 * @param "token" "quoted stacks token" 
 *		a quoted stacks token
 * @returnType "string"
 *		the quoted region without the quotes
 * @author "Richard Arriaga"
 */
Public method "_'s⁇contents" is
[
 	token : quoted stacks token
 |
 	token's lexeme[2..|token's lexeme|-1]
]:string;

/**
 * A class that defines a special token for the stacks lexor.
 * 
 * @type "bracketed stacks token"
 * @supertype {@type "special region stacks token" special region stacks token}
 * @category "Stacks"
 * @field "lexeme" "string"
 * 	this token is a token of note.
 */
Public explicit class "bracketed stacks token" 
	extends special region stacks token
	with fields
		subtokens : <stacks token…|>;

/*TODO Extend erroneous stacks token tree to include bad quoted tokens and bad
 * bracketed stacks tokens.*/

/**
 * A method that constructs a subtype of stacks token class.
 *
 * @method "_ is a stacks token"
 * @categories "Stacks"
 * @param "name" "string" 
 *		name of new token type
 * @returns "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "_is a stacks token" is
[
 	tokenName : <character…|1..>
 |
 	Class tokenName extends special stacks token
 		with fields
 			lexeme : tokenName's type;
 ]:⊤;

/* All keywords that will ultimately be special stacks tokens */

stacksTokenTypeNames::= {"@field","@type","@supertype","@category","@param",
	"@raises","@restricts","@returns","@forbids","@public","@method","@see",
	"@author","@link","@code","@general","Module","Versions",
	"Extends","Uses","Names"};
	
For each stacksTokenTypeNames do
[
	tokenTypeName : <character…|1..>
 |
 	tokenTypeName is a stacks token;
];

/* Strings that should not be tokenized */
doNotTokenize ::= {"/*","/**","*/"," ","","\t"};

/**
 * Take a tuple of stacks tokens and concatenate the lexemes seperated by
 * provided character
 *
 * @method "Concatenate_separated by_"
 * @public
 * @categories "Stacks"
 * @param "tokens" "<stacks token…|1..>" 
 *      a tuple of stacks tokens
 * @param "delimeter" "string" 
 *      the string to separate the tokens' lexems in the string
 * @returns "string"
 *      a string sentence of the tokens' lexemes
 * @author "authorName"
 */
Public method "concatenate_separated by_" is
[
	tokens : <stacks token…|>,
	delimeter : string
 |
	if |tokens| = 0 then [""]
	else if [|tokens| = 1] then [tokens[1]'s lexeme]
	else
	[
		i : natural number := 1;
		lexemeAndSpace : <string…|> := <>;
		Do 
		[
			lexemeAndSpace := lexemeAndSpace ++ <tokens[i]'s lexeme>;
			↑i++;
		]
		until [i > |tokens|]
		alternate with [lexemeAndSpace := lexemeAndSpace ++ <delimeter>;];
		cast concatenate lexemeAndSpace into [s : string | s]
	]
]:string;
	
/**
 * A container for comments post lexing, pre-parsing.  
 * 
 * @type "raw comment"
 * @supertype {@type "object" object}
 * @category Stacks
 * @field "comment tokens" "<stacks token…|>"
 *  a tuple of stacks tokens that comprise the text of the comment
 * @field "erroneous comment" "boolean"
 *  does the comment contain an error
 * @field "special token regions" "<<stacks token…|1..>…|1..>"
 *  start/end of special token text
 * @field "comment type" "[1..2]"
 * 	if 1 then this is a method comment, if 2 then is a class comment.
 * @author Richard Arriaga
 */
Public class "raw comment" extends object
	with fields
		public comment tokens : <stacks token…|>,
		public erroneous comment : boolean,
		public special token regions : <<natural number…|2>…|>,
		public comment type : [1..2];

/**
 * A container for comments post lexing, pre-parsing.  
 * 
 * @type "raw comment"
 * @supertype {@type "object" object}
 * @category Stacks
 * @field "comment tokens" "<stacks token…|>"
 *  a tuple of stacks tokens that comprise the text of the comment
 * @field "erroneous comment" "boolean"
 *  does the comment contain an error
 * @field "special token regions" "<<stacks token…|1..>…|1..>"
 *  start/end of special token text
 * @field "comment type" "[1..2]"
 * 	if 1 then this is a method comment, if 2 then is a class comment.
 * @author Richard Arriaga
 */
Public class "raw header" extends object
	with fields
		public header tokens : <stacks token…|>,
		special token regions : <<natural number…|2>…|>;

/**
 * A class that defines a Stacks lexical scanner.  This is a concrete class.
 * 
 * @type "stacks scanner"
 * @supertype {@type "Avail scanner" object}
 * @category "Stacks"
 * @field "comments" "<<stacks token…|>…|>"
 * 	an a tuple of stacks token tuples.  Each tuple represents a comment.
 * @field "subtoken buffer" "<scanner token…|>"
 *	a place to temporarily store tokens that are to be stored in a special
 *	region token, such as a {@type "bracketed stacks token"}.
 * @field "comment buffer" "<character…|>"
 * 	buffer that temporarily retains the body of a comment while scanning is 
 * 	making first pass
 * @field "character buffer" "<character…|>"
 * 	buffer that temporarily retains characters awaiting tokenization
 * @field "comment buffer" "<character…|>"
 * 	buffer that temporarily retains characters from buffer obtained in first 
 * 	pass parse.
 * @field "token buffer" "<character…|>"
 * 	buffer that temporarily retains tokens of a common comment awaiting to be
 * 	added to comments.
 * @field "open comment count" "whole number"
 * 	number of comments currently opened
 * @field "special comment" "boolean"
 * 	if scanner current element is in a stacks comment.  Should be initialized
 * 	to false.
 * @field "special region flag" "boolean"
 * 	if scanner current element in a quoted region.  Should be initialized to
 * 	false.
 * @author Richard Arriaga
 */
Public class "stacks scanner" extends Avail scanner
	with fields
		module name : nonempty string
	with mutable fields
		comments : <raw comment…|>,
		module header : raw header,
		module header read : boolean, 
		subtokens buffer : <stacks token…|>,
		erroneous comment flag : boolean,
		comment buffer : <character…|>,
		character buffer : <character…|>,
		referable comment buffer index : natural number,
		referable open comment count : whole number,
		new line : boolean,
		special comment : boolean,
		special region flag : boolean,
		tokenize : boolean;

/**
 * Public constructor of stacks scanner
 *
 * @method "construct stacks scanner with_"
 * @categories "Stacks Scanner"
 * @param "iter" "iterator of character" 
 *      and iterator of characters
 * @returns "stacks scanner"
 *      a stacks scanner object
 * @author "Richard Arriaga"
 */
Public method "a stacks scanner with_" is
[
	fileName : file name
|
	decoded : decoding iterator := a decoding iterator of a file iterator for 
		fileName using a UTF-8 codec;
	a stacks scanner with
		source ::= decoded,
		module header read := false,
		module name ::= fileName's name,
		token buffer := <>,
		line number := 1,
		column number := 1,
		token start := 1,
		erroneous comment flag := false,
		comments := <>,
		subtokens buffer := <>,
		comment buffer := <>,
		character buffer := <>,
		comment buffer index := 1,
		open comment count := 0,
		new line := true,
		special comment := false,
		special region flag := false,
		tokenize := true
] : stacks scanner;
	
/**
 * an accessor for a scanner's erroneous comment flag.
 *
 * @method "_'s⁇erroneous comment flag"
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *		a stacks scanner
 * @returns "boolean"
 *		the current setting of the flag
 * @author "Richard Arriaga"
 */
Public method "_in erroneous comment" is
[
 	scanner : stacks scanner
 |
 	scanner's erroneous comment flag 
]:boolean;


/**
 * Reset all comment tokenizing fields in a stacks scanner to initial settings
 *
 * @method "Reset_'s⁇comment processing structure"
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returns "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Public method "Reset_'s⁇comment processing structure" is
[
	scanner : stacks scanner
 |
	scanner's comment buffer := <>;
	scanner's character buffer := <>;
	scanner's comment buffer index := 1;
	scanner's open comment count := 0;
	scanner's special comment := false;
	scanner's erroneous comment flag := false;
	scanner's new line := true;
	scanner's token buffer := <>;
	scanner's column number := 1;
]:⊤;

/**
 * A method that toggles the called boolean fields of a stacks scanner object.
 *
 * @method "Toggle_'s⁇«newline|quotedFlag|specialComment|tokenize»!"
 * @categories "Stacks"
 * @public
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returns "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Public method "Toggle_'s⁇new line" is
[
	scanner : stacks scanner
 |
	scanner's new line := ¬scanner's new line;
]:⊤;

/**
 * Toggle scanner's stacks object special region flag
 *
 * @method "Toggle_'s⁇special region flag"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returns "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Public method "Toggle_'s⁇special region flag" is
[
	scanner : stacks scanner
 |
	scanner's special region flag := ¬scanner's special region flag;
]:⊤;

/**
 * Toggle scanner's stacks object special region flag
 *
 * @method "Toggle_'s⁇special comment"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returns "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Public method "Toggle_'s⁇special comment" is
[
	scanner : stacks scanner
 |
	scanner's special comment := ¬scanner's special comment;
]:⊤;

/**
 * Toggle scanner's stacks object special region flag
 *
 * @method "Toggle_'s⁇tokenize"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returns "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Public method "Toggle_'s⁇tokenize" is
[
	scanner : stacks scanner
 |
	scanner's tokenize := ¬scanner's tokenize;
]:⊤;

/**
 * An open-comment-less-than-zero exception is raised when an attempt is made 
 * to reduce a stacks scanner object open comment count below 0.
 *
 * @type "open-comment-less-than-zero exception"
 * @supertype {@type "Avail scanner" object}
 * @category "Stacks"
 */
Explicit class "open-comment-less-than-zero exception" extends exception;

/**
 * Increment/decrement the stacks open comment field.
 *
 * @method "«Increment|Decrement»!_'s⁇open comment count"
 * @categories "category"
 * @param "actionFlag" "[1..2]" 
 *      will 1 be added or subtracted
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returns "⊤"
 *      none
 * @raises "open-comment-less-than-zero exception" 
 *      An open-comment-less-than-zero exception is raised when an attempt is 
 *      made to reduce a stacks scanner object open comment count below 0.
 * @author "Richard Arriaga"
 */
Public method "«Increment|Decrement»!_'s⁇open comment count" is
[
	actionFlag : [1..2],
	scanner : stacks scanner
 |
	change : [-1..1] := if actionFlag = 1 then [1] else [-1];
	
	Unless change = -1 ∧ [scanner's open comment count = 0] then
	[
		scanner's open comment count := cast scanner's open comment count + 
			change into [w : whole number | w];
	]
	else
	[
		Raise an open-comment-less-than-zero exception
	];
]:⊤;

/**
 * Advance the stacks scanner's source.  If it is not in a stacks comment,
 * increment the line number and column number if able.
 *
 * @method "Next character from_"
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *		a stacks scanner
 * @returns "⊤"
 *		none
 * @raises "Raise an exhausted-iterator exception" 
 *		there is nothing left on the iterator to consume
 * @author "Richard Arriaga"
 */
Method "Next character from_" is
[
	scanner : stacks scanner
 |
	scanner's previous element := scanner's current element;
	Advance scanner's source;
	If scanner's source is not exhausted then
	[
		If ¬scanner's special comment then 
		[
			If scanner's current element = ¢"\n" then 
			[
				scanner's column number := 1;
				scanner's line number := scanner's line number + 1;
			]
			else
			[
				scanner's column number := scanner's column number + 1;
			];
		];
	];
]:⊤;

/**
 * Determine if the comment character is exhausted
 *
 * @method "_'s⁇comment buffer is exhausted"
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returns "boolean"
 *      true if buffer is exhausted, false if it is not.
 * @author "Richard Arriaga"
 */
Public method "_'s⁇comment buffer is exhausted" is
[
	scanner : stacks scanner
 |
	if scanner's comment buffer index > |scanner's comment buffer| then
	[true] else [false]
]:boolean;

/**
 * Determine if the comment character is not exhausted
 *
 * @method "_'s⁇comment buffer is not exhausted"
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returns "boolean"
 *      true if buffer is not exhausted, false if it is.
 * @author "Richard Arriaga"
 */
Public method "_'s⁇comment buffer is not exhausted" is
[
	scanner : stacks scanner
 |
	¬scanner's comment buffer is exhausted
]:boolean;

/**
 * Clear the scanner's comment buffer
 *
 * @method "clear_'s⁇comment buffer"
 * @categories "category"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returns "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Private method "clear_'s⁇comment buffer" is
[
	scanner : stacks scanner
 |
	scanner's comment buffer := <>;
	scanner's comment buffer index := 1;
]:⊤;

/**
 * An access-comment-buffer-element-out-of-bounds exception is raised when an 
 * attempt is made to access an element from a buffer outside of the buffer's 
 * bounds.
 *
 * @type "access-comment-buffer-element-out-of-bounds exception"
 * @supertype {@type "Avail scanner" object}
 * @category "Stacks"
 */
Explicit class "access-comment-buffer-element-out-of-bounds exception" 
	extends exception;

/**
 * The character at the scanner comment buffer's index.
 *
 * @method "_'s⁇current buffer character"
 * @categories "category"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returns "character"
 *      the character at the index position of the comment buffer
 * @raises "exceptionName" 
 *      exceptionDescription
 * @author "Richard Arriaga"
 */
Public method "_'s⁇current buffer character" is
[
	scanner : stacks scanner
 |
	Unless scanner's comment buffer index > |scanner's comment buffer| then
	[
		scanner's comment buffer[scanner's comment buffer index]
	]
	else
	[
		Raise an access-comment-buffer-element-out-of-bounds exception
	]
]:character;

/**
 * The character at the scanner comment buffer's index.
 *
 * @method "_'s⁇previous buffer character"
 * @categories "category"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returns "character"
 *      the character at the index position of the comment buffer
 * @raises "exceptionName" 
 *      exceptionDescription
 * @author "Richard Arriaga"
 */
Public method "_'s⁇previous buffer character" is
[
	scanner : stacks scanner
 |
	Unless scanner's comment buffer index < 2 ∨
		[scanner's comment buffer index > |scanner's comment buffer| +1 ] then
	[
		i : natural number := cast scanner's comment buffer index-1 into 
			[n : natural number | n];
		scanner's comment buffer[i]
	]
	else
	[
		Raise an access-comment-buffer-element-out-of-bounds exception
	]
]:character;

/**
 * A comment-buffer-index-exceeds-bounds exception is raised when an 
 * attempt is made to increase the stacks scanner's buffer index to exceed
 * the size of the stacks scanner's comment buffer.
 *
 * @type "comment-buffer-index-exceeds-bounds exception"
 * @supertype {@type "exception"}
 * @category "Stacks"
 */
Explicit class "comment-buffer-index-exceeds-bounds exception" 
	extends exception;

/**
 * Increment the scanner's character buffer index
 *
 * @method "Increment_'s⁇buffer index"
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returns "⊤"
 *      none
 * @raises "exceptionName" 
 *      exceptionDescription
 * @author "Richard Arriaga"
 */
Public method "Increment_'s⁇comment buffer index" is
[
	scanner : stacks scanner
 |
	If |scanner's comment buffer| < scanner's comment buffer index then
	[
		Raise a comment-buffer-index-exceeds-bounds exception
	] else
	[
		↑scanner's comment buffer index++;
		If ¬scanner's special region flag ∧ [scanner's comment buffer index > 1  ∧ 
			[scanner's previous buffer character = ¢"\n"]] 
		then 
		[
			scanner's column number := 1;
			scanner's line number := scanner's line number + 1;
		]
		else
		[
			scanner's column number := scanner's column number + 1;
		];
	];
]:⊤;

/**
 * Read from Avail scanner's comment buffer while supplied condition is true 
 * or the buffer is exhausted.
 *
 * @method "read from_'s⁇comment buffer while_"
 * @public
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *		an stacks scanner 
 * @param "predicate" "boolean" 
 *		The function that guards repeated application of reading from the source
 * @returns "<character…|>"
 *		the tuple of characters read from the source
 * @author "Richard Arriaga"
 */
Public method "read from_'s⁇comment buffer while_" is
[
 	scanner : stacks scanner,
 	predicate : []→boolean
 |
	buffer : <character…|> := <>;
	While 
	[
		scanner's comment buffer is not exhausted ∧ 
			[predicate()]
	]
	do
	[
		buffer := buffer ++ 
			<scanner's comment buffer[scanner's comment buffer index]>;
			Increment scanner's comment buffer index;
	];
	buffer
]:<character…|>;

/**
 * return the most specific type of the stacks scanner's token buffer's element
 * @method "_[_]"
 * @categories "Stacks Scanner"
 * @restrcits "scannerType" "stacks scanner's type" 
 * @restricts "indexType" "natural number's type"
 * @author "Richard Arriaga"
 */
Semantic restriction "_[_]" is
[
	scannerType : Avail scanner's type,
	indexType : natural number's type
 |
	if |scannerType| = |indexType| = 1 then
	[
	 	scan ::= scannerType's instance;
		(scan[indexType's instance])'s type
	]
	else if [|scannerType| = 1] then
	[
		tb ::= ((scannerType's instance)'s token buffer)'s type;
		∪ (tb's leading types ++ <tb's default type>)
	]
	else [⊤]
];

/**
 * @method "_'s⁇token buffer"
 * @categories "Stacks Scanner"
 * @restricts "scannerType" "stacks scanner's type" 
 * @author "Richard Arriaga"
 */
Semantic restriction "_'s⁇token buffer" is
[
	scannerType : stacks scanner's type
 |
	<stacks token…|>
];

/**
 * A method that creates a single stacks token object
 *
 * @method "tokenize_'s⁇«quoted»?character buffer"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a tuple <token lexeme,token line number,token column position>
 * @returns "stacks token"
 *		a stacks token of the input string
 * @author "Richard Arriaga"
 */
Private method "tokenize_'s⁇«quoted»?character buffer" is
[
	scanner : stacks scanner,
	optionalFlag : boolean
 |
	cb : <character…|1..> := cast scanner's character buffer into 
		[s : <character…|1..> | s];

	tokenStart : natural number := if scanner's special region flag then
	[
		scanner's token start
	]
	else
	[
		cast scanner's column number - |cb| into [n : natural number | n]
	];
	if optionalFlag then 
	[
		a quoted stacks token with
			lexeme ::= "\"" ++ cb ++ "\"",
			line ::= scanner's line number,
			position ::= tokenStart
	]
	else if [scanner's character buffer ∉ stacksTokenTypeNames] then
	[
		if cb[1] ≠ ¢@ then
		[
		 	 a generic stacks token with
				lexeme ::= cb,
				line ::= scanner's line number,
				position ::= tokenStart
		] else
		[
		 	scanner's erroneous comment flag := true;
			an erroneous stacks token with
				lexeme ::= cb,
				line ::= scanner's line number,
				position ::= tokenStart
		]
	] else
	[
		a special stacks token with
			lexeme ::= cb,
			line ::= scanner's line number,
			position ::= tokenStart
	]
] : stacks token;

/**
 * A method that creates a single bracketed stacks token object
 *
 * @method "tokenize_'s⁇ bracketed character buffer"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a tuple <token lexeme,token line number,token column position>
 * @returns "stacks token"
 *		a stacks token of the input string
 * @author "Richard Arriaga"
 */
Private method "tokenize_'s⁇bracketed character buffer" is
[
	scanner : stacks scanner
 |
	cb : <character…|1..> := cast scanner's character buffer into 
		[s : <character…|1..> | s];
	a bracketed stacks token with
		lexeme ::= cb,
		line ::= scanner's line number,
		position ::= scanner's token start,
		subtokens ::= scanner's subtokens buffer
] : bracketed stacks token;

/**
 * A method that accepts a stacks scanner and tokenizes its character buffer if
 * the buffer does not meet the do not tokenize criteria
 * 
 * @method "Buffer_'s⁇ current«quoted»?token"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a stacks lexical scanner
 * @returns "stacks token"
 *		the newly tokenized stacks token
 * @author "Richard Arriaga"
 */
Public method "Buffer_'s⁇current«quoted»?token" is
[
	scanner : stacks scanner,
	optionalFlag : boolean
 |
	If scanner's character buffer ∉ doNotTokenize ∧ 
		[|scanner's character buffer| > 0]
	then 
	[
		tokenized : stacks token :=
			if optionalFlag then
			[
			 	tokenize scanner's quoted character buffer
			]
			else [tokenize scanner's character buffer];

		If scanner's tokenize then
		[
			tb : <scanner token…|> := scanner's token buffer ++ <tokenized>;
			scanner's token buffer := tb;
		] else
		[
			tb : <stacks token…|> := scanner's subtokens buffer ++ <tokenized>;
			scanner's subtokens buffer := tb;
		];
	];
	scanner's character buffer := <>;
]:⊤;

/**
 * A method that accepts a stacks scanner and tokenizes its character buffer if
 * the buffer does not meet the do not tokenize criteria
 *
 * @method "Buffer_'s⁇current bracketed token"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a stacks lexical scanner
 * @returns "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Public method "Buffer_'s⁇current bracketed token" is
[
	scanner : stacks scanner
 |
	If scanner's character buffer ∉ doNotTokenize ∧ 
		[|scanner's character buffer| > 0]
	then 
	[
		tb :<scanner token…|>:= scanner's token buffer ++ 
			<tokenize scanner's bracketed character buffer>;

		scanner's token buffer := tb;
	];
	scanner's character buffer := <>;
	scanner's subtokens buffer := <>;
]:⊤;
