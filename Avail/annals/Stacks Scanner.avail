/*
 * Stacks Stream Parser.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Stacks Scanner"
Versions
	"Dev"
Extends

Uses
	"Avail",
	"Avail Scanner",
	"Patricia Trie"

Names
	"@author",
	"@category",
	"@code",
	"@field",
	"@forbids",
	"@general",
	"@global",
	"@link",
	"@method",
	"@param",
	"@public",
	"@raises",
	"@restricts",
	"@returns",
	"@see",
	"@supertype",
	"@type",
	"comments",
	"concatenate_separated by_",
	"erroneous stacks token",
	"generic stacks token",
	"special flag",
	"stacks scanner",
	"special stacks token",
	"stacks token",
	"_'s⁇comments",
	"_'s⁇comments:=_",
	"_'s⁇error flag",
	"_'s⁇position",
	"_'s⁇special flag"

Body

"character buffer" is a new field atom;
"comment buffer" is a new field atom;
"comments" is a new field atom;
"quoted flag" is a new field atom;
"special comment" is a new field atom;
"special flag" is a new field atom;
"error flag" is a new field atom;
"open comment count" is a new field atom;

/**
 * A class that defines a token for the stacks lexor.  
 * 
 * @type "stacks token"
 * @supertype {@type "scanner token" scanner token}
 * @category Stacks
 * @field "lexeme" "string"
 * 	string representation of token
 * @field "line" "natural number"
 * 	line number on which token appears 
 * @field "position" "natural number"
 * 	column position where token begins
 * @author Richard Arriaga
 */
Public class "stacks token" extends scanner token
	with fields
		public special flag : boolean,
		public error flag : boolean;

/**
 * A class that defines a generic token for the stacks lexor.  
 * 
 * @type "@generic stacks token"
 * @supertype {@type "element" element}
 * @category Stacks
 * @field "special flag" "false's type"
 * 	this token is not a token of note.
 */
Public explicit class "generic stacks token" extends stacks token
	with fields
		special flag : false's type,
		error flag : false's type;

/**
 * A class that defines a token that resembles a special token but is not
 * representative of any of the special tokens.
 * 
 * @type "@special stacks token"
 * @supertype {@type "element" element}
 * @category "Stacks"
 * @field "lexeme" "string"
 * 	this token is an erroneous token of note.
 */
Public explicit class "erroneous stacks token" extends stacks token
	with fields
	special flag : false's type,
	error flag : true's type;

/**
 * A class that defines a special token for the stacks lexor.
 * 
 * @type "@special stacks token"
 * @supertype {@type "element" element}
 * @category "Stacks"
 * @field "lexeme" "string"
 * 	this token is a token of note.
 */
Public explicit class "special stacks token" extends stacks token
	with fields
	special flag : true's type,
	error flag : false's type;

/**
 * A method that constructs a subtype of stacks token class.
 *
 * @method "_ is a stacks token"
 * @categories "Stacks"
 * @param "name" "string" 
 *		name of new token type
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "_is a stacks token" is
[
 	tokenName : <character…|1..>
 |
 	Class tokenName extends special stacks token
 		with fields
 			lexeme : tokenName's type;
 ]:⊤;
 


/* All keywords that will ultimately be special stacks tokens */

stacksTokenTypeNames::= {"@field","@type","@supertype","@category","@param",
	"@raises","@restricts","@returns","@forbids","@public","@method","@see",
	"@author","@link","@code","@global","@general"};
	
For each stacksTokenTypeNames do
[
	tokenTypeName : <character…|1..>
 |
 	tokenTypeName is a stacks token;
];

/* Special characters that could result in token delimiter */
tokenDelimiter ::= {¢@,¢" ",¢"\t",¢"\"",¢{,¢`,¢/,¢*,¢"\n"};


/* Strings that should not be tokenized */
doNotTokenize ::= {"/*","/**","*/"," ","","\t"};

/**
 * A class that defines a Stacks lexical scanner.  This is a concrete class.
 * 
 * @type "stacks scanner"
 * @supertype {@type "Avail scanner" object}
 * @category "Stacks"
 * @field "comments" "<<stacks token…|>…|>"
 * 	an a tuple of stacks token tuples.  Each tuple represents a comment.
 * @field "comment buffer" "<character…|>"
 * 	buffer that temporarily retains the body of a comment while scanning is 
 * 	making first pass
 * @field "character buffer" "<character…|>"
 * 	buffer that temporarily retains characters awaiting tokenization
 * @field "token buffer" "<character…|>"
 * 	buffer that temporarily retains tokens of a common comment awaiting to be
 * 	added to comments.
 * @field "open comment count" "whole number"
 * 	number of comments currently opened
 * @field "special comment" "boolean"
 * 	if scanner current element is in a stacks comment.  Should be initialized
 * 	to false.
 * @field "quoted flag" "boolean"
 * 	if scanner current element in a quoted region.  Should be initialized to
 * 	false.
 * @author Richard Arriaga
 */
Public class "stacks scanner" extends Avail scanner
	with mutable fields
		public comments : <<stacks token…|>…|>,
		comment buffer : <character…|>,
		character buffer : <character…|>,
		referable open comment count : whole number,
		special comment : boolean,
		quoted flag : boolean;

/**
 * return the most specific type of the stacks scanner's token buffer's element
 * @method "_[_]"
 * @categories "Stacks Scanner"
 * @restrcits "scannerType" "stacks scanner's type" 
 * @restricts "indexType" "natural number's type"
 * @author "Richard Arriaga"
 */
Semantic restriction "_[_]" is
[
	scannerType : Avail scanner's type,
	indexType : natural number's type
 |
	if |scannerType| = |indexType| = 1 then
	[
	 	scan ::= scannerType's instance;
		(scan[indexType's instance])'s type
	]
	else if [|scannerType| = 1] then
	[
		tb ::= ((scannerType's instance)'s token buffer)'s type;
		∪ (tb's leading types ++ <tb's default type>)
	]
	else [⊤]
];

/**
 * @method "_'s⁇token buffer"
 * @categories "Stacks Scanner"
 * @restricts "scannerType" "stacks scanner's type" 
 * @author "Richard Arriaga"
 */
Semantic restriction "_'s⁇token buffer" is
[
	scannerType : stacks scanner's type
 |
	<stacks token…|>
];


/**
 * A method that creates a single stacks token object
 *
 * @method "tokenize_"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a tuple <token lexeme,token line number,token column position>
 * @returnType "stacks token"
 *		a stacks token of the input string
 * @author "Richard Arriaga"
 */
Method "tokenize_" is
[
	scanner : stacks scanner
 |
	 cb : <character…|1..> := cast scanner's character buffer into 
	 	[c : <character…|1..> | c];
	if scanner's character buffer ∉ stacksTokenTypeNames then
	[
		if cb[1] ≠ ¢@ then
		[
		 	 a generic stacks token with
				lexeme ::= cb,
				line ::= scanner's line number,
				position ::= scanner's token start
		] else
		[
			an erroneous stacks token with
				lexeme ::= cb,
				line ::= scanner's line number,
				position ::= scanner's token start
		]
	] else
	[
		a special stacks token with
			lexeme ::= cb,
			line ::= scanner's line number,
			position ::= scanner's token start
	]
] : stacks token;

/**
 * A method that accepts a stacks scanner and tokenizes its character buffer if
 * the buffer does not meet the do not tokenize criteria
 * 
 * @method "Buffer_'s⁇ current token"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a stacks lexical scanner
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "Buffer_'s⁇current token" is
[
 	scanner : stacks scanner
 |
	If scanner's character buffer ∉ doNotTokenize then 
	[
	 	
	 	tb :<scanner token…|>:= scanner's token buffer ++ <tokenize scanner>;
	 	scanner's token buffer := tb;
	];
 	scanner's character buffer := <>;
]:⊤;

/**
 * A method that accepts a stacks scanner and stores a completely tokenized 
 * comment into its comment buffer.
 *
 * @method "Buffer_'s⁇ current comment"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a stacks lexical scanner
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "Buffer_'s⁇current comment" is
[
	scanner : stacks scanner
|
	scanner's comments := (scanner's comments ++ <scanner's token buffer>);
	
	scanner's token buffer := <>;
]:⊤;

Private abstract method "Process_comment" is [stacks scanner]→⊤;
Private forward method "_is at new comment" is [stacks scanner]→boolean;

/***
 * Determine if a scanner comment is at the start of a new stacks comment.
 *
 * @method "_is at new comment"
 * @categories "stacks"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returnType "boolean"
 *      whether or not at start of a new comment.
 * @author "Richard Arriaga"
 */
Private method "_is at new comment" is
[
	scanner : stacks scanner
 |
	Next character from scanner;
	if scanner's source's current element = ¢/ then
	[
		scanner is at new comment
	]
	else
	[
		buffer ::= "/" ++ 
			read from scanner while [scanner's source's current element = ¢*];
		if |buffer| = 1 then [false] 
		else [true]
	]
] : boolean;

/**
 * Consume the scanners nested comment without tokenizing any elements
 *
 * @method "Consume_'s⁇nested comment;"
 * @categories "stacks"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returnType "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Private method "Consume_'s⁇nested comment" is
[
	scanner : stacks scanner
 |
	While [scanner's open comment count > 1] do
	[
		throwAway ::= read from scanner while
		[
			scanner's source's current element ∉ {¢/,¢*}
		];
		if scanner's source's current element = ¢/ then
		[
			Next character from scanner;
			If scanner's source is not exhausted ∧ 
				[scanner's source's current element = ¢*] then
			[
				↑scanner's open comment count++;
			];
		]
		else
		[
			/* current element is `* */
			Next character from scanner;
			If scanner's source is not exhausted ∧ 
				[scanner's source's current element = ¢/] then
			[
				↑scanner's open comment count--;
			];
		];
	];
]:⊤;

/**
 * Handle a forward slash in a stacks scanner.
 *
 * @method "_process forward slash"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returnType "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Private method "Process forward slash from_" is
[
	scanner : stacks scanner
 |
	If scanner is at new comment then
	[
		If scanner's open comment count = 0 then
		[
			↑scanner's open comment count++;
			Process scanner comment;
		] else
		[
			Consume scanner's nested comment;
		];
	]
	else
	[/*TODO what should happen as a default.  Probably nothing?*/];
]:⊤;



/**
 * Handle case where scanner's current element is a forward slash while in a
 * comment
 *
 * @method "Process forward slash in comment from_"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a stacks scanner
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "Process forward slash in comment from_" is
[
 	scanner : stacks scanner
 |
/*TODO create method*/
 ]:⊤;

/**
 * Tokenize all characters in double quotes including white space.
 *
 * @method "Process double quote in comment from_"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a stacks scanner
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "Process double quote in comment from_" is
[
	scanner : stacks scanner
 |
		scanner's token start := scanner's column number;
		word ::= <¢"\""> ++ read from scanner 
			while
			[
/*TODO Figure out condition to stop scanning - need close quote and the ability
 * to handled new lines and the pipe new line - "\\
 * \\|"*/
			 	scanner's source's current element ∈ tokenDelimiter
			];

		scanner's character buffer := word;
		Buffer scanner's current token;
 ]:⊤;

/**
 * Tokenize all characters in buffer up to white space.
 *
 * @method "Process white space in comment from_"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a stacks scanner
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "Process white space in comment from_" is
[
	scanner : stacks scanner
|
		
		wordStart ::= scanner's column number;
		word ::= read from scanner 
			while
			[
/*TODO Figure out condition to stop scanning*/
			 	scanner's source's current element ∈ tokenDelimiter
			];

		scanner's character buffer := word;
		Buffer scanner's current token;
]:⊤;
		
/**
 * Tokenize all characters in buffer up to newline character.
 *
 * @method "Process new line in comment from_"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a stacks scanner
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "Process new line in comment from_" is
[
	scanner : stacks scanner
|
		
		wordStart ::= scanner's column number;
		word ::= read from scanner 
			while
			[
/*TODO Figure out condition to stop scanning*/
			 	scanner's source's current element ∈ tokenDelimiter
			];

		scanner's character buffer := word;
		Buffer scanner's current token;
]:⊤;

/**
 * methodDescription
 *
 * @method "Process left curly brace in comment from_;"
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *	a stacks scanner
 * @returnType "⊤"
 *      none
 * @author "authorName"
 */
Private method "Process left curly brace in comment from_" is
[
	scanner : stacks scanner
 |
	/*TODO Write me if needed*/
]:⊤;

/**
 * methodDescription
 *
 * @method "Process grave accent in comment from_;"
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *	a stacks scanner
 * @returnType "⊤"
 *      none
 * @author "authorName"
 */
Private method "Process grave accent in comment from_" is
[
	scanner : stacks scanner
 |
	/*TODO Write me if needed*/
]:⊤;

/**
 * methodDescription
 *
 * @method "Process at sign in comment from_;"
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *	a stacks scanner
 * @returnType "⊤"
 *      none
 * @author "authorName"
 */
Private method "Process at sign in comment from_" is
[
	scanner : stacks scanner
 |
	/*TODO Write me if needed*/
]:⊤;

/**
 * methodDescription
 *
 * @method "Process asterick in comment from_;"
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *	a stacks scanner
 * @returnType "⊤"
 *      none
 * @author "authorName"
 */
Private method "Process asterick in comment from_" is
[
	scanner : stacks scanner
 |
	/*TODO Write me if needed*/
]:⊤;

inCommentDispatchTable : {character→[stacks scanner]→⊤|} := {};

For each tokenDelimiter do
[
 	c : character
 |
	if c = ¢/ then
	[
	 	inCommentDispatchTable := inCommentDispatchTable + 
	 		c→ [
			 	 	scanner : stacks scanner
			 	 |
			 	 	Process forward slash in comment from scanner;
			 	];
	]
	else if [c = ¢"\n"] then
	[
	 	inCommentDispatchTable := inCommentDispatchTable + 
	 		c→ [
			 	 	scanner : stacks scanner
			 	 |
			 	 	Process new line in comment from scanner;
			 	];
	]
	else if [c = ¢"\""] then
	[
	 	inCommentDispatchTable := inCommentDispatchTable + 
	 		c→ [
			 	 	scanner : stacks scanner
			 	 |
			 	 	Process double quote in comment from scanner;
			 	];
	]
	else if [c = ¢{] then
	[
	 	inCommentDispatchTable := inCommentDispatchTable  + 
	 		c→ [
			 	 	scanner : stacks scanner
			 	 |
			 	 	Process left curly brace in comment from scanner;
			 	];
	]
	else if [c = ¢`] then
	[
	 	inCommentDispatchTable := inCommentDispatchTable  + 
	 		c→ [
			 	 	scanner : stacks scanner
			 	 |
			 	 	Process grave accent in comment from scanner;
			 	];
	]
	else if [c is whitespace] then
	[
	 	inCommentDispatchTable := inCommentDispatchTable  + 
	 		c→ [
			 	 	scanner : stacks scanner
			 	 |
			 	 	Process white space in comment from scanner;
			 	];
	]
	else if [c = ¢@] then
	[
	 	inCommentDispatchTable := inCommentDispatchTable  + 
	 		c→ [
			 	 	scanner : stacks scanner
			 	 |
			 	 	Process at sign in comment from scanner;
			 	];
	]
	else /* c = ¢* */
	[
	 	inCommentDispatchTable := inCommentDispatchTable + 
	 		c→ [
			 	 	scanner : stacks scanner
			 	 |
			 	 	Process asterick in comment from scanner;
			 	];
	];
];

/**
 * Tokenize all elements of the stacks scanner comment
 *
 * @method "Process_comment"
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *		a stacks scanner
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "Process the_comment" is
[
 	scanner : stacks scanner
 |
	Until
	[
		scanner's source is not exhausted ∨
			[scanner's character buffer = "*/" ∧ 
				[scanner's open comment count = 1]]
	]
	do
	[
		c ::= scanner's source's current element; 
		f ::= inCommentDispatchTable[c] else
			[
			 	[
			 	 	s : stacks scanner
			 	 |
			 	 	/* Unimportant character, let scanner proceed */
			 	]
			];
		f(scanner);
		Next character from scanner;
	]; 
]:⊤;

/**
 * Take a tuple of stacks tokens and concatenate the lexemes seperated by
 * provided character
 *
 * @method "Concatenate_separated by_"
 * @public
 * @categories "Stacks"
 * @param "tokens" "<stacks token…|1..>" 
 *      a tuple of stacks tokens
 * @param "delimeter" "string" 
 *      the string to separate the tokens' lexems in the string
 * @returnType "string"
 *      a string sentence of the tokens' lexemes
 * @author "authorName"
 */
Public method "concatenate_separated by_" is
[
 	tokens : <stacks token…|>,
 	delimeter : string
 |
 	if |tokens| = 0 then [""]
 	else if [|tokens| = 1] then [tokens[1]'s lexeme]
 	else
 	[
 	 	i : natural number := 1;
 	 	lexemeAndSpace : <string…|> := <>;
 	 	Do 
 	 	[
 	 	 	lexemeAndSpace := lexemeAndSpace ++ <tokens[i]'s lexeme>;
 	 	 	↑i++;
 	 	]
 	 	until [i > |tokens|]
 	 	alternate with [lexemeAndSpace := lexemeAndSpace ++ <delimeter>;];
 	 	cast flatten lexemeAndSpace into [s : string | s]
 	]
 ]:string;

/***
 * Find the start of the scanner's next new unnested comment.
 *
 * @method "find_'s⁇next comment"
 * @categories "stacks"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returnType "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Private method "find_'s⁇next comment" is
[
	scanner : stacks scanner
 |
	Next character from scanner;
	if scanner's source's current element = ¢/ then
	[
		scanner is at new comment
	]
	else
	[
		buffer ::= "/" ++ 
			read from scanner while [scanner's source's current element = ¢*];
		if |buffer| = 1 then [false] 
		else if [|buffer| = 2] then [true]
		else 
		[
			scanner's special comment := true; 
			true
		]
	]
] : boolean;

/**
 * Process first pass of comment.
 *
 * @method "comment first pass from_using_in level_"
 * @categories "category"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @param "tree" "patricia trie"
 * 		the patricia trie that identifies the delimiters.
 * @param "regionCount" "whole number" the number of comments currently nested
 * 	in
 * @returnType "whole number"
 *      the number of comments deep currently nested
 * @author "Richard Arriaga"
 */
Private method "comment first pass from_using_in level_" is
[
	scanner : stacks scanner,
	tree : patricia trie,
	regionCount : ↑whole number
 |
 	tempCommentBuffer : string := "";
	buffer : string := "";
	cursor : patricia trie := tree;
	Until [scanner's source is exhausted ∨ 
			[cursor is at terminus ∧ 
				[scanner's current element ∉ cursor's next steps]]]
	do
	[
		value : character := scanner's current element;
		next ::= cursor's next steps;
		If value = ¢"\"" then
		[
			tempCommentBuffer := tempCommentBuffer ++ <value> ++ 
				read from scanner while 
				[
					scanner's current element ≠ ¢"\"" ∧ 
						[scanner's previous element = ¢\ ∧
						 		[scanner's current element = ¢"\""]]
				] ++ <¢"\"">;
			/* We know the next element is a quote, we need to move pass this*/
			Next character from scanner;
		]
		else if [value ∉ next] then
		[
			/* We have not hit a delimiter, add collected characters
			 * to the region and reset buffer and cursor.            */
			If scanner's special comment = true then
			[
				tempCommentBuffer := tempCommentBuffer ++ buffer ++ <value>;
			];
			buffer := "";
			cursor := tree;
		]
		else
		[
		 	/* On track to buidling a delimiter; proceed down tree */
			cursor := next[value];
			buffer := buffer ++ <value>;
		];
		If cursor is at terminus then
		[
		 	/*Check to see if terminating region or opening nested
		 	 * region. Increment region count appropriately.  */
			If buffer ∈ {"/**","/*"} then
			[
				If scanner's special comment = true then
				[
					tempCommentBuffer := tempCommentBuffer ++ buffer;
				];
				regionCount++;
			]
			else 
			[
				regionCount--;
				If ↓regionCount > 0 ∧ [scanner's special comment = true] then 
				[
					tempCommentBuffer := tempCommentBuffer ++ buffer;
				];
			];
		];
		Next character from scanner;
	];
	/* check to see if in stacks comment, if so, save captured comment */
	If scanner's special comment = true then
	[
		scanner's comment buffer := scanner's comment buffer ++ 
			tempCommentBuffer;
	];
	↓regionCount
]:whole number;

/**
 * Obtain all Stacks comments from a scanner then process them into tokenized 
 * regions.
 *
 * @method "Obtain Stacks comments from_"
 * @categories "category"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returnType "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Private method "Obtain Stacks comments from_" is
[
 scanner : stacks scanner
 |
	tree : patricia trie := a patricia trie;
	/* Add open and close comment delimiters to patricia trie */
	Add "/**" to tree;  /* open stacks comment*/
	Add "/*" to tree;  /* open plain comment*/
	Add "*/" to tree;  /* open stacks comment*/

	Until [scanner's source is exhausted]
	do
	[
	 	inComment : boolean := false;
	 	Until 
	 	[
	 	 	scanner's source is exhausted ∨ [inComment = true]
	 	]
	 	do [find scanner's next comment];
	 	
	 	nestedLevel : whole number := 0;
	 	If inComment = true then [nestedLevel := 1;];
		
	 	While [nestedLevel > 0] do
		[
		 	nestedLevel := comment first pass from scanner using tree 
		 					in level ↑nestedLevel;
		];
	 	
	 	If scanner's special comment = true then 
		[
			/*TODO complete second pass*/
			scanner's special comment := false;
		];
	];
]:⊤;













/* All work that follows is old work*/

/**
 * Tokenize all elements of a string.
 *
 * @method "tokenize comment_"
 * @public
 * @categories "Stacks"
 * @param "comment" "string" 
 *		a qualifying stacks comment
 * @returnType "<stacks token…|>"
 *		a tuple of stacks tokens.  Excludes astericks.
 * @author "Richard Arriaga"
 */
Public method "tokenize comment_" is
[
 	comment : string
 |
 	lineCount : natural number := 1;
 	openComment : whole number := 0;
	openQuote : whole number := 0;
	stacksTokens : <stacks token…|> := <>;
	
	/* delimiting characters for tokenization */
	keyCharacters ::= {¢@,¢" ",¢"\"",¢{,¢},¢`,¢/,¢*,¢"\t",¢"\n"};
 
	doNotTokenize ::= {"/*","/**","*/"," ","","\t"};
	
	newLinePositions ::= all indices of comment where 
		[c : character | c = ¢"\n"];

	priorNewLine : natural number := 1;
	bufferMap : {natural number→string|} := {};
	
	/* Break up comment by new lines.  Map key is line count, value is line *
	 * less the new line character at the end of the line                   */
	For each newLinePositions do
	[
	 	i : natural number
	 |
	 	if priorNewLine = 1 then
	 	[
	 	 	bufferMap := bufferMap + lineCount→comment[priorNewLine..i-1];
	 	] else
	 	[
	 	 	bufferMap := bufferMap + lineCount→comment[priorNewLine + 1..i-1];
	 	];
	 
	 	priorNewLine := i;
		↑lineCount++;
	];
	
	/* Tokenize comment lines */
	For each bufferMap do
	[
	 	lineNumber : natural number,
	 	commentLine : string
	 |
	 	columnPosition : natural number := 1;
		charCounter : whole number := 0;

		/* Is the new line a continuation of a nested comment, if so consume *
		 * without tokenizing the contents                                   */

		While
		[
		 	charCounter < |commentLine|
		]
		do
		[
			If openComment > 1 then
			[
			 	While
			 	[
			 	 	openComment > 1 ∧ [charCounter < |commentLine|]
			 	]
			 	do
			 	[
	
			 	 	/* Consume nested comment without tokenizing but moving *
			 	 	 * column pointer										*/
			 	 	If charCounter = 0 then [↑charCounter++;];
			 	 	
					word : <character…|> := take from commentLine[charCounter+1..] 
					until 
					[
					 	c : character 
					 |
	
						If charCounter ≠ |commentLine| then [↑charCounter++;];
					 	c ∈ {¢/,¢*}  ∨ [charCounter = |commentLine|]
					];
			 	 	
			 	 	j : natural number := cast charCounter into 
						[n : natural number | n];
	
			 	 	If charCounter < |commentLine| +1 ∧ [commentLine[j] ∈ {¢/,¢*}] then  
					[
						Cast commentLine[j] into
						[
						 	c : enumeration of {¢/,¢*}
						 |
							Choose c from enumeration of {¢/,¢*}
							where
							¢* is
							[
							 	If commentLine[j+1] = ¢/ then
							 	[
							 	 	/*Close nested comment*/
							 	 	↑openComment--;
							 	 	↑charCounter++;
							 	];
							],
							¢/ is
							[
								If commentLine[j+1] = ¢* then
								[
								 	/*Open new nested comment*/
									↑openComment++;
									↑charCounter++;
								];
							];
						];
					];
			 	 	
			 	];
			];
			While
			[
			 	charCounter < |commentLine| ∧ [openComment < 2]
			]
			do
			[
			 	wordStart : natural number := charCounter + 1;
				word : <character…|> := take from commentLine[charCounter+1..] until 
				[
				 	c : character 
				 |
				 	↑charCounter++;
				 	c ∈ keyCharacters  ∨ [charCounter = |commentLine|+1]
				];
	
				j : natural number := cast charCounter into 
					[n : natural number | n];
	
				if charCounter < |commentLine| then
				[
					Cast commentLine[j] into
					[
					 	c : enumeration of 
					 		{¢@,¢" ",¢"\"",¢{,¢},¢`,¢/,¢*,¢"\t",¢"\n"}
					 |
						Choose c from enumeration of keyCharacters
						where
						¢"\t" is
						[
						 	If word ∉ doNotTokenize then 
						 	[
						 	 	stacksTokens := stacksTokens ++ 
						 	 		<token <word,lineNumber,wordStart>>;
						 	];
						],
						¢@ is
						[
						 	If word ∉ doNotTokenize then 
						 	[
						 	 	stacksTokens := stacksTokens ++ 
						 	 		<token <word,lineNumber,wordStart>>;
						 	];
			 				wordStart := j;
			 				word := take from commentLine[j..] until 
			 				[
			 					ch : character 
			 				 |
			 				 	↑charCounter++;
			 					ch = ¢" " ∨ [ch =  ¢"\n"]
			 				];
				 			stacksTokens := stacksTokens ++ 
				 				<token <word,lineNumber,wordStart>>;
						 	/* Counter will be re-incremented above.*/
						 	↑charCounter--;
						],
						¢" " is
						[
						 	If word ∉ doNotTokenize then 
						 	[
						 	 	stacksTokens := stacksTokens ++ 
						 	 		<token <word,lineNumber,wordStart>>;
						 	];
						],
						¢"\"" is
						[
						 	If word ∉ doNotTokenize then 
						 	[
						 	 	stacksTokens := stacksTokens ++ 
						 	 		<token <word,lineNumber,wordStart>>;
						 	];
				 			wordStart := j;
			 				word := take from commentLine[j+1..] until 
			 				[
			 					ch : character 
			 				 |
			 					↑charCounter++;
			 					ch = ¢"\"" ∨ [charCounter = |commentLine|]
			 				];
						 	if charCounter < |commentLine| + 1 then
						 	[
						 		word := <¢"\""> ++ word ++ <¢"\"">;
						 		stacksTokens := stacksTokens ++ 
						 			<token <word,lineNumber,wordStart>>;
						 	] else
						 	[
						 	 	/* TODO some sort of Error handling of missing close quote*/
						 	];
						],
						¢{ is
						[/* TODO Better handling of this, want entire thing in one token if followed by @ tag*/
						 	If word ∉ doNotTokenize then 
						 	[
						 	 	stacksTokens := stacksTokens ++ 
						 	 		<token <word,lineNumber,wordStart>>;
						 	];
							stacksTokens := stacksTokens ++ 
								<token <"{",lineNumber,j>>;
						],
						¢} is
						[/* TODO Don't actually need this once { is handled correctly*/
						 	If word ∈ doNotTokenize then 
						 	[
						 	 	stacksTokens := stacksTokens ++ 
						 	 		<token <word,lineNumber,wordStart>>;
						 	];
				 			stacksTokens := stacksTokens ++ 
				 				<token <"}",lineNumber,j>>;
						],
						¢` is
						[
						 /* Check for following escaped special characters */
						 	if charCounter < |commentLine| then
						 	[
							  	if commentLine[j+1] ∈ {¢@,¢"\"",¢`,¢*} then
							  	[
							  	 	word := word ++ commentLine[j..j+1];
							  		↑charCounter++;
							  		If charCounter ≠ |commentLine| then
							  		[
								  		word := word ++ 
								  			take from commentLine[j+2..] until 
						 				[
						 					ch : character 
						 				 |
						 					↑charCounter++;
						 					ch ∈ keyCharacters  
						 				];
									 	If word ∉ doNotTokenize then 
									 	[
									 	 	stacksTokens := stacksTokens ++ 
									 	 		<token <word,lineNumber,wordStart>>;
									 	];
									];
							  	]
							  	else 
							  	[
							  	 	word := word ++ <commentLine[j]>;
							  		↑charCounter++;
							  		word := word ++ take from commentLine[j+1..] until 
					 				[
					 					ch : character 
					 				 |
					 					↑charCounter++;
					 					ch ∈ keyCharacters ∨ 
				 							[charCounter = |commentLine|]
					 				];
								 	If word ∉ doNotTokenize then 
								 	[
								 	 	stacksTokens := stacksTokens ++ 
								 	 		<token <word,lineNumber,wordStart>>;
								 	];
							  	];
							] else
							[
							 	word := word ++ <commentLine[j]>;
							 	If word ∉ doNotTokenize then 
							 	[
							 	 	stacksTokens := stacksTokens ++ 
							 	 		<token <word,lineNumber,wordStart>>;
							 	];
							];
						],
						¢/ is
						[
						 	/*Check to see if open nested comment*/
						 	if commentLine[j+1] = ¢* then
					 		[
			 		 	 		↑charCounter++;
					 		 	if openComment = 0 ∧ [|commentLine| ≤ j + 2] then
					 		 	[
					 		 	 	/*Open new comment*/
					 		 	 	↑openComment++;
					 		 	 	If commentLine[j+2] = ¢* then
					 		 	 	[
					 		 	 	 	/* Start of main comment*/
					 		 	 	 	↑charCounter++;
					 		 	 	];
					 		 	] else
					 		 	[
					 		 	 	/*Open new nested comment*/
					 		 	 	↑openComment++;
					 		 	 	↑charCounter++;
					 		 	];
							] else
							[
						  	 	word := word ++ <commentLine[j]>;
						  		↑charCounter++;
						  		word := word ++ take from commentLine[j+1..] until 
				 				[
				 					ch : character 
				 				 |
				 					↑charCounter++;
				 					ch ∈ keyCharacters ∨ 
			 							[charCounter = |commentLine|]
				 				];
							];
						 	If word ∉ doNotTokenize then 
						 	[
						 	 	stacksTokens := stacksTokens ++ 
						 	 		<token <word,lineNumber,wordStart>>;
						 	];
						],
						¢* is
						[
						 /*Do nothing special here.  If closing comment, it will *
						  * end the buffer.  If not, `* will not be converted 	 *
						  * into a token.  Tokenize prior word if applicable.	 */
						 	If word ∉ doNotTokenize then 
						 	[
						 	 	stacksTokens := stacksTokens ++ 
						 	 		<token <word,lineNumber,wordStart>>;
						 	];
						 ],
						 ¢"\n" is
						 [
						 	If word ∉ doNotTokenize then 
						 	[
						 	 	stacksTokens := stacksTokens ++ 
						 	 		<token <word,lineNumber,wordStart>>;
						 	];
						 ];
					];
				] else
				[
				 	If word ∉ doNotTokenize then 
				 	[
				 	 	stacksTokens := stacksTokens ++ 
				 	 		<token <word,lineNumber,wordStart>>;
				 	];
				];
			];
		];
	];
	stacksTokens
]:<stacks token…|>;

/**
 *
 * @method "tokenize_"
 * @public
 * @categories "Stacks"
 * @param "comment" "string's type" 
 *		a qualifying stacks comment type
 *		a tuple of stacks tokens.  Excludes astericks.
 * @author "Richard Arriaga"
 */
Semantic restriction "tokenize_" is
[
 	comment : string's type
 |
 	if comment ≠ <>'s type then 
 	[
 	 	<stacks token…|1..>
	] 
	else
	[
	 	<stacks token…|0>
	]
 ];


