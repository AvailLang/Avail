/*
 * Stacks Stream Parser.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Stacks Scanner"
Versions
	"Dev"
Extends

Uses
	"Avail",
	"Avail Scanner",
	"Patricia Trie"

Names
	"@author",
	"@category",
	"@code",
	"@field",
	"@forbids",
	"@general",
	"@global",
	"@link",
	"@method",
	"@param",
	"@public",
	"@raises",
	"@restricts",
	"@returns",
	"@see",
	"@supertype",
	"@type",
	"a stacks scanner with_",
	"bracketed stacks token",
	"comments",
	"concatenate_separated by_",
	"erroneous stacks token",
	"generic stacks token",
	"Obtain Stacks comments from_",
	"quoted stacks token",
	"special flag",
	"special region stacks token",
	"stacks scanner",
	"special stacks token",
	"stacks token",
	"_'s⁇comments",
	"_'s⁇comments:=_",
	"_'s⁇error flag",
	"_'s⁇position",
	"_'s⁇special flag",
	"_'s⁇special region flag"

Body

"character buffer" is a new field atom;
"comment buffer" is a new field atom;
"comment buffer index" is a new field atom;
"comments" is a new field atom;
"error flag" is a new field atom;
"new line" is a new field atom;
"open comment count" is a new field atom;
"quoted" is a new field atom;
"quoted flag" is a new field atom;
"special comment" is a new field atom;
"special flag" is a new field atom;
"special region flag" is a new field atom;
"subtokens" is a new field atom;
"subtokens buffer" is a new field atom;
"tokenize" is a new field atom;

/**
 * A class that defines a token for the stacks lexor.  
 * 
 * @type "stacks token"
 * @supertype {@type "scanner token" scanner token}
 * @category Stacks
 * @field "lexeme" "string"
 * 	string representation of token
 * @field "line" "natural number"
 * 	line number on which token appears 
 * @field "position" "natural number"
 * 	column position where token begins
 * @author Richard Arriaga
 */
Public class "stacks token" extends scanner token
	with fields
		public special flag : boolean,
		public error flag : boolean,
		public special region flag : boolean;

/**
 * A class that defines a generic token for the stacks lexor.  
 * 
 * @type "generic stacks token"
 * @supertype {@type "stacks token" stacks token}
 * @category Stacks
 * @field "special flag" "false's type"
 * 	this token is not a token of note.
 */
Public explicit class "generic stacks token" extends stacks token
	with fields
		special flag : false's type,
		error flag : false's type,
		special region flag : false's type;

/**
 * A class that defines a token that resembles a special token but is not
 * representative of any of the special tokens.
 * 
 * @type "erroneous stacks token"
 * @supertype {@type "stacks token" stacks token}
 * @category "Stacks"
 * @field "lexeme" "string"
 * 	this token is an erroneous token of note.
 */
Public explicit class "erroneous stacks token" extends stacks token
	with fields
	special flag : false's type,
	error flag : true's type,
	special region flag : false's type;

/**
 * A class that defines a special token for the stacks lexor.
 * 
 * @type "special stacks token"
 * @supertype {@type "stacks token" stacks token}
 * @category "Stacks"
 * @field "lexeme" "string"
 * 	this token is a token of note.
 */
Public explicit class "special stacks token" extends stacks token
	with fields
	special flag : true's type,
	error flag : false's type,
	special region flag : false's type;

/**
 * A class that defines a special token for the stacks lexor.
 * 
 * @type "special region stacks token"
 * @supertype {@type "special stacks token" special stacks token}
 * @category "Stacks"
 * @field "lexeme" "string"
 * 	this token is a token of note.
 */
Public explicit class "special region stacks token" extends stacks token
	with fields
	special flag : false's type,
	error flag : false's type,
	special region flag : true's type;

/**
 * A class that defines a special token for the stacks lexor.
 * 
 * @type "quoted stacks token"
 * @supertype {@type "special region stacks token" special region stacks token}
 * @category "Stacks"
 * @field "lexeme" "string"
 * 	this token is a token of note.
 */
Public explicit class "quoted stacks token" extends special region stacks token
	with fields
		quoted : true's type;

/**
 * A class that defines a special token for the stacks lexor.
 * 
 * @type "bracketed stacks token"
 * @supertype {@type "special region stacks token" special region stacks token}
 * @category "Stacks"
 * @field "lexeme" "string"
 * 	this token is a token of note.
 */
Public explicit class "bracketed stacks token" 
	extends special region stacks token
	with fields
		subtokens : <stacks token…|>;

/**
 * A method that constructs a subtype of stacks token class.
 *
 * @method "_ is a stacks token"
 * @categories "Stacks"
 * @param "name" "string" 
 *		name of new token type
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "_is a stacks token" is
[
 	tokenName : <character…|1..>
 |
 	Class tokenName extends special stacks token
 		with fields
 			lexeme : tokenName's type;
 ]:⊤;
 


/* All keywords that will ultimately be special stacks tokens */

stacksTokenTypeNames::= {"@field","@type","@supertype","@category","@param",
	"@raises","@restricts","@returns","@forbids","@public","@method","@see",
	"@author","@link","@code","@global","@general"};
	
For each stacksTokenTypeNames do
[
	tokenTypeName : <character…|1..>
 |
 	tokenTypeName is a stacks token;
];

/* Special characters that could result in token delimiter */
tokenDelimiter ::= {¢@,¢" ",¢"\t",¢"\"",¢"\n",¢{,¢/,¢*};


/* Strings that should not be tokenized */
doNotTokenize ::= {"/*","/**","*/"," ","","\t"};

/**
 * Take a tuple of stacks tokens and concatenate the lexemes seperated by
 * provided character
 *
 * @method "Concatenate_separated by_"
 * @public
 * @categories "Stacks"
 * @param "tokens" "<stacks token…|1..>" 
 *      a tuple of stacks tokens
 * @param "delimeter" "string" 
 *      the string to separate the tokens' lexems in the string
 * @returnType "string"
 *      a string sentence of the tokens' lexemes
 * @author "authorName"
 */
Public method "concatenate_separated by_" is
[
	tokens : <stacks token…|>,
	delimeter : string
 |
	if |tokens| = 0 then [""]
	else if [|tokens| = 1] then [tokens[1]'s lexeme]
	else
	[
		i : natural number := 1;
		lexemeAndSpace : <string…|> := <>;
		Do 
		[
			lexemeAndSpace := lexemeAndSpace ++ <tokens[i]'s lexeme>;
			↑i++;
		]
		until [i > |tokens|]
		alternate with [lexemeAndSpace := lexemeAndSpace ++ <delimeter>;];
		cast flatten lexemeAndSpace into [s : string | s]
	]
]:string;

/**
 * A class that defines a Stacks lexical scanner.  This is a concrete class.
 * 
 * @type "stacks scanner"
 * @supertype {@type "Avail scanner" object}
 * @category "Stacks"
 * @field "comments" "<<stacks token…|>…|>"
 * 	an a tuple of stacks token tuples.  Each tuple represents a comment.
 * @field "subtoken buffer" "<scanner token…|>"
 *	a place to temporarily store tokens that are to be stored in a special
 *	region token, such as a {@type "bracketed stacks token"}.
 * @field "comment buffer" "<character…|>"
 * 	buffer that temporarily retains the body of a comment while scanning is 
 * 	making first pass
 * @field "character buffer" "<character…|>"
 * 	buffer that temporarily retains characters awaiting tokenization
 * @field "comment buffer" "<character…|>"
 * 	buffer that temporarily retains characters from buffer obtained in first 
 * 	pass parse.
 * @field "token buffer" "<character…|>"
 * 	buffer that temporarily retains tokens of a common comment awaiting to be
 * 	added to comments.
 * @field "open comment count" "whole number"
 * 	number of comments currently opened
 * @field "special comment" "boolean"
 * 	if scanner current element is in a stacks comment.  Should be initialized
 * 	to false.
 * @field "quoted flag" "boolean"
 * 	if scanner current element in a quoted region.  Should be initialized to
 * 	false.
 * @author Richard Arriaga
 */
Public class "stacks scanner" extends Avail scanner
	with mutable fields
		public comments : <<stacks token…|>…|>,
		subtokens buffer : <stacks token…|>,
		comment buffer : <character…|>,
		character buffer : <character…|>,
		referable comment buffer index : natural number,
		referable open comment count : whole number,
		new line : boolean,
		special comment : boolean,
		quoted flag : boolean,
		tokenize : boolean;

/**
 * Public constructor of stacks scanner
 *
 * @method "construct stacks scanner with_"
 * @categories "Stacks Scanner"
 * @param "iter" "iterator of character" 
 *      and iterator of characters
 * @returnType "stacks scanner"
 *      a stacks scanner object
 * @author "Richard Arriaga"
 */
Public method "a stacks scanner with_" is
[
	iter : iterator of character
|
	a stacks scanner with
		source ::= iter,
		token buffer := <>,
		line number := 1,
		column number := 1,
		token start := 1,
		comments := <>,
		subtokens buffer := <>,
		comment buffer := <>,
		character buffer := <>,
		comment buffer index := 1,
		open comment count := 0,
		new line := true,
		special comment := false,
		quoted flag := false,
		tokenize := true
] : stacks scanner;

/**
 * Advance the stacks scanner's source.  If it is not in a stacks comment,
 * increment the line number and column number if able.
 *
 * @method "Next character from_"
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *		a stacks scanner
 * @returnType "⊤"
 *		none
 * @raises "Raise an exhausted-iterator exception" 
 *		there is nothing left on the iterator to consume
 * @author "Richard Arriaga"
 */
Method "Next character from_" is
[
	scanner : stacks scanner
 |
	scanner's previous element := scanner's current element;
	Advance scanner's source;
	If scanner's source is not exhausted then
	[
		If ¬scanner's special comment then 
		[
			If scanner's current element = ¢"\n" then 
			[
				scanner's column number := 1;
				scanner's line number := scanner's line number + 1;
			]
			else
			[
				scanner's column number := scanner's column number + 1;
			];
		];
	];
]:⊤;

Private forward method "_is at new comment" is [stacks scanner]→boolean;

/***
 * Determine if a scanner comment is at the start of a new stacks comment.
 *
 * @method "_is at new comment"
 * @categories "stacks"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returnType "boolean"
 *      whether or not at start of a new comment.
 * @author "Richard Arriaga"
 */
Private method "_is at new comment" is
[
	scanner : stacks scanner
 |
	Next character from scanner;
	if scanner's source is not exhausted then
	[
		if scanner's source's current element = ¢/ then
		[
			scanner is at new comment
		]
		else
		[
			if scanner's previous element = ¢/ then
			[
				buffer ::= read from scanner while [scanner's current element = ¢*];
				if |buffer| = 0 then [false]
				else if [|buffer| = 1] then [true]
				else
				[
					scanner's special comment := true;
					true
				]
			] else [false]
		]
	] else [false]
] : boolean;

/**
 * Determine if the comment character is exhausted
 *
 * @method "_'s⁇comment buffer is exhausted"
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returnType "boolean"
 *      true if buffer is exhausted, false if it is not.
 * @author "Richard Arriaga"
 */
Private method "_'s⁇comment buffer is exhausted" is
[
	scanner : stacks scanner
 |
	if scanner's comment buffer index > |scanner's comment buffer| then
	[true] else [false]
]:boolean;

/**
 * Determine if the comment character is not exhausted
 *
 * @method "_'s⁇comment buffer is not exhausted"
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returnType "boolean"
 *      true if buffer is not exhausted, false if it is.
 * @author "Richard Arriaga"
 */
Private method "_'s⁇comment buffer is not exhausted" is
[
	scanner : stacks scanner
 |
	¬scanner's comment buffer is exhausted
]:boolean;

/**
 * clear the scanner's comment buffer
 *
 * @method "clear_'s⁇comment buffer"
 * @categories "category"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returnType "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Private method "clear_'s⁇comment buffer" is
[
	scanner : stacks scanner
 |
	scanner's comment buffer := <>;
	scanner's comment buffer index := 1;
]:⊤;

/**
 * The character at the scanner comment buffer's index.
 *
 * @method "_'s⁇current buffer character"
 * @categories "category"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returnType "character"
 *      the character at the index position of the comment buffer
 * @raises "exceptionName" 
 *      exceptionDescription
 * @author "Richard Arriaga"
 */
Private method "_'s⁇current buffer character" is
[
	scanner : stacks scanner
 |
 	/*TODO handle error when no character at index*/
	scanner's comment buffer[scanner's comment buffer index]
]:character;

/**
 * The character at the scanner comment buffer's index.
 *
 * @method "_'s⁇previous buffer character"
 * @categories "category"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returnType "character"
 *      the character at the index position of the comment buffer
 * @raises "exceptionName" 
 *      exceptionDescription
 * @author "Richard Arriaga"
 */
Private method "_'s⁇previous buffer character" is
[
	scanner : stacks scanner
 |
 	/*TODO handle error when no character at index*/
 	i : natural number := cast scanner's comment buffer index-1 into 
 		[n : natural number | n];  
	scanner's comment buffer[i]
]:character;

/**
 * Increment the scanner's character buffer index
 *
 * @method "Increment_'s⁇buffer index"
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returnType "⊤"
 *      none
 * @raises "exceptionName" 
 *      exceptionDescription
 * @author "Richard Arriaga"
 */
Private method "Increment_'s⁇buffer index" is
[
	scanner : stacks scanner
 |
	
	scanner's comment buffer index := scanner's comment buffer index + 1;

	If scanner's comment buffer is exhausted then
	[
		/*TODO add error handling for attempt to increment index beyond buffer size*/
	] else
	[
		If scanner's comment buffer index > 1  ∧ 
			[scanner's previous buffer character = ¢"\n"] 
		then 
		[
			scanner's column number := 1;
			scanner's line number := scanner's line number + 1;
		]
		else
		[
			scanner's column number := scanner's column number + 1;
		];
	];
]:⊤;

/**
 * Read from Avail scanner's comment buffer while supplied condition is true 
 * or the buffer is exhausted.
 *
 * @method "read from_'s⁇comment buffer while_"
 * @public
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *		an stacks scanner 
 * @param "predicate" "boolean" 
 *		The function that guards repeated application of reading from the source
 * @returnType "<character…|>"
 *		the tuple of characters read from the source
 * @author "Richard Arriaga"
 */
Private method "read from_'s⁇comment buffer while_" is
[
 	scanner : stacks scanner,
 	predicate : []→boolean
 |
	buffer : <character…|> := <>;
	While 
	[
		scanner's comment buffer is not exhausted ∧ 
			[predicate()]
	]
	do
	[
		buffer := buffer ++ 
			<scanner's comment buffer[scanner's comment buffer index]>;
			Increment scanner's buffer index;
	];
	buffer
]:<character…|>;

/**
 * return the most specific type of the stacks scanner's token buffer's element
 * @method "_[_]"
 * @categories "Stacks Scanner"
 * @restrcits "scannerType" "stacks scanner's type" 
 * @restricts "indexType" "natural number's type"
 * @author "Richard Arriaga"
 */
Semantic restriction "_[_]" is
[
	scannerType : Avail scanner's type,
	indexType : natural number's type
 |
	if |scannerType| = |indexType| = 1 then
	[
	 	scan ::= scannerType's instance;
		(scan[indexType's instance])'s type
	]
	else if [|scannerType| = 1] then
	[
		tb ::= ((scannerType's instance)'s token buffer)'s type;
		∪ (tb's leading types ++ <tb's default type>)
	]
	else [⊤]
];

/**
 * @method "_'s⁇token buffer"
 * @categories "Stacks Scanner"
 * @restricts "scannerType" "stacks scanner's type" 
 * @author "Richard Arriaga"
 */
Semantic restriction "_'s⁇token buffer" is
[
	scannerType : stacks scanner's type
 |
	<stacks token…|>
];

/**
 * A method that creates a single stacks token object
 *
 * @method "tokenize_'s⁇«quoted»?character buffer"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a tuple <token lexeme,token line number,token column position>
 * @returnType "stacks token"
 *		a stacks token of the input string
 * @author "Richard Arriaga"
 */
Private method "tokenize_'s⁇«quoted»?character buffer" is
[
	scanner : stacks scanner,
	optionalFlag : boolean
 |
	cb : <character…|1..> := cast scanner's character buffer into 
		[s : <character…|1..> | s];

	tokenStart : natural number := if scanner's quoted flag then
	[
		scanner's token start
	]
	else
	[
		cast scanner's column number - |cb| + 1
			into [n : natural number | n]
	];
	if optionalFlag then 
	[
		a quoted stacks token with
			lexeme ::= cb,
			line ::= scanner's line number,
			position ::= tokenStart
	]
	else if [scanner's character buffer ∉ stacksTokenTypeNames] then
	[
		if cb[1] ≠ ¢@ then
		[
		 	 a generic stacks token with
				lexeme ::= cb,
				line ::= scanner's line number,
				position ::= tokenStart
		] else
		[
			an erroneous stacks token with
				lexeme ::= cb,
				line ::= scanner's line number,
				position ::= tokenStart
		]
	] else
	[
		a special stacks token with
			lexeme ::= cb,
			line ::= scanner's line number,
			position ::= tokenStart
	]
] : stacks token;

/**
 * A method that creates a single bracketed stacks token object
 *
 * @method "tokenize_'s⁇ bracketed character buffer"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a tuple <token lexeme,token line number,token column position>
 * @returnType "stacks token"
 *		a stacks token of the input string
 * @author "Richard Arriaga"
 */
Private method "tokenize_'s⁇bracketed character buffer" is
[
	scanner : stacks scanner
 |
	cb : <character…|1..> := cast scanner's character buffer into 
		[s : <character…|1..> | s];
	a bracketed stacks token with
		lexeme ::= cb,
		line ::= scanner's line number,
		position ::= scanner's token start,
		subtokens ::= scanner's subtokens buffer
] : bracketed stacks token;

/**
 * A method that accepts a stacks scanner and tokenizes its character buffer if
 * the buffer does not meet the do not tokenize criteria
 * 
 * @method "Buffer_'s⁇ current«quoted»?token"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a stacks lexical scanner
 * @returnType "stacks token"
 *		the newly tokenized stacks token
 * @author "Richard Arriaga"
 */
Private method "Buffer_'s⁇current«quoted»?token" is
[
	scanner : stacks scanner,
	optionalFlag : boolean
 |
	If scanner's character buffer ∉ doNotTokenize ∧ 
		[|scanner's character buffer| > 0]
	then 
	[
		tokenized : stacks token :=
			if optionalFlag then
			[
			 	tokenize scanner's quoted character buffer
			]
			else [tokenize scanner's character buffer];

		If scanner's tokenize then
		[
			tb : <scanner token…|> := scanner's token buffer ++ <tokenized>;
			scanner's token buffer := tb;
		] else
		[
			tb : <stacks token…|> := scanner's subtokens buffer ++ <tokenized>;
			scanner's subtokens buffer := tb;
		];
	];
	scanner's character buffer := <>;
]:⊤;

/**
 * A method that accepts a stacks scanner and tokenizes its character buffer if
 * the buffer does not meet the do not tokenize criteria
 *
 * @method "Buffer_'s⁇ current«quoted»?token"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a stacks lexical scanner
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "Buffer_'s⁇current bracketed token" is
[
	scanner : stacks scanner
 |
	If scanner's character buffer ∉ doNotTokenize ∧ 
		[|scanner's character buffer| > 0]
	then 
	[
		tb :<scanner token…|>:= scanner's token buffer ++ 
			<tokenize scanner's bracketed character buffer>;

		scanner's token buffer := tb;
	];
	scanner's character buffer := <>;
	scanner's subtokens buffer := <>;
]:⊤;

Private forward method "_is at nested comment" is [stacks scanner]→boolean;

/***
 * Determine if a scanner comment buffer is at the start of a nested comment.
 *
 * @method "_is at nested comment"
 * @categories "stacks"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returnType "boolean"
 *      whether or not at start of a nested.
 * @author "Richard Arriaga"
 */
Private method "_is at nested comment" is
[
	scanner : stacks scanner
 |
	if scanner's current buffer character = ¢/ then
	[
		scanner is at nested comment
	]
	else
	[
		if scanner's previous buffer character = ¢/ then
		[
			buffer : <character…|> := read from scanner's comment buffer while 
				[scanner's current buffer character = ¢*];
			if |buffer| = 1 then 
			[
			 	scanner's character buffer := scanner's character buffer ++ 
			 		buffer;
				false]
			else 
			[
				If |scanner's character buffer| ≠ 0 then
					[Buffer scanner's current token;];
				true
			]
		] else [false]
	]
] : boolean;

/**
 * Consume the scanners nested comment without tokenizing any elements
 *
 * @method "Consume_'s⁇nested comment"
 * @categories "stacks"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returnType "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Private method "Consume_'s⁇nested comment" is
[
	scanner : stacks scanner
 |
	While 
	[
		scanner's comment buffer is not exhausted ∧ 
			[scanner's open comment count > 1] 
	] 
	do
	[
		throwAway ::= read from scanner's comment buffer while
		[
			scanner's current buffer character ∉ {¢/,¢*}
		];
		if scanner's current buffer character = ¢/ then
		[
			Increment scanner's buffer index;
			If scanner's comment buffer is not exhausted ∧ 
				[scanner's current buffer character = ¢*] then
			[
				↑scanner's open comment count++;
			];
		]
		else
		[
			/* current element is * */
			Increment scanner's buffer index;
			If scanner's comment buffer is not exhausted ∧ 
				[scanner's current buffer character = ¢/] then
			[
				↑scanner's open comment count--;
			];
		];
	];
]:⊤;

/**
 * Handle a forward slash in a stacks scanner.
 *
 * @method "_process forward slash"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returnType "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Private method "Process forward slash from_" is
[
	scanner : stacks scanner
 |
	If scanner is at nested comment then
	[
		↑scanner's open comment count++;
		Consume scanner's nested comment;
	];
]:⊤;

/**
 * Tokenize all characters in double quotes including white space.
 *
 * @method "Process double quote in comment from_"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a stacks scanner
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "Process double quote in comment from_" is
[
	scanner : stacks scanner
 |
/*TODO Error handling.  What if new lines not handled with expected syntax?*/
	scanner's token start := scanner's column number;
	scanner's quoted flag := true;
	Increment scanner's buffer index;
	word : string := read from scanner's comment buffer  
		while
		[
			scanner's current buffer character ≠ ¢"\"" ∨ 
			[scanner's previous buffer character = ¢\ ∧
			 		[scanner's current buffer character = ¢"\""]]
		];

	/* Find all instances of \" in word.  All remaining instances will be 
	 * preceded by a \ */
	quoteIndices ::= all indices of word where [c : character | c = ¢"\""];
	/* Iteratate through quote indices removing the char before the quote */
	From |quoteIndices| to 1 by -1 do
	[
		n : natural number
	 |
		z ::= split word after quoteIndices[n];
		i ::= |z[1]| - 1; 
		word := z[1][1..i] ++ z[2];
	];

	/* Find all new line instances in word */
	newlineIndices ::= all indices of word where [c : character | c = ¢"\n"];
	/* Iterate through new line indices removing them and associated 
	 * syntax used to break quoted strings over many lines */
	From |newlineIndices| to 1 by -1 do
	[
		n : natural number
	 |
		z ::= split word after quoteIndices[n];
		half1End ::= last index of z[1] where [c: character | c = ¢\];
		end ::= cast |half1End|-1 into [r : natural number | r];
		half1 : string := if z[1][end] ≠ ¢" " then 
		[
			z[1][..end] ++ " "
		] else 
		[
			z[1][..end]
		];

		half2Start ::= first index of z[2] where [c: character | c = ¢|];
		half2 : string := if z[2][|half2Start|+1] ≠ ¢" " then 
		[
			z[2][|half2Start|+1..]
		] else 
		[
			z[2][|half2Start|+2..]
		];

		word := half1 ++ half2;
	];

	scanner's character buffer := word;
	Buffer scanner's current quoted token;
	scanner's line number := scanner's line number + |newlineIndices|;
	Increment scanner's buffer index;
	scanner's quoted flag := false;
 ]:⊤;

/**
 * Tokenize all characters in buffer up to white space.
 *
 * @method "Process white space in comment from_"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a stacks scanner
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "Process white space in comment from_" is
[
	scanner : stacks scanner
|
		Buffer scanner's current token;
		Increment scanner's buffer index;
]:⊤;

Private forward method "Process newline in comment from_" is [stacks scanner]→⊤;

/**
 * Tokenize all characters in buffer up to newline.
 *
 * @method "Process white space in comment from_"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a stacks scanner
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "Process newline in comment from_" is
[
	scanner : stacks scanner
|

	Buffer scanner's current token;
	scanner's new line := true;
	asterickCount : whole number := 0;
	While
	[
		scanner's comment buffer is not exhausted ∧
			[asterickCount < 1  ∨ 
			[scanner's current buffer character is whitespace]]
	]
	do
	[
		If scanner's current buffer character = ¢* then 
		[
			↑asterickCount++;
		];
		If scanner's current buffer character = ¢"\n" then 
		[
			asterickCount := 0;
		];
		Increment scanner's buffer index;
	];
	scanner's new line := false;

]:⊤;

/**
 * Tokenize all characters in buffer up to at symbol then tokenize word that 
 * starts with at symbol 
 *
 * @method "Process at sign in comment from_"
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *	a stacks scanner
 * @returnType "⊤"
 *      none
 * @author "authorName"
 */
Private method "Process at sign in comment from_" is
[
	scanner : stacks scanner
 |
	Buffer scanner's current token;
	Increment scanner's buffer index;
	word ::= <scanner's previous buffer character> ++ 
		read from scanner's comment buffer while
			[ scanner's current buffer character ∉ tokenDelimiter];
	scanner's character buffer := word;
	Buffer scanner's current token;
]:⊤;

/**
 * Tokenize characters in character buffer with asterisk if appropriate
 *
 * @method "Process asterick in comment from_;"
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *	a stacks scanner
 * @returnType "⊤"
 *      none
 * @author "authorName"
 */
Private method "Process asterick in comment from_" is
[
	scanner : stacks scanner
 |
	If scanner's new line then
	[
		Buffer scanner's current token;
		Increment scanner's buffer index;
	] else
	[
		Increment scanner's buffer index;
		throwAway ::= read from scanner's comment buffer while
			[scanner's comment buffer is not exhausted ∧
			 [scanner's current buffer character is whitespace ∧
				[scanner's current buffer character ≠ ¢"\n"]]];
		If scanner's current buffer character ≠ ¢"\n" then
		[
		 	scanner's character buffer := scanner's character buffer ++ "*";
		 	If scanner's previous buffer character is whitespace then
		 	[Buffer scanner's current token;];
		];
	];
]:⊤;

Private forward method "Process left curly brace in comment from_" is
	[stacks scanner]→⊤;

inCommentDispatchTable : {character→[stacks scanner]→⊤|} := {};

For each tokenDelimiter do
[
	c : character
 |
	if c = ¢/ then
	[
	 	inCommentDispatchTable := inCommentDispatchTable + 
	 		c→ [
					scanner : stacks scanner
				 |
					Process forward slash from scanner; /*Done*/
				];
	]
	else if [c = ¢"\n"] then
	[
		inCommentDispatchTable := inCommentDispatchTable + 
			c→ [
					scanner : stacks scanner
				 |
					Process newline in comment from scanner; /*Done*/
				];
	]
	else if [c = ¢"\""] then
	[
	 	inCommentDispatchTable := inCommentDispatchTable + 
	 		c→ [
			 	 	scanner : stacks scanner
			 	 |
			 	 	Process double quote in comment from scanner; /*Done*/
			 	];
	]
	else if [c = ¢{] then
	[
	 	inCommentDispatchTable := inCommentDispatchTable  + 
	 		c→ [
			 	 	scanner : stacks scanner
			 	 |
			 	 	Process left curly brace in comment from scanner; /*Done*/
			 	];
	]
	else if [c is whitespace] then
	[
	 	inCommentDispatchTable := inCommentDispatchTable  + 
	 		c→ [
			 	 	scanner : stacks scanner
			 	 |
			 	 	Process white space in comment from scanner; /*Done*/
			 	];
	]
	else if [c = ¢@] then
	[
	 	inCommentDispatchTable := inCommentDispatchTable  + 
	 		c→ [
			 	 	scanner : stacks scanner
			 	 |
			 	 	Process at sign in comment from scanner; /*Done*/
			 	];
	]
	else if [c = ¢*] then
	[
	 	inCommentDispatchTable := inCommentDispatchTable + 
	 		c→ [
			 	 	scanner : stacks scanner
			 	 |
			 	 	Process asterick in comment from scanner; /*Done*/
			 	];
	];
];

/**
 * Tokenize all characters in region in curly brace
 *
 * @method "Process left curly brace in comment from_;"
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *	a stacks scanner
 * @returnType "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Private method "Process left curly brace in comment from_" is
[
	scanner : stacks scanner
 |
	/*Store current comment buffer index to be reset to if not start of special 
	 * bracketed region */
	startIndex : natural number := scanner's comment buffer index;
	Increment scanner's buffer index;

	throwAway ::= read from scanner's comment buffer while
		[ scanner's current buffer character is whitespace];
	If scanner's current buffer character = ¢@ then
	[
		Buffer scanner's current token;
		scanner's tokenize := false;
		startIndex := scanner's comment buffer index;
		region ::= read from scanner's comment buffer while
			[scanner's current buffer character ≠ ¢}]; 
		scanner's character buffer := <>;
		endIndex : natural number := scanner's comment buffer index;
		scanner's comment buffer index := startIndex;
		While
		[
			scanner's comment buffer index < endIndex
		]
		do
		[
			c ::= scanner's current buffer character;
			f ::= inCommentDispatchTable[c] else
				[
					[
						s : stacks scanner
					 |
						scanner's character buffer := 
							scanner's character buffer ++ <c>;
						Increment scanner's buffer index;
					]
				];
			f(scanner);
		];
		/*Reached index pointing at close of region, }.  Advance index beyond
		 * this point in order to not tokenize it*/
		Increment scanner's buffer index;
		Buffer scanner's current token;
		scanner's character buffer := 
			concatenate scanner's subtokens buffer separated by " ";
		scanner's tokenize := true;
		Buffer scanner's current bracketed token;
	]
	else
	[
		scanner's comment buffer index := startIndex;
		scanner's character buffer := scanner's character buffer ++ 
			<scanner's current buffer character>;
		Increment scanner's buffer index;
	];
]:⊤;

/**
 * Tokenize all elements of the stacks scanner comment
 *
 * @method "Process the_'s⁇comment buffer"
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *		a stacks scanner
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "Process the_'s⁇comment buffer" is
[
 	scanner : stacks scanner
 |
	Until
	[
		scanner's comment buffer is exhausted
	]
	do
	[
		c ::= scanner's current buffer character; 
		f ::= inCommentDispatchTable[c] else
			[
				[
					s : stacks scanner
				 |
					scanner's character buffer := 
						scanner's character buffer ++ <c>;
					Increment scanner's buffer index;
				]
			];
		f(scanner);
	];
]:⊤;

/***
 * Find the start of the scanner's next new unnested comment.
 *
 * @method "find_'s⁇next comment"
 * @categories "stacks"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returnType "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Private method "find_'s⁇next comment" is
[
	scanner : stacks scanner
 |
	inComment : boolean := false;
	Until 
	[
		scanner's source is exhausted ∨
			[inComment]
	]
	do
	[
		inComment := scanner is at new comment;
	];
	inComment
] : boolean;

/**
 * Process first pass of comment.
 *
 * @method "comment first pass from_using_in level_"
 * @categories "category"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @param "tree" "patricia trie"
 * 		the patricia trie that identifies the delimiters.
 * @param "regionCount" "whole number" the number of comments currently nested
 * 	in
 * @returnType "whole number"
 *      the number of comments deep currently nested
 * @author "Richard Arriaga"
 */
Private method "comment first pass from_using_in level_" is
[
	scanner : stacks scanner,
	tree : patricia trie,
	regionCount : ↑whole number
 |
	tempCommentBuffer : string := "";
	buffer : string := "";
	cursor : patricia trie := tree;
	Until [scanner's source is exhausted ∨ 
			[cursor is at terminus ∧ 
				[scanner's current element ∉ cursor's next steps]]]
	do
	[
		value : character := scanner's current element;
		next ::= cursor's next steps;
		If value = ¢"\"" then
		[
			Next character from scanner;
			tempCommentBuffer := tempCommentBuffer ++ <¢"\""> ++ 
				<scanner's current element> ++
				read from scanner while 
				[
					scanner's current element ≠ ¢"\"" ∨
						[scanner's previous element = ¢\ ∧
						 		[scanner's current element = ¢"\""]]
				];
		]
		else if [value ∉ next] then
		[
			/* We have not hit a delimiter, add collected characters
			 * to the region and reset buffer and cursor.            */
			If scanner's special comment = true then
			[
				tempCommentBuffer := tempCommentBuffer ++ buffer ++ <value>;
			];
			buffer := "";
			cursor := tree;
		]
		else
		[
		 	/* On track to buidling a delimiter; proceed down tree */
			cursor := next[value];
			buffer := buffer ++ <value>;
		];
		If cursor is at terminus then
		[
		 	/*Check to see if terminating region or opening nested
		 	 * region. Increment region count appropriately.  */
			If buffer ∈ {"/**","/*"} then
			[
				If scanner's special comment = true then
				[
					tempCommentBuffer := tempCommentBuffer ++ buffer;
				];
				regionCount++;
			]
			else 
			[
				regionCount--;
				If ↓regionCount > 0 ∧ [scanner's special comment = true] then 
				[
					tempCommentBuffer := tempCommentBuffer ++ buffer;
				];
			];
		];
		Next character from scanner;
	];
	/* check to see if in stacks comment, if so, save captured comment */
	If scanner's special comment = true then
	[
		scanner's comment buffer := scanner's comment buffer ++ 
			tempCommentBuffer;
	];
	↓regionCount
]:whole number;

/**
 * Reset all comment tokenizing fields in a stacks scanner to initial settings
 *
 * @method "Reset_'s⁇comment processing structure"
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returnType "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Private method "Reset_'s⁇comment processing structure" is
[
	scanner : stacks scanner
 |
	scanner's comment buffer := <>;
	scanner's character buffer := <>;
	scanner's comment buffer index := 1;
	scanner's  open comment count := 0;
	scanner's special comment := false;
	scanner's new line := true;
	scanner's token buffer := <>;
]:⊤;


/**
 * A method that accepts a stacks scanner and stores a completely tokenized 
 * comment into its comment buffer.
 *
 * @method "Buffer_'s⁇ current comment"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a stacks lexical scanner
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "Buffer_'s⁇current comment" is
[
	scanner : stacks scanner
|
	scanner's comments := (scanner's comments ++ <scanner's token buffer>);
	Reset scanner's comment processing structure;
]:⊤;

/**
 * Obtain all Stacks comments from a scanner then process them into tokenized 
 * regions.
 *
 * @method "Obtain Stacks comments from_"
 * @categories "category"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returnType "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Public method "Obtain Stacks comments from_" is
[
	scanner : stacks scanner
 |
	tree : patricia trie := a patricia trie;
	/* Add open and close comment delimiters to patricia trie */
	Add "/**" to tree;  /* open stacks comment*/
	Add "/*" to tree;  /* open plain comment*/
	Add "*/" to tree;  /* open stacks comment*/

	Until [scanner's source is exhausted]
	do
	[
		inComment : boolean := false;
		inComment := find scanner's next comment;

		nestedLevel : whole number := 0;
		If inComment = true then 
		[
			nestedLevel := 1;
			↑scanner's open comment count++;
		];

		While [nestedLevel > 0] do
		[
			nestedLevel := comment first pass from scanner using tree 
							in level ↑nestedLevel;
		];

		If scanner's special comment = true then 
		[
			/*Transform comment buffer into a tokenized comment tuple*/
			Process the scanner's comment buffer;
			Buffer scanner's current comment;
		];
	];
]:⊤;