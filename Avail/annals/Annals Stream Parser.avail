/*
 * Annals Stream Parser.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Annals Stream Parser"
Versions
	"Dev"
Extends

Uses
	"Avail",
	"Annals Class Definitions"
Names
/* TODO: Exports */
Body

z ::= "/**
 * Iteratively apply `action` to each consecutive element of `aTuple`.
 * 
 *	Parameters:
 *    @param aTuple: A tuple.
 *    @param action: A function that accepts the elements of the tuple.
 *	Returns:
 *		⊤.
 */
Method \"For each_do_\" is
[
	aTuple : tuple,
	action : [⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			Invoke action with <aTuple[index]>;
			↑index++;
			Restart loop
		];
	]();
] : ⊤;

/**
 * Construct and answer a stream type that answers values of the specified type.
 * 
 * Parameters:
 *    @param elementType: The type of value produced by the desired stream 
 *    	type.
 * Returns:
 *    The requested stream type.
 */
Public method \"stream of_\" is
[
	elementType : any's type
|
	extend stream with element type : elementType's type
] : stream's type;";

/**
 * Replace all occurences of a character in a string with another character.
 * 
 * Parameters:
 * 	@param origChar : the character to be replaced
 * 	@param newChar : the replacing character
 * 	@param aString: The string to replace characters in
 */
Private method "replace all_with_in_" is
[
 	origChar : character,
 	newChar : character,
 	aString : string
 |
 	concatenate map aString through 
	[
		c : character
	 |
		if c = origChar then [<newChar>] else [<c>]
	]
]: string;

/**
 * Remove all occurences of a character in a string.
 * 
 * Parameters:
 * 	@param origChar : the character to be replaced
 * 	@param aString: The string to replace characters in
 */
Private method "remove all_in_" is
[
 	origChar : character,
 	aString : string
 |
 	concatenate map aString through 
	[
		c : character
	 |
		if c = origChar then [""] else [<c>]
	]
]: string;

/**
 * Replace a substring within a string with a new substring
 * 
 * Parameters:
 * 	@param origSubString - string to find and replace
 * 	@param newSubString - replacement string
 * 	@param aString - string to search for substring
 */
Private method "replace all_with_in_" is
[
 	origSubString : <character…|1..>,
 	newSubString : string,
 	aString : string
 |
 	If |aString| < |origSubString| then [aString]
	 	else
	 	[
	 	 	startCharOrig ::= all indices of aString where
	 	 	[
	 	 	 	c : character
	 	 	 |
	 	 	 	c = origSubString[1]
	 	 	];
	 	 	if startCharOrig is empty then [aString]
	 	 		else
	 	 		[
	 	 		 	position : natural number := 1;
	 	 		 	i : whole number := |origSubString|;
	 	 		 	j : whole number := |newSubString|;
	 	 		 	returnString : string := "";
	 	 		 	For each startCharOrig do
	 	 		 	[
	 	 		 	 	n : natural number
	 	 		 	 |
	 	 		 	 	If n ≠ 1 then [
	 	 		 	 		returnString := 
	 	 		 	 			returnString ++ aString[position..n-1];
	 	 		 		];
	 	 		 		if aString[n..n+i-1] = origSubString[1..i] then
	 	 		 		[
	 	 		 		 	returnString := returnString ++ newSubString;
	 	 		 			position := n + i;
	 	 		 		] else
	 	 		 		[
	 	 		 		 	position := n;
	 	 		 		];
	 	 		 	];
	 	 		 	returnString ++ aString[position..|aString|]
	 	 		]
	 	]
 	
]:string;


Print: "sticky in the bicky\n";
Print: remove all ¢"i" in "sticky in the bicky"; Print : "\n";
Print: replace all ¢"i" with ¢"a" in "sticky in the bicky"; Print : "\n";
Print: replace all "ick" with "ar" in "sticky in the bicky"; Print : "\n";
Print: replace all "ick" with "" in "sticky in the bicky"; Print : "\n";
Print: replace all "" with "ar" in "sticky in the bicky"; Print : "\n";
Print: "\n";
/* create stream from the string, dividing the stream by each method*/ 
q ::= stream over z delimited by "/**\n";

/* Walk through the strings an remove key useless characters */
methodTexts : <string…|> := <>;

For each q do 
[
	s : string
 |
 	asterisk : boolean := false;
 	str : string := concatenate map s through 
	[
		c : character
	|
		if c = ¢"\t" /*∨ [c = ¢"\n"]*/
			then [
				asterisk := false;
				""
			] else if [c = ¢"*"] 
			then [
				asterisk := true;
				""
			]
			else [
				if asterisk = true then [
					if c = ¢"/" then [ 
						asterisk := false;
						""
					] else [
						asterisk := false;
						<c>
					]
				] else [
					<c>
				]
			]
 	];
 	If ¬str is empty then [
 		methodTexts := methodTexts ++ <str>;
 	];
];

/* Parse each method stream into key parts:
 * 1) description
 * 2) parameters grouping
 * 3) return description
 * 4) method body
 * 5) return type
 */
parsed1MethodTexts : <<string…|>…|> := <>;

For each methodTexts do 
[
 	str : string
 |
 	temp : <string…|> := <>;
 	parts ::= stream over str delimited by any of 
 	<"Parameters:", "Returns:", "Method \"","Public method \"",
 	 "\" is", "]:", "] : ">;
 	 For each parts do
 	[ value : string | temp := temp ++ <value>;];
	parsed1MethodTexts := parsed1MethodTexts ++ <temp>;
];

/* Divide out each section into its separate parts.  Partition the parameters
 * description and variable names.  
 */
For each parsed1MethodTexts do
[
 	tupleOfStrings : <string…|>
 | 
 	topDescription ::= tupleOfStrings[1];
 	returnDescription ::= tupleOfStrings[3];
 	methodName ::= tupleOfStrings[4];
 	returnType ::= tupleOfStrings[6];
 	
 	/* Break up parameter descriptions */
 	parmetersDescriptions : <string…|> := <>;
 	
 	params1 ::= stream over tupleOfStrings[2] delimited by "@param";
 	param1Tuple : <<string…|2>…|> := <>;
 	
 	For each params1 do
 	[
 	 	value : string
 	 |
 	 	tempTup : <string…|> := <>;
 	 	For each stream over value delimited by ": " do
 	 	[
 	 	 	sub : string
 	 	 |
 	 	 	tempTup := tempTup ++ <sub>;
 	 	];

 	 	If |tempTup| = 2 then 
 	 	[
 	 	 	param1Tuple := param1Tuple ++ <<tempTup[1],tempTup[2]>>;
 	 	];
 	];
 	
 	Print: "Method Name: " ++ methodName ++ "\n";
 	Print: "Main Description: " ++ topDescription ++ "\n";

 	For each param1Tuple do
 	[
 	 	tup : <string…|2>
 	 |
 		Print: "Input name: " ++ tup[1] ++ "\n";
 		Print: "Input description: " ++ tup[2] ++ "\n";
 	];
 	Print: "Return Type: " ++ returnType ++ "\n";
 	Print: "Return Description: " ++ returnDescription ++ "\n";
 	Print: "\n";
 	Print: format "tupleOfStrings[5]=‘①’\n" with tupleOfStrings[5];
 	
 	/*TODO: [RAA]  
 	 * Parse the parameter types from tupleOfStrings[5]
 	 */
];

