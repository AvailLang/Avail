/*
 * Annals Stream Parser.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
	
keyCharacters ::= {¢/, ¢@, ¢*, ¢"\n"}; /* Special parse characters */
/* Special keywords using @ symbols */
keyWords ::= 
	{@type,@supertype,@field,@category,@param,@raises,@restricts,@returns,
	 @forbids,@category,@pubilc,@method,@see,@author,@link,@code};
openCommentCount : whole number := 0;
newLineCount : whole number := 0;
buffer : <character…|> := <>;
inAnnalsType : boolean := false; 
annalsType : string := "";
annalsObjectName: string :"";

/* TODO - create global variables for maps of classes and methods */

/**
 *
 * @method "_is a key character"
 * @categories ""
 * @param
 * @returnType
 * @raises
 */
Private method "_is a key character" is
[
 	char : character;
 |
 	element ∈ keyCharacters
]:boolean;

/**
 *
 * @method "Increment the open comment count"
 * @categories ""
 * @param
 * @returnType
 * @raises
 */
Private method "Increment the open comment count" is
[
 |
 	openCommentCount := openCommentCount + 1;
]:⊤;

/**
 *
 * @method "Decrement the open comment count"
 * @categories ""
 * @param
 * @returnType
 * @raises
 */
Private method "Decrement the open comment count" is
[
|
	openCommentCount := openCommentCount - 1;
]:⊤;

/**
 *
 * @method "Increment the new line count"
 * @categories ""
 * @param
 * @returnType
 * @raises
 */
Private method "Increment the new line count" is
[
|
	newLineCount := newLineCount + 1;
]:⊤;

/**
 *
 * @method "Clear the buffer"
 * @categories ""
 * @param
 * @returnType
 * @raises
 */
Private method "Clear the buffer" is
[
 |
	buffer := <>;:= <>;
]:⊤;

/**
 *
 * @method ""
 * @categories ""
 * @param
 * @returnType
 * @raises
 */
Private method "Buffer_" is
[
	iter : iterator
 |
	buffer := buffer ++ <iter's current value>;
	Advance theIterator;
]:⊤;

/**
 *
 * @method "_is not exhausted"
 * @categories ""
 * @param
 * @returnType
 * @raises
 */
Private method "_is not exhausted" is
[
 	iter : iterator
 |
 	iter is exhausted
]:boolean;


Private methods "Generate the key word from_" is
[
	iter : iterator
 |
 	tempKeyBuffer : <character…|> := <>;
	While 
	[
	 	iter is not exhausted ∨ 
	 		theIterator's current value ∉ {¢" ",¢"\n"}
	]
	do
	[
	 	tempKeyBuffer := tempKeyBuffer ++ <iter's current value>;
	 	Buffer iter;
	];
	tempKeyBuffer
]:<character…|>; 

/**
 * Determine what is to be done when "/" is reached in the iterator.
 * @method "Handle forward slash key word buffer_"
 * @categories ""
 * @param
 * @returnType
 * @raises
 */
Method "Handle forward slash key word buffer using_"
[
	keyBuffer : <character…|>
 |
	Choose keyBuffer from enumeration of {"/*", "/**"} where
	"/*" is
	[
	 	/* Just a new comment, increment count only */
	 	Increment the open comment count;
	],
	"/**" is
	[
	 	if openCommentCount > 0 then
	 	[
	 	 	/* Start of a nested comment */
	 	 	Increment the open comment count;
	 	]
	 	else
	 	[
	 	 	/* Start of annals object comment, clear buffer */
	  		increment the open comment count;
	 		Clear the buffer;
		 	 	/*Do something cool, like start an Annals object*/
	 	]
	],
	else [/* Do nothing */];
]:⊤;

/**
 * Determine what is to be done when "@" is reached in the iterator.
 * @method "Handle the @ key word buffer_"
 * @categories ""
 * @param
 * @returnType
 * @raises
 */
Method "Handle the @ key word buffer using_"
[
	keyBuffer : <character…|>
 |
	/* TODO - RAA - Handle @ tags */
	Choose keyBuffer from enumeration of keyWords where
	"@type" is
	[],
	"@supertype" is
	[],
	"@field" is
	[],
	"@category" is
	[],
	"@param" is
	[],
	"@raises" is
	[],
	"@restricts" is
	[],
	"@returns" is
	[],
	"@forbids" is
	[],
	"@category" is
	[],
	"@pubilc" is
	[],
	"@method" is
	[],
	"@see" is
	[],
	"@author" is
	[],
	"@link" is
	[],
	"@code" is
	[],
	else [/* do nothing */];
]:⊤;

/**
 * Determine what is to be done when "*" is reached in the iterator.
 * @method "Handle the asterisk key word buffer_"
 * @categories ""
 * @param
 * @returnType
 * @raises
 */
Private method "Handle the asterisk key word buffer using_" is
[
	keyBuffer : <character…|>
|
	Choose keyBuffer from enumeration of {"/*", "/**"} where
	"*/" is
	[
	 	if openCommentCount = 0 then
	 	[ /* ERROR!  Do something error-like*/]
	 	else if [openCommentCount > 1] then
	 	[
	 	 	/* Close of a nested comment */
	 	 	Decrement the open comment count;
	 	]
	 	else
	 	[
	 	 	/* Closing of a non-nested comment */
	 	 	Decrement the open comment count;
	 		if inAnnalsType then
	 		[
	 		 	/* Wrap up annals object creation */
	 		]
	 		else
	 		[
	 		 	/* Not an annals object comment, clear buffer */
	 		 	Clear the buffer;
	 		]
	 	];
	],
	else [/* Do nothing */];
]:⊤;

/**
 * Avail document main parsing method
 * @method "Parse the Avail document_"
 * @categories ""
 * @param
 * @returnType
 * @raises
 */
Public method "Parse the Avail document_" is
[
 	availSourceDoc : string
 |
 	theIterator : iterator := an iterator over availSourceDoc;
	
	While [ theIterator is not exhausted ] 
	do
	[
	 	If theIterator's current value is a key character then
	 	[		 	 	
 	 	 	Choose theIterator's current value 
 	 	 		from enumeration of keyCharacters where
 	 	 	¢"\n" is 
 	 	 	[
 	 	 	 	Increment the new line count;
 	 	 	 	Advance theIterator;
 	 	 	 ],
 	 	 	¢/ is
 	 	 	[
 	 	 	 	tempKeyBuffer : <character…|> := 
 	 	 	 		Generate the key word from theIterator;
				Handle the forward slash key word buffer using tempKeyBuffer;
			], 
 	 	 	¢@
 	 	 	[ 
 	 	 	 	if inAnnalsType then
 	 	 	 	[
 	 	 	 	 	tempKeyBuffer : <character…|> := 
 	 	 	 	 		Generate the key word from theIterator;
 	 	 	 		Handle the @ key word buffer using tempKeyBuffer;
				]
				else 
				[
					/* Not an annals object comment, clear buffer */
				 	Clear the buffer;
				];
 	 	 	], 
 	 	 	¢*
 	 	 	[ 
 	 	 	 	tempKeyBuffer : <character…|> := 
 	 	 	 		Generate the key word from theIterator;
				Handle the asterisk key word buffer using tempKeyBuffer;
			];
	 	 ]
	 	else
	 	[
	 	 	Buffer theIterator;
	 	];	
	];
]:⊤;