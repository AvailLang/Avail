/*
 * Stacks Stream Parser.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Stacks Lexer"
Versions
	"Dev"
Extends

Uses
	"Avail"

Names
	"@author",
	"@category",
	"@code",
	"@field",
	"@forbids",
	"@global",
	"@link",
	"@method",
	"@param",
	"@public",
	"@raises",
	"@restricts",
	"@returns",
	"@see",
	"@supertype",
	"@type",
	"stacks token"

Body

lexeme ::= $lexeme;		/*string representation of token*/
line ::= $line;			/*line in which token appears*/
position ::= $position; /*column position token begins*/

/**
 * A class that defines a token for the stacks lexor.  
 * 
 * @type "@public"
 * @supertype {@type "element" element}
 * @category Stacks
 * @field "lexeme" "string"
 * 	string representation of token
 * @field "line" "natural number"
 * 	line number on which token appears 
 * @field "position" "natural number"
 * 	column position where token begins
 * @author Richard Arriaga
 */
Public explicit class "stacks token" extends object
	with fields
		lexeme : string,
		line : natural number,
		position : natural number;

/**
 * A method that constructs a subtype of stacks token class.
 *
 * @method "_ is a stacks token"
 * @categories "Stacks"
 * @param "name" "string" 
 *		name of new token type
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "_is a stacks token" is
[
 	name : <character…|1..>
 |
 	 Class name extends stacks token
 		with fields
 			lexeme : name's type;
 ]:⊤;

/* All keywords that will ultimately be special stacks tokens */

stacksTokenTypeNames::= <"@type","@supertype","@field","@category","@param",
	"@raises","@restricts","@returns","@forbids","@public","@method","@see",
	"@author","@link","@code","@global">;
	
For each stacksTokenTypeNames do
[
	tokenName : <character…|1..>
 |
 	tokenName is a stacks token;
];

/**
 * A method that creates a single stacks token object
 *
 * @method "token_"
 * @categories "Stacks"
 * @param "tokenComponents" "<string,natural number…|3>" 
 *		a tuple <token lexeme,token line number,token column position>
 * @returnType "stacks token"
 *		a stacks token of the input string
 * @author "Richard Arriaga"
 */
Private method "token_" is
[
 	tokenComponents : <string,natural number…|3>
 |
 	 a stacks token with
		lexeme := tokenComponents[1],
		line := tokenComponents[2],
		position := tokenComponents[3]
 ]:stacks token;

/**
 * Tokenize all elements of a string.
 *
 * @method "tokenize_"
 * @categories "Stacks"
 * @param "comment" "string" 
 *		a qualifying stacks comment
 * @returnType "<stacks token…|>"
 *		a tuple of stacks tokens.  Excludes astericks.
 * @author "Richard Arriaga"
 */
Private method "tokenize_" is
[
 	comment : string
 |
 	lineCount : natural number := 1;
 	openComment : whole number := 0;
	openQuote : whole number := 0;
	stacksTokens : <stacks token…|> := <>;
	
	/* delimiting characters for tokenization */
	keyCharacters ::= {¢@,¢" ",¢"\"",¢{,¢},¢`,¢/,¢*,¢"\t"};
 
	doNotTokenize ::= {"/*","/**","*/"," ","","\t"};
	
	newLinePositions ::= all indices of comment where 
		[c : character | c = ¢"\n"];

	priorNewLine : natural number := 1;
	bufferMap : {natural number→string|} := {};
	
	/* Break up comment by new lines.  Map key is line count, value is line *
	 * less the new line character at the end of the line                   */
	For each newLinePositions do
	[
	 	i : natural number
	 |
	 	if priorNewLine = 1 then
	 	[
	 	 	bufferMap := bufferMap + lineCount→comment[priorNewLine..i-1];
	 	] else
	 	[
	 	 	bufferMap := bufferMap + lineCount→comment[priorNewLine + 1..i-1];
	 	];
	 
	 	priorNewLine := i;
		↑lineCount++;
	];
	/* Tokenize comment lines */
	For each bufferMap do
	[
	 	lineNumber : natural number,
	 	commentLine : string
	 |
	 	columnPosition : natural number := 1;
		charCounter : whole number := 0;
/*Print: format "\n\nStart Newline=“①”\n" with lineNumber;*/
		/* Is the new line a continuation of a nested comment, if so consume *
		 * without tokenizing the contents                                   */
		If openComment > 1 then
		[
		 	While
		 	[
		 	 	openComment > 1 ∨ [charCounter < |commentLine|]
		 	]
		 	do
		 	[
Print: "In nested comment\n";
/*Print: format "commentLine[charCounter]=“①”\n" with commentLine[charCounter];*/
		 	 	/* Consume nested comment without tokenizing but moving *
		 	 	 * column pointer										*/
		 	 	wordStart : natural number := charCounter + 1;
				word : <character…|> := take from commentLine[charCounter+1..] 
				until 
				[
				 	c : character 
				 |
Print: "here1\n";
Print: <c>;
Print: format "\nc=“①”\n" with c;
				 	↑charCounter++;
				 	c ∈ {¢/,¢*}  ∨ [charCounter = |commentLine|]
				];
		 	 	
		 	 	j : natural number := cast charCounter into 
					[n : natural number | n];
Print: "here2\n";
		 	 	
Print: format "lineNumber=“①”\n" with lineNumber;
Print: "word="; Print: word; Print: "\n";
Print: format "charCounter=“①”\n" with charCounter;
Print: format "j=“①”\n" with j;
Print: format "|commentLine|=“①”\n" with |commentLine|;
Print: format "commentLine[j]=“①”\n" with commentLine[j];
		 	 	If charCounter < |commentLine| +1 ∨ [commentLine[j] ∈ {¢/,¢*}] then  
				[
					Cast commentLine[j] into
					[
					 	c : enumeration of {¢/,¢*}
					 |
Print: "here3\n";
						Choose c from enumeration of {¢/,¢*}
						where
						¢* is
						[
Print: "here4\n";
						 	If commentLine[j+1] = ¢/ then
						 	[
Print: "here5\n";
						 	 	/*Close nested comment*/
						 	 	↑openComment--;
						 	 	↑charCounter++;
						 	];
						],
						¢/ is
						[
Print: "here6\n";
							/*If commentLine[j+1] = ¢* then
							[
Print: "here7\n";
							 	/*Open new nested comment*/
								↑openComment++;
								↑charCounter++;
							];*/
						];
					];
				];
		 	 	
		 	];
		];
		While
		[
		 	charCounter < |commentLine|
		]
		do
		[
		 	wordStart : natural number := charCounter + 1;
			word : <character…|> := take from commentLine[charCounter+1..] until 
			[
			 	c : character 
			 |
			 	↑charCounter++;
			 	c ∈ keyCharacters  ∨ [charCounter = |commentLine|+1]
			];

			j : natural number := cast charCounter into 
				[n : natural number | n];

			if charCounter < |commentLine| then
			[
				Cast commentLine[j] into
				[
				 	c : enumeration of {¢@,¢" ",¢"\"",¢{,¢},¢`,¢/,¢*,¢"\t"}
				 |
Print: "\n";
					Choose c from enumeration of keyCharacters
					where
					¢"\t" is
					[
					 	If word ∉ doNotTokenize then 
					 	[
					 	 	stacksTokens := stacksTokens ++ 
					 	 		<token <word,lineNumber,wordStart>>;
					 	];
					],
					¢@ is
					[
Print: " In @\n";
Print: "  previous word="; Print: word; Print: "~\n";
					 	If word ∉ doNotTokenize then 
					 	[
					 	 	stacksTokens := stacksTokens ++ 
					 	 		<token <word,lineNumber,wordStart>>;
					 	];
		 				wordStart := j;
		 				word := take from commentLine[j..] until 
		 				[
		 					ch : character 
		 				 |
		 				 	↑charCounter++;
		 					ch = ¢" " ∨ [charCounter = |commentLine|]
		 				];
			 			stacksTokens := stacksTokens ++ 
			 				<token <word,lineNumber,wordStart>>;
					 	/* Counter will be re-incremented above.*/
					 	↑charCounter--;
					],
					¢" " is
					[
Print: " In space\n";
Print: "  word="; Print: word; Print: "~\n"; 
					 	If word ∉ doNotTokenize then 
					 	[
					 	 	stacksTokens := stacksTokens ++ 
					 	 		<token <word,lineNumber,wordStart>>;
					 	];
					],
					¢"\"" is
					[
Print: " In Quote\n";
Print: "  previous word="; Print: word; Print: "~\n";
					 	If word ∉ doNotTokenize then 
					 	[
					 	 	stacksTokens := stacksTokens ++ 
					 	 		<token <word,lineNumber,wordStart>>;
					 	];
			 			wordStart := j;
		 				word := take from commentLine[j+1..] until 
		 				[
		 					ch : character 
		 				 |
		 				 	Print: <ch>;
		 					↑charCounter++;
		 					ch = ¢"\"" ∨ [charCounter = |commentLine|]
		 				];
					 	if charCounter < |commentLine| + 1 then
					 	[
					 		word := <¢"\""> ++ word ++ <¢"\"">;
					 		stacksTokens := stacksTokens ++ 
					 			<token <word,lineNumber,wordStart>>;
					 	] else
					 	[
					 	 	/* TODO some sort of Error handling of missing close quote*/
					 	];
Print: "  quote word="; Print: word; Print: "~\n";
					],
					¢{ is
					[
Print: " In {\n";
Print: "  word="; Print: word; Print: "~\n";
					 	If word ∉ doNotTokenize then 
					 	[
					 	 	stacksTokens := stacksTokens ++ 
					 	 		<token <word,lineNumber,wordStart>>;
					 	];
						stacksTokens := stacksTokens ++ 
							<token <"{",lineNumber,j>>;
					],
					¢} is
					[
Print: " In }\n";
Print: "  word="; Print: word; Print: "~\n";
					 	If word ∈ doNotTokenize then 
					 	[
					 	 	stacksTokens := stacksTokens ++ 
					 	 		<token <word,lineNumber,wordStart>>;
					 	];
			 			stacksTokens := stacksTokens ++ 
			 				<token <"}",lineNumber,j>>;
					],
					¢` is
					[
Print: " In `\n";
Print: "  word="; Print: word; Print: "~\n";
					 /* Check for following escaped special characters */
					 	if charCounter < |commentLine| then
					 	[
						  	if commentLine[j+1] ∈ {¢@,¢"\"",¢`,¢*} then
						  	[
						  	 	word := word ++ commentLine[j..j+1];
						  		↑charCounter++;
						  		If charCounter ≠ |commentLine| then
						  		[
							  		word := word ++ 
							  			take from commentLine[j+2..] until 
					 				[
					 					ch : character 
					 				 |
					 					↑charCounter++;
					 					ch ∈ keyCharacters  ∨ 
					 						[charCounter = |commentLine|]
					 				];
								 	If word ∉ doNotTokenize then 
								 	[
								 	 	stacksTokens := stacksTokens ++ 
								 	 		<token <word,lineNumber,wordStart>>;
								 	];
								];
						  	]
						  	else 
						  	[
						  	 	word := word ++ <commentLine[j]>;
						  		↑charCounter++;
						  		word := word ++ take from commentLine[j+1..] until 
				 				[
				 					ch : character 
				 				 |
				 					↑charCounter++;
				 					ch ∈ keyCharacters ∨ 
			 							[charCounter = |commentLine|]
				 				];
							 	If word ∉ doNotTokenize then 
							 	[
							 	 	stacksTokens := stacksTokens ++ 
							 	 		<token <word,lineNumber,wordStart>>;
							 	];
						  	];
						] else
						[
						 	word := word ++ <commentLine[j]>;
						 	If word ∉ doNotTokenize then 
						 	[
						 	 	stacksTokens := stacksTokens ++ 
						 	 		<token <word,lineNumber,wordStart>>;
						 	];
						];
					],
					¢/ is
					[
Print: " In forward slash\n";
Print: "  word="; Print: word; Print: "~\n";
					 	/*Check to see if open nested comment*/
					 	If commentLine[j+1] = ¢* then
				 		[Print: "In 1\n";
		 		 	 		↑charCounter++;
				 		 	if openComment = 0 ∧ [|commentLine| ≤ j + 2] then
				 		 	[Print: "In 2\n";
				 		 	 	/*Open new comment*/
				 		 	 	↑openComment++;
				 		 	 	If commentLine[j+2] = ¢* then
				 		 	 	[Print: "In 3\n";
				 		 	 	 	/* Start of main comment*/
				 		 	 	 	↑charCounter++;
				 		 	 	];
				 		 	] else
				 		 	[Print: "In 4\n";
				 		 	 	/*Open new nested comment*/
				 		 	 	↑openComment++;
				 		 	 	↑charCounter++;
				 		 	];
						]; /*else
						[Print: "In 5\n"; Print: format "commentLine[j]=“①”\n" with commentLine[j];
					  	 	word := word ++ <commentLine[j]>;
					  		↑charCounter++;
					  		word := word ++ take from commentLine[j+1..] until 
			 				[
			 					ch : character 
			 				 |
			 					↑charCounter++;
			 					ch ∈ keyCharacters ∨ 
		 							[charCounter = |commentLine|]
			 				];
						];*/
					 	If word ∉ doNotTokenize then 
					 	[
					 	 	stacksTokens := stacksTokens ++ 
					 	 		<token <word,lineNumber,wordStart>>;
					 	];
					],
					¢* is
					[
Print: " In *\n";
Print: "  word="; Print: word; Print: "~\n";
					 /*Do nothing special here.  If closing comment, it will *
					  * end the buffer.  If not, `* will not be converted 	 *
					  * into a token.  Tokenize prior word if applicable.	 */
					 	If word ∉ doNotTokenize then 
					 	[
					 	 	stacksTokens := stacksTokens ++ 
					 	 		<token <word,lineNumber,wordStart>>;
					 	];
					 ];
				];
			] else
			[
			 	If word ∉ doNotTokenize then 
			 	[
			 	 	stacksTokens := stacksTokens ++ 
			 	 		<token <word,lineNumber,wordStart>>;
			 	];
Print: " \nIn last word\n";
Print: "  word="; Print: word; Print: "~\n";
Print: format "\nEnd of Line=“①”\n" with lineNumber;
			];
		];
	];
	stacksTokens
]:<stacks token…|>;

keyCharacters ::= {¢@,¢" ",¢"\"",¢{,¢},¢`,¢/,¢*};
charCounter : whole number := 0;
t ::="/**
 * Tokenize all elements of a string.
*
* @method \"tokenize_\"
* @categories \"Stacks\"
* @param \"comment\" \"string\" 
*		a qualifying stacks comment
* @returnType \"<stacks token…|>\"
*		a tuple of stacks tokens.  /* Frog */ Excludes `*.
* @author \"Richard Arriaga\"
*/";

z ::= tokenize t;

Print: format "z=“①”\n" with z;

