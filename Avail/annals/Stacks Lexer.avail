/*
 * Stacks Stream Parser.avail
 * Copyright © 1993-2013, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Stacks Lexer"
Versions
	"Dev"
Extends

Uses
	"Avail",
	"Avail Scanner",
	"Patricia Trie",
	"Stacks Scanner"

Names
	"Obtain Stacks comments from_"

Body
"Avail file" is a new field atom;
"error occurs after line number" is a new field atom;

/* Special characters that could result in token delimiter */
tokenDelimiter ::= {¢@,¢" ",¢"\t",¢"\"",¢"\n",¢{,¢/,¢*,¢\};

Private forward method "_is at new comment" is [stacks scanner]→boolean;

/**
 * Determine if a scanner comment is at the start of a new stacks comment.
 *
 * @method "_is at new comment"
 * @categories "stacks"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returns "boolean"
 *      whether or not at start of a new comment.
 * @author "Richard Arriaga"
 */
Private method "_is at new comment" is
[
	scanner : stacks scanner
 |
	Next character from scanner;
	if scanner's source is not exhausted then
	[
		if scanner's source's current element = ¢/ then
		[
			scanner is at new comment
		]
		else
		[
			if scanner's previous element = ¢/ then
			[
				buffer ::= read from scanner while [scanner's current element = ¢*];
				if |buffer| = 0 then [false]
				else if [|buffer| = 1] then [true]
				else
				[
					Toggle scanner's special comment;
					/*Don't want to start comment buffer with newline*/
					If scanner's current element = ¢"\n" then
						[Next character from scanner;];
					true
				]
			]
			else 
			[
				If scanner's current element = ¢"\"" then
				[
					Next character from scanner;
					throwAway : string := read from scanner while 
						[
							scanner's current element ≠ ¢"\"" ∨
								[scanner's previous element = ¢\ ∧
								 		[scanner's current element = ¢"\""]]
						];
				];
				false
			]
		]
	] else [false]
] : boolean;

Private forward method "_is at nested comment" is [stacks scanner]→boolean;

/***
 * Determine if a scanner comment buffer is at the start of a nested comment.
 *
 * @method "_is at nested comment"
 * @categories "stacks"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returns "boolean"
 *      whether or not at start of a nested.
 * @author "Richard Arriaga"
 */
Private method "_is at nested comment" is
[
	scanner : stacks scanner
 |
	if scanner's current buffer character = ¢/ then
	[
		Increment scanner's comment buffer index;
		scanner is at nested comment
	]
	else
	[
		if scanner's previous buffer character = ¢/ then
		[
			buffer : <character…|> := read from scanner's comment buffer while 
				[scanner's current buffer character = ¢*];
			if |buffer| = 0 then 
			[
				scanner's character buffer := scanner's character buffer ++ 
					buffer;
				false
			]
			else 
			[
				Increment scanner's open comment count;
				Buffer scanner's current token;
				true
			]
		] else [false]
	]
] : boolean;

/**
 * Consume the scanners nested comment without tokenizing any elements
 *
 * @method "Consume_'s⁇nested comment"
 * @categories "stacks"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returns "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Private method "Consume_'s⁇nested comment" is
[
	scanner : stacks scanner
 |
	While 
	[
		scanner's comment buffer is not exhausted ∧ 
			[scanner's open comment count > 0] 
	] 
	do
	[
		throwAway ::= read from scanner's comment buffer while
			[scanner's current buffer character ∉ {¢/,¢*}];
		Increment scanner's comment buffer index;
		If scanner's previous buffer character = ¢/ then
		[
			If scanner's comment buffer is not exhausted ∧ 
				[scanner's current buffer character = ¢*] then
			[
				Increment scanner's open comment count;
			];
		]
		else
		[
			/* previous element is * */
			If scanner's comment buffer is not exhausted ∧ 
				[scanner's current buffer character = ¢/] then
			[
				Decrement scanner's open comment count;
				Increment scanner's comment buffer index;
			];
		];
	];
]:⊤;

/**
 * Handle the escape character, back slash, in a stacks scanner by ignoring
 * the next immediate character and treating it as a generic character.
 *
 * @method "Process back slash from_"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returns "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Private method "Process back slash from_" is
[
	scanner : stacks scanner
 |
	Increment scanner's comment buffer index;
	If scanner's current buffer character ≠ ¢"\n" then
	[
		Unless scanner's comment buffer is exhausted then 
		[
			scanner's character buffer := scanner's character buffer ++ 
				<scanner's current buffer character>;
			Increment scanner's comment buffer index;
		]
		else
		[/*TODO Add issue to warning file.  Concluding comment with escape char*/];
	]
	else [/*TODO Add waring that attempting to escape newline not allowed and is ignored*/];
]:⊤;

/**
 * Handle a forward slash in a stacks scanner.
 *
 * @method "Process forward slash from_"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returns "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Private method "Process forward slash from_" is
[
	scanner : stacks scanner
 |
	If scanner is at nested comment then
	[
		Consume scanner's nested comment;
	];
]:⊤;

/**
 * Function that handles case where \...|\ is not used.  As an input accepts 
 * the index location of the newline being processed. Returns the string with 
 * that newline character as well as the next line's starting asterisk and 
 * white space fileterd out
 *
 * @method "process raw new line from_at_"
 * @categories "Stacks"
 * @param "phrase" "string"
 *  	special region to remove new lines from
 * @param "index" "natural number" 
 *      tuple of new line location
 * @returns "string"
 *      string with new line removed
 * @author "Richard Arriaga"
 */
Private method "process raw new line from_at_" is
[
	phrase : string,
	index : natural number
 |
	filtered : string := phrase;
	firstAsterisk : natural number := 
		first index of "*" in filtered[index+1..] + index;
	start : natural number := first index of 
		filtered[firstAsterisk + 1..] where
		[
			c : character
		 |
			¬c is whitespace
		] + firstAsterisk;
	if start = firstAsterisk then
	[
		if index = 1 then [""]
		else 
		[
			end : natural number := cast index-1 into 
				[k : natural number | k]; 
			filtered[..end]
		]
	]
	else
	[
		if index = 1 then 
		[
			filtered[start..]
		]
		else 
		[
			end : natural number := cast index-1 into 
				[k : natural number | k]; 
			if filtered[end] ≠ ¢" " then 
			[filtered[..end] ++ " " ++ filtered[start..]]
			else [filtered[..end] ++ filtered[start..]]
		]
	]
]:string;

/**
 * Remove the new lines from a special region string given a tuple of indices
 * of the new line locations.
 *
 * @method "remove new lines from_at_"
 * @categories "stacks"
 * @param "phrase" "string" 
 *  	special region to remove new lines from
 * @param "indices" "<natural number…|1..>"
 * 		indices of a new line characters
 * @returns "string"
 *      string with new lines removed
 * @raises "exceptionName" 
 *      exceptionDescription
 * @author "Richard Arriaga"
 */
Private method "remove new lines from_at_" is
[
	phrase : string,
	indices : <natural number…|1..>
 |
	size : natural number := |indices|;
	filtered : string := phrase;
	From size to 1 by -1 do
	[
		n : natural number
	 |
		filtered := if indices[n] > 1 then
		[
			i : natural number := cast indices[n]-1 into 
				[k : natural number | k];
		 	if filtered[i] = ¢\ then
			[
				startHalf2 : natural number := 
					first index of "\\|" in filtered[i+1..] + i + 2;
				if startHalf2 = 2 then
				[
					/*TODO Insert error handling.  Missing \| */
					filtered
				]
				else
				[
					if i = 1 then 
					[
						/*TODO Insert warning, string starts
						 * with new line unncessarily.*/
						filtered [startHalf2..]
					]
					else if [startHalf2 -1 = |filtered|] then 
					[
						/*TODO Insert warning, string concludes
						 * with |\ making new line unncessary.*/
						end : natural number := cast i-1 into 
							[k : natural number | k]; 
						filtered[..end]
					]
					else
					[
						end : natural number := cast i-1 into 
							[k : natural number | k];
						if filtered[end] ≠ ¢" " then 
						[filtered[..end] ++ " " ++ filtered[startHalf2..]]
						else [filtered[..end] ++ filtered[startHalf2..]]
					]
				]
			]
			else 
			[
				/*Did not use \ ... \| in this new line*/
				process raw new line from filtered at indices[n]
			]
		]
		else
		[
		 	process raw new line from filtered at indices[n]
		];
	];
	filtered
]:string;

/**
 * Remove from the quoted region all the escaped characters that indicates the 
 * subsequent quotes is escaped
 *
 * @method "remove escaped character for quotes from_"
 * @categories "Stacks"
 * @param "phrase" "string" 
 *      the string to remove escaped
 * @returns "string"
 *      the string with escape characters removed
 * @author "Richard Arriaga"
 */
Private method "remove escaped character for quotes from_" is
[
	phrase : string
 |
 	word : string := phrase;
	quoteIndices ::= all indices of word where [c : character | c = ¢"\""];
	/* Iteratate through quote indices removing the char before the quote */
	If |quoteIndices| > 0 then
	[
		size : natural number := cast |quoteIndices| into 
			[i : natural number | i]; 
		From size to 1 by -1 do
		[
			n : natural number
		 |
			z ::= split word after quoteIndices[n];
			i ::= |z[1]| - 1; 
			word := z[1][1..i] ++ z[2];
		];
	];
	phrase
]:string;


/**
 * Tokenize all characters in double quotes including white space as one token.
 *
 * @method "Process double quote in comment from_"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a stacks scanner
 * @returns "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "Process double quote in comment from_" is
[
	scanner : stacks scanner
 |
	scanner's token start := scanner's column number;
	Toggle scanner's special region flag;
	Increment scanner's comment buffer index;
	columnNumber : natural number;
	/*columnStart := scanner's column number;*/

	/*Obtain quoted region*/
	region : string := read from scanner's comment buffer  
		while
		[
			scanner's current buffer character ≠ ¢"\"" ∨ 
			[scanner's previous buffer character = ¢\ ∧
			 		[scanner's current buffer character = ¢"\""]]
		];

	/* Find all new line instances in word and remove them*/
	newlineIndices : <natural number…|> := all indices of region where 
		[c : character | c = ¢"\n"];
	region := if |newlineIndices| > 0 then 
		[
		 	indices : <natural number…|1..> := cast newlineIndices into 
		 		[t : <natural number…|1..> | t];
			columnNumber := |region[indices' last + 1..]| + 1;
			remove new lines from region at indices
		] else
		[
			columnNumber := scanner's column number;
			region
		];

	/* Find all instances of escaped quotes in word and remove the escape 
	 * character prior to the quote.  */
	scanner's character buffer := 
		remove escaped character for quotes from region;
	
	/*Tokenize quoted string*/
	Buffer scanner's current quoted token;
	scanner's line number := scanner's line number + |newlineIndices|;
	scanner's column number := columnNumber;
	Increment scanner's comment buffer index;
	Toggle scanner's special region flag;
 ]:⊤;

/**
 * Tokenize all characters in buffer up to white space.
 *
 * @method "Process white space in comment from_"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a stacks scanner
 * @returns "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "Process white space in comment from_" is
[
	scanner : stacks scanner
|
		Buffer scanner's current token;
		Increment scanner's comment buffer index;
]:⊤;

Private forward method "Process newline in comment from_" is [stacks scanner]→⊤;

/**
 * Tokenize all characters in buffer up to newline.
 *
 * @method "Process white space in comment from_"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a stacks scanner
 * @returns "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "Process newline in comment from_" is
[
	scanner : stacks scanner
|
	Buffer scanner's current token;
	Toggle scanner's new line;
 	scanner's column number := 1;
	asterickCount : whole number := 0;
	While
	[
		scanner's comment buffer is not exhausted ∧
			[asterickCount < 1  ∨ 
			[scanner's current buffer character is whitespace]]
	]
	do
	[
		If scanner's current buffer character = ¢* then 
		[
			↑asterickCount++;
		];
		If scanner's current buffer character = ¢"\n" then 
		[
			asterickCount := 0;
		];
		Increment scanner's comment buffer index;
	];
	Toggle scanner's new line;

]:⊤;

/**
 * Tokenize all characters in buffer up to at symbol then tokenize word that 
 * starts with at symbol 
 *
 * @method "Process at sign in comment from_"
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *	a stacks scanner
 * @returns "⊤"
 *      none
 * @author "authorName"
 */
Private method "Process at sign in comment from_" is
[
	scanner : stacks scanner
 |
	Buffer scanner's current token;
	Increment scanner's comment buffer index;
	word ::= <scanner's previous buffer character> ++ 
		read from scanner's comment buffer while
			[ scanner's current buffer character ∉ tokenDelimiter];
	scanner's character buffer := word;
	Buffer scanner's current token;
]:⊤;

/**
 * Tokenize characters in character buffer with asterisk if appropriate
 *
 * @method "Process asterick in comment from_;"
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *	a stacks scanner
 * @returns "⊤"
 *      none
 * @author "authorName"
 */
Private method "Process asterick in comment from_" is
[
	scanner : stacks scanner
 |
	If scanner's new line then
	[
		Buffer scanner's current token;
		Increment scanner's comment buffer index;
	] else
	[
		Increment scanner's comment buffer index;
		throwAway ::= read from scanner's comment buffer while
			[scanner's comment buffer is not exhausted ∧
			 [scanner's current buffer character is whitespace ∧
				[scanner's current buffer character ≠ ¢"\n"]]];
		If scanner's current buffer character ≠ ¢"\n" then
		[
		 	scanner's character buffer := scanner's character buffer ++ "*";
		 	If scanner's previous buffer character is whitespace then
		 	[Buffer scanner's current token;];
		];
	];
]:⊤;

Private forward method "Process left curly brace in comment from_" is
	[stacks scanner]→⊤;

/* Construct the function dispatch table for functions that handle characters
 * in a comment.*/

inCommentDispatchTable : {character→[stacks scanner]→⊤|} := {};

For each tokenDelimiter do
[
	c : character
 |
	if c = ¢/ then
	[
	 	inCommentDispatchTable := inCommentDispatchTable + 
	 		c→ [
					scanner : stacks scanner
				 |
					Process forward slash from scanner; /*Done*/
				];
	]
	else if [c = ¢"\n"] then
	[
		inCommentDispatchTable := inCommentDispatchTable + 
			c→ [
					scanner : stacks scanner
				 |
					Process newline in comment from scanner; /*Done*/
				];
	]
	else if [c = ¢"\""] then
	[
	 	inCommentDispatchTable := inCommentDispatchTable + 
	 		c→ [
			 	 	scanner : stacks scanner
			 	 |
			 	 	Process double quote in comment from scanner; /*Done*/
			 	];
	]
	else if [c = ¢{] then
	[
	 	inCommentDispatchTable := inCommentDispatchTable  + 
	 		c→ [
			 	 	scanner : stacks scanner
			 	 |
			 	 	Process left curly brace in comment from scanner; /*Done*/
			 	];
	]
	else if [c is whitespace] then
	[
	 	inCommentDispatchTable := inCommentDispatchTable  + 
	 		c→ [
			 	 	scanner : stacks scanner
			 	 |
			 	 	Process white space in comment from scanner; /*Done*/
			 	];
	]
	else if [c = ¢@] then
	[
	 	inCommentDispatchTable := inCommentDispatchTable  + 
	 		c→ [
			 	 	scanner : stacks scanner
			 	 |
			 	 	Process at sign in comment from scanner; /*Done*/
			 	];
	]
	else if [c = ¢*] then
	[
	 	inCommentDispatchTable := inCommentDispatchTable + 
	 		c→ [
			 	 	scanner : stacks scanner
			 	 |
			 	 	Process asterick in comment from scanner; /*Done*/
			 	];
	]
	else if [c = ¢\] then
	[
	 	inCommentDispatchTable := inCommentDispatchTable + 
	 		c→ [
					scanner : stacks scanner
				 |
					Process back slash from scanner; /*Done*/
				];
	];
];

/**
 * Tokenize all characters in region in curly brace
 *
 * @method "Process left curly brace in comment from_;"
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *	a stacks scanner
 * @returns "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Private method "Process left curly brace in comment from_" is
[
	scanner : stacks scanner
 |
	/*Store current comment buffer index to be reset to if not start of special 
	 * bracketed region */
	startIndex : natural number := scanner's comment buffer index;
	startColumn : natural number := scanner's column number;
	Increment scanner's comment buffer index;
	throwAway ::= read from scanner's comment buffer while
		[ scanner's current buffer character is whitespace];
	If scanner's current buffer character = ¢@ then
	[
		Buffer scanner's current token;
		Toggle scanner's special region flag;
		Toggle scanner's tokenize;
		startIndex := scanner's comment buffer index;
		region ::= read from scanner's comment buffer while
			[scanner's current buffer character ≠ ¢}]; 
		endIndex : natural number := scanner's comment buffer index;
		newlineIndices : <natural number…|> := all indices of region where 
			[c : character | c = ¢"\n"];
		columnPosition : natural number := if |newlineIndices| > 0 then 
		[
			indices : <natural number…|1..> := cast newlineIndices into 
				[t : <natural number…|1..> | t];
			cast |region[indices' last + 1..]| into
				[n : natural number | n]
		] else [scanner's column number] + 1; 
		scanner's character buffer := <>;
		scanner's comment buffer index := startIndex;
		While
		[
			scanner's comment buffer index < endIndex
		]
		do
		[
			c ::= scanner's current buffer character;
			f ::= inCommentDispatchTable[c] else
				[
					[
						s : stacks scanner
					 |
						scanner's character buffer := 
							scanner's character buffer ++ <c>;
						Increment scanner's comment buffer index;
					]
				];
			f(scanner);
		];
		/*Reached index pointing at close of region, }.  Advance index beyond
		 * this point in order to not tokenize it*/
		Increment scanner's comment buffer index;
		Buffer scanner's current token;
		scanner's character buffer := 
			concatenate scanner's subtokens buffer separated by " ";
		Toggle scanner's tokenize;
		scanner's token start := startColumn;
		Buffer scanner's current bracketed token;
		Toggle scanner's special region flag;
		scanner's line number := scanner's line number + |newlineIndices|;
		scanner's column number := columnPosition;
	]
	else
	[
		scanner's comment buffer index := startIndex;
		scanner's column number := startColumn;
		scanner's character buffer := scanner's character buffer ++ 
			<scanner's current buffer character>;
		Increment scanner's comment buffer index;
	];
]:⊤;

/**
 * Tokenize all elements of the stacks scanner comment
 *
 * @method "Process the_'s⁇comment buffer"
 * @categories "Stacks Scanner"
 * @param "scanner" "stacks scanner" 
 *		a stacks scanner
 * @returns "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "Process the_'s⁇comment buffer" is
[
 	scanner : stacks scanner
 |
	Until
	[
		scanner's comment buffer is exhausted
	]
	do
	[
		c ::= scanner's current buffer character;
		f ::= inCommentDispatchTable[c] else
			[
				[
					s : stacks scanner
				 |
					scanner's character buffer := 
						scanner's character buffer ++ <c>;
					Increment scanner's comment buffer index;
				]
			];
		f(scanner);
	];
]:⊤;

/***
 * Find the start of the scanner's next new unnested comment.
 *
 * @method "find_'s⁇next comment"
 * @categories "stacks"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returns "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Private method "find_'s⁇next comment" is
[
	scanner : stacks scanner
 |
	inComment : boolean := false;
	Until 
	[
		scanner's source is exhausted ∨
			[inComment]
	]
	do
	[
		inComment := scanner is at new comment;
	];
	inComment
] : boolean;

/**
 * A unescaped-unterminated-double-quote exception is raised when a \" is 
 * reached that does not have a terminating \" nor does it have the appropriate
 * escaper character, \\.
 *
 * @type "unescaped-unterminated-double-quote exception"
 * @supertype {@type "descriptive exception"}
 * @category "Stacks"
 */
Explicit class "unescaped-unterminated-double-quote exception" 
	extends descriptive exception;
	
/**
 * Process first pass of comment.
 *
 * @method "comment first pass from_using_in level_"
 * @categories "category"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @param "tree" "patricia trie"
 * 		the patricia trie that identifies the delimiters.
 * @param "regionCount" "whole number" the number of comments currently nested
 * 	in
 * @returns "whole number"
 *      the number of comments deep currently nested
 * @author "Richard Arriaga"
 */
Private method "comment first pass from_using_in level_" is
[
	scanner : stacks scanner,
	tree : patricia trie,
	regionCount : ↑whole number
 |
	tempCommentBuffer : string := "";
	buffer : string := "";
	cursor : patricia trie := tree;
	Until [scanner's source is exhausted ∨ 
			[cursor is at terminus ∧ 
				[scanner's current element ∉ cursor's next steps]]]
	do
	[
		value : character := scanner's current element;
		next ::= cursor's next steps;
		If value = ¢"\"" ∧ [scanner's previous element ≠ ¢\] then
		[
			Next character from scanner;
			tempCommentBuffer := tempCommentBuffer ++ <¢"\""> ++
				read from scanner while 
				[
					scanner's current element ≠ ¢"\"" ∨
						[scanner's previous element = ¢\ ∧
						 		[scanner's current element = ¢"\""]]
				];
			If scanner's source is not exhausted ∧ 
				[scanner's current element = ¢"\""] then
			[
			 	tempCommentBuffer := tempCommentBuffer ++ <¢"\"">;
			];
			size : natural number := cast |tempCommentBuffer| into 
				[n : natural number | n];
			If tempCommentBuffer[size] ≠ ¢"\"" then
			[
			 	e::= an unescaped-unterminated-double-quote exception
					with 
						error message ::= format "In module, ‘①’, error occurs in \
								\|comment starting at line number “②”\n" with
						scanner's module name, scanner's line number;
				Raise e
			];
		]
		else if [value ∉ next] then
		[
			/* We have not hit a delimiter, add collected characters
			 * to the region and reset buffer and cursor.            */
			If scanner's special comment = true then
			[
				tempCommentBuffer := tempCommentBuffer ++ buffer ++ <value>;
			];
			buffer := "";
			cursor := tree;
		]
		else
		[
		 	/* On track to buidling a delimiter; proceed down tree */
			cursor := next[value];
			buffer := buffer ++ <value>;
		];
		If cursor is at terminus then
		[
		 	/*Check to see if terminating region or opening nested
		 	 * region. Increment region count appropriately.  */
			If buffer ∈ {"/**","/*"} then
			[
				If scanner's special comment = true then
				[
					tempCommentBuffer := tempCommentBuffer ++ buffer;
				];
				regionCount++;
			]
			else 
			[
				regionCount--;
				If ↓regionCount > 0 ∧ [scanner's special comment = true] then 
				[
					tempCommentBuffer := tempCommentBuffer ++ buffer;
				];
			];
		];
		Next character from scanner;
	];
	/* check to see if in stacks comment, if so, save captured comment */
	If scanner's special comment = true then
	[
		scanner's comment buffer := scanner's comment buffer ++ 
			tempCommentBuffer;
	];
	↓regionCount
]:whole number;

/**
 * A method that accepts a stacks scanner and stores a completely tokenized 
 * comment into its comment buffer.
 *
 * @method "Buffer_'s⁇ current comment"
 * @categories "Stacks"
 * @param "scanner" "stacks scanner" 
 *		a stacks lexical scanner
 * @returns "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Private method "Buffer_'s⁇current comment" is
[
	scanner : stacks scanner
|
	rawComment : raw comment := a raw comment with
		comment tokens := scanner's token buffer,
		erroneous comment := scanner in erroneous comment,
		special token regions := <>; /*TODO actually populate this*/
	scanner's comments := (scanner's comments ++ <rawComment>);
	Reset scanner's comment processing structure;
]:⊤;

/**
 * Obtain all Stacks comments from a scanner then process them into tokenized 
 * regions.
 *
 * @method "Obtain Stacks comments from_"
 * @categories "category"
 * @param "scanner" "stacks scanner" 
 *      a stacks scanner
 * @returns "⊤"
 *      none
 * @author "Richard Arriaga"
 */
Public method "Obtain Stacks comments from_" is
[
	scanner : stacks scanner
 |
	tree : patricia trie := a patricia trie;
	/* Add open and close comment delimiters to patricia trie */
	Add "/**" to tree;  /* open stacks comment*/
	Add "/*" to tree;  /* open plain comment*/
	Add "*/" to tree;  /* open stacks comment*/

	Until [scanner's source is exhausted]
	do
	[
		inComment : boolean := false;
		inComment := find scanner's next comment;

		nestedLevel : whole number := 0;
		If inComment = true then 
		[
			nestedLevel := 1;
		];

		While [nestedLevel > 0] do
		[
			nestedLevel := comment first pass from scanner using tree 
							in level ↑nestedLevel;
		];

		If scanner's special comment = true then 
		[
			/*Transform comment buffer into a tokenized comment tuple*/
			Process the scanner's comment buffer;
			Buffer scanner's current comment;
		];
	];
]:⊤;