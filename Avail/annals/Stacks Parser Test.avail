/*
 * Stacks Stream Parser.avail
 * Copyright © 1993-2013, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Stacks Parser Test"
Versions
"Dev"
Extends

Uses
	"Avail",
	"Avail Scanner",
	"Stacks Scanner",
	"Stacks Lexer"
Names

Body
test : string := "purple
\"/**Frog*/\"
Stuff
/*Hooray*/ no
/*
* Construct and answer a {@type \"dimensioned quantity\"} type with the specified
* {@type \"number\" extent} I'ma \\\" quote
*
* @method \"dimensioned_\"
*/
Public explicit class \"base unit\" extends unit
with fields
	unit map : {atom→1's type|1};

/**
* A f {@method burger} break {@type 
* \"number\" 
* extent   } base \"unit is metrically\" irreducible; though * it may be reduced to smaller*
* quanta, it may /*/*not*/ be reduced*/ to simpler *terms. Examples of base units are * 
* meters (m), seconds (s), or grams (g). type \"first function to accept a dimensioned quantity and a unit \\
*		\\|(but it accepts ① and ②)\\
*		\\|over three lines baby!\"
* An email address {@link \"turkey@turkeytown.com\"} does it work?
* yup yup yup \"Second function to accept a dimensioned quantity and a unit
*		(but it accepts ① and ②)\"
* hut hut hut \"third function to accept a dimensioned quantity and a unit \\
*		(but it accepts ① and ②)\"
* now now now \"mixed style to accept a dimensioned quantity and a unit \\
*		\\|(but it accepts ① and ②)
*		mixed over three lines baby!\"
* @type \"base unit\" tea \\\" a
* @supertype \"unit\" garble \\
* @method so @ \\@ feels \\@scruffy me @wood perky\\@google.com jeffy\\ tickle-fuck
* stuff and {nickels} for { sammy } \\
*/
Public explicit class \"base unit\" extends unit
	with fields
		unit map : {atom→1's type|1};


/**
* Construct and answer a {@type \"dimensioned quantity\"} type with the specified
* {@type \"number\" extent} I'ma \\\" quote
*
* @method \"dimensioned_\"
* @param \"magnitudeType\" \"number's type\"
*        The magnitude type.
* @returns \"dimensioned quantity\"
*          The requested {@type \"dimensioned quantity\"} type.
*/
Public method \"dimensioned_\" is
[
	magnitudeType : number's type
|
	extend dimensioned quantity with extent : magnitudeType
] : dimensioned quantity's type;

Semantic restriction \"dimensioned_\" is
[
	magnitudeType : number's type's type
|
	(extend dimensioned quantity with extent : magnitudeType's instance)'s type
];";

it : iterator of character := an iterator over test;
scanner : stacks scanner := a stacks scanner with it;
Obtain Stacks comments from scanner;
Print: format "scanner's comments[1]=“①”\n\n" with scanner's comments[1];
For each scanner's comments[1] do
[
	s : stacks token
 |
 Print: format "‘①’-“②”, " with s's lexeme,s's line;
];
Print: "\n\n";
q : string := concatenate scanner's comments[1] separated by "_";
Print: q; Print: "\n\n";
For each scanner's comments[2] do
[
	s : stacks token
 |
 Print: format "“①” " with s's line;
];
Print: "\n\n";
v : string := concatenate scanner's comments[2] separated by ",";
Print: v; Print: "\n";


/*
y : nonempty string : = "bagobannananbana";
d : nonempty string := "bana";
Print: format "The start index of the first occurrence of “①” in “②” is “③”\n\n" with d, y, first index of d in y;

y : nonempty string : = "bagobaananbana";
d : nonempty string := "bana";
Print: format "The start index of the first occurrence of “①” in “②” is “③”\n\n" with d, y, first index of d in y;

y : nonempty string : = "bagobaananbana";
d : nonempty string := "punk";
Print: format "The start index of the first occurrence of “①” in “②” is “③”\n\n" with d, y, first index of d in y;

y : nonempty string : = "bagobaananbana";
d : nonempty string := "b";
Print: format "The start index of the first occurrence of “①” in “②” is “③”\n\n" with d, y, first index of d in y;


y : nonempty string : = "b";
d : nonempty string := "pi";
Print: format "The start index of the first occurrence of “①” in “②” is “③”\n\n" with d, y, first index of d in y;

y : string : = "";
d : nonempty string := "pi";
Print: format "The start index of the first occurrence of “①” in “②” is “③”\n\n" with d, y, first index of d in y;

y : nonempty string : = "brr";
d : string := "";
Print: format "The start index of the first occurrence of “①” in “②” is “③”\n\n" with d, y, first index of d in y;

y : string : = "";
d : string := "";
Print: format "The start index of the first occurrence of “①” in “②” is “③”\n\n" with d, y, first index of d in y;

y : <any…|1..> : = <1,"frog",2,3,"pickle",4,"eric",<"peaches","cream">,8,7,"harriet">;
d : <any…|1..> := <"eric",<"peaches","cream">,8>;

Print: format "The start index of the first occurrence of “①”\n in “②” is “③”\n\n" with d, y, first index of d in y;





y : string : = "bagobanananbana";
d : string := "bana";
Print: format "The start index of all occurrences of “①” in “②” is “③”\n\n" with d, y, all indices of d in y;

y : nonempty string : = "bagobaananbana";
d : nonempty string := "bana";
Print: format "The start index of all occurrences of “①” in “②” is “③”\n\n" with d, y, all indices of d in y;

y : nonempty string : = "bagobbbbbaananbana";
d : nonempty string := "b";
Print: format "The start index of all occurrences of “①” in “②” is “③”\n\n" with d, y, all indices of d in y;

y : nonempty string : = "bagobababababaananbana";
d : nonempty string := "ba";
Print: format "The start index of all occurrences of “①” in “②” is “③”\n\n" with d, y, all indices of d in y;

y : nonempty string : = "bagobaananbana";
d : nonempty string := "punk";
Print: format "The start index of all occurrences of “①” in “②” is “③”\n\n" with d, y, all indices of d in y;

y : nonempty string : = "b";
d : nonempty string := "pi";
Print: format "The start index of all occurrences of “①” in “②” is “③”\n\n" with d, y, all indices of d in y;

y : string : = "";
d : string := "pi";
Print: format "The start index of all occurrences of “①” in “②” is “③”\n\n" with d, y, all indices of d in y;

y : string : = "bee";
d : string := "";
Print: format "The start index of all occurrences of “①” in “②” is “③”\n\n" with d, y, all indices of d in y;

y : string : = "";
d : string := "";
Print: format "The start index of all occurrences of “①” in “②” is “③”\n\n" with d, y, all indices of d in y;

y : string : = "The ferret went for a walk down the street.  He met the man with the iron hand.  He asked the iron-handed man for the time.  Unbeknownst to the ferret, this is the gravest of insultes in the culture of the iron-handed man.  Thus began the war that would rage through the ages.  There will never be a victor for they are as one and the half cannot destroy the whole.";
d : string := "the";
Print: format "The start index of all occurrences of “①” in \n“②”\n is “③”\n\n" with d, y, all indices of d in y;
*/