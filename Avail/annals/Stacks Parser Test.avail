/*
 * Stacks Stream Parser.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Stacks Parser Test"
Versions
"Dev"
Extends

Uses
	"Avail",
	"Stacks Stream Parser"
Names


Body
test ::=
"/**
 * Reject the current parse if the {@type \"unit\" metrics} are well-known but no
 * conversion function has been defined prior to this send.
 *
 * @method \"_converted to_\"
 * @restricts \"dimensioned quantity's type\"
 * @restricts \"unit's type\"
 */
Semantic restriction \"_converted to_\" is
[
	quantityType : dimensioned quantity's type,
	unitType : unit's type
|
	If {|quantityType's metric|, |unitType|} = {1} then
	[
		key ::= <quantityType's metric's instance, unitType's instance>;
		Unless key ∈ converters then
		[
			Reject parse, expected:
				format
					\"conversion function for “①” → “②” to have been previously\
					\| defined\"
				with key[1], key[2]
		];
	];
	extend dimensioned quantity with metric : unitType
];

/**
 * Define {@method \"_converted to_\" methods} for converting {@type
 * \"dimensioned quantity\" dimensioned quantities} between two compatible {@type
 * \"unit\" metrics}.
 *
 * @method \"Conversion method is_,⁇inverse is_\"
 * @param \"aFunction\" \"[⊥, ⊥]→dimensioned quantity\"
 *        A function whose first parameter type is a subtypes of {@type
 *        \"dimensioned quantity\"} and whose second parameter type is a subtype
 *        of {@type \"unit\"}. This function must return a {@type \"dimensioned
 *        quantity\"} whose metric equals the second parameter type.
 * @param \"inverseFunction\" \"[⊥, ⊥]→dimensioned quantity\"
 *        A function whose first parameter type is a subtype of {@type
 *        \"dimensioned quantity\"} having a metric that equals the second
 *        parameter type of {@param \"aFunction\"} and whose second parameter type
 *        equals the metric of the first parameter type of same. This function
 *        must return a {@type \"dimensioned quantity\"} whose metric equals the
 *        second parameter type.
 * @see \"_converted to_\"
 */";


it : iterator := an iterator over test;
identify comment from it;

