/*
 * Stacks Stream Parser.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Avail Scanner"
Versions
	"Dev"
Extends

Uses
	"Avail"

Names
	"an Avail Scanner with_",
	"Avail scanner",
	"column number",
	"Exhaust_",
	"lexeme",
	"line",
	"line number",
	"Next character from_",
	"position",
	"Process digit from_",
	"Process double quote from_",
	"Process forward slash from_",
	"Process identifier starter from_",
	"Process operator from_",
	"Process white space from_",
	"Process zero width whitespace from_",
	"read from_while_",
	"scanner token",
	"token buffer",
	"token start",
	"tokenize_",
	"_'s⁇column number",
	"_'s⁇lexeme",
	"_'s⁇line",
	"_'s⁇line number",
	"_'s⁇position",
	"_'s⁇source",
	"_'s⁇token buffer",
	"_'s⁇token start"

Body

/* Definition of atoms for fields in class, Avail scanner */
"source" is a new field atom;
"lexeme" is a new field atom;
"line" is a new field atom;
"line number" is a new field atom;
"column number" is a new field atom;
"position" is a new field atom;
"token buffer" is a new field atom;
"token start" is a new field atom;

/* Global variable definitions */
lineNumber : natural number := 1;   /*Current line # of the scanner */
columnNumber : natural number := 1; /*Current column # of the scanner */

/**
 * A class that defines a token for the Avail scanner.  
 * 
 * @type "scanner token"
 * @supertype {@type "object" object}
 * @category Stacks
 * @field "lexeme" "string"
 *  string representation of token
 * @field "line" "natural number"
 *  line number on which token appears 
 * @field "position" "natural number"
 *  column position where token begins
 * @author Richard Arriaga
 */
Public class "scanner token" extends object
	with fields
		public lexeme : <character…|1..>,
		public line : natural number,
		public position : natural number;

/**
 * A class that defines an Avail lexical scanner.  This is an abstract class.
 * 
 * @type "Avail scanner"
 * @supertype {@type "object" object}
 * @category Avail Lexical Scanner
 * @field "source" "iterator of character"
 *    an iterator over the .avail input file
 * @field "line number" "natural number"
 *    line number of current element of the iterator 
 * @field "column number" "natural number"
 *    column position on line of current element of the iterator
 * @author Richard Arriaga
 */

Public class "Avail scanner" extends object
	with fields
		public source : iterator of character,
		public token buffer : ↑<scanner token…|>,
		public line number : ↑natural number,
		public column number : ↑natural number,
		public token start : ↑natural number;

/**
 * Public constructor of Avail scanner
 *
 * @method "construct Avail Scanner with_"
 * @categories "Avail Lexical Scanner"
 * @param "iter" "iterator of character" 
 *      and iterator of characters
 * @returnType "Avail scanner"
 *      an Avail scanner object
 * @author "Richard Arriaga"
 */
Public method "an Avail Scanner with_" is
[
	iter : iterator of character
|
	line : natural number := 1;
	column : natural number := 1;
	tokenStart : natural number := 1;
	tokens : <scanner token…|> := <>;
	an Avail scanner with
		source := iter,
		token buffer := ↑tokens,
		line number := ↑line,
		column number := ↑column,
		token start := ↑tokenStart
] : Avail scanner;

Public abstract method "tokenize_" is [Avail scanner]→scanner token;

/* Methods on handling character types from the scanner */
Public abstract method "Process digit from_" is [Avail scanner]→⊤;
Public abstract method "Process identifier starter from_" is [Avail scanner]→⊤;
Public abstract method "Process white space from_" is [Avail scanner]→⊤;
Public abstract method "Process operator from_" is [Avail scanner]→⊤;
Public abstract method "Process forward slash from_" is [Avail scanner]→⊤;
Public abstract method "Process double quote from_" is [Avail scanner]→⊤;
Public abstract method "Process zero width whitespace from_" is [Avail scanner]→⊤;

dispatchTable : {code point→[Avail scanner]→⊤|} := {};

From 1 to 256 do
[
 	cp : [1..256]
 |
 	c ::= cp → character;
	if c = ¢/ then
	[
	 	dispatchTable := dispatchTable + 
	 		cp→ [
			 	 	s : Avail scanner
			 	 |
			 	 	Process forward slash from s;
			 	];
	]
	else if [c = ¢"\""] then
	[
	 	dispatchTable := dispatchTable + 
	 		cp→ [
			 	 	s : Avail scanner
			 	 |
			 	 	Process double quote from s;
			 	];
	]
	else if [c is an Arabic numeral] then
	[
	 	dispatchTable := dispatchTable  + 
	 		cp→ [
			 	 	s : Avail scanner
			 	 |
			 	 	Process digit from s;
			 	];
	]
	else if [c is a letter ∨ [c = ¢_]] then
	[
	 	dispatchTable := dispatchTable  + 
	 		cp→ [
			 	 	s : Avail scanner
			 	 |
			 	 	Process identifier starter from s;
			 	];
	]
	else if [c is whitespace] then
	[
	 	dispatchTable := dispatchTable  + 
	 		cp→ [
			 	 	s : Avail scanner
			 	 |
			 	 	Process white space from s;
			 	];
	]
	else if [c = "FEFF"(base 16)→character] then
	[
	 	dispatchTable := dispatchTable  + 
	 		cp→ [
			 	 	s : Avail scanner
			 	 |
			 	 	Process zero width whitespace from s;
			 	];
	]
	else
	[
		dispatchTable := dispatchTable  + 
			cp→ [
			 	 	s : Avail scanner
			 	 |
			 	 	Process operator from s;
			 	];
	];
];

/**
 * Advance the scanner's source and increment the line number and column number
 * if able
 *
 * @method "Next character from_"
 * @categories "Avail Lexical Scanner"
 * @param "scanner" "Avail scanner" 
 *		an Avail scanner
 * @returnType "⊤"
 *		none
 * @raises "Raise an exhausted-iterator exception" 
 *		there is nothing left on the iterator to consume
 * @author "Richard Arriaga"
 */
Public method "Next character from_" is
[
 	scanner : Avail scanner
 |
 	Unless scanner's source is exhausted then
 	[
		Advance scanner's source;
		If scanner's source is not exhausted then
		[ 
			if scanner's source's current element = ¢"\n" then 
			[
				↓scanner's column number ?= 1;
				scanner's line number++;
			]
			else
			[
			 	scanner's column number++;
			];
		];
 	] 
 	else
 	[
 	 	Raise an exhausted-iterator exception
 	];
 ]:⊤;

/**
 * Advance the scanner's source until exhaustion.  Perform appropriate functions
 * for each element of the scanner's source's elements
 *
 * @method "Exhaust_"
 * @categories "Avail Lexical Scanner"
 * @param "scanner" "Avail scanner" 
 *		an Avail scanner
 * @returnType "⊤"
 *		none
 * @author "Richard Arriaga"
 */
Public method "Exhaust_" is
[
	scanner : Avail scanner
|
	While
	[
		scanner's source is not exhausted 
	]
	do
	[
		c ::= scanner's source's current element; 
		/*  TODO:  Current implementation is incomplete due to lacking character
		 * functionality.  May miss many operator characters.  Once tuple
		 * performance issue and/or character module limitiations addressed,
		 * this needs to be revisited.*/
		f ::= dispatchTable[c's code point] else
			[ /* else addresses limits in dispatch table.  Assertions not
			   * 100% effective on providing correct coverage.            */
			 	[
			 	 	s : Avail scanner
			 	 |
			 	 	if s's source's current element is whitespace then
			 	 	[
			 	 	 	Process white space from s;
			 	 	] 
			 	 	else
			 	 	[
			 	 	 	Process identifier starter from s;
			 	 	];
			 	]
			];
		f(scanner);
		Next character from scanner;
	];
]:⊤;

/**
 * Read from Avail scanner's source while supplied condition is true or the 
 * source is exhausted.
 *
 * @method "read from_while_"
 * @public
 * @categories "Avail Lexical Scanner"
 * @param "scanner" "Avail scanner" 
 *		an avail scanner 
 * @param "predicate" "boolean" 
 *		The function that guards repeated application of reading from the source
 * @returnType "<character…|>"
 *		the tuple of characters read from the source
 * @author "Richard Arriaga"
 */
Public method "read from_while_" is
[
 	scanner : Avail scanner,
 	predicate : []→boolean
 |
 	buffer : <character…|> := <>;
	While 
	[
	 	scanner's source is not exhausted ∧ 
	 		[predicate()]
	]
	do
	[
	 	Next character from scanner;
	 	buffer := buffer ++ <scanner's source's current element>;
	];
	buffer
 ]:<character…|>;
