/*
 * Delimited Iterators.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Delimited Iterators"
Versions
	"dev"
Uses
	"Abstract Iterators",
	"Foundation",
	"Unit Testing"
Names
	"_delimited by_",
	"_delimited by any of_"
Body

/* TODO: [TLS] Remove these constants once a macro is available for "$…". */
_delimiter ::= $"delimiter|delimiters";

Private method "delimiter|delimiters" is [ _delimiter ];

/**
 * A delimited iterator answers tuples of elements from its decorated iterator.
 * These tuples are separated by occurrences of the delimiter.
 *
 * @type "delimited iterator"
 * @supertype "iterator"
 */
Class "delimited iterator" extends iterator
	with fields
		element type : tuple's type,
		decorated iterator : iterator,
		delimiter : tuple;

Method "_is exhausted" is
[
	anIterator : delimited iterator
|
	anIterator's decorated iterator is exhausted
] : boolean;

/* TODO: [TLS] Repair the rest of these! It's mid-refactor! */
delimited iterator's current element method is
[
	anIterator : delimited iterator
|
	head : tuple := <>;
	Until [anIterator is exhausted]
	do
	[
		head := eject ↑head ++ <rest's head>;
		rest := eject ↑rest's tail;
	];
	head
] : tuple;

delimited iterator's head method is
[
	anIterator : extend delimited iterator with delimiter : <⊥…|0>
|
	<anIterator's decorated iterator's head>
];

delimited iterator's tail method is
[
	anIterator : delimited iterator
|
	rest : iterator := anIterator's decorated iterator;
	Until [ rest is empty ∨ [ rest starts with anIterator's delimiter ] ]
	do
	[
		rest := eject ↑rest's tail;
	];
	If ¬rest is empty then
	[
		rest := drop |anIterator's delimiter| from eject ↑rest;
	];
	anIterator's decorated iterator := rest
] : delimited iterator;

delimited iterator's tail method is
[
	anIterator : extend delimited iterator with delimiter : <⊥…|0>
|
	anIterator's decorated iterator := (anIterator's decorated iterator's tail)
] : delimited iterator;

/**
 * Construct and answer an iterator that produces tuples of values from `anIterator`.
 * These tuples are separated by occurrences of `delimiterTuple` (which will
 * never be produced as output from the answered iterator).
 * 
 * Parameters:
 *    anIterator - A iterator.
 *    delimiterTuple - The delimiter.
 * Returns:
 *    The requested iterator.
 */
Public method "_delimited by_" is
[
	anIterator : iterator,
	delimiterTuple : tuple
|
	a delimited iterator with
		element type := <anIterator's element type…|>,
		decorated iterator := anIterator,
		delimiter := delimiterTuple
] : iterator of tuple;

Semantic restriction "_delimited by_" is
[
	iteratorType : iterator's type,
	delimiterType : tuple's type
|
	extend delimited iterator with
		element type : <iteratorType's element type's instance…|>'s type,
		decorated iterator : iteratorType,
		delimiter : delimiterType
];

/**
 * A delimited iterator answers tuples of elements from its decorated iterator.
 * These tuples are separated by occurrences of any delimiter.
 */
Explicit class "multiply delimited iterator" extends delimited iterator
	with fields
		delimiters : <<any…|1..>…|1..>;

multiply delimited iterator's head method is
[
	anIterator : multiply delimited iterator
|
	head : tuple := <>;
	rest : iterator := anIterator's decorated iterator;
	Until
	[
		rest is empty ∨ [ any of anIterator's delimiters satisfies
			[ delimiter : tuple | rest starts with delimiter ] ]
	]
	do
	[
		head := eject ↑head ++ <rest's head>;
		rest := eject ↑rest's tail;
	];
	head
] : tuple;

multiply delimited iterator's tail method is
[
	anIterator : multiply delimited iterator
|
	rest : iterator := anIterator's decorated iterator;
	theDelimiter : tuple;
	Until
	[
		if rest is empty then [ true ]
		else
		[
			index ::= first index of anIterator's delimiters where
				[ delimiter : tuple | rest starts with delimiter ];
			If index ≠ 0 then
			[
				nonzero ::= cast index into [ t : natural number | t ];
				theDelimiter := anIterator's delimiters[nonzero];
			];
			↑theDelimiter is assigned
		]
	]
	do
	[
		rest := eject ↑rest's tail;
	];
	If ¬rest is empty then
	[
		rest := drop |theDelimiter| from eject ↑rest;
	];
	anIterator's decorated iterator := rest
] : multiply delimited iterator;

/**
 * Construct and answer an iterator that produces tuples of values from `anIterator`.
 * These tuples are separated by occurrences of `delimiterTuple` (which will
 * never be produced as output from the answered iterator).
 * 
 * Parameters:
 *    anIterator - A iterator.
 *    delimiterTuple - The delimiter.
 * Returns:
 *    The requested iterator.
 */
Public method "_delimited by any of_" is
[
	anIterator : iterator,
	delimitersTuple : <<any…|1..>…|1..>
|
	a multiply delimited iterator with
		element type := <anIterator's element type…|>,
		decorated iterator := anIterator,
		delimiters := delimitersTuple
] : iterator of tuple;

Semantic restriction "_delimited by any of_" is
[
	iteratorType : iterator's type,
	delimitersType : <<any…|1..>…|1..>'s type
|
	extend multiply delimited iterator with
		element type : <iteratorType's element type's instance…|>'s type,
		decorated iterator : iteratorType,
		delimiters : delimitersType
];
