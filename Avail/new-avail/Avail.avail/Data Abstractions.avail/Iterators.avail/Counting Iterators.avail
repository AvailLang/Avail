/*
 * Counting Iterators.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Counting Iterators"
Versions
	"dev"
Uses
	"Abstract Iterators",
	"Foundation",
	"Sizable Positionable Iterators",
	"Unit Testing"
Names
	"a counting iterator from_to_",
	"a counting iterator from_to_by_",
	"counting iterator test suite"
Body

"next" is a new field atom;
"step" is a new field atom;
"start" is a new field atom;
"end" is a new field atom;

/**
 * A counting number iterator is an immutable lazy list of arbitarily many
 * numbers, each of which is a fixed distance from its neighbors.
 *
 * @type "counting number iterator"
 * @supertype "iterator"
 */
Class "counting number iterator" extends sizable positionable iterator
	with fields
		element type : number's type,
		position type : number's type,
		step : number,
		start : number,
		end : number
	with mutable fields
		next : number;

/**
 * An counting integer iterator is an immutable lazy list of arbitrarily many
 * integers, each of which is a fixed distance from its neighbors.
 *
 * @type "counting integer iterator"
 * @supertype "iterator"
 */
Class "counting integer iterator" extends counting number iterator
	with fields
		element type : integer's type,
		position type : integer's type,
		step : integer,
		start : extended integer,
		end : extended integer;

Method "_is exhausted" is
[
	anIterator : counting number iterator
|
	if anIterator's step ≥ 0 then
	[
		anIterator's next > anIterator's end
	]
	else
	[
		anIterator's next < anIterator's end
	]
] : boolean;

counting number iterator's current element method is
[
	anIterator : counting number iterator
|
	anIterator's next
] : number;

counting number iterator's advance method is
[
	anIterator : counting number iterator
|
	anIterator's next := anIterator's next + anIterator's step;
] : ⊤;

Method "_'s⁇position" is
[
	anIterator : counting number iterator
|
	anIterator's next
] : number;

Private method "Require:_is a valid position for_" is
[
	position : number,
	anIterator : counting number iterator
|
	first ::= anIterator's start;
	last ::= anIterator's end;
	delta ::= anIterator's step;
	ok : boolean := (position - first) mod delta = 0;
	ok := ok ∧ [if delta < 0 then [position ≤ first] else [position ≥ first]];
	ok := ok ∧ [if delta < 0 then [position ≥ last] else [position ≤ last]];
	If ¬ok then
	[
		Raise an invalid-position exception
	];
];

Method "_'s⁇position:=_" is
[
	anIterator : counting number iterator,
	position : number
|
	Require: position is a valid position for anIterator;
	anIterator's next := position;
] : ⊤;

Method "`|_`|" is
[
	anIterator : counting number iterator
|
	count ::= ((anIterator's end - anIterator's start + anIterator's step)
		÷ anIterator's step)→extended integer;
	cast count into [t : whole number | t]
] : whole number;

Method "`|_'s⁇remaining elements`|" is
[
	anIterator : counting number iterator
|
	size ::= |anIterator|;
	answered ::= |(anIterator's next - anIterator's start) ÷ anIterator's step|;
	cast (size - answered)→extended integer into [t : whole number | t]
] : whole number;

Semantic restriction "For each of⁇_do_" is
[
	iteratorType : counting integer iterator's type,
	actionType : [⊥]→⊤'s type
|
	return ::= actionType's return type;
	endSet ::= {⎣iteratorType's end⎦, ⎡iteratorType's end⎤};
	step ::= iteratorType's step;
	elementType ::= iteratorType's element type's instance;
	definitelyRuns ::=
		if step ⊆ [0..∞) then [⎡elementType⎤ ≤ ⎣iteratorType's end⎦]
		else
		[
			if step ⊆ (-∞..-1] then [⎣elementType⎦ ≥ ⎡iteratorType's end⎤]
			else [false]
		];
	/* These are four circumstances which lead to non-termination:
	 * 
	 * 1. The step is 0.
	 * 2. The step is positive, the end is ∞, and the action answers `true`.
	 * 3. The step is negative, the end is -∞, and the action answers `true`.
	 * 4. The action is definitely invoked and it never terminates.
	 */
	if step ⊆ [0..0]
		∨ [(step ⊆ [0..∞) ∧ [endSet = {∞}])
		∨ [(step ⊆ (-∞..-1] ∧ [endSet = {-∞}])
		∨ [definitelyRuns ∧ [return = ⊥]]]]
	then [⊥]
	else [⊤]
];

/**
 * Construct and answer an {@type "iterator"} that lazily produces all
 * consecutive values between {@param "start"} and {@param "end"}.
 *
 * @method "a counting iterator from_to_"
 * @param "first" "integer"
 *        The start value, inclusive. This is the first value that will be
 *        answered by the iterator.
 * @param "last" "extended integer"
 *        The end value, inclusive. This is the last value that will be
 *        answered by the iterator.
 * @returns "iterator of integer"
 *          The requested iterator.
 */
Public method "a counting iterator from_to_" is
[
	first : integer,
	last : extended integer
|
	a counting integer iterator with
		element type ::= (first - 1..last + 1),
		position type ::= (first - 1..last + 1),
		next := first,
		step ::= 1,
		start ::= first,
		end ::= last
] : counting integer iterator;

Semantic restriction "a counting iterator from_to_" is
[
	startType : integer's type,
	endType : extended integer's type
|
	elementType ::= (⎣startType⎦ - 1..⎡endType⎤ + 1);
	extend counting integer iterator with
		element type : elementType's type,
		position type : elementType's type,
		step : 1's type,
		start : startType,
		end : endType
];

/**
 * Construct and answer an {@type "iterator"} that lazily produces values
 * between {@param "start"} and {@param "end"}. For each value <em>v</em>
 * produced, there is some <em>n ∈ number</em> such that:
 *
 *    anIterator ::= a counting iterator from start to end by step;
 *    ...
 *    v ::= anIterator's current element;
 *    Assert: v = start + n × step;
 *
 * Note that {@param "end"} is not guaranteed to be the last value produced by
 * the iterator. It is only guaranteed that no larger values than {@param "end"}
 * will be answered.
 *
 * @method "a counting iterator from_to_by_"
 * @param "first" "number"
 *        The start value, inclusive. This is the first value that will be
 *        answered by the iterator.
 * @param "last" "number"
 *        The end value, inclusive. If {@param "delta"} ≥ 0, then no values
 *        larger than this will be answered by the iterator. If {@param delta}
 *        < 0, then no values smaller than this will be answered by the
 *        iterator.
 * @param "delta" "number"
 *        The amount by which successive values anwered by the iterator will
 *        differ.
 * @returns "iterator of number"
 *          The requested iterator.
 */
Public method "a counting iterator from_to_by_" is
[
	first : number,
	last : number,
	delta : number
|
	elementType ::= cast first + delta into
		[t : double | double],
		[t : float | float],
		[t : extended integer | extended integer]
		else [number];
	a counting number iterator with
		element type ::= elementType,
		position type ::= elementType,
		next := first,
		step ::= delta,
		start ::= first,
		end ::= last
] : counting number iterator;

Semantic restriction "a counting iterator from_to_by_" is
[
	startType : number's type,
	endType : number's type,
	deltaType : number's type
|
	elementType ::=
		if startType ⊆ double ∨ [deltaType ⊆ double]
			then [double]
		else if [startType ⊆ float ∨ [endType ⊆ float]]
			then [float]
		else if [startType ⊆ extended integer ∧ [endType ⊆ extended integer]]
			then [extended integer]
		else [number];
	extend counting number iterator with
		element type : elementType's type,
		position type : elementType's type,
		step : deltaType,
		start : startType,
		end : endType
];

/**
 * Construct and answer an {@type "iterator"} that lazily produces values
 * between {@param "start"} and {@param "end"}. For each value <em>v</em>
 * produced, there is some <em>n ∈ number</em> such that:
 *
 *    anIterator ::= a counting iterator from start to end by step;
 *    ...
 *    v ::= anIterator's current element;
 *    Assert: v = start + n × step;
 *
 * Note that {@param "end"} is not guaranteed to be the last value produced by
 * the iterator. It is only guaranteed that no larger values than {@param "end"}
 * will be answered.
 *
 * @method "a counting iterator from_to_by_"
 * @param "first" "number"
 *        The start value, inclusive. This is the first value that will be
 *        answered by the iterator.
 * @param "last" "number"
 *        The end value, inclusive. If {@param "delta"} ≥ 0, then no values
 *        larger than this will be answered by the iterator. If {@param delta}
 *        < 0, then no values smaller than this will be answered by the
 *        iterator.
 * @param "delta" "number"
 *        The amount by which successive values anwered by the iterator will
 *        differ.
 * @returns "iterator of number"
 *          The requested iterator.
 */
Public method "a counting iterator from_to_by_" is
[
	first : integer,
	last : number,
	delta : integer
|
	integralEnd ::= last→extended integer;
	a counting integer iterator with
		element type ::= (first - 1..integralEnd + 1),
		position type ::= (first - 1..integralEnd + 1),
		next := first,
		step ::= delta,
		start ::= first,
		end ::= integralEnd
] : counting integer iterator;

Semantic restriction "a counting iterator from_to_by_" is
[
	startType : integer's type,
	endType : extended integer's type,
	deltaType : integer's type
|
	elementType ::= (⎣startType⎦ - 1..⎡endType⎤ + 1);
	extend counting integer iterator with
		element type : elementType's type,
		position type : elementType's type,
		step : deltaType,
		start : startType,
		end : endType
];

"counting iterator test suite" is a new atom;
New test suite counting iterator test suite extends iterators test suite;

Test "counting iterator basics" in counting iterator test suite is
[
	ref ::= 1 to 10;
	index : natural number := 1;
	iter ::= a counting iterator from 1 to 10;
	For each iter do
	[
		element : [1..10]
	|
		Require: ref[(↑index++)] = element;
	];
	Require: (|ref| + 1) = index;
];

Test "counting iterator(map)" in counting iterator test suite is
[
	ref ::= <1, 4, 9, 16, 25, 36, 49, 64, 81, 100>;
	index : natural number := 1;
	iter ::= map a counting iterator from 1 to 10 through [i : [1..10] | i × i];
	For each iter do
	[
		element : [1..100]
	|
		Require: ref[(↑index++)] = element;
	];
	Require: (|ref| + 1) = index;
];

Test "counting iterator(filter)" in counting iterator test suite is
[
	ref ::= <2, 4, 6, 8, 10>;
	index : natural number := 1;
	iter ::= filter a counting iterator from 1 to 10
		by [i : [1..10] | i is even];
	For each iter do
	[
		element : [1..10]
	|
		Require: ref[(↑index++)] = element;
	];
	Require: (|ref| + 1) = index;
];

Test "counting iterator(concatenation)" in counting iterator test suite is
[
	ref ::= 1 to 10;
	index : natural number := 1;
	iters ::= <
		an exhausted iterator,
		a counting iterator from 1 to 2,
		an exhausted iterator,
		an exhausted iterator,
		a counting iterator from 3 to 7,
		an exhausted iterator,
		a counting iterator from 8 to 8,
		a counting iterator from 9 to 10,
		an exhausted iterator>;
	iter ::= concatenate iters;
	For each iter do
	[
		element : [1..10]
	|
		Require: ref[(↑index++)] = element;
	];
	Require: (|ref| + 1) = index;
];

Test "counting iterator(lexical concatenation)"
	in counting iterator test suite is
[
	ref ::= 1 to 10;
	index : natural number := 1;
	iters ::= <
		an exhausted iterator,
		a counting iterator from 1 to 2,
		an exhausted iterator,
		an exhausted iterator,
		a counting iterator from 3 to 7,
		an exhausted iterator,
		a counting iterator from 8 to 8,
		a counting iterator from 9 to 10,
		an exhausted iterator>;
	iter ::= iters[1]
		++ iters[2]
		++ iters[3]
		++ iters[4]
		++ iters[5]
		++ iters[6]
		++ iters[7]
		++ iters[8]
		++ iters[9];
	For each iter do
	[
		element : [1..10]
	|
		Require: ref[(↑index++)] = element;
	];
	Require: (|ref| + 1) = index;
];

Test "counting iterator(zip)" in counting iterator test suite is
[
	ref ::= <
		<1, 1>, <2, 4>, <3, 9>, <4, 16>, <5, 25>,
		<6, 36>, <7, 49>, <8, 64>, <9, 81>, <10, 100>>;
	index : natural number := 1;
	iters ::= <
		a counting iterator from 1 to 10,
		map a counting iterator from 1 to 10
			through [n : [1..10] | n × n]>;
	iter ::= zip iters;
	For each iter do
	[
		element : <[1..10], [1..100]…|2>
	|
		Require: ref[(↑index++)] = element;
	];
	Require: (|ref| + 1) = index;
];

Test "counting iterator(lexical zip)" in counting iterator test suite is
[
	ref ::= <
		<1, 1>, <2, 4>, <3, 9>, <4, 16>, <5, 25>,
		<6, 36>, <7, 49>, <8, 64>, <9, 81>, <10, 100>>;
	index : natural number := 1;
	iters ::= <
		a counting iterator from 1 to 10,
		map a counting iterator from 1 to 10
			through [n : [1..10] | n × n]>;
	iter ::= iters[1] zip iters[2];
	For each iter do
	[
		element : <[1..10], [1..100]…|2>
	|
		Require: ref[(↑index++)] = element;
	];
	Require: (|ref| + 1) = index;
];

Test "counting iterator(take_from_)" in counting iterator test suite is
[
	ref ::= 1 to 5;
	index : natural number := 1;
	iter ::= a counting iterator from 1 to 10;
	result ::= take 5 from iter;
	For each result do
	[
		element : [1..10]
	|
		Require: ref[(↑index++)] = element;
	];
	Require: 6 = iter's current element;
	Require: [take 6 from iter] raises exhausted-iterator exception;
];

Test "counting iterator(take from_while_)" in counting iterator test suite is
[
	ref ::= 1 to 5;
	index : natural number := 1;
	iter ::= a counting iterator from 1 to 10;
	result ::= take from iter while [n : [1..10] | n ≤ 5];
	For each result do
	[
		element : [1..10]
	|
		Require: ref[(↑index++)] = element;
	];
	Require: 6 = iter's current element;
];

Test "counting iterator(take from_until_)" in counting iterator test suite is
[
	ref ::= 1 to 5;
	index : natural number := 1;
	iter ::= a counting iterator from 1 to 10;
	result ::= take from iter until [n : [1..10] | n ≥ 6];
	For each result do
	[
		element : [1..10]
	|
		Require: ref[(↑index++)] = element;
	];
	Require: 6 = iter's current element;
];

Test "counting iterator(Drop_from_)" in counting iterator test suite is
[
	ref ::= 6 to 10;
	index : natural number := 1;
	iter ::= a counting iterator from 1 to 10;
	Drop 5 from iter;
	For each iter do
	[
		element : [1..10]
	|
		Require: ref[(↑index++)] = element;
	];
	Require: (|ref| + 1) = index;
	Require: [Drop 6 from iter;] raises exhausted-iterator exception;
];

Test "counting iterator(Drop from_while_)" in counting iterator test suite is
[
	ref ::= 6 to 10;
	index : natural number := 1;
	iter ::= a counting iterator from 1 to 10;
	Drop from iter while [n : [1..10] | n ≤ 5];
	For each iter do
	[
		element : [1..10]
	|
		Require: ref[(↑index++)] = element;
	];
	Require: (|ref| + 1) = index;
];

Test "counting iterator(Drop from_until_)" in counting iterator test suite is
[
	ref ::= 6 to 10;
	index : natural number := 1;
	iter ::= a counting iterator from 1 to 10;
	Drop from iter until [n : [1..10] | n ≥ 6];
	For each iter do
	[
		element : [1..10]
	|
		Require: ref[(↑index++)] = element;
	];
	Require: (|ref| + 1) = index;
];

Test "counting iterator(size)" in counting iterator test suite is
[
	iter : sizable iterator := a counting iterator from 1 to 10;
	Require: 10 = |iter|;
	iter := a counting iterator from 3 to 16;
	Require: 14 = |iter|;
	iter := a counting iterator from 2 to 16 by 3;
	Require: 5 = |iter|;
	iter := a counting iterator from -5 to 25 by 5;
	Require: 7 = |iter|;
	iter := a counting iterator from -6.25 to 21.4 by 3.1;
	Require: 9 = |iter|;
];

Test "counting iterator(position)" in counting iterator test suite is
[
	iter : sizable iterator of integer positioned by integer;
	iter := a counting iterator from 1 to 5;
	From 1 to 5 do
	[
		i : [1..5]
	|
		iter's position := i;
		Require: i to 5 = take 5 - i + 1 from iter;
		Require: iter is exhausted;
	];
	iter := a counting iterator from 2 to 16 by 3;
	From 2 to 16 by 3 do
	[
		i : [2..16]
	|
		iter's position := i;
		Require: i to 16 by 3 = take (16 - i + 3) ÷ 3 from iter;
		Require: iter is exhausted;
	];
	iter's position := 4;
]
must raise invalid-position exception;

Test "counting iterator(remaining elements)" in counting iterator test suite is
[
	iter ::= a counting iterator from 2 to 10 by 3;
	remaining : integer := |iter|;
	For each iter do
	[
		element : [2..10]
	|
		Require: remaining = |iter's remaining elements|;
		↑remaining--;
	];
	Require: iter is exhausted;
	Require: remaining = |iter's remaining elements|;
];
