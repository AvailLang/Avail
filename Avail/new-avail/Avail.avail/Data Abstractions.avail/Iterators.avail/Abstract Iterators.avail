/*
 * Abstract Iterators.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Abstract Iterators"
Versions
	"dev"
Extends
	"Common" = ("element type"),
	"Foundation" =
	(
		"For each_do_",
		"concatenate_",
		"filter_by_",
		"map_through_",
		"«_‡++»"
	)
Uses
	"Foundation"
Names
	"Advance_",
	"an exhausted iterator",
	"decorated iterator|iterators",
	"exhausted iterator",
	"exhausted-iterator exception",
	"iterator",
	"iterator of_",
	"_is exhausted",
	"_'s⁇current element",
	"_'s⁇current element method is_",
	"_'s⁇advance method is_"
Body

/* TODO: [TLS] Remove these constants once a macro is available for "$…". */
privateCurrentElementName ::= $"private_'s⁇current element";
privateAdvanceName ::= $"Private advance_";
decoratedIterator ::= $"decorated iterator|iterators";
transformer ::= $"transformer";
filter ::= $"filter";
iteratorIndex ::= $"iterator index";

/**
 * Answer the field atom that represents a decorated iterator.
 *
 * @method "decorated iterator|iterators"
 * @returns "atom"
 *          The requested field atom.
 */
Public method "decorated iterator|iterators" is [ decoratedIterator ];

/**
 * Answer the field atom that represents an iterator index.
 *
 * @method "iterator index"
 * @returns "atom"
 *          The requested field atom.
 */
Method "iterator index" is [ iteratorIndex ];

/**
 * An iterator is a mutable lazy list of arbitrarily many elements.
 *
 * @type "iterator"
 */
Public explicit class "iterator" extends object
	with fields
		element type : any's type;

/**
 * Construct and answer an iterator type that answers values of the specified
 * type.
 *
 * @method "iterator of_"
 * @param "elementType" "any's type"
 *        The type of value produced by iterators of the answered type.
 * @returns "iterator's type"
 *          The requested iterator type.
 */
Public method "iterator of_" is
[
	elementType : any's type
|
	extend iterator with element type : elementType's type
] : iterator's type;

/**
 * An exhausted-iterator exception is raised when an inappropriate operation,
 * like `advance_`, is performed on an exhausted iterator.
 *
 * @type "exhausted-iterator exception"
 */
Public explicit class "exhausted-iterator exception" extends exception;

/**
 * Is the specified iterator exhausted?
 *
 * @method "_is exhausted"
 * @param "anIterator" "iterator"
 *        An iterator.
 * @returns "boolean"
 *          {@code true} if the argument is exhausted, {@code false} otherwise.
 */
Abstract method "_is exhausted" is [iterator]→boolean;

Private abstract method privateCurrentElementName is [iterator]→any;

/**
 * Ensure that the specified iterator is not exhausted, then answer its current
 * element.
 *
 * @method "_'s⁇current element"
 * @param "anIterator" "iterator"
 *        An iterator.
 * @returns "any"
 *          The current element of the specified iterator.
 * @raises "exhausted-iterator exception"
 *         If the iterator is exhausted.
 */
Method "_'s⁇current element" is
[
	anIterator : iterator
|
	Unless anIterator is exhausted then
	[
		private anIterator's current element
	]
	else
	[
		Raise an exhausted-iterator exception
	]
] : any;

Semantic restriction "_'s⁇current element" is
[
	iteratorType : iterator's type
|
	iteratorType's element type's instance
];

/**
 * Define a method to provide the current element of a non-exhausted iterator.
 * The public operation, {@"_'s⁇current element"}, does not permit extension (to
 * ensure that iterators are always checked for exhaustion), but the private
 * operation should not be called directly from client code. This special
 * defining method allows the private operation to be overridden for specific
 * iterator implementations without exposing it for direct use. These mechanisms
 * cooperate to ensure that iterator exhaustion checking is never bypassed.
 *
 * @method "_'s⁇current element method is_"
 * @param "iteratorType" "iterator's type"
 *        The iterator's type, as a cross check for the implementation.
 * @param "implementation" "[⊥]→any"
 *        The new method extension.
 */
Public method "_'s⁇current element method is_" is
[
	iteratorType : iterator's type,
	implementation : [⊥]→any
|
	Private method privateCurrentElementName is implementation;
] : ⊤;

Semantic restriction "_'s⁇current element method is_" is
[
	iteratorMeta : iterator's type's type,
	implementationType : [⊥]→any's type
|
	If implementationType[1] = ⊥ then
	[
		Reject parse, expected:
			"function's parameter types to be statically known"
	];
	If ¬implementationType[1] ⊆ iteratorMeta's instance then
	[
		Reject parse, expected:
			"function parameter type ("
			++ “implementationType[1]”
			++ ") to be a subtype of the iterator type ("
			++ “iteratorMeta's instance”
			++ ")"
	];
	⊤
];

Private abstract method privateAdvanceName is [iterator]→⊤;

/**
 * Ensure that the specified iterator is not exhausted, then advance its state.
 *
 * @method "Advance_"
 * @param "anIterator" "iterator"
 *        An iterator.
 * @raises "exhausted-iterator exception"
 *         If the iterator is exhausted.
 */
Method "Advance_" is
[
	anIterator : iterator
|
	Unless anIterator is exhausted then
	[
		Private advance anIterator;
	]
	else
	[
		Raise an exhausted-iterator exception
	];
] : ⊤;

/**
 * Define a method to advance the state of a non-exhausted iterator. The public
 * operation, {@"Advance_"}, does not permit extension (to ensure that iterators
 * are always checked for exhaustion), but the private operation should not be
 * called directly from client code. This special defining method allows the
 * private operation to be overridden for specific iterator implementations
 * without exposing it for direct use. These mechanisms cooperate to ensure that
 * iterator exhaustion checking is never bypassed.
 *
 * @method "_'s⁇advance method is_"
 * @param "iteratorType" "iterator's type"
 *        The iterator's type, as a cross check for the implementation.
 * @param "implementation" "[⊥]→⊤"
 *        The new method extension.
 */
Public method "_'s⁇advance method is_" is
[
	iteratorType : iterator's type,
	implementation : [⊥]→⊤
|
	Private method privateAdvanceName is implementation;
] : ⊤;

Semantic restriction "_'s⁇advance method is_" is
[
	iteratorMeta : iterator's type's type,
	implementationType : [⊥]→⊤'s type
|
	If implementationType[1] = ⊥ then
	[
		Reject parse, expected:
			"function's parameter types to be statically known"
	];
	If ¬implementationType[1] ⊆ iteratorMeta's instance then
	[
		Reject parse, expected:
			"function parameter type ("
			++ “implementationType[1]”
			++ ") to be a subtype of the iterator type ("
			++ “iteratorMeta's instance”
			++ ")"
	];
	⊤
];

/**
 * An exhausted iterator has ⊥ as its element type.
 *
 * @type "exhausted iterator"
 */
Public explicit class "exhausted iterator" extends iterator
	with fields
		element type : ⊥'s type;

/**
 * Answer {@code true}.
 *
 * @method "_is exhausted"
 * @param "anIterator" "exhausted iterator"
 *        An exhausted iterator.
 * @returns {@code true}.
 */
Method "_is exhausted" is
[
	anIterator : exhausted iterator
|
	true
] : true's type;

/**
 * Raise an `exhausted-iterator exception`.
 *
 * @method "_s⁇current element"
 * @param "anIterator" "exhausted iterator"
 *        An exhausted iterator.
 * @raises "exhausted-iterator exception"
 *         Always.
 */
Method "_s⁇current element" is
[
	anIterator : exhausted iterator
|
	Raise an exhausted-iterator exception
] : ⊥;

Semantic restriction "_s⁇current element" is
[
	iteratorType : exhausted iterator's type
|
	Reject parse, expected:
		"an exhausted iterator not to be asked for its current element"
];

/**
 * Raise an `exhausted-iterator exception`.
 *
 * @method "Advance_"
 * @param "anIterator" "exhausted iterator"
 *        An exhausted iterator.
 * @raises "exhausted-iterator exception"
 *         Always.
 */
Method "Advance_" is
[
	anIterator : exhausted iterator
|
	Raise an exhausted-iterator exception
] : ⊥;

Semantic restriction "Advance_" is
[
	iteratorType : exhausted iterator's type
|
	Reject parse, expected:
		"an exhausted iterator not to be asked to advance"
];

theExhaustedIterator ::= an exhausted iterator with element type := ⊥;

/**
 * Answer an {@type "exhausted iterator"}.
 *
 * @method "an exhausted iterator"
 * @returns "exhausted iterator"
 *          An exhausted iterator.
 */
Public method "an exhausted iterator" is [ theExhaustedIterator ];
Grammatical restriction "a|an_«with«_:=_‡,»»"
	is <{"exhausted iterator"}, ∅, ∅>;

/* Seal the public operations. */
Seal method "_is exhausted" at <exhausted iterator>;
Seal method "_'s⁇current element" at <iterator>;
Seal method "Advance_" at <iterator>;

/**
 * Iteratively apply {@param "action"} to each consecutive element of {@param
 * "anIterator"}.
 *
 * @method "For each_do_"
 * @param "anIterator" "iterator"
 *        An iterator.
 * @param "action" "[⊥]→⊤"
 *        A function that accepts the elements of the iterator.
 */
Method "For each_do_" is
[
	anIterator : iterator,
	action : [⊥]→⊤
|
	Until [ anIterator is exhausted ]
	do
	[
		Invoke action with <anIterator's current element>;
		Advance anIterator;
	];
] : ⊤;

/**
 * Helper method for semantic restrictions: If `action` does not accept the
 * element type of `iteratorType`, then reject the current parse.
 *
 * @method "Require:_accepts_"
 * @param "action" "[⊥]→⊤'s type"
 *        A function type whose sole parameter must correspond to the element
 *        type of `iteratorType`.
 * @param "iteratorType" "iterator's type"
 *        An iterator type.
 */
Method "Require:_accepts_" is
[
	actionType : [⊥]→⊤'s type,
	iteratorType : iterator's type
|
	elementType ::= iteratorType's element type's instance;
	If actionType[1] ≠ ⊥ ∧ [ ¬elementType ⊆ actionType[1] ] then
	[
		Reject parse, expected:
			format
				"repeatedly applied function to accept all elements ∈ ‘①’ \
				\|of the iterator (but it only accepts ‘②’)"
			with elementType, actionType[1]
	];
] : ⊤;

Semantic restriction "For each_do_" is
[
	iteratorType : iterator's type,
	actionType : [⊥]→⊤'s type
|
	Require: actionType accepts iteratorType;
	⊤
];

/**
 * {@method "map_through_"} produces mapped iterators. A mapped iterator
 * decorates another iterator and retains a transformer function. When it is
 * asked for its current element, it answers the result of applying the function
 * to the current element of the decorated iterator.
 *
 * @type "mapped iterator"
 * @subtype "iterator"
 */
Class "mapped iterator" extends iterator
	with fields
		decorated iterator : iterator,
		transformer : [⊥]→any;

Method "_is exhausted" is
[
	anIterator : mapped iterator
|
	anIterator's decorated iterator is exhausted
] : boolean;

mapped iterator's current element method is
[
	anIterator : mapped iterator
|
	invoke anIterator's transformer
		with <anIterator's decorated iterator's current element>
] : any;

mapped iterator's advance method is
[
	anIterator : mapped iterator
|
	Advance anIterator's decorated iterator;
] : ⊤;

/**
 * Construct and answer an iterator that applies {@param "theTransformer"} to
 * the consecutive elements of {@param "anIterator"}. The result is lazy, so
 * {@param "anIterator"} may be infinite.
 *
 * @method "map_through_"
 * @param "anIterator" "iterator"
 *        The source {@type "iterator"}.
 * @param "theTransformer" "[⊥]→any"
 *        A function that accepts the elements of {@param "anIterator"}.
 * @returns "iterator"
 *          An iterator that applies {@param "theTransformer"} to the current
 *          element of {@param "anIterator"} when asked for its own current
 *          element.
 */
Method "map_through_" is
[
	anIterator : iterator,
	theTransformer : [⊥]→any
|
	a mapped iterator with
		element type := theTransformer's type's return type,
		decorated iterator := anIterator,
		transformer := theTransformer
] : iterator;

Semantic restriction "map_through_" is
[
	iteratorType : iterator's type,
	transformerType : [⊥]→any's type
|
	Require: transformerType accepts iteratorType;
	extend iterator with element type : transformerType's return type's type
];

/**
 * {@method "filter_by_"} produces filtered iterators. A filtered iterator
 * decorates another iterator and retains a filter function. When asked for its
 * current element, it answers the first element of the decorated iterator that
 * satisfies the filter function.
 *
 * @type "filtered iterator"
 * @subtype "iterator"
 */
Class "filtered iterator" extends iterator
	with fields
		decorated iterator : iterator,
		filter : [⊥]→boolean;

Method "_is exhausted" is
[
	anIterator : filtered iterator
|
	found : boolean := false;
	inner ::= anIterator's decorated iterator;
	Until [found ∨ [inner is exhausted]]
	do
	[
		If invoke anIterator's filter with <inner's current element> then
		[
			found := true;
		]
		else
		[
			Advance inner;
		];
	];
	¬found
] : boolean;

filtered iterator's current element method is
[
	anIterator : filtered iterator
|
	/* The current element of the decorated iterator must satisfy the filter.
	 * This is ensured by "_is exhausted".
	 */
	anIterator's decorated iterator's current element
] : any;

filtered iterator's advance method is
[
	anIterator : filtered iterator
|
	/* Unconditionally advance the decorated iterator. "_is exhausted" will
	 * determine if there is actually another element that passes the filter.
	 */
	Advance anIterator's decorated iterator;
] : ⊤;

/**
 * Construct and answer an iterator that applies {@param "predicate"} to an
 * {@param "anIterator"}. The result is lazy, so {@param "anIterator"} may be
 * infinite. The result contains only those elements of {@param "anIterator"}
 * that pass the specified filter.
 *
 * Note that {@method "_is exhausted"} may require an infinite amount of time to
 * complete when presented with an infinite filtered iterator, e.g., consider
 * the case of:
 *
 * <pre>
 *     filter iterator from 1 to ∞ by [ x : natural number | x < 10 ]
 * </pre>
 *
 * Which will require infinite computation after advancing beyond the element
 * {@code 10}.
 *
 * @method "filter_by_"
 * @param "anIterator" "iterator"
 *        An {@type "iterator"}.
 * @param "predicate" "[⊥]→boolean"
 *        A function that accepts the elements of {@param "anIterator"} and
 *        answers {@code true} iff they should be obtainable via the result
 *        iterator.
 * @returns "iterator"
 *          An iterator capable of producing exactly those elements of {@param
 *          "anIterator"} for which {@param "predicate"} answers {@code true}.
 */
Method "filter_by_" is
[
	anIterator : iterator,
	predicate : [⊥]→boolean
|
	a filtered iterator with
		element type := anIterator's element type,
		decorated iterator := anIterator,
		filter := predicate
] : iterator;

Semantic restriction "filter_by_" is
[
	iteratorType : iterator's type,
	predicateType : [⊥]→boolean's type
|
	Require: predicateType accepts iteratorType;
	extend iterator with element type : iteratorType's element type
];

/**
 * A concatenation iterator produces values from a sequenced collection of
 * iterators.
 *
 * @type "concatenation iterator"
 * @subtype "iterator"
 */
Class "concatenation iterator" extends iterator
	with fields
		decorated iterators : <iterator…|>,
		iterator index : ↑natural number;

Method "_is exhausted" is
[
	anIterator : concatenation iterator
|
	index : ↑natural number := anIterator's iterator index;
	iterators ::= anIterator's decorated iterators;
	limit ::= |iterators|;
	While [↓index ≤ limit ∧ [iterators[↓index] is exhausted]]
	do
	[
		index++;
	];
	↓index > limit
] : boolean;

concatenation iterator's current element method is
[
	anIterator : concatenation iterator
|
	inner ::= anIterator's decorated iterators[↓anIterator's iterator index];
	inner's current element
] : any;

concatenation iterator's advance method is
[
	anIterator : concatenation iterator
|
	index ::= ↓anIterator's iterator index;
	iterators ::= anIterator's decorated iterators;
	Advance iterators[index];
] : ⊤;

/**
 * Construct and answer an {@type "iterator"} that produces values from the
 * specified tuple of iterators The result first produces the values of the
 * first element of the tuple, then the second, etc.
 *
 * @method "concatenate_"
 * @param "iterators" "<iterator…|>"
 *        A tuple of iterators.
 * @returns "iterator"
 *          The requested iterator.
 */
Method "concatenate_" is
[
	iterators : <iterator…|>
|
	if |iterators| = 0 then [ an exhausted iterator ]
	else if [ |iterators| = 1 ] then [ iterators[1] ]
	else
	[
		elementType ::=
			cast ∪ map iterators through [i : iterator | i's element type]
			into [t : any's type | t];
		var ::= cast (new ↑natural number := 1) into [t : ↑natural number | t];
		a concatenation iterator with
			element type := elementType,
			decorated iterators := iterators,
			iterator index := var
	]
] : iterator;

/**
 * Construct and answer an {@type "iterator"} that produces values from the
 * specified tuple of iterators The result first produces the values of the
 * first lexical argument, then the second, etc.
 *
 * @method "«_‡++»"
 * @param "iterators" "<iterator…|>"
 *        A tuple of iterators.
 * @returns "iterator"
 *          The requested iterator.
 */
Method "«_‡++»" is
[
	iterators : <iterator…|2..>
|
	elementType ::=
		cast ∪ map iterators through [i : iterator | i's element type]
		into [t : any's type | t];
	var ::= cast (new ↑natural number := 1) into [t : ↑natural number | t];
	a concatenation iterator with
		element type := elementType,
		decorated iterators := iterators,
		iterator index := var
];

/**
 * Answer a function suitable for use as a semantic restriction for the
 * {@method "concatenate_"} and {@method "«_‡++»"} methods.
 *
 * @returns "[<stream…|>'s type]→(concatenation iterator's type)"
 *          The requested function.
 */
Private method "concatenation semantic restriction" is
[
	[
		iterators : <iterator…|>'s type
	|
		elementType : any's type's type := ⊥;
		From 1 to (⎣iterators⎦ min (|iterators' leading types| + 1)) do
		[
			index : natural number
		|
			elementType := eject ↑elementType ∪ iterators[index]'s element type;
		];
		extend concatenation iterator with
			element type : elementType,
			decorated iterators : iterators
	]
];

Semantic restriction "concatenate_" is concatenation semantic restriction;
Semantic restriction "«_‡++»" is concatenation semantic restriction;
