/*
 * UTF8 Codec.avail
 * Copyright © 1993-2013, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "UTF-8 Codec"
Versions
	"dev"
Uses
	"Abstract Codecs",
	"Foundation",
	"Iterators"
Names
/* TODO: Exports */
Body

/**
 * Transfor a contination byte according to UTF-8 specification
 *
 * @method "transform_ as acontinuation byte"
 * @categories "Codec"
 * @param "continuationByte" "byte" 
 *      a continuation byte with leading bits 10
 * @returnType "byte"
 *      the transformed byte
 * @author "Richard Arriaga"
 */
Private method "transform_as a UTF8 continuation byte" is
[
	continuationByte : byte
 |
	63 bit∧ continuationByte
]:byte;


/**
 * Abstract method that covers all UTF-8 decoding byte codes for all byte sizes.  
 * Transforms the input bytes using the appropriate tranformation function to 
 * generate a unicode code point to obtain unicode character.
 *
 * @method "decode_from_"
 * @categories "Codec"
 * @param "bytesExpected" "[1..4]" 
 *      the number of bytes that will appear in the byte tuple.  The purpose
 *      of this input is for the sake of optimization.  It allows the optimizer
 *      to know exactly which method to dispatch.
 * @param "accumulator" "<byte…|..4>"
 * 		the tuple containing the bytes to be transformed into a code point
 * @returnType "character"
 *      the unicode character represented by the code point
 * @author "Richard Arriaga"
 */
Private abstract  method "decode_from_" is [[1..4],<byte…|1..4>]→character;

/**
 * This method defines the decoding of the UTF-8 single byte code.  This is for
 * the range [0..127], the ASCII characters.  The left most bit in the
 * byte must be 0 as this is the only byte code whose leading byte is the only
 * byte.
 *
 * @method "decode_from_"
 * @categories "Codec"
 * @param "bytesExpected" "1's type" 
 *      only 1 byte is expected in the accumulator
 * @param "accumulator" "<byte…|..4>"
 * 		the tuple containing the bytes to be transformed into a code point
 * @returnType "character"
 *      the unicode character represented by the code point
 * @author "Richard Arriaga"
 */
Method "decode_from_" is
[
	bytesExpected : 1's type,
	accumulator : <byte…|1..4>
 |
	accumulator[1] → character
]:character;

/**
 * This method defines the decoding of the UTF-8 two byte code.  This is for
 * the range [128..2047].  The leading byte starts with the left most bits
 * as 110xxxxx, where "x" indicates bits of the code point.
 *
 * @method "decode_from_"
 * @categories "Codec"
 * @param "bytesExpected" "2's type" 
 *      2 bytes are expected in the accumulator
 * @param "accumulator" "<byte…|..4>"
 * 		the tuple containing the bytes to be transformed into a code point
 * @returnType "character"
 *      the unicode character represented by the code point
 * @author "Richard Arriaga"
 */
Method "decode_from_" is
[
	bytesExpected : 2's type,
	accumulator : <byte…|1..4>
 |
	leadingByte : byte := 31 bit∧ accumulator[1];
	secondByte : byte := transform accumulator[2] as a UTF8 continuation byte;
	leadingByte << 6 + secondByte → character
]:character;

/**
 * This method defines the decoding of the UTF-8 three byte code.  This is for
 * the range [2048..65534].  The leading byte starts with the left most bits
 * as 1110xxxx, where "x" indicates bits of the code point.
 *
 * @method "decode_from_"
 * @categories "Codec"
 * @param "bytesExpected" "3's type" 
 *      3 bytes are expected in the accumulator
 * @param "accumulator" "<byte…|..4>"
 * 		the tuple containing the bytes to be transformed into a code point
 * @returnType "character"
 *      the unicode character represented by the code point
 * @author "Richard Arriaga"
 */
Method "decode_from_" is
[
	bytesExpected : 3's type,
	accumulator : <byte…|1..4>
 |
	/*TODO handle errors for D800 to DFFF*/
	leadingByte : byte := 15 bit∧ accumulator[1];
	secondByte : byte := transform accumulator[2] as a UTF8 continuation byte;
	thirdByte : byte := transform accumulator[3] as a UTF8 continuation byte;
	leadingByte << 12 + secondByte << 6 + thirdByte → character
]:character;

/**
 * This method defines the decoding of the UTF-8 four byte code.  This is for
 * the range [65536..1114111].  The leading byte starts with the left most bits
 * as 11110xxx, where "x" indicates bits of the code point.
 *
 * @method "decode_from_"
 * @categories "Codec"
 * @param "bytesExpected" "4's type" 
 *      4 bytes are expected in the accumulator
 * @param "accumulator" "<byte…|..4>"
 * 		the tuple containing the bytes to be transformed into a code point
 * @returnType "character"
 *      the unicode character represented by the code point
 * @author "Richard Arriaga"
 */
Method "decode_from_" is
[
	bytesExpected : 4's type,
	accumulator : <byte…|1..4>
 |
	leadingByte : byte := 7 bit∧ accumulator[1];
	secondByte : byte := transform accumulator[2] as a UTF8 continuation byte;
	thirdByte : byte := transform accumulator[3] as a UTF8 continuation byte;
	fourthByte : byte := transform accumulator[4] as a UTF8 continuation byte;
	lookup: [0..1114111] := cast ((leadingByte << 18) + (secondByte << 12) + 
		(thirdByte << 6) + fourthByte) into [a : [0..1114111] | a];
	lookup → character
]:character;

/**
 * This method defines the encoding of the UTF-8 ascii character.  This is for
 * the code point range [0..127].  The left most bit in the resultant byte will 
 * be 0 as this is the only byte code whose leading byte is the only byte.
 *
 * @method "encode_"
 * @categories "Codec"
 * @param "ascii" "[0..127]"
 * 		the ascii unicode code point
 * @returnType "[0..127]"
 *      the UTF-8 encoded character byte
 * @author "Richard Arriaga"
 */
Method "encode_" is
[
	cp : [0..127]
 |
	cp
]:[0..127];

/**
 * This method defines the encoding of the UTF-8 two byte code.  This is for
 * the range [128..2047].  The leading byte starts with the left most bits
 * as 110xxxxx, where "x" indicates bits of the code point.  Continuation bytes
 * take the form 10xxxxxx.  The resulting form of this encoding is
 * 110xxxxx10xxxxxx
 *
 * @method "encode_"
 * @categories "Codec"
 * @param "cp" "[128..2047]"
 * 		the unicode code point
 * @returnType "[49280..57279]"
 *      the UTF-8 encoded character bytes (2 bytes)
 * @author "Richard Arriaga"
 */
Method "encode_" is
[
	cp : [128..2047]
 |
	/*TODO Implement me*/
 57278
]:[49280..57279];

/**
 * This method defines the encoding of the UTF-8 three byte code.  This is for
 * the range [2048..65534].  The leading byte starts with the left most bits
 * as 110xxxxx, where "x" indicates bits of the code point.  Continuation bytes
 * take the form 10xxxxxx.  The resulting form of this encoding is
 * 1110xxxx10xxxxxx10xxxxxx
 *
 * @method "encode_"
 * @categories "Codec"
 * @param "cp" "[2048..65534]"
 * 		the unicode code point
 * @returnType "[14712960..15712191]"
 *      the UTF-8 encoded character bytes (3 bytes)
 * @author "Richard Arriaga"
 */
Method "encode_" is
[
	cp : [2048..65534]
|
	/*TODO Implement me.  Exception for [55296..57343] as surrogate*/
15712190
]:[14712960..15712191];

/**
 * This method defines the decoding of the UTF-8 four byte code.  This is for
 * the range [65536..1114111].  The leading byte starts with the left most bits
 * as 110xxxxx, where "x" indicates bits of the code point.  Continuation bytes
 * take the form 10xxxxxx.  The resulting form of this encoding is
 * 11110xxx10xxxxxx10xxxxxx10xxxxxx
 *
 * @method "encode_"
 * @categories "Codec"
 * @param "cp" "[65536..1114111]"
 * 		the unicode code point
 * @returnType "[4034953344..4156538815]"
 *      the UTF-8 encoded character bytes (4 bytes)
 * @author "Richard Arriaga"
 */
Method "encode_" is
[
	cp : [65536..1114111]
|
	/*TODO Implement me.*/
4156538814
]:[4034953344..4156538815];