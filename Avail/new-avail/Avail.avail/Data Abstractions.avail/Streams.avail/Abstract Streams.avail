/*
 * Abstract Streams.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Abstract Streams"
Versions
	"dev"
Extends
	"Common",
	"Foundation" =
	(
		"For each of⁇_do_",
		"concatenate_",
		"drop from_until_",
		"drop from_while_",
		"filter_by_",
		"map_through_",
		"take from_until_",
		"take from_while_",
		"zip_",
		"_is empty",
		"_starts with_",
		"_'s⁇head",
		"_'s⁇tail",
		"«_‡zip»",
		"«_‡++»"
	)
Uses
	"Foundation"
Names
	"an empty stream",
	"decorated stream|streams",
	"drop«at most»?_from_",
	"empty stream",
	"empty-stream exception",
	"stream",
	"stream of_",
	"take«at most»?_from_",
	"_'s⁇head method is_",
	"_'s⁇tail method is_"

	/* We don't include "_'s⁇element type" here because it already exists (as
	 * a method on set types).
	 */
Body

/* TODO: [TLS] Remove these constants once a macro is available for "$…". */
privateHeadName ::= $"private_'s⁇head";
privateTailName ::= $"private_'s⁇tail";
decoratedStream ::= $"decorated stream|streams";
transformer ::= $"transformer";
filter ::= $"filter";
streamIndex ::= $"stream index";

/**
 * Answer the field atom that represents a decorated stream.
 *
 * Returns:
 *    The requested field atom.
 */
Public method "decorated stream|streams" is [ decoratedStream ];

/**
 * Answer the field atom that represents the stream index of a concatenation
 * stream.
 * 
 * Returns:
 *    The requested field atom.
 */
Method "stream index" is [ streamIndex ];

/**
 * A stream is an immutable lazy list of arbitarily many elements.
 */
Public explicit class "stream" extends object
	with fields
		element type : any's type;

/**
 * Construct and answer a stream type that answers values of the specified type.
 * 
 * Parameters:
 *    elementType - The type of value produced by streams of the answered type.
 * Returns:
 *    The requested stream type.
 */
Public method "stream of_" is
[
	elementType : any's type
|
	extend stream with element type : elementType's type
] : stream's type;

/**
 * An empty-stream exception is raised when an inappropriate operation, like
 * `_'s⁇head` and `_'s⁇tail`, is performed on an empty stream.
 */
Public explicit class "empty-stream exception" extends exception;

/**
 * Is the specified stream empty?
 * 
 * Parameters:
 *    aStream - A stream.
 * Returns:
 *    `true` if the argument is empty, `false` otherwise.
 */
Abstract method "_is empty" is [stream]→boolean;

/**
 * Answer the first element of the specified nonempty stream.
 * 
 * Parameters:
 *    aStream - A nonempty stream.
 * Returns:
 *    The first element of the specified stream.
 */
Private abstract method privateHeadName is [stream]→any;

/**
 * Ensure that the specified stream is not empty, then answer its first element.
 * 
 * Parameters:
 *    aStream - A stream.
 * Returns:
 *    The first element of the specified stream.
 * Raises:
 *    {@"empty-stream exception"} - If the stream is empty.
 */
Method "_'s⁇head" is
[
	aStream : stream
|
	Unless aStream is empty then
	[
		private aStream's head
	]
	else
	[
		Raise an empty-stream exception
	]
] : any;

Semantic restriction "_'s⁇head" is
[
	streamType : stream's type
|
	streamType's element type's instance
];

/**
 * Define a method to provide the head of a nonempty stream. The public
 * operation, {@"_'s⁇head"}, does not permit extension (to ensure that streams
 * are always checked for exhaustion), but the private operation should not be
 * called directly from client code. This special defining method allows the
 * private operation to be overridden for specific stream implementations
 * without exposing it for direct use. These mechanisms cooperate to ensure that
 * stream exhaustion checking is never bypassed.
 *
 * Parameters:
 *    streamType - The stream's type, as a cross check for the implementation.
 *    implementation - The new method extension.
 */
Public method "_'s⁇head method is_" is
[
	streamType : stream's type,
	implementation : [⊥]→any
|
	Private method privateHeadName is implementation;
] : ⊤;

/**
 * Ensure that the implementation function accepts a stream.
 */
Semantic restriction "_'s⁇head method is_" is
[
	streamMeta : stream's type's type,
	implementationType : [⊥]→any's type
|
	If implementationType[1] = ⊥ then
	[
		Reject parse, expected:
			"function's parameter types to be statically known"
	];
	If ¬implementationType[1] ⊆ streamMeta's instance then
	[
		Reject parse, expected:
			"function parameter type ("
			++ “implementationType[1]”
			++ ") to be a subtype of the stream type ("
			++ “streamMeta's instance”
			++ ")"
	];
	⊤
];

/**
 * Construct and answer a stream that contains all but the first element of the
 * specified nonempty stream.
 * 
 * Parameters:
 *    aStream - A nonempty stream.
 * Returns:
 *    The requested stream.
 */
Private abstract method privateTailName is [stream]→stream;

/**
 * Ensure that the specified stream is not empty, then construct and answer a
 * stream that contains all but the first element of the specified nonempty
 * stream.
 * 
 * Parameters:
 *    aStream - A stream.
 * Returns:
 *    The requested stream.
 * Raises:
 *    {@"empty-stream exception"} - If the stream is empty.
 */
Method "_'s⁇tail" is
[
	aStream : stream
|
	Unless aStream is empty then
	[
		private aStream's tail
	]
	else
	[
		Raise an empty-stream exception
	]
] : stream;

Semantic restriction "_'s⁇tail" is
[
	streamType : stream's type
|
	streamType
];

/**
 * Define a method to provide the tail of a nonempty stream. The public
 * operation, {@"_'s⁇tail"}, does not permit extension (to ensure that streams
 * are always checked for exhaustion), but the private operation should not be
 * called directly from client code. This special defining method allows the
 * private operation to be overridden for specific stream implementations
 * without exposing it for direct use. These mechanisms cooperate to ensure that
 * stream exhaustion checking is never bypassed.
 * 
 * Parameters:
 *    streamType - The stream's type, as a cross check for the implementation.
 *    implementation - The new method extension.
 */
Public method "_'s⁇tail method is_" is
[
	streamType : stream's type,
	implementation : [⊥]→stream
|
	Private method privateTailName is implementation;
] : ⊤;

/**
 * Ensure that the implementation function accepts a stream.
 */
Semantic restriction "_'s⁇tail method is_" is
[
	streamMeta : stream's type's type,
	implementationType : [⊥]→stream's type
|
	If implementationType[1] = ⊥ then
	[
		Reject parse, expected:
			"function's parameter type to be statically known"
	];
	If ¬implementationType[1] ⊆ streamMeta's instance then
	[
		Reject parse, expected:
			"function parameter type ("
			++ “implementationType[1]”
			++ ") to be a subtype of the stream type ("
			++ “streamMeta's instance”
			++ ")"
	];
	⊤
];

/**
 * An empty stream has ⊥ as its element type.
 */
Public explicit class "empty stream" extends stream
	with fields
		element type : ⊥'s type;

/**
 * Answer `true`.
 * 
 * Parameters:
 *    aStream - An empty stream.
 * Returns:
 *    `true`.
 */
Method "_is empty" is
[
	aStream : empty stream
|
	true
] : true's type;

/**
 * Raise an `empty-stream exception`.
 * 
 * Parameters:
 *    aStream - An empty stream.
 */
Method "_'s⁇head" is
[
	aStream : empty stream
|
	Raise an empty-stream exception
] : ⊥;

Semantic restriction "_'s⁇head" is
[
	streamType : empty stream's type
|
	Reject parse, expected:
		"an empty stream not to be asked for its head"
];

/**
 * Raise an `empty-stream exception`.
 * 
 * Parameters:
 *    aStream - An empty stream.
 */
Method "_'s⁇tail" is
[
	aStream : empty stream
|
	Raise an empty-stream exception
] : ⊥;

Semantic restriction "_'s⁇tail" is
[
	streamType : empty stream's type
|
	Reject parse, expected:
		"an empty stream not to be asked for its tail"
];

theEmptyStream ::= an empty stream with element type := ⊥;

/**
 * Answer an empty stream.
 * 
 * Returns:
 *    An empty stream.
 */
Public method "an empty stream" is [ theEmptyStream ];
Grammatical restriction "a|an_«with«_:=_‡,»»" is <{"empty stream"}, ∅, ∅>;

/* Seal the public operations. */
Seal method "_is empty" at <empty stream>;
Seal method "_'s⁇head" at <stream>;
Seal method "_'s⁇tail" at <stream>;

/**
 * Iteratively apply `action` to each consecutive element of `aStream`.
 * 
 * Parameters:
 *    aStream - A stream.
 *    action - A function that accepts the elements of the stream.
 */
Method "For each of⁇_do_" is
[
	aStream : stream,
	action : [⊥]→⊤
|
	rest : stream := aStream;
	Until [ rest is empty ]
	do
	[
		action(rest's head);
		rest := eject ↑rest's tail;
	];
] : ⊤;

/**
 * Helper method for semantic restrictions: If `action` does not accept the
 * element type of `streamType`, then reject the current parse.
 * 
 * Parameters:
 *    action - A function type whose sole parameter must correspond to the
 *       element type of `streamType`.
 *    streamType - A stream type.
 */
Method "Require:_accepts_" is
[
	actionType : [⊥]→⊤'s type,
	streamType : stream's type
|
	elementType ::= streamType's element type's instance;
	If actionType[1] ≠ ⊥ ∧ [ ¬elementType ⊆ actionType[1] ] then
	[
		Reject parse, expected:
			format
				"repeatedly applied function to accept all elements ∈ “①” \
				\|of the stream (but it only accepts “②”)"
			with elementType, actionType[1]
	];
] : ⊤;

Semantic restriction "For each of⁇_do_" is
[
	streamType : stream's type,
	actionType : [⊥]→⊤'s type
|
	Require: actionType accepts streamType;
	⊤
];

/**
 * `map_through_` produces mapped streams. A mapped stream decorates another
 * stream and retains a transformer function. When it is asked for its head,
 * it answers the result of applying the function to the head of the decorated
 * stream.
 */
Class "mapped stream" extends stream
	with fields
		decorated stream : stream,
		transformer : [⊥]→any;

Method "_is empty" is
[
	aStream : mapped stream
|
	aStream's decorated stream is empty
] : boolean;

mapped stream's head method is
[
	aStream : mapped stream
|
	aStream's transformer(aStream's decorated stream's head)
] : any;

mapped stream's tail method is
[
	aStream : mapped stream
|
	a mapped stream with
		element type := aStream's element type,
		decorated stream := aStream's decorated stream's tail,
		transformer := aStream's transformer
] : mapped stream;

/**
 * Construct and answer a stream that applies `theTransformer` to the
 * consecutive elements of `aStream`. The result is lazy, so `aStream` may be
 * infinite.
 * 
 * Parameters:
 *    aStream - The source stream.
 *    theTransformer - A function that accepts the elements of `aStream`.
 * Returns:
 *    A stream that applies `transformer` to the head of `aStream` when asked
 *    for its own head.
 */
Method "map_through_" is
[
	aStream : stream,
	theTransformer : [⊥]→any
|
	a mapped stream with
		element type := theTransformer's type's return type,
		decorated stream := aStream,
		transformer := theTransformer
] : stream;

Semantic restriction "map_through_" is
[
	streamType : stream's type,
	transformerType : [⊥]→any's type
|
	Require: transformerType accepts streamType;
	extend stream with element type : transformerType's return type's type
];

/**
 * `filter_by_` produces filtered streams. A filtered stream decorates another
 * stream and retains a filter function. When it is asked for its head,
 * it answers the first element of the decorated stream that satisfies the
 * filter function.
 */
Class "filtered stream" extends stream
	with fields
		decorated stream : stream,
		filter : [⊥]→boolean;

/**
 * A headed filtered stream is a filtered stream that has already been forwarded
 * to the next element that passes the filter.
 */
Explicit class "headed filtered stream" extends filtered stream;

Method "_is empty" is
[
	aStream : filtered stream
|
	found : boolean := false;
	rest : stream := aStream's decorated stream;
	Until [ found ∨ [ rest is empty ] ]
	do
	[
		If aStream's filter(rest's head) then
		[
			found := true;
		];
		rest := eject ↑rest's tail;
	];
	¬found
] : boolean;

filtered stream's head method is
[
	aStream : filtered stream
|
	/* There is guaranteed to be a satisfactory element remaining. */
	rest : stream := aStream's decorated stream;
	Until [ aStream's filter(rest's head) ]
	do
	[
		rest := eject ↑rest's tail;
	];
	rest's head
] : any;

filtered stream's tail method is
[
	aStream : filtered stream
|
	/* There is guaranteed to be a satisfactory element remaining. */
	rest : stream := aStream's decorated stream;
	Until [ aStream's filter(rest's head) ]
	do
	[
		rest := eject ↑rest's tail;
	];
	rest := eject ↑rest's tail;
	If rest is empty then [ an empty stream ]
	else
	[
		streamType ::= if aStream's filter(rest's head)
			then [ headed filtered stream]
			else [ filtered stream ];
		a streamType with
			element type := aStream's element type,
			decorated stream := rest,
			filter := aStream's filter
	]
] : stream;

headed filtered stream's head method is
[
	aStream : headed filtered stream
|
	aStream's decorated stream's head
] : any;

/**
 * Construct and answer a stream that applies `predicate` to `aStream`. The
 * result is lazy, so `aStream` may be infinite. The result contains only those
 * elements of `aStream` that pass the specified filter.
 *
 * Note that the public stream operations may require an infinite amount of time
 * to complete when presented with an infinite filtered stream, e.g., consider
 * that case of:
 *
 *    filter stream from 1 to ∞ by [ x : natural number | x < 10 ]
 *
 * Which will require infinite computation after advancing beyond the element
 * `10`.
 *
 * Also, filtered streams are slow in general (because they must rescan for each
 * public operation). Consider using filtered iterators instead.
 *
 * Parameters:
 *    aStream - The source stream.
 *    predicate - A function that accepts the elements of `aStream` and answers
 *       `true` iff they should be obtainable via the result stream.
 * Returns:
 *    A stream capable of producing exactly those elements of `aStream` for
 *    which `predicate` answers `true`.
 */
Method "filter_by_" is
[
	aStream : stream,
	predicate : [⊥]→boolean
|
	a filtered stream with
		element type := aStream's element type,
		decorated stream := aStream,
		filter := predicate
] : stream;

Semantic restriction "filter_by_" is
[
	streamType : stream's type,
	predicateType : [⊥]→boolean's type
|
	Require: predicateType accepts streamType;
	extend stream with element type : streamType's element type
];

/**
 * A concatenation stream produces values from a sequenced collection of
 * streams.
 */
Class "concatenation stream" extends stream
	with fields
		decorated streams : <stream…|>,
		stream index : natural number;

Method "_is empty" is
[
	aStream : concatenation stream
|
	index ::= aStream's stream index;
	streams ::= aStream's decorated streams;
	each of streams[index..] satisfies [s : stream | s is empty]
] : boolean;

concatenation stream's head method is
[
	aStream : concatenation stream
|
	index : natural number := aStream's stream index;
	streams ::= aStream's decorated streams;
	While [ streams[index] is empty ] do [ ↑index++; ];
	streams[index]'s head
];

concatenation stream's tail method is
[
	aStream : concatenation stream
|
	index : natural number := aStream's stream index;
	streams ::= aStream's decorated streams;
	While [ streams[index] is empty ] do [ ↑index++; ];
	a concatenation stream with
		element type := aStream's element type,
		decorated streams := streams[index]→(streams[index]'s tail),
		stream index := index
];

/**
 * Construct and answer a stream that produces values from the specified tuple
 * of streams. The result first produces the values of the first element of the
 * tuple, then the second, etc.
 * 
 * Parameters:
 *    streams - A tuple of streams.
 * Returns:
 *    The requested stream.
 */
Method "concatenate_" is
[
	streams : <stream…|>
|
	if |streams| = 0 then [ an empty stream ]
	else if [ |streams| = 1 ] then [ streams[1] ]
	else
	[
		elementType ::=
			cast ∪ map streams through [s : stream | s's element type]
			into [ t : any's type | t ];
		a concatenation stream with
			element type := elementType,
			decorated streams := streams,
			stream index := 1
	]
] : stream;

/**
 * Construct and answer a stream that produces values from the specified tuple
 * of streams. The result first produces the values of the first lexical
 * argument, then the second, etc.
 * 
 * Parameters:
 *    streams - A tuple of streams.
 * Returns:
 *    The requested stream.
 */
Method "«_‡++»" is
[
	streams : <stream…|2..>
|
	elementType ::=
		cast ∪ map streams through [s : stream | s's element type]
		into [ t : any's type | t ];
	a concatenation stream with
		element type := elementType,
		decorated streams := streams,
		stream index := 1
] : stream;

/**
 * Answer a function suitable for use as a semantic restriction for the
 * `concatenate_` and `«_‡++»` methods.
 * 
 * Returns:
 *    The requested funcion.
 */
Private method "concatenation semantic restriction" is
[
	[
		streams : <stream…|>'s type
	|
		elementType : any's type's type := ⊥;
		From 1 to (⎣streams⎦ min (|streams' leading types| + 1)) do
		[
			index : natural number
		|
			elementType := eject ↑elementType ∪ streams[index]'s element type;
		];
		extend concatenation stream with
			element type : elementType,
			decorated streams : streams,
			stream index : 1's type
	]
];

Semantic restriction "concatenate_" is concatenation semantic restriction;
Semantic restriction "«_‡++»" is concatenation semantic restriction;

/**
 * A zipped stream produces zipped tuples from a sequenced collection of
 * streams.
 */
Explicit class "zipped stream" extends stream
	with fields
		element type : tuple's type,
		decorated streams : <stream…|>;

Method "_is empty" is
[
	aStream : zipped stream
|
	any of aStream's decorated streams satisfies [s : stream | s is empty]
] : boolean;

zipped stream's head method is
[
	aStream : zipped stream
|
	map aStream's decorated streams through [s : stream | s's head]
] : any;

zipped stream's tail method is
[
	aStream : zipped stream
|
	a zipped stream with
		element type := aStream's element type,
		decorated streams :=
			map aStream's decorated streams through [s : stream | s's tail]
] : zipped stream;

/**
 * Construct and answer the zip of the specified streams. Given n input streams,
 * the output is the stream whose i-th element is an n-tuple containing the i-th
 * element from each consecutive input stream. The answer is empty when any of
 * the input streams becomes empty.
 * 
 * Parameters:
 *    streams - A tuple of streams.
 * Returns:
 *    The requested stream.
 */
Method "zip_" is
[
	streams : <stream…|1..>
|
	types ::= map streams through [s : stream | s's element type];
	elementType ::= <types[1..|types| - 1], types[|types|]… | |streams|'s type>;
	a zipped stream with
		element type := elementType,
		decorated streams := streams
] : stream;

/**
 * Construct and answer the zip of the specified streams. Given n input streams,
 * the output is the stream whose i-th element is an n-tuple containing the i-th
 * element from each consecutive input stream. The answer is empty when any of
 * the input streams becomes empty.
 * 
 * Parameters:
 *    streams - A tuple of streams.
 * Returns:
 *    The requested stream.
 */
Method "«_‡zip»" is
[
	streams : <stream…|2..>
|
	types ::= map streams through [s : stream | s's element type];
	elementType ::= <types[1..|types| - 1], types[|types|]… | |streams|'s type>;
	a zipped stream with
		element type := elementType,
		decorated streams := streams
] : stream;

/**
 * Answer a function suitable for use as a semantic restriction for the `zip_`
 * and `«_‡zip»` methods.
 * 
 * Returns:
 *    The requested funcion.
 */
Private method "zip semantic restriction" is
[
	[
		streams : <stream…|1..>'s type
	|
		types : <any's type…|> := <>;
		From 1 to (⎣streams⎦ min (|streams' leading types| + 1)) do
		[
			index : natural number
		|
			types := eject ↑types ++ <streams[index]'s element type's instance>;
		];
		nonempty ::= cast types into [ t : <any's type…|1..> | t ];
		elementType ::=
			<nonempty[1..|nonempty| - 1], nonempty[|nonempty|]…
				| ||streams||>;
		extend zipped stream with
			element type : elementType's type,
			decorated streams : streams
	]
];

Semantic restriction "zip_" is zip semantic restriction;
Semantic restriction "«_‡zip»" is zip semantic restriction;

/**
 * Answer a tuple containing the first `count` elements of `aStream`.
 * 
 * Parameters:
 *    isLax - `false` if an `empty-stream exception` should be raised if
 *       `count` exceeds the number of elements remaining, `true` otherwise.
 *    count - The size of the requested tuple.
 *    aStream - A stream.
 * Returns:
 *    A tuple containing the first `count` elements of `aStream`, preserving the
 *    original order.
 * Raises:
 *    empty-stream exception - If `isLax` is `false` and `aStream` does not
 *       contain `count` elements.
 */
Method "take«at most»?_from_" is
[
	isLax : boolean,
	count : whole number,
	aStream : stream
|
	rest : stream := aStream;
	result : tuple := <>;
	Guard
	[
		Repeat
		[
			result := eject ↑result ++ <rest's head>;
			rest := eject ↑rest's tail;
		] count times;
	]
	intercept
	[
		e : empty-stream exception
	|
		Unless isLax then [Raise e];
	];
	result
] : tuple;

Semantic restriction "take«at most»?_from_" is
[
	laxity : boolean's type,
	count : whole number's type,
	streamType : stream's type
|
	min ::= if laxity = true then [0] else [⎣count⎦];
	<<>, streamType's element type's instance…|[min..⎡count⎤+1)>
];

/**
 * Answer a tuple containing the prefix of `aStream` that answered `true` to
 * `predicate`.
 *
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that can accept each element of the specified
 *       stream. It should answer `true` to keep the element (and continue
 *       scanning) or `false` to abort.
 * Returns:
 *    A tuple containing the prefix of `aStream` that satisfied `predicate`.
 */
Method "take from_while_" is
[
	aStream : stream,
	predicate : [⊥]→boolean
|
	result : tuple := <>;
	rest : stream := aStream;
	While [¬rest is empty ∧ [predicate(rest's head)]]
	do
	[
		result := eject ↑result ++ <rest's head>;
		rest := eject ↑rest's tail;
	];
	result
] : tuple;

Semantic restriction "take from_while_" is
[
	streamType : stream's type,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts streamType;
	<streamType's element type's instance…|>
];

/**
 * Answer a tuple containing the prefix of `aStream` that answered `false` to
 * `predicate`.
 *
 * Parameters:
 *    aStream - A stream.
 *    predicate - A function that can accept each element of the specified
 *       stream. It should answer `false` to keep the element (and continue
 *       scanning) or `true` to abort.
 * Returns:
 *    A tuple containing the prefix of `aStream` that satisfied `predicate`.
 */
Method "take from_until_" is
[
	aStream : stream,
	predicate : [⊥]→boolean
|
	result : tuple := <>;
	rest : stream := aStream;
	Until [rest is empty ∨ [predicate(rest's head)]]
	do
	[
		result := eject ↑result ++ <rest's head>;
		rest := eject ↑rest's tail;
	];
	result
] : tuple;

Semantic restriction "take from_until_" is
[
	streamType : stream's type,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts streamType;
	<streamType's element type's instance…|>
];

/**
 * Answer a stream containing every element of `aStream` except for the first
 * `count` elements.
 * 
 * Parameters:
 *    isLax - `false` if an `empty-stream exception` should be raised if
 *       `count` exceeds the number of elements remaining, `true` otherwise.
 *    count - The size of the prefix of `aStream` that should be omitted from
 *       the result stream.
 *    aStream - A stream.
 * Returns:
 *    A stream containing every element but the first `count` elements of
 *    `aStream`, preserving the original order.
 * Raises:
 *    empty-stream exception - If `isLax` is `false` and `aStream` does not
 *       contain `count` elements.
 */
Method "drop«at most»?_from_" is
[
	isLax : boolean,
	count : whole number,
	aStream : stream
|
	rest : stream := aStream;
	Guard
	[
		Repeat
		[
			rest := eject ↑rest's tail;
		] count times;
	]
	intercept
	[
		e : empty-stream exception
	|
		Unless isLax then [Raise e];
	];
	rest
] : stream;

Semantic restriction "drop«at most»?_from_" is
[
	laxity : boolean's type,
	count : whole number's type,
	streamType : stream's type
|
	streamType
];

/**
 * Compute and answer the suffix of `aStream` that begins with the element that
 * answers `false` to `predicate`.
 * 
 * Parameters:
 *    aStream - A stream.
 *    predicate - A function that can accept each element of the specified
 *       stream. It should answer `true` to discard the element (and continue
 *       scanning) or `false` to abort.
 * Returns:
 *    The requested suffix.
 */
Method "drop from_while_" is
[
	aStream : stream,
	predicate : [⊥]→boolean
|
	rest : stream := aStream;
	While [¬rest is empty ∧ [predicate(rest's head)]]
	do
	[
		rest := eject ↑rest's tail;
	];
	rest
] : stream;

Semantic restriction "drop from_while_" is
[
	streamType : stream's type,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts streamType;
	stream of (streamType's element type's instance)
];

/**
 * Compute and answer the suffix of `aStream` that begins with the element that
 * answers `true` to `predicate`.
 * 
 * Parameters:
 *    aStream - A stream.
 *    predicate - A function that can accept each element of the specified
 *       stream. It should answer `false` to discard the element (and continue
 *       scanning) or `true` to abort.
 * Returns:
 *    The requested suffix.
 */
Method "drop from_until_" is
[
	aStream : stream,
	predicate : [⊥]→boolean
|
	rest : stream := aStream;
	Until [rest is empty ∨ [predicate(rest's head)]]
	do
	[
		rest := eject ↑rest's tail;
	];
	rest
] : stream;

Semantic restriction "drop from_until_" is
[
	streamType : stream's type,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts streamType;
	stream of (streamType's element type's instance)
];

/**
 * Does `aStream` start with the subsequence `prefix`?
 * 
 * Parameters:
 *    aStream - The stream whose prefix should be checked against `prefix`.
 *    prefix - The search tuple.
 * Returns:
 *    `true` if `aStream` starts with the subsequence `prefix`, `false`
 *    otherwise.
 */
Method "_starts with_" is
[
	aStream : stream,
	prefix : tuple
|
	$body : boolean;
	rest : stream := aStream;
	For each prefix do
	[
		value : any
	|
		If rest's head ≠ value then [ Exit body with false ];
		rest := eject ↑rest's tail;
	];
	true
] : boolean;
