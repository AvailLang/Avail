/*
 * Tuple Tests.avail
 * Copyright © 1993-2013, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Tuple Tests"
Versions
	"dev"
Uses
	"Common",
	"Foundation",
	"Unit Testing"
Names
	"tuple test suite"
Body

/* The test suite identifier. */
"tuple test suite" is a new atom;

New test suite tuple test suite extends foundation test suite;

/*Sorting Tests*/

Test "trivial empty merge sort" in tuple test suite is
[
	ref : <natural number…|>;
	ref := merge sort <>;
	Require: <> = ref;
];

Test "trivial one element merge sort" in tuple test suite is
[
	ref : <natural number…|>;
	ref := merge sort <18>;
	Require: <18> = ref;
];

Test "small merge sort" in tuple test suite is
[
	ref : <natural number…|>;
	ref := merge sort <4,6,1>;
	Require: <1,4,6> = ref;
];

Test "merge sort" in tuple test suite is
[
	ref : <natural number…|>;
	ref := merge sort <4,6,1,2,3,20,18,19,17,14,16,15,12,13,5,7,8,9,10,11>;
	Require: <1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20> = ref;
];

Test "small merge sort with" in tuple test suite is
[
	ref : <natural number…|>;
	ref := merge sort <4,6,1> with 
		[n : natural number, m : natural number | n ≥ m];
	Require: <6,4,1> = ref;
];

Test "merge sort with" in tuple test suite is
[
	ref : <natural number…|>;
	ref := merge sort <14,4,6,1,2,3,20,18,19,17,16,15,12,13,5,7,8,9,10,11> with 
		[n : natural number, m : natural number | n ≥ m];
	Require: <20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1> = ref;
];

Test "complex merge sort with" in tuple test suite is
[
	ref : <natural number…|>;
	ref := merge sort <14,4,6,1,2,3,20,18,19,17,16,15,12,13,5,7,8,9,10,11> with
		[
			n : natural number, 
			m : natural number 
		|
			n is odd ∧ [m is even] ∨ [n is odd ∧ [m is odd ∧ [n ≤ m]]] ∨
				[n is even ∧ [m is even ∧ [n ≥ m]]]];
	Require: <1,3,5,7,9,11,13,15,17,19,20,18,16,14,12,10,8,6,4,2> = ref;
];

Test "trivial empty quicksort" in tuple test suite is
[
	ref : <natural number…|>;
	ref := quicksort <>;
	Require: <> = ref;
];

Test "trivial one element quicksort" in tuple test suite is
[
	ref : <natural number…|>;
	ref := quicksort <18>;
	Require: <18> = ref;
];

Test "small quicksort" in tuple test suite is
[
	ref : <natural number…|>;
	ref := quicksort <4,6,1>;
	Require: <1,4,6> = ref;
];

Test "quicksort" in tuple test suite is
[
	ref : <natural number…|>;
	ref := quicksort <4,6,1,2,3,20,18,19,17,14,16,15,12,13,5,7,8,9,10,11>;
	Require: <1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20> = ref;
];

Test "small quicksort with" in tuple test suite is
[
	ref : <natural number…|>;
	ref := quicksort <4,6,1> with 
		[n : natural number, m : natural number | n ≥ m];
	Require: <6,4,1> = ref;
];

Test "quicksort with" in tuple test suite is
[
	ref : <natural number…|>;
	ref := quicksort <14,4,6,1,2,3,20,18,19,17,16,15,12,13,5,7,8,9,10,11> with 
		[n : natural number, m : natural number | n ≥ m];
	Require: <20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1> = ref;
];

Test "complex quicksort with" in tuple test suite is
[
	ref : <natural number…|>;
	ref := quicksort <14,4,6,1,2,3,20,18,19,17,16,15,12,13,5,7,8,9,10,11> with
		[
			n : natural number, 
			m : natural number 
		|
			n is odd ∧ [m is even] ∨ [n is odd ∧ [m is odd ∧ [n ≤ m]]] ∨
				[n is even ∧ [m is even ∧ [n ≥ m]]]];
	Require: <1,3,5,7,9,11,13,15,17,19,20,18,16,14,12,10,8,6,4,2> = ref;
];

Test "quasi-destructive update" in tuple test suite is
[
	t : <natural number…|> := <1,2,3>;
	n ::= t[2] → 5;
	Require: <1,5,3> = n;
];

Test "quasi-destructive n-ary tuple update" in tuple test suite is
[
	t : <<natural number…|3>…|> := <<1,2,3>,<4,5,6>>;
	n ::= t[1][3] → 7;
	Require: <<1,2,7>,<4,5,6>> = n;
];

Test "quasi-destructive n-ary complex tuple update" in tuple test suite is
[
	t : <<natural number,{string→natural number|1},natural number…|3>…|> := 
		<<1,{"foo"→2},3>,<4,{"boo"→5},6>>;
	n ::= t[1][2]["foo"] → 7;
	Require: <<1,{"foo"→7},3>,<4,{"boo"→5},6>> = n;
];

Test "quasi-destructive n-ary very complex tuple update" in tuple test suite is
[
	t : <<natural number,{string→<string…|2>|1},natural number…|3>…|> := 
		<<1,{"foo"→<"cheese","apples">},3>,<4,{"boo"→<"purple","chariots">},6>>;
	n ::= t[1][2]["foo"][2] → "motor torpedo boat";
	Require: <<1,{"foo"→<"cheese","motor torpedo boat">},3>,
		<4,{"boo"→<"purple","chariots">},6>> = n;
];

Test "integer interval tuple" in tuple test suite is
[
	From -5 to 5 do
	[
		start : [-5..5]
	|
		From -5 to 5 do
		[
			end : [-5..5]
		|
			From -5 to 5 do
			[
				delta : [-5..5]
			|
				expected : tuple := <>;
				If delta ≠ 0 then
				[
					From start to end by delta do
					[
						i : integer
					|
						expected := expected ++ <i>;
					];
				];
				Guard
				[
					actual ::= start to end by delta;
					Require: expected = actual;
					Require: 0 ≠ delta;
				]
				intercept
				[
					e : incorrect-argument-type exception
				|
					Require: 0 = delta;
				];
			];
		];
	];
	Require: <83, 66, 49, 32, 15, -2, -19> = 83 to -29 by -17;
];
