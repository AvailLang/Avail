/*
 * Exceptions.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Exceptions"
Versions
	"dev"
Uses
	"Bootstrap",
	"Control Structures",
	"Definers",
	"Early Assertions",
	"Early Error Codes",
	"Enumeration Support",
	"Functions",
	"Literals",
	"Logic",
	"Objects",
	"Strings",
	"Tuples",
	"Types"
Names
	"Guard|guard_«intercept_»",
	"Raise_",
	"cascade_",
	"causal exception",
	"descriptive_",
	"error message",
	"try_else_",
	"_'s⁇causal exception",
	"_'s⁇error message",
	"_'s⁇unhandled exception handler is_",

	/* System exception categories. */
	"arithmetic exception",
	"bad-argument exception",
	"bad-format exception",
	"bad-message exception",
	"bad-phrase exception",
	"bad-primitive exception",
	"cascade exception",
	"code-generation exception",
	"definition exception",
	"descriptive exception",
	"element-access exception",
	"I/O exception",
	"instantiation exception",
	"invocation exception",
	"security exception",
	"variable-use exception"

	/* Quite a few names are introduced, but all dynamically by the
	 * "Public exception_(_)extends_" defining method.
	 */
Body

/* TODO: [TLS] Remove these constants once a macro is available for "$…". */
_errorCode ::= $"error code";
_errorName ::= $"error name";
_cause ::= $"causal exception";
_errorMessage ::= $"error message";
_unhandledExceptionHandler ::= $"unhandled exception handler";

Private method "error code" is [ _errorCode ];
Private method "error name" is [ _errorName ];

/**
 * Answer the field atom that represents an exception's cause.
 * 
 * Returns:
 *    The requested field atom.
 */
Public method "causal exception" is [ _cause ];

/**
 * Answer the field atom that represents an error message.
 *
 * Returns:
 *    The requested field atom.
 */
Public method "error message" is [ _errorMessage ];

/**
 * Answer the field atom that represents a fiber's unhandled exception handler.
 *
 * Returns:
 *    The requested field atom.
 */
Private method "unhandled exception handler" is [ _unhandledExceptionHandler ];

/**
 * Establish `handle` as the function that the specified fiber will apply in
 * the event of an unhandled exception.
 * 
 * Parameters:
 *    handler - The unhandled exception handler. When an unhandled exception is
 *       trapped by the VM, the exception machinery will arrange to apply this
 *       function with the unhandled exception.
 */
Public method "_'s⁇unhandled exception handler is_" is
[
	aFiber : fiber,
	handler : [exception]→⊥
|
	aFiber[unhandled exception handler] := handler;
] : ⊤;

/**
 * Execute `body`. If an exception is raised, the virtual machine will scan the
 * current fiber's chain of continuations to identify invocations of this
 * primitive. The continuation nearest to the end of the continuation chain,
 * i.e., closest to the raise of the exception, that defines a handler that
 * accepts an argument of the correct type is invoked with the exception. So
 * an exception handler will potentially run if code run (directly or
 * indirectly) by `body` throws an exception of the accepted type.
 *
 * Parameters:
 *    body - The protected function.
 *    handlers - A tuple of exception handlers.
 */
Public method "Guard|guard_«intercept_»" is
[
	body : []→⊤,
	handler : <[⊥]→⊤…|1..>
|
	Primitive 200 (failureCode :
		enumeration of {0, incorrect-argument-type code, unwind-sentinel code});
	If failureCode = 0 then body
	else
	[
		early failure function(incorrect-argument-type code)
	];
] : ⊤;

/**
 * Reject the current parse if 1) any of the exception handlers aren't or 2) any
 * earlier handlers hide later handlers (by having a more general type).
 */
Semantic restriction "Guard|guard_«intercept_»" is
[
	bodyType : []→⊤'s type,
	handlersType : <[⊥]→⊤…|1..>'s type
|
	returnType : type := bodyType's return type;
	limit ::= ⎣handlersType⎦;
	From 1 to limit do
	[
		index : natural number
	|
		handlerType ::= handlersType[index];
		argType ::= handlerType[1];
		If argType = ⊥ then
		[
			Reject parse, expected: format
				"exception handler #‘①’'s parameter type to be \
				\|statically known"
				with index
		];
		If ¬argType ⊆ exception then
		[
			Reject parse, expected: format
				"exception handler to accept only exceptions (not ‘①’)"
				with argType
		];
		hidingArgTypes : <type…|> := <>;
		From 1 to index - 1 do
		[
			inner : natural number
		|
			previousArgType ::= handlersType[inner][1];
			If argType ⊆ previousArgType then
			[
				hidingArgTypes := eject ↑hidingArgTypes ++ <previousArgType>;
			];
		];
		If ¬hidingArgTypes is empty then
		[
			Reject parse, expected: format
			"exception handler for ‘①’ to be reachable \
			\|(but it is hidden by each of: ‘②’)"
			with argType, hidingArgTypes
		];
		returnType := eject ↑returnType ∪ handlerType's return type;
	];
	returnType
];

/**
 * Raise the specified exception. The virtual machine scans the current fiber's
 * chain of continuations to identify an invocation of `guard_with handler_`
 * (primitive 200). Extract the second argument from that continuation. This is
 * an arity-one exception handling function. If it accepts `anException`, then
 * discard all continuations after this one and then invoke the handler with
 * `anException`. If the handler does not accept the argument, then the
 * virtual machine continues scanning the chain of continuations for correctly
 * typed exception handling functions. If no suitable exception handling
 * function is found, then invoke the current fiber's unhandled-exception
 * exception handler; terminate the current fiber if no such handler exists.
 *
 * Parameters:
 *    exception - An exception.
 */
Public method "Raise_" is
[
	anException : exception
|
	Primitive 201 (unhandledException : exception);
	If unhandled exception handler ∈ current fiber then
	[
		handler ::= cast current fiber[unhandled exception handler]
			into [ t : [exception]→⊥ | t ];
		handler(unhandledException)
	]
	else
	[
		Terminate: "unhandled exception: " ++ “anException”
	]
] : ⊥;

/**
 * Attempt {@param "protected"}. If it does not raise an {@type "exception"},
 * then answer its result. Otherwise, answer the result of applying {@param
 * "else"}.
 *
 * @method "try_else_"
 * @param "protected" "[]→any"
 *         The function whose answer is preferred.
 * @param "else" "[]→any"
 *         The function whose answer will be returned if {@param "protected"}
 *         raises an {@type "exception"}.
 * @return "any"
 *         If possible, then the answer obtained by applying {@param
 *         "protected"}. Otherwise, the answer obtained by applying {@param
 *         "else"}.
 */
Public method "try_else_" is
[
	protected : []→any,
	else : []→any
|
	guard protected
	intercept
	[
		e : exception
	|
		else()
	]
] : any;

Semantic restriction "try_else_" is
[
	protected : []→any's type,
	else : []→any's type
|
	if protected's return type = ⊥ then [else's return type]
	else [protected's return type ∪ else's return type]
];

/**
 * A system exception privately contains a system error code.
 */
Class "system exception" extends exception
	with fields
		error code : natural number,
		error name : string;

englishVowels ::= "AEIOUaeiou"→set;

Stable method "“_”" is
[
	anException : system exception
|
	name ::= anException's error name;
	(if name ∈ englishVowels then ["an "] else ["a "]) ++ name
] : string;

/* A map from error codes to system exceptions. */
exceptionsByCode : {natural number→system exception's type|} := {};

/**
 * Define a new system exception class. Publish the name of the class.
 * 
 * Parameters:
 *    exceptionBaseName - The base name of the exception class (without the
 *       trailing " exception").
 *    supertype - The nearest supertype of the new exception class.
 *    code - The error code that uniquely identifies the system exception.
 */
Private method "System exception_(_)extends_" is
[
	exceptionBaseName : <character…|1..>,
	code : natural number,
	supertype : exception's type
|
	Assert: ¬code ∈ exceptionsByCode ("code " ++ “code” ++ " already in use");
	Assert: ¬exceptionBaseName ends with " exception"
		(format "\"“①”\" ends with \" exception\"" with exceptionBaseName);
	exceptionName ::= exceptionBaseName ++ " exception";
	Class exceptionName extends supertype ∩ system exception
		with fields
			error code : code's type,
			error name : exceptionName's type;
	Publish new name: exceptionName;
	site ::= cast method site of method for atom for exceptionName for <>
		into [ t : implementation site | t ];
	implementation ::= cast site's function into [t : []→object meta | t];
	exceptionType ::= cast implementation()
		into  [ t : system exception's type | t ];
	exceptionsByCode := eject ↑exceptionsByCode + code→exceptionType;
];

/**
 * An arithmetic exception describes error conditions related to arithmetic and
 * manipulation of numbers.
 */
Public explicit class "arithmetic exception" extends exception;

/**
 * A bad-argument exception describes error conditions related to invoking a
 * method, function, or similar entity with arguments that are correctly typed
 * but not semantically valid.
 */
Public explicit class "bad-argument exception" extends exception;

/**
 * A bad-format exception describes error conditions related to invalid formats
 * and/or format applications.
 */
Public explicit class "bad-format exception" extends bad-argument exception;

/**
 * A message exception describes error conditions related to messages, i.e.,
 * method names.
 */
Public explicit class "bad-message exception" extends exception;

/**
 * A bad phrase exception describes error conditions related to phrase
 * construction.
 */
Public explicit class "bad-phrase exception" extends exception;

/**
 * A bad-primitive exception describes error conditions related to invocations
 * of nonexistent or not meaningfully implemented primitives.
 */
Public explicit class "bad-primitive exception" extends exception;

/**
 * A code-generation exception describes error conditions related to runtime
 * generation of code.
 */
Public explicit class "code-generation exception" extends exception;

/**
 * A definition exception describes error conditions related to defining Avail
 * methods, restrictions, types, and other entities.
 */
Public explicit class "definition exception" extends exception;

/**
 * An element-access exception describes error conditions related to failed
 * retrieval of an object from a larger structure (including the runtime
 * system).
 */
Public explicit class "element-access exception" extends exception;

/**
 * An I/O exception describes error conditions related to program input or
 * output.
 */
Public explicit class "I/O exception" extends exception;

/**
 * An invocation exception describes error conditions related to invoking
 * functions, methods, or similar objects with the wrong number or types of
 * arguments.
 */
Public explicit class "invocation exception" extends exception;

/**
 * An instantiation exception describes error conditions related to
 * instantiating types (particulary user-defined object types).
 */
Public explicit class "instantiation exception" extends exception;

/**
 * A security exception describes error conditions related to program
 * permissions.
 */
Public explicit class "security exception" extends exception;

/**
 * A variable use exception describes error conditions related to usage of
 * variables.
 */
Public explicit class "variable-use exception" extends exception;

/* Define specific exception classes for each of the VM and Foundation error
 * codes.
 */
System exception "cannot-add-unlike-infinities" (1)
	extends arithmetic exception;
System exception "cannot-subtract-like-infinities" (2)
	extends arithmetic exception;
System exception "cannot-multiply-zero-and-infinity" (3)
	extends arithmetic exception;
System exception "cannot-divide-by-zero" (4)
	extends arithmetic exception;
System exception "cannot-divide-infinities" (5)
	extends arithmetic exception;
System exception "cannot-read-unassigned-variable" (6)
	extends variable-use exception;
System exception "cannot-store-incorrectly-typed-value" (7)
	extends variable-use exception;
System exception "cannot-swap-contents-of-differently-typed-variables" (8)
	extends variable-use exception;
System exception "no-such-fiber-variable" (9)
	extends element-access exception;
System exception "subscript-out-of-bounds" (10)
	extends element-access exception;
System exception "incorrect-number-of-arguments" (11)
	extends invocation exception;
System exception "incorrect-argument-type" (12)
	extends invocation exception;
System exception "method-return-type-not-as-forward-declared" (13)
	extends definition exception;
System exception "continuation-expected-stronger-type" (14)
	extends invocation exception;
System exception "primitive-not-supported" (15)
	extends bad-primitive exception;
System exception "unwind-sentinel" (16)
	extends system exception;
System exception "not-enumeration" (17)
	extends invocation exception;
System exception "shift-and-truncate-requires-non-negative" (18)
	extends arithmetic exception;
System exception "no-method" (19)
	extends element-access exception;
System exception "wrong-number-of-outers" (20)
	extends code-generation exception;
System exception "key-not-found" (21)
	extends element-access exception;
System exception "negative-size" (22)
	extends bad-argument exception;
System exception "general-I/O" (23)
	extends I/O exception;
System exception "permission-denied" (24)
	extends security exception;
System exception "invalid-handle" (25)
	extends bad-argument exception;
System exception "invalid-primitive-number" (26)
	extends code-generation exception;
System exception "function-disagrees-with-primitive-restriction" (27)
	extends code-generation exception;
System exception "local-type-literal-is-not-a-type" (28)
	extends code-generation exception;
System exception "outer-type-literal-is-not-a-type" (29)
	extends code-generation exception;
System exception "unhandled-exception" (30)
	extends system exception;
System exception "type-restriction-must-accept-only-types" (31)
	extends definition exception;
System exception "incorrect-type-for-group" (32)
	extends bad-message exception;
System exception "no-special-object" (33)
	extends element-access exception;
System exception "macro-argument-must-be-a-parse-node" (34)
	extends definition exception;
System exception "ambiguous-name" (35)
	extends bad-message exception;
System exception "declaration-kind-does-not-support-assignment" (36)
	extends bad-phrase exception;
System exception "declaration-kind-does-not-support-reference" (37)
	extends bad-phrase exception;
System exception "redefined-with-same-argument-types" (39)
	extends definition exception;
System exception "result-type-should-covary-with-arguments" (40)
	extends definition exception;
System exception "special-atom" (41)
	extends bad-argument exception;
System exception "incorrect-type-for-complex-group" (42)
	extends bad-message exception;
System exception "incorrect-use-of-double-dagger" (43)
	extends bad-message exception;
System exception "unbalanced-guillemets" (44)
	extends bad-message exception;
System exception "method-name-is-not-canonical" (45)
	extends bad-message exception;
System exception "expected-operator-after-backquote" (46)
	extends bad-message exception;
System exception "incorrect-type-for-boolean-group" (47)
	extends bad-message exception;
System exception "incorrect-type-for-counting-group" (48)
	extends bad-message exception;
System exception "octothorp-must-follow-a-simple-group" (49)
	extends bad-message exception;
System exception "question-mark-must-follow-a-simple-group" (50)
	extends bad-message exception;
System exception "case-insensitive-expression-canonization" (51)
	extends bad-message exception;
System exception "tilde-must-not-follow-argument" (52)
	extends bad-message exception;
System exception "double-question-mark-must-follow-a-simple-or-simple-group" (53)
	extends bad-message exception;
System exception "alternative-must-not-contain-arguments" (54)
	extends bad-message exception;
System exception "vertical-bar-must-follow-a-simple-or-simple-group" (55)
	extends bad-message exception;
System exception "cannot-convert-not-a-number-to-integer" (56)
	extends bad-argument exception;
System exception "compilation-is-over" (70)
	extends system exception;
System exception "method-implementation-lookup-failed" (71)
	extends element-access exception;
System exception "method-is-sealed" (72)
	extends definition exception;
System exception "no-implementation" (73)
	extends bad-primitive exception;
System exception "block-contains-invalid-statements" (100)
	extends bad-phrase exception;
System exception "block-is-invalid" (101)
	extends bad-phrase exception;
System exception "block-must-not-contain-outers" (102)
	extends bad-phrase exception;
System exception "block-compilation-failed" (103)
	extends code-generation exception;
System exception "sequence-contains-invalid-statements" (105)
	extends bad-phrase exception;
System exception "Java-class-not-available" (500)
	extends element-access exception;
System exception "pojo-type-is-abstract" (501)
	extends bad-argument exception;
System exception "Java-method-not-available" (502)
	extends element-access exception;
System exception "Java-marshaling-failed" (504)
	extends invocation exception;
System exception "Java-field-not-available" (505)
	extends element-access exception;
System exception "Java-field-reference-is-ambiguous" (506)
	extends bad-message exception;
System exception "cannot-modify-final-Java-field" (507)
	extends variable-use exception;
System exception "Java-method-reference-is-ambiguous" (508)
	extends bad-message exception;
System exception "object-type-extension-contains-duplicates" (1000)
	extends definition exception;
System exception "object-type-extension-did-not-produce-subtype" (1001)
	extends definition exception;
System exception "object-instantiation-contains-duplicates" (1002)
	extends instantiation exception;
System exception "object-instantiation-did-not-produce-instance" (1004)
	extends instantiation exception;
System exception "invalid-argument" (1005)
	extends bad-format exception;
System exception "runaway-format-variable" (1006)
	extends bad-format exception;
System exception "empty-format-variable" (1007)
	extends bad-format exception;
System exception "invalid-format-metacharacter-escape" (1008)
	extends bad-format exception;
System exception "invalid-format-metacharacter-use" (1009)
	extends bad-format exception;
System exception "format-variable-interpolation-failed" (1010)
	extends bad-format exception;
System exception "invalid-format-variable" (1011)
	extends bad-format exception;
System exception "missing-format-variable-binding" (1012)
	extends bad-format exception;

/**
 * Ensure that all error codes have corresponding exceptions.
 */
Private method "Ensure:all error codes have corresponding exceptions" is [];
Semantic restriction "Ensure:all error codes have corresponding exceptions" is
[
	missingExceptionClasses ::= filter error codes by
	[
		errorCode : natural number,
		errorName : string
	|
		¬errorCode ∈ exceptionsByCode
	];
	If |missingExceptionClasses| ≠ 0 then
	[
		Reject parse, expected:
			format
				"exception classes to be defined for the following \
				\|error codes: ‘①’"
			with missingExceptionClasses
	];
	⊤
];

Ensure: all error codes have corresponding exceptions;

/**
 * A cascade exception retains the exception that originally caused it.
 */
Public class "cascade exception" extends exception
	with fields
		public causal exception : exception;

/**
 * Construct and answer the type intersection of the argument and {@type
 * "cascade exception"}.
 *
 * @method "cascade_"
 * @param "exceptionType" "exception's type"
 *        An exception type.
 * @returns "cascade exception"
 *          An exception type that is a subtype of both {@type "cascade
 *          exception"} and {@param "exceptionType"}.
 */
Public method "cascade_" is
[
	exceptionType : exception's type
|
	cascade exception ∩ exceptionType
] : cascade exception 's type;

Grammatical restriction "cascade_" is <{"exception"}>;

Semantic restriction "cascade_" is
[
	exceptionMeta : exception's type's type
|
	((cascade exception) ∩ (exceptionMeta's instance))'s type
];

/**
 * A descriptive exception holds an error message.
 */
Public class "descriptive exception" extends exception
	with fields
		public error message : string;

/**
 * Construct and answer the type intersection of the argument and {@type
 * "descriptive exception"}.
 *
 * @method "descriptive_"
 * @param "exceptionType" "exception's type"
 *        An exception type.
 * @returns "descriptive exception"
 *          An exception type that is a subtype of both {@type "descriptive
 *          exception"} and {@param "exceptionType"}.
 */
Public method "descriptive_" is
[
	exceptionType : exception's type
|
	descriptive exception ∩ exceptionType
] : descriptive exception's type;

Grammatical restriction "descriptive_" is <{"exception"}>;

Semantic restriction "descriptive_" is
[
	exceptionMeta : exception's type's type
|
	((descriptive exception) ∩ (exceptionMeta's instance))'s type
];

/* Exceptions are going live! Failures of bootstrap linked primitives will now
 * raise appropriate exceptions.
 */
Set early failure function to
[
	errorCode : natural number
|
	Assert: errorCode ∈ exceptionsByCode
		("no exception class for " ++ “errorCode”);
	exceptionType ::= exceptionsByCode[errorCode];
	Raise an exceptionType with
		error code := errorCode,
		error name := exceptionType's error name's instance
] : ⊥;
