/*
 * Exceptions.avail
 * Copyright © 1993-2013, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Exceptions"
Versions
	"dev"
Uses
	"Atoms",
	"Bootstrap",
	"Control Structures",
	"Definers",
	"Early Assertions",
	"Early Error Codes",
	"Enumeration Support",
	"Functions",
	"Literals",
	"Logic",
	"Math",
	"Objects",
	"Strings",
	"Tuples",
	"Types",
	"Variables"
Names
	"Current fiber's unhandled exception handler is_",
	"Guard|guard_«intercept_»«ensure_»",
	"Raise_",
	"cascade_",
	"current fiber's unhandled exception handler",
	"causal exception",
	"descriptive_",
	"error message",
	"try_else_",
	"_caused by_",
	"_'s⁇causal exception",
	"_'s⁇error message",
	"_'s⁇stack summary",
	"“_”(stack summary)",

	/* System exception categories. */
	"arithmetic exception",
	"bad-argument exception",
	"bad-format exception",
	"bad-message exception",
	"bad-phrase exception",
	"bad-primitive exception",
	"cascade exception",
	"code-generation exception",
	"definition exception",
	"descriptive exception",
	"element-access exception",
	"I/O exception",
	"instantiation exception",
	"invocation exception",
	"security exception",
	"variable-use exception"

	/* Quite a few names are introduced, but all dynamically by the
	 * "Public exception_(_)extends_" defining method.
	 */
Body

/**
 * Answer a summary of the continuation stack associated with the specified
 * {@type "exception"}.
 *
 * @method "_'s⁇stack summary"
 * @param "e" "exception"
 *        An {@type "exception"}.
 * @returns "<string…|>"
 *          A tuple of strings, each of which describes a continuation.
 */
Public method "_'s⁇stack summary" is
[
	e : exception
|
	Primitive 203 (failureCode : incorrect-argument-type code's type);
	early failure function(failureCode)
] : <string…|>;

/* Private field definitions. */
"error code" is a new atom;
"error name" is a new atom;

/**
 * Answer the field atom that represents an exception's cause.
 *
 * @method "causal exception"
 * @returns "atom"
 */
"causal exception" is a new atom;

/**
 * Answer the field atom that represents an error message.
 *
 * @method "error message"
 * @returns "atom"
 */
"error message" is a new atom;

/**
 * Answer the heritable fiber-local atom that represents a fiber's unhandled
 * exception handler.
 *
 * @method "unhandled exception handler"
 * @returns "atom"
 */
"unhandled exception handler" is a new heritable fiber-local atom;

/**
 * Answer the unhandled exception handler for the current fiber.
 *
 * @method "current fiber's unhandled exception handler"
 */
Public method "current fiber's unhandled exception handler" is
[
	cast current fiber[unhandled exception handler] into [t : [exception]→⊥ | t]
] : [exception]→⊥;

/**
 * Establish {@param "handler"} as the function that the current fiber will
 * apply in the event of an unhandled exception.
 * 
 * @method "Current fiber's unhandled exception handler is_"
 * @param "handler"
 *    The unhandled exception handler. When an unhandled exception is trapped by
 *    the VM, the exception machinery will arrange to apply this function with
 *    the unhandled exception.
 */
Public method "Current fiber's unhandled exception handler is_" is
[
	handler : [exception]→⊥
|
	current fiber[unhandled exception handler] := handler;
] : ⊤;

/* This function that "Raise_" should invoke if the current fiber does not have
 * an unhandled exception handler. This will be updated after all other
 * exception machinery has been built.
 */
noUnhandledExceptionHandler : [exception]→⊥ :=
	[
		anException : exception
	|
		Crash: "unhandled exception: " ++ “anException”
	];

/**
 * Raise the specified {@type "exception"}. The virtual machine scans the
 * {@method "current fiber"}'s chain of {@type "continuation"}s to identify an
 * invocation of {@method "Guard|guard_«intercept_»«ensure_»"} (primitive 200).
 * Extract the second argument from that continuation. This is a {@type "tuple"}
 * of arity-one exception handling {@type "function"}. If any of these handlers,
 * from left to right, accepts {@param "anException"}, then discard all
 * continuations after this one and then invoke the handler with {@param
 * "anException"}. If none of these handlers accept the argument, then the
 * virtual machine continues scanning the chain of continuations for correctly
 * typed exception handling functions. If no suitable exception handling
 * function is found, then invoke the current fiber's {@method
 * "_'s⁇unhandled exception handler is_" unhandled exception handler}. {@method
 * "Crash:_" Crash} the current fiber if no such handler exists.
 *
 * @method "Raise_"
 * @param "anException" "exception"
 * @returns "⊥"
 */
Public method "Raise_" is
[
	anException : exception
|
	Primitive 201 (unhandledException : exception);
	If unhandled exception handler ∈ current fiber then
	[
		handler ::= current fiber's unhandled exception handler;
		handler(unhandledException)
	]
	else
	[
		noUnhandledExceptionHandler(anException)
	]
] : ⊥;

/**
 * Mark the nearest {@method "Guard|guard_«intercept_»«ensure_»" guard frame}
 * with the current exception handling state.
 *
 * @method "Guarded function has run to completion"
 */
Private method "Mark nearest guard frame with_" is
[
	marker : {handler-sentinel code, unwind-sentinel code}ᵀ
|
	Primitive 202 (failureCode : 
		{cannot-mark-handler-frame code, no-handler-frame code}ᵀ);
	early failure function(failureCode)
] : ⊤;

/**
 * This is a helper for {@method "Private guard_intercept_ensure_"}. Run
 * {@param "body"} and then {@param "unwind"}. If {@param "body"} produces a
 * value, then polymorphism and a semantic restriction make sure that it gets
 * returned.
 *
 * @method "Run_and_"
 * @param "body" "[]→⊤"
 * @param "unwind" "[]→⊤"
 */
Private method "Run_and_" is
[
	body : []→⊤,
	unwind : []→⊤
|
	body();
	Mark nearest guard frame with handler-sentinel code;
	unwind();
	Mark nearest guard frame with unwind-sentinel code;
] : ⊤;

Method "Run_and_" is
[
	body : []→any,
	unwind : []→⊤
|
	result ::= body();
	Mark nearest guard frame with handler-sentinel code;
	unwind();
	Mark nearest guard frame with unwind-sentinel code;
	result
] : any;

/**
 * Though this is the primitive guard method, it is merely a helper for
 * {@method "Guard|guard_«intercept_»«ensure_»"}, the public exception
 * protection control structure.
 *
 * Execute {@param "body"}. If an {@type "exception"} is {@method "Raise_"
 * raised}, the virtual machine will scan the {@method "current fiber"}'s chain
 * of {@type "continuation"}s to identify invocations of this primitive. The
 * continuation nearest to the end of the continuation chain, i.e., closest to
 * the raise of the exception, that defines a handler that accepts an argument
 * of the correct type is invoked with the exception. So an exception handler
 * will potentially run if code run (directly or indirectly) by {@param "body"}
 * raises an exception of the accepted type.
 *
 * Whether {@param "body"} succeeds or is curtailed by an exception, always
 * apply {@param "unwind"}. This is a safe place to clean up an algorithm after
 * it runs or fails. If one of the handlers is invoked, then it will run after
 * the handler runs, even if the handler raises its own exception. This happens
 * because the public control structure, {@method
 * "Guard|guard_«intercept_»«ensure_»"}, embeds {@param "unwind"} into each of
 * the (modified) exception handlers.
 *
 * @method "Private guard_intercept_ensure_"
 * @param "body" "[]→⊤"
 *    The protected function.
 * @param "handlers" "<[⊥]→⊤…|>"
 *    A tuple of exception handlers.
 * @param "optionalUnwind" "<[]→⊤…|0..1>"
 *    If specified, then a function to apply after either the successful
 *    completion of {@param "body"} or an unwind through this continuation.
 */
Private method "Private guard_intercept_ensure_" is
[
	body : []→⊤,
	handlers : <[⊥]→⊤…|>,
	optionalUnwind : <[]→⊤…|0..1>
|
	Primitive 200 (failureCode :
		{
			0,
			incorrect-argument-type code,
			handler-sentinel code,
			unwind-sentinel code
		}ᵀ);
	If failureCode = 0 then
	[
		Run body and optionalUnwind[1] else [[]];
	]
	else
	[
		early failure function(incorrect-argument-type code)
	];
] : ⊤;

/**
 * A cascade exception retains the exception that originally caused it.
 */
Public class "cascade exception" extends exception
	with fields
		public causal exception : exception;

/**
 * Construct and answer the type intersection of the argument and {@type
 * "cascade exception"}.
 *
 * @method "cascade_"
 * @param "exceptionType" "exception's type"
 *        An exception type.
 * @returns "cascade exception"
 *          An exception type that is a subtype of both {@type "cascade
 *          exception"} and {@param "exceptionType"}.
 */
Public method "cascade_" is
[
	exceptionType : exception's type
|
	cascade exception ∩ exceptionType
] : cascade exception's type;

Grammatical restriction "cascade_" is <{"exception"}>;

Semantic restriction "cascade_" is
[
	exceptionMeta : exception's type's type
|
	((cascade exception) ∩ (exceptionMeta's instance))'s type
];

/**
 * Answer a {@type "cascade exception"} based on {@param "newException"} and
 * caused by {@param "originalException"}.
 *
 * @method "_caused by_"
 * @param "newException" "exception"
 * @param "originalException" "exception"
 * @returns "cascade exception"
 */
Public method "_caused by_" is
[
	newException : exception,
	originalException : exception
|
	fields ::= newException→map + causal exception→originalException;
	cast fields→object into [t : cascade exception | t]
] : cascade exception;

/**
 * This is a helper for {@method "Guard|guard_«intercept_»«ensure_»"}. Having
 * intercepted {@param "originalException"}, invoke {@param "handler"}. If it
 * raises an {@type "exception", then intercept it and store it locally. Run
 * {@param "unwind"}. If it raises an exception, then intercept it and store it
 * locally, overwriting any exception intercepted by a failure of {@param
 * "handler"}. If a new exception has been stored locally, then convert it into
 * a {@type "cascade exception"} and reraise it. Otherwise answer the result
 * produced by {@param "handler"}.
 *
 * @method "Handle_with_and_"
 * @param "originalException" "exception"
 *        The exception originally caught by the handler that {@method
 *        "Guard|guard_«intercept_»«ensure_»"} wrapped around {@param
 *        "handler"}.
 * @param "handler" "[⊥]→⊤"
 *        An exception handler lexically specified in the send of {@method
 *        "Guard|guard_«intercept_»«ensure_»"}.
 * @param "unwind" "[]→⊤"
 *        The unwind handler lexically specified in the send of {@method
 *        "Guard|guard_«intercept_»«ensure_»"}.
 * @returns "any"
 *          The value, if any, produced by {@param "handler"}.
 * @raises "cascade exception"
 *         If either {@param "handler"} or {@param "unwind"} raises an
 *         {@type "exception"}.
 */
Private method "Handle_with_and_" is
[
	originalException : exception,
	handler : [⊥]→⊤,
	unwind : []→⊤
|
	preemptiveException : exception;
	/* Guard the handler, because we need to try the unwind no matter what
	 * happens.
	 */
	Private guard [handler(originalException);]
	intercept <[e : exception | preemptiveException := e;]>
	ensure <>;
	/* Guard the unwind, because if it blows up, then we want to build a cascade
	 * exception from it instead of from the handler.
	 */
	Private guard [unwind();]
	intercept <[e : exception | preemptiveException := e;]>
	ensure <>;
	/* Forbid a subsequent unwind. */
	Mark nearest guard frame with unwind-sentinel code;
	/* If either the handler or the unwind raised an exception, then convert it
	 * to a cascade exception (with the original exception attached) and reraise
	 * it.
	 */
	If ↑preemptiveException is assigned then
	[
		Raise preemptiveException caused by originalException
	];
] : ⊤;

Private method "Handle_with_and_" is
[
	originalException : exception,
	handler : [⊥]→any,
	unwind : []→⊤
|
	result : any;
	preemptiveException : exception;
	/* Guard the handler, because we need to try the unwind no matter what
	 * happens.
	 */
	Private guard [result := handler(originalException);]
	intercept <[e : exception | preemptiveException := e;]>
	ensure <>;
	/* Guard the unwind, because if it blows up, then we want to build a cascade
	 * exception from it instead of from the handler.
	 */
	Private guard [unwind();]
	intercept <[e : exception | preemptiveException := e;]>
	ensure <>;
	/* Forbid a subsequent unwind. */
	Mark nearest guard frame with unwind-sentinel code;
	/* If either the handler or the unwind raised an exception, then convert it
	 * to a cascade exception (with the original exception attached) and reraise
	 * it.
	 */
	If ↑preemptiveException is assigned then
	[
		Raise preemptiveException caused by originalException
	];
	/* The result must be assigned, or control would have left because of a
	 * raised exception.
	 */
	Assert: ↑result is assigned;
	result
] : any;

/**
 * Execute {@param "body"}. If an {@type "exception"} is {@method "Raise_"
 * raised}, the virtual machine will scan the {@method "current fiber"}'s chain
 * of {@type "continuation"}s to identify invocations of this primitive. The
 * continuation nearest to the end of the continuation chain, i.e., closest to
 * the raise of the exception, that defines a handler that accepts an argument
 * of the correct type is invoked with the exception. So an exception handler
 * will potentially run if code run (directly or indirectly) by {@param "body"}
 * raises an exception of the accepted type.
 *
 * Whether {@param "body"} succeeds or is curtailed by an exception, always
 * apply {@param "unwind"}. This is a safe place to clean up an algorithm after
 * it runs or fails. If one of the handlers is invoked, then it will run after
 * the handler runs, even if the handler raises its own exception.
 *
 * @method "Guard|guard_«intercept_»«ensure_»"
 * @param "body" "[]→⊤"
 *    The protected function.
 * @param "handlers" "<[⊥]→⊤…|>"
 *    A tuple of exception handlers.
 * @param "optionalUnwind" "<[]→⊤…|0..1>"
 *    If specified, then a function to apply after either the successful
 *    completion of {@param "body"} or an unwind through this continuation.
 */
Public method "Guard|guard_«intercept_»«ensure_»" is
[
	body : []→⊤,
	handlers : <[⊥]→⊤…|>,
	optionalUnwind : <[]→⊤…|0..1>
|
	unwind ::= optionalUnwind[1] else [[]];
	realHandlers ::=
		/* If only an unwind handler was provided, then synthesize a catch-all
		 * exception handler.
		 */
		if handlers is empty then
		[
			<[
				e : exception
			|
				Handle e with [ex : exception | Raise ex] and unwind
			]>
		]
		/* Otherwise, wrap each of the handlers. The wrapper will call the
		 * user-supplied exception handler and then the unwind handler.
		 */
		else
		[
			map handlers through
			[
				handler : [⊥]→⊤
			|
				handlerType ::= handler's type;
				/* Make sure that the new handler has the same signature as
				 * the wrapped handler.
				 */
				new [handlerType[1]]→(handlerType's return type) applying
				[
					originalException : exception
				|
					Handle originalException with handler and unwind;
				]
			]
		];
	Private guard body intercept realHandlers ensure optionalUnwind;
] : ⊤;

/**
 * Reject the current parse if 1) any of the exception handlers aren't or 2) any
 * earlier handlers hide later handlers (by having a more general type).
 */
Semantic restriction "Guard|guard_«intercept_»«ensure_»" is
[
	bodyType : []→⊤'s type,
	handlersType : <[⊥]→⊤…|>'s type,
	unwindType : <[]→⊤…|0..1>'s type
|
	returnType : type := bodyType's return type;
	handlerCount ::= ⎣handlersType⎦;
	unwindCount ::= ⎣unwindType⎦;
	If handlerCount = 0 ∧ [unwindCount = 0] then
	[
		Reject parse, expected:
			"at least one exception handler or an unwind handler"
	];
	From 1 to handlerCount do
	[
		index : natural number
	|
		handlerType ::= handlersType[index];
		argType ::= handlerType[1];
		If argType = ⊥ then
		[
			Reject parse, expected: format
				"exception handler #“①”'s parameter type to be \
				\|statically known"
				with index
		];
		If ¬argType ⊆ exception then
		[
			Reject parse, expected: format
				"exception handler to accept only exceptions (not “①”)"
				with argType
		];
		hidingArgTypes : <type…|> := <>;
		From 1 to index - 1 do
		[
			inner : natural number
		|
			previousArgType ::= handlersType[inner][1];
			If argType ⊆ previousArgType then
			[
				hidingArgTypes := eject ↑hidingArgTypes ++ <previousArgType>;
			];
		];
		If ¬hidingArgTypes is empty then
		[
			Reject parse, expected: format
			"exception handler for “①” to be reachable \
			\|(but it is hidden by each of: “②”)"
			with argType, hidingArgTypes
		];
		returnType := eject ↑returnType ∪ handlerType's return type;
	];
	returnType
];

/**
 * Attempt {@param "protected"}. If it does not raise an {@type "exception"},
 * then answer its result. Otherwise, answer the result of applying {@param
 * "else"}.
 *
 * @method "try_else_"
 * @param "protected" "[]→any"
 *    The function whose answer is preferred.
 * @param "else" "[]→any"
 *    The function whose answer will be returned if {@param "protected"} raises
 *    an {@type "exception"}.
 * @return "any"
 *    If possible, then the answer obtained by applying {@param "protected"}.
 *    Otherwise, the answer obtained by applying {@param "else"}.
 */
Public method "try_else_" is
[
	protected : []→any,
	else : []→any
|
	guard protected
	intercept [e : exception | else()]
] : any;

Semantic restriction "try_else_" is
[
	protected : []→any's type,
	else : []→any's type
|
	if protected's return type = ⊥ then [else's return type]
	else [protected's return type ∪ else's return type]
];

/**
 * A system exception privately contains a system error code.
 */
Class "system exception" extends exception
	with fields
		error code : natural number,
		error name : string;

Stable method "“_”" is
[
	anException : system exception
|
	(a|an) “anException's error name”
] : string;

/* A map from error codes to system exceptions. */
exceptionsByCode : {natural number→system exception's type|} := {};

/**
 * Define a new system exception class. Publish the name of the class.
 *
 * @method "System exception_(_)extends_"
 * @param "exceptionBaseName" "nonempty string"
 *    The base name of the exception class (without the trailing " exception").
 * @param "code" "natural number"
 *    The error code that uniquely identifies the system exception.
 * @param "supertype" "exception's type"
 *    The nearest supertype of the new exception class.
 */
Private method "System exception_(_)extends_" is
[
	exceptionBaseName : nonempty string,
	code : natural number,
	supertype : exception's type
|
	Assert: ¬code ∈ exceptionsByCode ("code " ++ “code” ++ " already in use");
	Assert: ¬exceptionBaseName ends with " exception"
		(format "\"‘①’\" ends with \" exception\"" with exceptionBaseName);
	exceptionName ::= exceptionBaseName ++ " exception";
	Class exceptionName extends supertype ∩ system exception
		with fields
			error code : code's type,
			error name : exceptionName's type;
	Publish new name: exceptionName;
	site ::= cast method definition of method for atom for exceptionName for <>
		into [ t : method definition | t ];
	implementation ::= cast site's function into [t : []→object meta | t];
	exceptionType ::= cast implementation()
		into  [ t : system exception's type | t ];
	exceptionsByCode := eject ↑exceptionsByCode + code→exceptionType;
];

/**
 * An arithmetic exception describes error conditions related to arithmetic and
 * manipulation of numbers.
 */
Public explicit class "arithmetic exception" extends exception;

/**
 * A bad-argument exception describes error conditions related to invoking a
 * method, function, or similar entity with arguments that are correctly typed
 * but not semantically valid.
 */
Public explicit class "bad-argument exception" extends exception;

/**
 * A bad-format exception describes error conditions related to invalid formats
 * and/or format applications.
 */
Public explicit class "bad-format exception" extends bad-argument exception;

/**
 * A message exception describes error conditions related to messages, i.e.,
 * method names.
 */
Public explicit class "bad-message exception" extends exception;

/**
 * A bad phrase exception describes error conditions related to phrase
 * construction.
 */
Public explicit class "bad-phrase exception" extends exception;

/**
 * A bad-primitive exception describes error conditions related to invocations
 * of nonexistent or not meaningfully implemented primitives.
 */
Public explicit class "bad-primitive exception" extends exception;

/**
 * A code-generation exception describes error conditions related to runtime
 * generation of code.
 */
Public explicit class "code-generation exception" extends exception;

/**
 * A definition exception describes error conditions related to defining Avail
 * methods, restrictions, types, and other entities.
 */
Public explicit class "definition exception" extends exception;

/**
 * An element-access exception describes error conditions related to failed
 * retrieval of an object from a larger structure (including the runtime
 * system).
 */
Public explicit class "element-access exception" extends exception;

/**
 * An I/O exception describes error conditions related to program input or
 * output.
 */
Public explicit class "I/O exception" extends exception;

/**
 * An invocation exception describes error conditions related to invoking
 * functions, methods, or similar objects with the wrong number or types of
 * arguments.
 */
Public explicit class "invocation exception" extends exception;

/**
 * An instantiation exception describes error conditions related to
 * instantiating types (particulary user-defined object types).
 */
Public explicit class "instantiation exception" extends exception;

/**
 * A security exception describes error conditions related to program
 * permissions.
 */
Public explicit class "security exception" extends exception;

/**
 * A variable use exception describes error conditions related to usage of
 * variables.
 */
Public explicit class "variable-use exception" extends exception;

/* Define specific exception classes for each of the VM and Foundation error
 * codes.
 */
System exception "cannot-add-unlike-infinities" (1)
	extends arithmetic exception;
System exception "cannot-subtract-like-infinities" (2)
	extends arithmetic exception;
System exception "cannot-multiply-zero-and-infinity" (3)
	extends arithmetic exception;
System exception "cannot-divide-by-zero" (4)
	extends arithmetic exception;
System exception "cannot-divide-infinities" (5)
	extends arithmetic exception;
System exception "cannot-read-unassigned-variable" (6)
	extends variable-use exception;
System exception "cannot-store-incorrectly-typed-value" (7)
	extends variable-use exception;
System exception "cannot-swap-contents-of-differently-typed-variables" (8)
	extends variable-use exception;
System exception "no-such-fiber-variable" (9)
	extends element-access exception;
System exception "subscript-out-of-bounds" (10)
	extends element-access exception;
System exception "incorrect-number-of-arguments" (11)
	extends invocation exception;
System exception "incorrect-argument-type" (12)
	extends invocation exception;
System exception "method-return-type-not-as-forward-declared" (13)
	extends definition exception;
System exception "continuation-expected-stronger-type" (14)
	extends invocation exception;
System exception "primitive-not-supported" (15)
	extends bad-primitive exception;
System exception "not-enumeration" (17)
	extends invocation exception;
System exception "shift-and-truncate-requires-non-negative" (18)
	extends arithmetic exception;
System exception "no-method" (19)
	extends element-access exception;
System exception "wrong-number-of-outers" (20)
	extends code-generation exception;
System exception "key-not-found" (21)
	extends element-access exception;
System exception "negative-size" (22)
	extends bad-argument exception;
System exception "general-I/O" (23)
	extends I/O exception;
System exception "permission-denied" (24)
	extends security exception;
System exception "invalid-handle" (25)
	extends bad-argument exception;
System exception "invalid-primitive-number" (26)
	extends code-generation exception;
System exception "function-disagrees-with-primitive-restriction" (27)
	extends code-generation exception;
System exception "local-type-literal-is-not-a-type" (28)
	extends code-generation exception;
System exception "outer-type-literal-is-not-a-type" (29)
	extends code-generation exception;
System exception "too-large-to-represent" (30)
	extends system exception;
System exception "type-restriction-must-accept-only-types" (31)
	extends definition exception;
System exception "incorrect-type-for-group" (32)
	extends bad-message exception;
System exception "no-special-object" (33)
	extends element-access exception;
System exception "macro-argument-must-be-a-parse-node" (34)
	extends definition exception;
System exception "ambiguous-name" (35)
	extends bad-message exception;
System exception "declaration-kind-does-not-support-assignment" (36)
	extends bad-phrase exception;
System exception "declaration-kind-does-not-support-reference" (37)
	extends bad-phrase exception;
System exception "exclamation-mark-must-follow-an-alternation-group-code" (38)
	extends bad-message exception;
System exception "redefined-with-same-argument-types" (39)
	extends definition exception;
System exception "result-type-should-covary-with-arguments" (40)
	extends definition exception;
System exception "special-atom" (41)
	extends bad-argument exception;
System exception "incorrect-type-for-complex-group" (42)
	extends bad-message exception;
System exception "incorrect-use-of-double-dagger" (43)
	extends bad-message exception;
System exception "unbalanced-guillemets" (44)
	extends bad-message exception;
System exception "method-name-is-not-canonical" (45)
	extends bad-message exception;
System exception "expected-operator-after-backquote" (46)
	extends bad-message exception;
System exception "incorrect-type-for-boolean-group" (47)
	extends bad-message exception;
System exception "incorrect-type-for-counting-group" (48)
	extends bad-message exception;
System exception "octothorp-must-follow-a-simple-group" (49)
	extends bad-message exception;
System exception "question-mark-must-follow-a-simple-group" (50)
	extends bad-message exception;
System exception "case-insensitive-expression-canonization" (51)
	extends bad-message exception;
System exception "tilde-must-not-follow-argument" (52)
	extends bad-message exception;
System exception "double-question-mark-must-follow-a-simple-or-simple-group" (53)
	extends bad-message exception;
System exception "alternative-must-not-contain-arguments" (54)
	extends bad-message exception;
System exception "vertical-bar-must-follow-a-simple-or-simple-group" (55)
	extends bad-message exception;
System exception "cannot-convert-not-a-number-to-integer" (56)
	extends bad-argument exception;
System exception "incorrect-type-for-numbered-choice" (57)
	extends bad-message exception;
System exception "label-macro-must-occur-inside-a-block" (58)
	extends bad-phrase exception;
System exception "fiber-result-unavailable" (59)
	extends element-access exception;
System exception "fiber-cannot-join-itself" (60)
	extends bad-argument exception;
System exception "loading-is-over" (70)
	extends system exception;
System exception "method-implementation-lookup-failed" (71)
	extends element-access exception;
System exception "method-is-sealed" (72)
	extends definition exception;
System exception "no-implementation" (73)
	extends bad-primitive exception;
System exception "handler-sentinel" (80)
	extends system exception;
System exception "cannot-mark-handler-frame" (81)
	extends system exception;
System exception "no-handler-frame" (82)
	extends system exception;
System exception "unwind-sentinel" (83)
	extends system exception;
System exception "block-contains-invalid-statements" (100)
	extends bad-phrase exception;
System exception "block-is-invalid" (101)
	extends bad-phrase exception;
System exception "block-must-not-contain-outers" (102)
	extends bad-phrase exception;
System exception "block-compilation-failed" (103)
	extends code-generation exception;
System exception "sequence-contains-invalid-statements" (105)
	extends bad-phrase exception;
System exception "Java-class-not-available" (500)
	extends element-access exception;
System exception "pojo-type-is-abstract" (501)
	extends bad-argument exception;
System exception "Java-method-not-available" (502)
	extends element-access exception;
System exception "Java-marshaling-failed" (504)
	extends invocation exception;
System exception "Java-field-not-available" (505)
	extends element-access exception;
System exception "Java-field-reference-is-ambiguous" (506)
	extends bad-message exception;
System exception "cannot-modify-final-Java-field" (507)
	extends variable-use exception;
System exception "Java-method-reference-is-ambiguous" (508)
	extends bad-message exception;
System exception "object-type-extension-contains-duplicates" (1000)
	extends definition exception;
System exception "object-type-extension-did-not-produce-subtype" (1001)
	extends definition exception;
System exception "object-instantiation-contains-duplicates" (1002)
	extends instantiation exception;
System exception "object-instantiation-did-not-produce-instance" (1004)
	extends instantiation exception;
System exception "invalid-argument" (1005)
	extends bad-format exception;
System exception "runaway-format-variable" (1006)
	extends bad-format exception;
System exception "empty-format-variable" (1007)
	extends bad-format exception;
System exception "invalid-format-metacharacter-escape" (1008)
	extends bad-format exception;
System exception "invalid-format-metacharacter-use" (1009)
	extends bad-format exception;
System exception "format-variable-interpolation-failed" (1010)
	extends bad-format exception;
System exception "invalid-format-variable" (1011)
	extends bad-format exception;
System exception "missing-format-variable-binding" (1012)
	extends bad-format exception;

/**
 * Ensure that all error codes have corresponding exceptions.
 */
Private method "Ensure:all error codes have corresponding exceptions" is [];
Semantic restriction "Ensure:all error codes have corresponding exceptions" is
[
	missingExceptionClasses ::= filter error codes by
	[
		errorCode : natural number,
		errorName : string
	|
		¬errorCode ∈ exceptionsByCode
	];
	If |missingExceptionClasses| ≠ 0 then
	[
		Reject parse, expected:
			format
				"exception classes to be defined for the following \
				\|error codes: “①”"
			with missingExceptionClasses
	];
	⊤
];

Ensure: all error codes have corresponding exceptions;

/**
 * A descriptive exception holds an error message.
 */
Public class "descriptive exception" extends exception
	with fields
		public error message : string;

/**
 * Construct and answer the type intersection of the argument and {@type
 * "descriptive exception"}.
 *
 * @method "descriptive_"
 * @param "exceptionType" "exception's type"
 *        An exception type.
 * @returns "descriptive exception"
 *          An exception type that is a subtype of both {@type "descriptive
 *          exception"} and {@param "exceptionType"}.
 */
Public method "descriptive_" is
[
	exceptionType : exception's type
|
	descriptive exception ∩ exceptionType
] : descriptive exception's type;

Grammatical restriction "descriptive_" is <{"exception"}>;

Semantic restriction "descriptive_" is
[
	exceptionMeta : exception's type's type
|
	((descriptive exception) ∩ (exceptionMeta's instance))'s type
];

Stable method "“_”" is
[
	e : descriptive exception
|
	(a|an) “e's type” ++ " (" ++ e's error message ++ ")"
];

/* Exceptions are going live! Failures of bootstrap linked primitives will now
 * raise appropriate exceptions.
 */
Set early failure function to
[
	errorCode : natural number
|
	Assert: errorCode ∈ exceptionsByCode
		("no exception class for " ++ “errorCode”);
	exceptionType ::= exceptionsByCode[errorCode];
	Raise an exceptionType with
		error code ::= errorCode,
		error name ::= exceptionType's error name's instance
] : ⊥;

/**
 * Obtain a printed representation of the specified {@type "exception"}'s stack
 * summary, suitable for printing.
 *
 * @method "“_”(stack summary)"
 * @param "e" "exception"
 */
Public method "“_”(stack summary)" is
[
	e : exception
|
	dump ::= e's stack summary;
	text : string := "";
	From |dump| to 1 by -1 do
	[
		index : natural number
	|
		frame ::= dump[index];
		text := eject ↑text ++ (format "\t‘①’\n" with frame);
	];
	text
];

/* This completes the behavior of "Raise_" in the event that no unhandled
 * exception handler has been specified for the current fiber.
 */
noUnhandledExceptionHandler :=
	[
		unhandled : exception
	|
		msg : string := "";
		/* If the error was encountered during compilation, then indicate which
		 * module was being compiled.
		 */
		Guard
		[
			m ::= current module;
			msg :=
				format "Unhandled exception during compilation of “①”:\n"
				with m's name;
		]
		intercept [e : loading-is-over exception |];
		e : exception := unhandled;
		firstTime : boolean := true;
		While [↑e is assigned] do
		[
			spec ::= if firstTime
				then ["unhandled exception [“ex”]:\n"]
				else ["“ex”:\n"];
			firstTime := false;
			msg := eject ↑msg ++ format spec with ex ::= e;
			msg := eject ↑msg ++ “e” (stack summary);
			Cast e into
			[
				cascade : cascade exception
			|
				msg := eject ↑msg ++ "\ncaused by…\n";
				e := cascade's causal exception;
			]
			else
			[
				Clear ↑e;
			];
		];
		msg := eject ↑msg ++ "\nThe current fiber will be terminated.\n";
		/* If the current fiber was launched in order to apply a semantic
		 * restriction, then reject the current parse. Otherwise, emit the
		 * error message to the stardard error stream and terminate the current
		 * fiber.
		 */
		If current fiber is applying a semantic restriction then
		[
			Reject parse, expected: msg
		]
		else
		[
			Error: msg;
			Terminate current fiber
		]
	];
