/*
 * Sets.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Sets"
Versions
	"dev"
Extends
	"Collections",
	"Early Sets"
Uses
	"Bootstrap",
	"Control Structures",
	"Early Functions",
	"Early Maps",
	"Early Tuples",
	"Early Types",
	"Enumeration Support",
	"Literals",
	"Logic",
	"Math",
	"Variables"
Names
	"group_by_",
	"_∋_",
	"_⊂_",
	"_⊇_",
	"_⊃_",
	"_∉_",
	"_⊄_"
Body

/**
 * Strengthen set element addition.
 * 
 * Parameters:
 *    setType -
 *    valueType -
 * Returns:
 *    The strongest possible set type for the given argument types.
 */
Semantic restriction "_+_" is
[
	setType : set meta,
	valueType : any meta
|
	/* Leverage instance types. */
	if |setType| = 1 ∧ [ |valueType| = 1; ] then
	[
		(setType's instance + valueType's instance)'s type;
	]
	else
	[
		elementType ::= setType's element type;
		/* If the element type is an instance type and equal to `valueType`,
		 * then the value is already present; the set type does not change.
		 */
		if |elementType| = 1 ∧ [ elementType = valueType; ] then
		[
			setType;
		]
		else
		[
			union ::= elementType ∪ valueType;
			sizes ::= ||setType||;
			/* If the type intersection of the element type and the new type is
			 * ⊥, then the new element cannot be present in the set. Adjust the
			 * cardinality accordingly.
			 */
			newSizes ::=
				if elementType ∩ valueType = ⊥ then
				[
					cast sizes + 1's type into [ t : whole number's type | t; ];
				]
				/* Otherwise the element *may* be present, but there's no way to
				 * know for sure. Adjust the cardinality accordingly.
				 */
				else
				[
					cast sizes + [0..1] into [ t : whole number's type | t; ];
				];
			{union | newSizes};
		];
	];
];

/**
 * Strengthen set-to-tuple conversion.
 * 
 * Parameters:
 *    setType -
 * Returns:
 *    The strongest possible set type for the given argument types.
 */
Semantic restriction "_→tuple" is
[
	setType : set meta
|
	if |setType| = 1 then
	[
		(setType's instance→tuple)'s type;
	]
	else
	[
		<<>, setType's element type… | ||setType||>;
	];
];

/**
 * Is the specified set empty?
 *
 * Parameters:
 *    aSet - A set.
 * Returns:
 *    `true` if the argument is empty, `false` otherwise.
 */
Method "_is empty" is
[
	aSet : set
|
	|aSet| = 0;
];

/**
 * Iteratively apply `action` to each element of `aSet`, but in no particular
 * order.
 * 
 * Parameters:
 *    aSet - A set.
 *    action - A function that accepts the elements of the set.
 */
Method "For each_do_" is
[
	aSet : set,
	action : [⊥]→⊤
|
	index : natural number := 1;
	aTuple ::= aSet→tuple;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			Invoke action with <aTuple[index]>;
			↑index++;
			Restart loop;
		];
	]();
] : ⊤;

/**
 * Helper method for semantic restrictions: If `action` does not accept the
 * element types of `setType`, then reject the current parse.
 * 
 * Parameters:
 *    action - A function type whose first argument must correspond to the
 *       element type of `setType`.
 *    setType - A set type.
 */
Method "Require:_accepts_" is
[
	action : function meta,
	setType : set meta
|
	If ||action's parameters' type||'s lower bound < 1 then
	[
		Reject parse, expected:
			"repeatedly applied function to accept at least one argument";
	];
	If action[1] ≠ ⊥ ∧ [ ¬setType's element type ⊆ action[1]; ] then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all elements of the set ∈ "
			++ primitive description of setType
			++ " (but it only accepts "
			++ primitive description of action[1]
			++ ")";
	];
] : ⊤;

/**
 * Ensure that the function will accept all elements of the set. If the set is
 * certainly nonempty and the function certainly does not complete if applied,
 * then answer ⊥.
 * 
 * Parameters:
 *    setType -
 *    action -
 * Returns:
 *    Either ⊤ or ⊥.
 */
Semantic restriction "For each_do_" is
[
	setType : set meta,
	action : [⊥]→⊤'s type
|
	Require: action accepts setType;
	if ||setType||'s lower bound > 0 ∧ [ action's return type = ⊥; ] then
	[
		⊥;
	]
	else
	[
		⊤;
	];
];

/**
 * Iteratively apply `transformer` to each element of `aSet`, collecting the
 * results into a new tuple. The set is traversed in no particular order. Answer
 * the resultant set.
 *
 * Parameters:
 *    aSet - A set.
 *    transformer - A function that accepts the elements of the set.
 * Returns:
 *    A set of results of applications of `transformer` to the elements of
 *    `aSet`.
 */
Method "map_through_" is
[
	aSet : set,
	transformer : [⊥]→any
|
	aTuple ::= aSet→tuple;
	index : natural number := 1;
	end ::= |aTuple|;
	result : set := ∅;
	[
		$loop;
		If index ≤ end then
		[
			result := eject ↑result + invoke transformer with <aTuple[index]>;
			↑index++;
			Restart loop;
		];
	]();
	result;
] : set;

/**
 * Ensure that the function will accept all elements of the set. If the set is
 * certainly nonempty, then the function cannot answer ⊥.
 *
 * Parameters:
 *    setType -
 *    transformer -
 * Returns:
 *    A set type whose element type is the return type of `transformer` and
 *    whose cardinality is the same as `setType`'s.
 */
Semantic restriction "map_through_" is
[
	setType : set meta,
	transformer : [⊥]→any's type
|
	Require: transformer accepts setType;
	If ||setType||'s lower bound > 0 then
	[
		If transformer's return type = ⊥ then
		[
			Reject parse, expected:
				"repeatedly applied function to have a return type other than\
				\| ⊥";
		];
	];
	{transformer's return type | ||setType||};
];

/**
 * Iteratively apply `predicate` to each element of `aSet`, in no particular
 * order, collecting those elements for which `predicate` answers `true` into a
 * new set. Answer the new set.
 * 
 * Parameters:
 *    aSet - A set.
 *    predicate - A function that accepts the elements of the set and answers
 *       `true` iff they should be accumulated into the output set.
 * Returns:
 *    A set containing exactly those elements of `aSet` for which
 *    `predicate` answered `true`.
 */
Method "filter_by_" is
[
	aSet : set,
	predicate : [⊥]→boolean
|
	aTuple ::= aSet→tuple;
	index : natural number := 1;
	end ::= |aTuple|;
	result : set := ∅;
	[
		$loop;
		If index ≤ end then
		[
			element ::= aTuple[index];
			If invoke predicate with <element> then
			[
				result := eject ↑result + element;
			];
			↑index++;
			Restart loop;
		];
	]();
	result;
] : set;

/**
 * Ensure that the function will accept all elements of the set.
 *
 * Parameters:
 *    setType -
 *    predicate -
 * Returns:
 *    A set type whose element type is the same as `setType`'s and which has
 *    cardinality `[0..||setType||'s upper bound + 1)`.
 */
Semantic restriction "filter_by_" is
[
	setType : set meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts setType;
	sizes ::=
		if predicate's return type = true's type then [ ||setType||; ]
		else if [ predicate's return type = false's type; ] then [ 0's type; ]
		else [ [0..||setType||'s upper bound + 1); ];
	{setType's element type|sizes};
];

/**
 * Iteratively apply `accumulator` to the elements of `aSet`, in no particular
 * order, in order to transform and filter its elements into a new set. When
 * `accumulator` is invoked, it is passed a "keeper" function. The keeper
 * function may be invoked to "save" a particular value, i.e., a value that will
 * be copied into the output set. The keeper function will save at most one
 * value per element of `aSet`, i.e., each time that `accumulator` is invoked,
 * it may invoke the keeper function at most one time. Answer the new set.
 * 
 * Parameters:
 *    aSet - A set.
 *    accumulator - A function that accepts 1) an element from `aSet` and 2)
 *       a keeper function. The keeper function accepts an argument of the type
 *       that should be saved.
 * Returns:
 *    A set whose elements are those saved by the `accumulator`.
 */
Method "map and filter_by_" is
[
	aSet : set,
	accumulator : [⊥, ⊥]→⊤
|
	aTuple ::= aSet→tuple;
	index : natural number := 1;
	end ::= |aTuple|;
	result : set := ∅;
	[
		$loop;
		If index ≤ end then
		[
			hasAlreadyKept : boolean := false;
			Invoke accumulator with
			<
				aTuple[index],
				[
					transformed : any
				|
					If ¬hasAlreadyKept then
					[
						result := eject ↑result + transformed;
						hasAlreadyKept := true;
					];
				]
			>;
			↑index++;
			Restart loop;
		];
	]();
	result;
] : set;

/**
 * Ensure that the function will accept all arguments of the set and also an
 * appropriately typed keeper function.
 *
 * Parameters:
 *    setType -
 *    accumulator -
 * Returns:
 *    A set type whose element type is the argument type of the keeper function
 *    and whose cardinality is `[0..||setType||'s upper bound + 1)`.
 */
Semantic restriction "map and filter_by_" is
[
	setType : set meta,
	accumulator : [⊥, ⊥]→⊤'s type
|
	Require: accumulator accepts setType;
	Require: accumulator's keeper is valid;
	If accumulator's return type ≠ ⊤ then
	[
		Reject parse, expected:
			"repeatedly applied function to have return type ⊤";
	];
	{
		cast accumulator[2] into [ t : function meta | t[1]; ]
		| [0..||setType||'s upper bound + 1)
	};
];

/**
 * Compute and answer whether any of the elements of `aSet` satisfies the
 * specified function. Do not examine more elements than necessary.
 * 
 * Parameters:
 *    aSet - A set.
 *    predicate - A function that accepts the elements of the set and answers
 *       a boolean.
 * Returns:
 *    `true` if `predicate` answers `true` for any element of `aSet`, `false`
 *    otherwise.
 */
Method "any of_satisfies_" is
[
	aSet : set,
	predicate : [⊥]→boolean
|
	$body : boolean;
	For each aSet do
	[
		element : any
	|
		If invoke predicate with <element> then
		[
			Exit body with true;
		];
	];
	false;
] : boolean;

/**
 * Ensure that the function will accept all elements of the set.
 * 
 * Parameters:
 *    setType -
 *    predicate -
 * Returns:
 *    The function's return type.
 */
Semantic restriction "any of_satisfies_" is
[
	setType : set meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts setType;
	predicate's return type;
];

/**
 * Compute and answer whether each of the elements of `aSet` satisfies the
 * specified function. Do not examine more elements than necessary.
 * 
 * Parameters:
 *    aSet - A set.
 *    predicate - A function that accepts the elements of the set and answers
 *       a boolean.
 * Returns:
 *    `true` if `predicate` answers `true` for each element of `aSet`, `false`
 *    otherwise.
 */
Method "each of_satisfies_" is
[
	aSet : set,
	predicate : [⊥]→boolean
|
	$body : boolean;
	For each aSet do
	[
		element : any
	|
		Unless invoke predicate with <element> then
		[
			Exit body with false;
		];
	];
	true;
] : boolean;

/**
 * Ensure that the function will accept all elements of the set.
 * 
 * Parameters:
 *    setType -
 *    predicate -
 * Returns:
 *    The function's return type.
 */
Semantic restriction "each of_satisfies_" is
[
	setType : set meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts setType;
	predicate's return type;
];

/**
 * Compute and answer the count of elements of `aSet` that satisfy the given
 * predicate.
 * 
 * Parameters:
 *    aSet - A set.
 *    predicate - A function that accepts the elements of the set and answers
 *       `true` if the element should be represented in the resulting count.
 * Returns:
 *    The number of elements of `aSet` for which `predicate` answers `true`.
 */
Method "count of_where_" is
[
	aSet : set,
	predicate : [⊥]→boolean
|
	|filter aSet by predicate|;
] : whole number;

/**
 * Ensure that the function will accept all elements of the set.
 * 
 * Parameters:
 *    setType -
 *    predicate -
 * Returns:
 *    `[0..||setType||'s upper bound + 1)`.
 */
Semantic restriction "count of_where_" is
[
	setType : set meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts setType;
	[0..||setType||'s upper bound + 1);
];

/**
 * Strengthen `_∈_`.
 * 
 * Parameters:
 *    valueType -
 *    setType -
 * Returns:
 *    The strongest possible boolean type.
 */
Semantic restriction "_∈_" is
[
	valueType : any meta,
	setType : set meta
|
	if |valueType| = 1 ∧ [ |setType| = 1; ] then
	[
		(valueType's instance ∈ setType's instance)'s type;
	]
	else if [ valueType ∩ (setType's element type) = ⊥; ] then
	[
		false's type;
	]
	else
	[
		/* Can't strengthen. */
		⊤;
	];
];

/**
 * Does `aSet` contain `value`?
 * 
 * Parameters:
 *    aSet - A set.
 *    value - An arbitrary value.
 * Returns:
 *    `true` if `aSet` contains `value` as a member, `false` otherwise.
 */
Method "_∋_" is
[
	aSet : set,
	value : any
|
	value ∈ aSet;
];

/**
 * Strengthen `_∋_`.
 * 
 * Parameters:
 *    setType -
 *    valueType -
 * Returns:
 *    The strongest possible boolean type.
 */
Semantic restriction "_∋_" is
[
	setType : set meta,
	valueType : any meta
|
	if |setType| = 1 ∧ [ |valueType| = 1; ] then
	[
		(setType's instance ∋ valueType's instance)'s type;
	]
	else if [ (setType's element type) ∩ valueType = ⊥; ] then
	[
		false's type;
	]
	else
	[
		/* Can't strengthen. */
		⊤;
	];
];

/**
 * Strengthen `_⊆_`.
 * 
 * Parameters:
 *    a -
 *    b -
 * Returns:
 *    The strongest possible boolean type.
 */
Semantic restriction "_⊆_" is
[
	a : set meta,
	b : set meta
|
	if |a| = 1 ∧ [ |b| = 1; ] then
	[
		(a's instance ⊆ b's instance)'s type;
	]
	else if [ a's element type ∩ (b's element type) = ⊥; ] then
	[
		false's type;
	]
	else
	[
		/* Can't strengthen. */
		⊤;
	];
];

/**
 * Is `a` a proper subset of `b`?
 *
 * Parameters:
 *    a - A set.
 *    b - A set.
 * Returns:
 *    `true` if `a` is a proper subset of `b`, `false` otherwise.
 */
Method "_⊂_" is
[
	a : set,
	b : set
|
	|a| ≠ |b| ∧ [ a ⊆ b; ];
] : boolean;

/**
 * Strengthen `_⊂_`.
 * 
 * Parameters:
 *    typeA - A set type.
 *    typeB - A set type.
 * Returns:
 *    A boolean type.
 */
Semantic restriction "_⊂_" is
[
	typeA : set meta,
	typeB : set meta
|
	/* If both arguments are instance types, then extract their instances and
	 * perform the subset operation on them, answering the result's type.
	 */
	if |typeA| = 1 ∧ [ |typeB| = 1; ] then
	[
		a ::= typeA's instance;
		b ::= typeB's instance;
		(a ⊂ b)'s type;
	]
	else
	[
		elementA ::= typeA's element type;
		elementB ::= typeB's element type;
		/* The basic rule is this: If the type intersection of the element type
		 * of `typeA` and the element type of `typeB` is ⊥, then the result must
		 * be false. Otherwise all bets are off.
		 */
		basicRule ::=
			[
				if elementA ∩ elementB = ⊥ then
				[
					false's type;
				]
				else
				[
					/* Can't strengthen. */
					⊤;
				];
			];
		sizesB ::= ||typeB||;
		/* This is finesse. If `typeB` is definitely the set of all possible
		 * instances of its (enumeration) element type, then `typeA`'s instances
		 * must be subsets of `typeB`'s instance if `typeA`'s element type is a
		 * subtype of `typeB`'s element type.
		 */
		if |elementB| ≠ ∞
			∧ [ sizesB's lower bound = sizesB's upper bound
			∧ [ |elementB| = sizesB's lower bound; ]; ]
		then
		[
			if ||typeA||'s upper bound < |elementB|
				∧ [ elementA ⊆ elementB; ]
			then [ true's type; ]
			else basicRule;
		]
		else basicRule;
	];
];

/**
 * Is `a` a superset of or equal to `b`?
 *
 * Parameters:
 *    a - A set.
 *    b - A set.
 * Returns:
 *    `true` if `a` is a superset of or equal to `b`, `false` otherwise.
 */
Method "_⊇_" is
[
	a : set,
	b : set
|
	b ⊆ a;
];

/**
 * Strengthen `_⊇_`.
 * 
 * Parameters:
 *    typeB - A set type.
 *    typeA - A set type.
 * Returns:
 *    A boolean type.
 */
Semantic restriction "_⊇_" is
[
	typeB : set's type,
	typeA : set's type
|
	/* If both arguments are instance types, then extract their instances and
	 * perform the subset operation on them, answering the result's type.
	 */
	if |typeA| = 1 ∧ [ |typeB| = 1; ] then
	[
		a ::= typeA's instance;
		b ::= typeB's instance;
		(a ⊆ b)'s type;
	]
	else
	[
		elementA ::= typeA's element type;
		elementB ::= typeB's element type;
		/* The basic rule is this: If the type intersection of the element type
		 * of `typeA` and the element type of `typeB` is ⊥, then the result must
		 * be false. Otherwise all bets are off.
		 */
		basicRule ::=
			[
				if elementA ∩ elementB = ⊥ then
				[
					false's type;
				]
				else
				[
					boolean;
				];
			];
		sizesB ::= ||typeB||;
		/* This is finesse. If `typeB` is definitely the set of all possible
		 * instances of its (enumeration) element type, then `typeA`'s instances
		 * must be subsets of `typeB`'s instance if `typeA`'s element type is a
		 * subtype of `typeB`'s element type.
		 */
		if |elementB| ≠ ∞
			∧ [ sizesB's lower bound = sizesB's upper bound
			∧ [ |elementB| = sizesB's lower bound; ]; ]
		then
		[
			if elementA ⊆ elementB then
			[
				true's type;
			]
			else basicRule;
		]
		else basicRule;
	];
];

/**
 * Is `a` a proper superset of `b`?
 *
 * Parameters:
 *    a - A set.
 *    b - A set.
 * Returns:
 *    `true` if `a` is a proper superset of `b`, `false` otherwise.
 */
Method "_⊃_" is
[
	a : set,
	b : set
|
	b ⊂ a;
];

/**
 * Strengthen `_⊂_`.
 * 
 * Parameters:
 *    typeB - A set type.
 *    typeA - A set type.
 * Returns:
 *    A boolean type.
 */
Semantic restriction "_⊂_" is
[
	typeB : set meta,
	typeA : set meta
|
	/* If both arguments are instance types, then extract their instances and
	 * perform the subset operation on them, answering the result's type.
	 */
	if |typeA| = 1 ∧ [ |typeB| = 1; ] then
	[
		a ::= typeA's instance;
		b ::= typeB's instance;
		(a ⊂ b)'s type;
	]
	else
	[
		elementA ::= typeA's element type;
		elementB ::= typeB's element type;
		/* The basic rule is this: If the type intersection of the element type
		 * of `typeA` and the element type of `typeB` is ⊥, then the result must
		 * be false. Otherwise all bets are off.
		 */
		basicRule ::=
			[
				if elementA ∩ elementB = ⊥ then
				[
					false's type;
				]
				else
				[
					/* Can't strengthen. */
					⊤;
				];
			];
		sizesB ::= ||typeB||;
		/* This is finesse. If `typeB` is definitely the set of all possible
		 * instances of its (enumeration) element type, then `typeA`'s instances
		 * must be subsets of `typeB`'s instance if `typeA`'s element type is a
		 * subtype of `typeB`'s element type.
		 */
		if |elementB| ≠ ∞
			∧ [ sizesB's lower bound = sizesB's upper bound
			∧ [ |elementB| = sizesB's lower bound; ]; ]
		then
		[
			if ||typeA||'s upper bound < |elementB|
				∧ [ elementA ⊆ elementB; ]
			then [ true's type; ]
			else basicRule;
		]
		else basicRule;
	];
];

/**
 * Is `element` not an element of `aSet`?
 *
 * Parameters:
 *    element - An arbitrary value.
 *    aSet - A set.
 * Returns:
 *    `true` if `element` is not an element of `aSet`, `false` otherwise.
 */
Method "_∉_" is
[
	element : any,
	aSet : set
|
	¬ element ∈ aSet;
] : boolean;

/**
 * Strengthen `_∉_`.
 * 
 * Parameters:
 *    valueType -
 *    setType -
 * Returns:
 *    The strongest possible boolean type.
 */
Semantic restriction "_∉_" is
[
	valueType : any meta,
	setType : set meta
|
	if |valueType| = 1 ∧ [ |setType| = 1; ] then
	[
		(valueType's instance ∉ setType's instance)'s type;
	]
	else if [ valueType ∩ (setType's element type) = ⊥; ] then
	[
		true's type;
	]
	else
	[
		/* Can't strengthen. */
		⊤;
	];
];

/**
 * Is `a` not a proper subset of `b`?
 *
 * Parameters:
 *    a - A set.
 *    b - A set.
 * Returns:
 *    `true` if `a` is not a proper subset of `b`, `false` otherwise.
 */
Method "_⊄_" is
[
	a : set,
	b : set
|
	¬ a ⊂ b;
] : boolean;

/**
 * Strengthen `_⊄_`.
 * 
 * Parameters:
 *    typeB - A set type.
 *    typeA - A set type.
 * Returns:
 *    A boolean type.
 */
Semantic restriction "_⊄_" is
[
	typeB : set meta,
	typeA : set meta
|
	/* If both arguments are instance types, then extract their instances and
	 * perform the subset operation on them, answering the result's type.
	 */
	if |typeA| = 1 ∧ [ |typeB| = 1; ] then
	[
		a ::= typeA's instance;
		b ::= typeB's instance;
		(a ⊄ b)'s type;
	]
	else
	[
		elementA ::= typeA's element type;
		elementB ::= typeB's element type;
		/* The basic rule is this: If the type intersection of the element type
		 * of `typeA` and the element type of `typeB` is ⊥, then the result must
		 * be true. Otherwise all bets are off.
		 */
		basicRule ::=
			[
				if elementA ∩ elementB = ⊥ then
				[
					true's type;
				]
				else
				[
					/* Can't strengthen. */
					⊤;
				];
			];
		sizesB ::= ||typeB||;
		/* This is finesse. If `typeB` is definitely the set of all possible
		 * instances of its (enumeration) element type, then `typeA`'s instances
		 * must be subsets of `typeB`'s instance if `typeA`'s element type is a
		 * subtype of `typeB`'s element type.
		 */
		if |elementB| ≠ ∞
			∧ [ sizesB's lower bound = sizesB's upper bound
			∧ [ |elementB| = sizesB's lower bound; ]; ]
		then
		[
			if ||typeA||'s upper bound < |elementB|
				∧ [ elementA ⊆ elementB; ]
			then [ false's type; ]
			else basicRule;
		]
		else basicRule;
	];
];

/**
 * Categorize the elements of `aSet` via `decider`.
 *
 * Parameters:
 *    aSet - The set to categorize.
 *    discriminator - A function that accepts each element of the set and
 *       answers a value that represents the group to which the element belongs.
 * Returns:
 *    A map whose keys describe groups and whose elements are the groups
 *    themselves, i.e., the sets of elements that constitute the described
 *    group.
 */
Method "group_by_" is
[
	aSet : set,
	discriminator : [⊥]→any
|
	groups : {any→set|} := {};
	For each aSet do
	[
		element : any
	|
		key ::= invoke discriminator with <element>;
		group ::= groups[key] else [ ∅; ] + element;
		groups := eject ↑groups + key→group;
	];
	groups;
] : map;

/**
 * Strengthen return type.
 *
 * Parameters:
 *    aSetType - The set to categorize's type.
 *    discriminator - A function that accepts each element of the set and
 *       answers a value that represents the group to which the element belongs.
 * Returns:
 *    Most specific map type.
 */
Semantic restriction "group_by_" is
[
	aSetType : set's type,
	discriminatorType : [⊥]→any's type
 |

 	Require: discriminatorType accepts aSetType;
 	
 	setCardinality ::= ||aSetType||;
 	setUpperBound ::= setCardinality's upper bound;
	keyType ::= discriminatorType's return type;
	
 	lowerBound ::= if setCardinality's lower bound = 0 then [0;] else [1;];
	upperBound ::= if setUpperBound > |keyType| 
		then [|keyType|;]
		else [setUpperBound;];

 	valueType ::= {aSetType's element type | 1..setUpperBound};

 	{keyType→valueType | lowerBound..upperBound};
 ];

/* Make various boolean-valued set operations bind more tightly than logical
 * negation.
 */
Grammatical restriction {"_∋_", "_⊂_", "_⊇_", "_⊃_", "_∉_", "_⊄_"} is
	<{"¬_"}, ∅>;
