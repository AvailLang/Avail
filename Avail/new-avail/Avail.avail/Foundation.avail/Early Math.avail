/*
 * Early Math.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Early Math"
Versions
	"dev"
Uses
	"Assertions",
	"Bootstrap",
	"Early Control Structures",
	"Early Literals",
	"Early Logic"
Names
	"[_.._]",
	"[_.._)",
	"(_.._]",
	"(_.._)",
	"_'s lower bound is inclusive",
	"_'s upper bound is inclusive",
	"max_",
	"min_",
	"«_‡max»",
	"«_‡min»",
	"_>_",
	"_≥_"
Body

/**
 * Answer the semantic restriction function that should be used for each of
 * `_'s lower bound` and `_'s upper bound`.
 *
 * Returns:
 *    A function that strengthens the integer range bounds methods.
 */
Method "integer range bound semantic restriction function" is
[
	[
		range : extended integer meta's type
	|
		Assert: range ≠ ⊥;
		instances ::= cast range's instances
			into [ t : {extended integer meta|whole number} | t; ];
		Assert: |instances| = 1;
		instance ::= cast instances→tuple[1] into
			[ t : extended integer meta | t; ];
		/* Treat the upper bound as inclusive in order to handle ∞. */
		integer range
			from instance's lower bound (inclusive=true)
			to instance's upper bound (inclusive=true);
	];
];

/**
 * Strengthen the bound to have the same static type as the argument. Note that
 * this is the strongest possible type because the argument's subtypes have
 * lower and upper bounds drawn from the argument's entire range.
 *
 * Parameters:
 *    range -
 * Returns:
 *    The same type as the argument to `_'s lower bound`.
 */
Semantic restriction "_'s lower bound" is
	integer range bound semantic restriction function;

/**
 * Strengthen the bound to have the same static type as the argument. Note that
 * this is the strongest possible type because the argument's subtypes have
 * lower and upper bounds drawn from the argument's entire range.
 *
 * Parameters:
 *    range -
 * Returns:
 *    The same type as the argument to `_'s upper bound`.
 */
Semantic restriction "_'s upper bound" is
	integer range bound semantic restriction function;

/**
 * Construct and answer an integer range type with the specified bounds.
 * 
 * Parameters:
 *    lowerBound - The lower bound, inclusive.
 *    upperBound - The upper bound, inclusive.
 * Returns:
 *    The requested integer range.
 */
Method "[_.._]" is
[
	lowerBound : extended integer,
	upperBound : extended integer
|
	integer range
		from lowerBound (inclusive=true)
		to upperBound (inclusive=true);
] : extended integer meta;

/**
 * Strengthen integer range types.
 *
 * Parameters:
 *    lowerBound -
 *    upperBound -
 * Returns:
 *    The most specific possible type of the integer range type expression.
 */
Semantic restriction "[_.._]" is
[
	lowerBound : extended integer meta,
	upperBound : extended integer meta
|
	(integer range
		from lowerBound's lower bound (inclusive=true)
		to upperBound's upper bound (inclusive=true))'s type;
];

/**
 * Construct and answer an integer range type with the specified bounds.
 * 
 * Parameters:
 *    lowerBound - The lower bound, inclusive.
 *    upperBound - The upper bound, exclusive.
 * Returns:
 *    The requested integer range.
 */
Method "[_.._)" is
[
	lowerBound : extended integer,
	upperBound : extended integer
|
	integer range
		from lowerBound (inclusive=true)
		to upperBound (inclusive=false);
] : extended integer meta;

/**
 * Strengthen integer range types.
 *
 * Parameters:
 *    lowerBound -
 *    upperBound -
 * Returns:
 *    The most specific possible type of the integer range type expression.
 */
Semantic restriction "[_.._)" is
[
	lowerBound : extended integer meta,
	upperBound : extended integer meta
|
	(integer range
		from lowerBound's lower bound (inclusive=true)
		to upperBound's upper bound (inclusive=false))'s type;
];

/**
 * Construct and answer an integer range type with the specified bounds.
 * 
 * Parameters:
 *    lowerBound - The lower bound, exclusive.
 *    upperBound - The upper bound, inclusive.
 * Returns:
 *    The requested integer range.
 */
Method "(_.._]" is
[
	lowerBound : extended integer,
	upperBound : extended integer
|
	integer range
		from lowerBound (inclusive=false)
		to upperBound (inclusive=true);
] : extended integer meta;

/**
 * Strengthen integer range types.
 *
 * Parameters:
 *    lowerBound -
 *    upperBound -
 * Returns:
 *    The most specific possible type of the integer range type expression.
 */
Semantic restriction "(_.._]" is
[
	lowerBound : extended integer meta,
	upperBound : extended integer meta
|
	(integer range
		from lowerBound's lower bound (inclusive=false)
		to upperBound's upper bound (inclusive=true))'s type;
];

/**
 * Construct and answer an integer range type with the specified bounds.
 * 
 * Parameters:
 *    lowerBound - The lower bound, exclusive.
 *    upperBound - The upper bound, exclusive.
 * Returns:
 *    The requested integer range.
 */
Method "(_.._)" is
[
	lowerBound : extended integer,
	upperBound : extended integer
|
	integer range
		from lowerBound (inclusive=false)
		to upperBound (inclusive=false);
] : extended integer meta;

/**
 * Strengthen integer range types.
 *
 * Parameters:
 *    lowerBound -
 *    upperBound -
 * Returns:
 *    The most specific possible type of the integer range type expression.
 */
Semantic restriction "(_.._)" is
[
	lowerBound : extended integer meta,
	upperBound : extended integer meta
|
	(integer range
		from lowerBound's lower bound (inclusive=false)
		to upperBound's upper bound (inclusive=false))'s type;
];

/**
 * Is the lower bound of the argument inclusive?
 * 
 * Note that integer ranges canonize each bound as inclusive unless the bound is
 * ±∞. So `(3..6)` is really `[4..5]` and will answer `true` if asked whether
 * its lower bound is inclusive. But `(-∞..0]` will answer `false` if asked
 * whether its lower bound is inclusive.
 * 
 * Parameters:
 *    range - An integer range.
 * Returns:
 *    `false` if the lower bound is infinite and exclusive, `true` otherwise.
 */
Method "_'s lower bound is inclusive" is
[
	range : extended integer meta
|
	bound ::= range's lower bound;
	bound's type ⊆ range;
] : boolean;

/**
 * Is the upper bound of the argument inclusive?
 * 
 * Note that integer ranges canonize each bound as inclusive unless the bound is
 * ±∞. So `(3..6)` is really `[4..5]` and will answer `true` if asked whether
 * its upper bound is inclusive. But `[0..∞)` will answer `false` if asked
 * whether its upper bound is inclusive.
 * 
 * Parameters:
 *    range - An integer range.
 * Returns:
 *    `false` if the upper bound is infinite and exclusive, `true` otherwise.
 */
Method "_'s upper bound is inclusive" is
[
	range : extended integer meta
|
	bound ::= range's upper bound;
	bound's type ⊆ range;
] : boolean;

/**
 * Answer a function that computes the  mininum of a tuple of numbers.
 * 
 * Returns:
 *    The requested function.
 */
Method "minimum function" is
[
	[
		numbers : <<>, number…|[1..∞)>
	|
		min : number := cast numbers[1] into [ t : number | t; ];
		From 2 to |numbers| do
		[
			index : natural number
		|
			n ::= cast numbers[index] into [ t : number | t; ];
			min := if n ≤ min then [ n; ] else [ min; ];
			¬(min = -∞);
		];
		min;
	] : number;
];

/**
 * Answer the minimum of the specified numbers.
 *
 * Parameters:
 *    numbers - A tuple of numbers.
 * Returns:
 *    The minimum of the specified numbers.
 */
Method "min_" is minimum function;

/**
 * Answer the minimum of the specified numbers.
 *
 * Parameters:
 *    numbers - A tuple of numbers.
 * Returns:
 *    The minimum of the specified numbers.
 */
Method "«_‡min»" is minimum function;

/* Don't parse `«_‡min»` recursively. */
invoke
[
	cast ::= [ t : {string|whole number} | t; ];
	names ::= cast <"«_‡min»">→set into cast;
	exclusions ::= cast <"«_‡min»">→set into cast;
	Grammatical restriction names is <exclusions>;
]
with <>;

/**
 * Answer a function that computes the maximum of a tuple of numbers.
 * 
 * Returns:
 *    The requested function.
 */
Method "maximum function" is
[
	[
		numbers : <<>, number…|[1..∞)>
	|
		max : number := cast numbers[1] into [ t : number | t; ];
		From 2 to |numbers| do
		[
			index : natural number
		|
			n ::= cast numbers[index] into [ t : number | t; ];
			max := if n ≤ max then [ max; ] else [ n; ];
			¬(max = ∞);
		];
		max;
	] : number;
];

/**
 * Answer the maximum of the specified numbers.
 *
 * Parameters:
 *    numbers - A tuple of numbers.
 * Returns:
 *    The maximum of the specified numbers.
 */
Method "max_" is maximum function;

/**
 * Answer the maximum of the specified numbers.
 *
 * Parameters:
 *    numbers - A tuple of numbers.
 * Returns:
 *    The maximum of the specified numbers.
 */
Method "«_‡max»" is maximum function;

/* Don't parse `«_‡max»` recursively. */
invoke
[
	cast ::= [ t : {string|whole number} | t; ];
	names ::= cast <"«_‡max»">→set into cast;
	exclusions ::= cast <"«_‡max»">→set into cast;
	Grammatical restriction names is <exclusions>;
]
with <>;

/**
 * Answer the semantic restriction function for minimum determination when all
 * values are extended integers.
 * 
 * Returns:
 *    The semantic restriction function.
 */
Method "minimum semantic restriction" is
[
	[
		numbers : <<>, extended integer…|[1..∞)>'s type
	|
		first ::= cast numbers[1] into [ t : extended integer meta | t; ];
		min : extended integer := first's lower bound;
		minInclusive : boolean := first's lower bound is inclusive;
		max : extended integer := first's upper bound;
		maxInclusive : boolean := first's upper bound is inclusive;
		limit ::= cast |numbers's leading types| + 1
			into [ t : natural number | t; ];
		From 2 to limit do
		[
			index : natural number
		|
			value ::= cast numbers[index]
				into [ t : extended integer meta | t; ];
			lower ::= value's lower bound;
			if lower = min then
			[
				minInclusive :=
					minInclusive ∨ [ value's lower bound is inclusive; ];
			]
			else
			[
				if lower < min then
				[
					min := lower;
					minInclusive := value's lower bound is inclusive;
				];
			];
			upper ::= value's upper bound;
			if upper = max then
			[
				maxInclusive :=
					maxInclusive ∧ [ value's upper bound is inclusive; ];
			]
			else
			[
				if upper < max then
				[
					max := upper;
					maxInclusive := value's upper bound is inclusive;
				];
			];
			true;
		];
		if (min = max) ∧ [ minInclusive = maxInclusive; ] then
		[
			min's type;
		]
		else
		[
			integer range
				from min (inclusive=minInclusive)
				to max (inclusive=maxInclusive);
		];
	] : extended integer meta;
];

/**
 * Given integer ranges [a1,n1], [a2,n2], [a3,n3], etc., the minimum
 * value will lie between [a1 min a2 min a3 min ..., n1 min n2 min n3 min ...].
 * Answer an instance type if possible.
 *
 * Parameters:
 *    numbers - The static types of the operand expressions.
 * Returns:
 *    The strongest possible integer range for the minimum value.
 */
Semantic restriction "min_" is minimum semantic restriction;
Semantic restriction "«_‡min»" is minimum semantic restriction;

/**
 * Answer the semantic restriction function for extremum determination when all
 * values are single-precision floating point numbers.
 * 
 * Returns:
 *    The semantic restriction function.
 */
Method "extremum semantic restriction(float)" is
[
	[
		number : <<>, float…|[2..∞)>'s type
	|
		float;
	];
];

/**
 * Answer the semantic restriction function for extremum determination when all
 * values are double-precision floating point numbers.
 * 
 * Returns:
 *    The semantic restriction function.
 */
Method "extremum semantic restriction(double)" is
[
	[
		number : <<>, double…|[2..∞)>'s type
	|
		double;
	];
];

/**
 * Given only floats, the minimum must be a float.
 *
 * Parameters:
 *    number - The static types of the operand expressions.
 * Returns:
 *    `float`.
 */
Semantic restriction "min_" is extremum semantic restriction (float);
Semantic restriction "«_‡min»" is extremum semantic restriction (float);

/**
 * Given only doubles, the minimum must be a double.
 *
 * Parameters:
 *    number - The static types of the operand expressions.
 * Returns:
 *    `double`.
 */
Semantic restriction "min_" is extremum semantic restriction (double);
Semantic restriction "«_‡min»" is extremum semantic restriction (double);

/**
 * Answer the semantic restriction function for maximum determination when all
 * values are extended integers.
 * 
 * Returns:
 *    The semantic restriction function.
 */
Method "maximum semantic restriction" is
[
	[
		numbers : <<>, extended integer…|[1..∞)>'s type
	|
		first ::= cast numbers[1] into [ t : extended integer meta | t; ];
		min : extended integer := first's lower bound;
		minInclusive : boolean := first's lower bound is inclusive;
		max : extended integer := first's upper bound;
		maxInclusive : boolean := first's upper bound is inclusive;
		limit ::= cast |numbers's leading types| + 1
			into [ t : natural number | t; ];
		From 2 to limit do
		[
			index : natural number
		|
			value ::= cast numbers[index]
				into [ t : extended integer meta | t; ];
			lower ::= value's lower bound;
			if min = lower then
			[
				minInclusive :=
					minInclusive ∧ [ value's lower bound is inclusive; ];
			]
			else
			[
				if min < lower then
				[
					min := lower;
					minInclusive := value's lower bound is inclusive;
				];
			];
			upper ::= value's upper bound;
			if max = upper then
			[
				maxInclusive :=
					maxInclusive ∨ [ value's upper bound is inclusive; ];
			]
			else
			[
				if max < upper then
				[
					max := upper;
					maxInclusive := value's upper bound is inclusive;
				];
			];
			true;
		];
		if (min = max) ∧ [ minInclusive = maxInclusive; ] then
		[
			min's type;
		]
		else
		[
			integer range
				from min (inclusive=minInclusive)
				to max (inclusive=maxInclusive);
		];
	] : extended integer meta;
];

/**
 * Given integer ranges [a1,n1], [a2,n2], [a3,n3], etc., the maximum
 * value will lie between [a1 max a2 max a3 max ..., n1 max n2 max n3 max ...].
 * Answer an instance type if possible.
 *
 * Parameters:
 *    numbers - The static types of the operand expressions.
 * Returns:
 *    The strongest possible integer range for the maximum value.
 */
Semantic restriction "max_" is maximum semantic restriction;
Semantic restriction "«_‡max»" is maximum semantic restriction;

/**
 * Given only floats, the maximum must be a float.
 *
 * Parameters:
 *    number - The static types of the operand expressions.
 * Returns:
 *    `float`.
 */
Semantic restriction "max_" is extremum semantic restriction (float);
Semantic restriction "«_‡max»" is extremum semantic restriction (float);

/**
 * Given only doubles, the maximum must be a double.
 *
 * Parameters:
 *    number - The static types of the operand expressions.
 * Returns:
 *    `double`.
 */
Semantic restriction "max_" is extremum semantic restriction (double);
Semantic restriction "«_‡max»" is extremum semantic restriction (double);

/**
 * Is `a` greater than `b`?
 * 
 * Parameters:
 *    a - A number.
 *    b - A number.
 * Returns:
 *    `true` if `a` is greater than `b`, `false` otherwise.
 */
Method "_>_" is
[
	a : number,
	b : number
|
	b < a;
] : boolean;

/**
 * Is `a` greater than or equal to `b`?
 * 
 * Parameters:
 *    a - A number.
 *    b - A number.
 * Returns:
 *    `true` if `a` is greater than or equal to `b`, `false` otherwise.
 */
Method "_≥_" is
[
	a : number,
	b : number
|
	b ≤ a;
] : boolean;

/* Make addition and subtraction left-associative. */
invoke
[
	cast ::= [ t : {string|whole number} | t; ];
	names ::= cast <"_+_", "_-_">→set into cast;
	Grammatical restriction names is <∅, names>;
]
with <>;
