/*
 * Early Math.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Early Math"
Versions
	"dev"
Uses
	"Bootstrap",
	"Definers",
	"Early Assertions",
	"Early Control Structures",
	"Early Enumeration Support",
	"Early Literals",
	"Early Logic"
Names
	"[_.._]",
	"[_.._)",
	"(_.._]",
	"(_.._)",
	"_is finite",
	"_is infinite",
	"⎣_⎦is inclusive",
	"⎡_⎤is inclusive",
	"max_",
	"min_",
	"«_‡max»",
	"«_‡min»",
	"_>_",
	"_≥_",

	/* Exported for use by Math. */
	"type promotion function for_"
Body

/**
 * Answer the semantic restriction function that should be used for each of
 * `_'s⁇genuine lower bound` and `_'s⁇genuine upper bound`.
 *
 * Returns:
 *    A function that strengthens the integer range bounds methods.
 */
Private method "integer range genuine«lower»?«upper»?\
		\|bound semantic restriction function" is
[
	wantsLower : boolean,
	wantsUpper : boolean
|
	Assert: wantsLower ≠ wantsUpper
		("exactly one of {\"lower\", \"upper\"} to follow \"genuine\"");
	[
		range : extended integer meta's type
	|
		instances ::= cast range's instances
			into [ t : {extended integer meta|whole number} | t ];
		Assert: |instances| = 1 ("range should be a single instance");
		instance ::= cast instances→tuple[1] into
			[ t : extended integer meta | t ];
		/* Must accommodate ⊥. It answers ∞ for its lower bound and -∞ for its
		 * upper bound.
		 */
		lower ::= if wantsUpper
			then [ -∞ ]
			else [ instance's genuine lower bound ];
		upper ::= if wantsLower
			then [ ∞ ]
			else [ instance's genuine upper bound ];
		integer range from lower (inclusive=true) to upper (inclusive=true)
	]
];

/**
 * Strengthen the bound to have the same static type as the argument. Note that
 * this is the strongest possible type because the argument's subtypes have
 * lower and upper bounds drawn from the argument's entire range.
 *
 * Parameters:
 *    range -
 * Returns:
 *    The same type as the argument to `⎣_⎦`.
 */
Semantic restriction "_'s⁇genuine lower bound" is
	integer range genuine lower bound semantic restriction function;

/**
 * Strengthen the bound to have the same static type as the argument. Note that
 * this is the strongest possible type because the argument's subtypes have
 * lower and upper bounds drawn from the argument's entire range.
 *
 * Parameters:
 *    range -
 * Returns:
 *    The same type as the argument to `⎡_⎤`.
 */
Semantic restriction "_'s⁇genuine upper bound" is
	integer range genuine upper bound semantic restriction function;

/**
 * Answer the lower bound of the specified integral range type. Note that unlike
 * `_'s⁇genuine lower bound`, this method explicitly forbids the argument from
 * being ⊥. It is intended as a practical (but not universal) replacement.
 *
 * Parameters:
 *    range - An integral range type. Must not be ⊥.
 * Returns:
 *    The lower bound of the argument.
 */
Method "⎣_⎦" is
[
	range : extended integer meta
|
	Assert: range ≠ ⊥ ("must use `_'s⁇genuine lower bound` for ⊥");
	range's genuine lower bound
];

/**
 * Answer the upper bound of the specified integral range type. Note that unlike
 * `_'s⁇genuine upper bound`, this method explicitly forbids the argument from
 * being ⊥. It is intended as a practical (but not universal) replacement.
 *
 * Parameters:
 *    range - An integral range type. Must not be ⊥.
 * Returns:
 *    The upper bound of the argument.
 */
Method "⎡_⎤" is
[
	range : extended integer meta
|
	Assert: range ≠ ⊥ ("must use `_'s⁇genuine upper bound` for ⊥");
	range's genuine upper bound
];

/**
 * Answer the semantic restriction function that should be used for each of
 * `⎣_⎦` and `⎡_⎤`.
 *
 * Returns:
 *    A function that strengthens the integer range bounds methods.
 */
Private method "integer range bound semantic restriction function" is
[
	[
		range : extended integer meta's type
	|
		instances ::= cast range's instances
			into [ t : {extended integer meta|whole number} | t ];
		Assert: |instances| = 1 ("range should be a single instance");
		instance ::= cast instances→tuple[1] into
			[ t : extended integer meta | t ];
		/* Specifically do not accommodate ⊥. */
		integer range
			from ⎣instance⎦ (inclusive=true)
			to ⎡instance⎤ (inclusive=true)
	]
];

/**
 * Strengthen the bound to have the same static type as the argument. Note that
 * this is the strongest possible type because the argument's subtypes have
 * lower and upper bounds drawn from the argument's entire range.
 *
 * Parameters:
 *    range -
 * Returns:
 *    The same type as the argument to `⎣_⎦`.
 */
Semantic restriction "⎣_⎦" is
	integer range bound semantic restriction function;

/**
 * Strengthen the bound to have the same static type as the argument. Note that
 * this is the strongest possible type because the argument's subtypes have
 * lower and upper bounds drawn from the argument's entire range.
 *
 * Parameters:
 *    range -
 * Returns:
 *    The same type as the argument to `⎡_⎤`.
 */
Semantic restriction "⎡_⎤" is
	integer range bound semantic restriction function;

/**
 * Construct and answer an integer range type with the specified bounds.
 * 
 * Parameters:
 *    lowerBound - The lower bound, inclusive.
 *    upperBound - The upper bound, inclusive.
 * Returns:
 *    The requested integer range.
 */
Public method "[_.._]" is
[
	lowerBound : extended integer,
	upperBound : extended integer
|
	integer range
		from lowerBound (inclusive=true)
		to upperBound (inclusive=true)
] : extended integer meta;

/**
 * Strengthen integer range types.
 *
 * Parameters:
 *    lowerBound -
 *    upperBound -
 * Returns:
 *    The most specific possible type of the integer range type expression.
 */
Semantic restriction "[_.._]" is
[
	lowerBound : extended integer meta,
	upperBound : extended integer meta
|
	(integer range
		from ⎣lowerBound⎦ (inclusive=true)
		to ⎡upperBound⎤ (inclusive=true))'s type
];

/**
 * Construct and answer an integer range type with the specified bounds.
 * 
 * Parameters:
 *    lowerBound - The lower bound, inclusive.
 *    upperBound - The upper bound, exclusive.
 * Returns:
 *    The requested integer range.
 */
Public method "[_.._)" is
[
	lowerBound : extended integer,
	upperBound : extended integer
|
	integer range
		from lowerBound (inclusive=true)
		to upperBound (inclusive=false)
] : extended integer meta;

/**
 * Strengthen integer range types.
 *
 * Parameters:
 *    lowerBound -
 *    upperBound -
 * Returns:
 *    The most specific possible type of the integer range type expression.
 */
Semantic restriction "[_.._)" is
[
	lowerBound : extended integer meta,
	upperBound : extended integer meta
|
	(integer range
		from ⎣lowerBound⎦ (inclusive=true)
		to ⎡upperBound⎤ (inclusive=false))'s type
];

/**
 * Construct and answer an integer range type with the specified bounds.
 * 
 * Parameters:
 *    lowerBound - The lower bound, exclusive.
 *    upperBound - The upper bound, inclusive.
 * Returns:
 *    The requested integer range.
 */
Public method "(_.._]" is
[
	lowerBound : extended integer,
	upperBound : extended integer
|
	integer range
		from lowerBound (inclusive=false)
		to upperBound (inclusive=true)
] : extended integer meta;

/**
 * Strengthen integer range types.
 *
 * Parameters:
 *    lowerBound -
 *    upperBound -
 * Returns:
 *    The most specific possible type of the integer range type expression.
 */
Semantic restriction "(_.._]" is
[
	lowerBound : extended integer meta,
	upperBound : extended integer meta
|
	(integer range
		from ⎣lowerBound⎦ (inclusive=false)
		to ⎡upperBound⎤ (inclusive=true))'s type
];

/**
 * Construct and answer an integer range type with the specified bounds.
 * 
 * Parameters:
 *    lowerBound - The lower bound, exclusive.
 *    upperBound - The upper bound, exclusive.
 * Returns:
 *    The requested integer range.
 */
Public method "(_.._)" is
[
	lowerBound : extended integer,
	upperBound : extended integer
|
	integer range
		from lowerBound (inclusive=false)
		to upperBound (inclusive=false)
] : extended integer meta;

/**
 * Strengthen integer range types.
 *
 * Parameters:
 *    lowerBound -
 *    upperBound -
 * Returns:
 *    The most specific possible type of the integer range type expression.
 */
Semantic restriction "(_.._)" is
[
	lowerBound : extended integer meta,
	upperBound : extended integer meta
|
	(integer range
		from ⎣lowerBound⎦ (inclusive=false)
		to ⎡upperBound⎤ (inclusive=false))'s type
];

/**
 * Is `value` within `range`?
 * 
 * Parameters:
 *    value - An extended integer.
 *    range - An integral range.
 * Returns:
 *    `true` if `value` is within `range`, `false` otherwise.
 */
Method "_∈_" is
[
	value : extended integer,
	range : extended integer meta
|
	value's type ⊆ range
] : boolean;

/**
 * Is the lower bound of the argument inclusive?
 * 
 * Note that integer ranges canonize each bound as inclusive unless the bound is
 * ±∞. So `(3..6)` is really `[4..5]` and will answer `true` if asked whether
 * its lower bound is inclusive. But `(-∞..0]` will answer `false` if asked
 * whether its lower bound is inclusive.
 * 
 * Parameters:
 *    range - An integer range.
 * Returns:
 *    `false` if the lower bound is infinite and exclusive, `true` otherwise.
 */
Public method "⎣_⎦is inclusive" is
[
	range : extended integer meta
|
	bound ::= ⎣range⎦;
	bound's type ⊆ range
] : boolean;

/**
 * Is the upper bound of the argument inclusive?
 * 
 * Note that integer ranges canonize each bound as inclusive unless the bound is
 * ±∞. So `(3..6)` is really `[4..5]` and will answer `true` if asked whether
 * its upper bound is inclusive. But `[0..∞)` will answer `false` if asked
 * whether its upper bound is inclusive.
 * 
 * Parameters:
 *    range - An integer range.
 * Returns:
 *    `false` if the upper bound is infinite and exclusive, `true` otherwise.
 */
Public method "⎡_⎤is inclusive" is
[
	range : extended integer meta
|
	bound ::= ⎡range⎤;
	bound's type ⊆ range
] : boolean;

/**
 * Answer a function that computes the minimum of a tuple of numbers.
 * 
 * Returns:
 *    The requested function.
 */
Private method "minimum function" is
[
	[
		numbers : <<>, number…|[1..∞)>
	|
		min : number := cast numbers[1] into [ t : number | t ];
		From 2 to |numbers| do
		[
			index : natural number
		|
			n ::= cast numbers[index] into [ t : number | t ];
			min := if n ≤ min then [ n ] else [ min ];
			¬(min = -∞)
		];
		min
	] : number
];

/**
 * Answer the minimum of the specified numbers.
 *
 * Parameters:
 *    numbers - A tuple of numbers.
 * Returns:
 *    The minimum of the specified numbers.
 */
Public method "min_" is minimum function;

/**
 * Answer the minimum of the specified numbers.
 *
 * Parameters:
 *    numbers - A tuple of numbers.
 * Returns:
 *    The minimum of the specified numbers.
 */
Public method "«_‡min»" is minimum function;

/* Don't parse `«_‡min»` recursively. */
Invoke
[
	cast ::= [ t : {string|whole number} | t ];
	names ::= cast <"«_‡min»">→set into cast;
	exclusions ::= cast <"«_‡min»">→set into cast;
	Grammatical restriction names is <exclusions>;
]
with <>;

/**
 * Answer a function that computes the maximum of a tuple of numbers.
 * 
 * Returns:
 *    The requested function.
 */
Private method "maximum function" is
[
	[
		numbers : <<>, number…|[1..∞)>
	|
		max : number := cast numbers[1] into [ t : number | t ];
		From 2 to |numbers| do
		[
			index : natural number
		|
			n ::= cast numbers[index] into [ t : number | t ];
			max := if n ≤ max then [ max ] else [ n ];
			¬(max = ∞)
		];
		max
	] : number
];

/**
 * Answer the maximum of the specified numbers.
 *
 * Parameters:
 *    numbers - A tuple of numbers.
 * Returns:
 *    The maximum of the specified numbers.
 */
Public method "max_" is maximum function;

/**
 * Answer the maximum of the specified numbers.
 *
 * Parameters:
 *    numbers - A tuple of numbers.
 * Returns:
 *    The maximum of the specified numbers.
 */
Public method "«_‡max»" is maximum function;

/* Don't parse `«_‡max»` recursively. */
Invoke
[
	cast ::= [ t : {string|whole number} | t ];
	names ::= cast <"«_‡max»">→set into cast;
	exclusions ::= cast <"«_‡max»">→set into cast;
	Grammatical restriction names is <exclusions>;
]
with <>;

/**
 * Answer the semantic restriction function for minimum determination when all
 * values are extended integers.
 * 
 * Returns:
 *    The semantic restriction function.
 */
Private method "minimum semantic restriction" is
[
	[
		numbers : <<>, extended integer…|[1..∞)>'s type
	|
		first ::= cast numbers[1] into [ t : extended integer meta | t ];
		min : extended integer := ⎣first⎦;
		minInclusive : boolean := ⎣first⎦ is inclusive;
		max : extended integer := ⎡first⎤;
		maxInclusive : boolean := ⎡first⎤ is inclusive;
		limit ::= cast |numbers' leading types| + 1
			into [ t : natural number | t ];
		From 2 to limit do
		[
			index : natural number
		|
			value ::= cast numbers[index]
				into [ t : extended integer meta | t ];
			lower ::= ⎣value⎦;
			If lower = min then
			[
				minInclusive :=
					minInclusive ∨ [ ⎣value⎦ is inclusive ];
			]
			else
			[
				If lower < min then
				[
					min := lower;
					minInclusive := ⎣value⎦ is inclusive;
				];
			];
			upper ::= ⎡value⎤;
			If upper = max then
			[
				maxInclusive :=
					maxInclusive ∧ [ ⎡value⎤ is inclusive ];
			]
			else
			[
				If upper < max then
				[
					max := upper;
					maxInclusive := ⎡value⎤ is inclusive;
				];
			];
			true
		];
		if (min = max) ∧ [ minInclusive = maxInclusive ] then
		[
			min's type
		]
		else
		[
			integer range
				from min (inclusive=minInclusive)
				to max (inclusive=maxInclusive)
		]
	] : extended integer meta
];

/**
 * Given integer ranges [a1,n1], [a2,n2], [a3,n3], etc., the minimum
 * value will lie between [a1 min a2 min a3 min ..., n1 min n2 min n3 min ...].
 * Answer an instance type if possible.
 *
 * Parameters:
 *    numbers - The static types of the operand expressions.
 * Returns:
 *    The strongest possible integer range for the minimum value.
 */
Semantic restriction "min_" is minimum semantic restriction;
Semantic restriction "«_‡min»" is minimum semantic restriction;

/**
 * Answer the semantic restriction function for extremum determination when all
 * values are single-precision floating point numbers.
 * 
 * Returns:
 *    The semantic restriction function.
 */
Private method "extremum semantic restriction(float)" is
[
	[
		number : <<>, float…|[2..∞)>'s type
	|
		float
	]
];

/**
 * Answer the semantic restriction function for extremum determination when all
 * values are double-precision floating point numbers.
 * 
 * Returns:
 *    The semantic restriction function.
 */
Private method "extremum semantic restriction(double)" is
[
	[
		number : <<>, double…|[2..∞)>'s type
	|
		double
	]
];

/**
 * Given only floats, the minimum must be a float.
 *
 * Parameters:
 *    number - The static types of the operand expressions.
 * Returns:
 *    `float`.
 */
Semantic restriction "min_" is extremum semantic restriction (float);
Semantic restriction "«_‡min»" is extremum semantic restriction (float);

/**
 * Given only doubles, the minimum must be a double.
 *
 * Parameters:
 *    number - The static types of the operand expressions.
 * Returns:
 *    `double`.
 */
Semantic restriction "min_" is extremum semantic restriction (double);
Semantic restriction "«_‡min»" is extremum semantic restriction (double);

/**
 * Answer the semantic restriction function for maximum determination when all
 * values are extended integers.
 * 
 * Returns:
 *    The semantic restriction function.
 */
Private method "maximum semantic restriction" is
[
	[
		numbers : <<>, extended integer…|[1..∞)>'s type
	|
		first ::= cast numbers[1] into [ t : extended integer meta | t ];
		min : extended integer := ⎣first⎦;
		minInclusive : boolean := ⎣first⎦ is inclusive;
		max : extended integer := ⎡first⎤;
		maxInclusive : boolean := ⎡first⎤ is inclusive;
		limit ::= cast |numbers' leading types| + 1
			into [ t : natural number | t ];
		From 2 to limit do
		[
			index : natural number
		|
			value ::= cast numbers[index]
				into [ t : extended integer meta | t ];
			lower ::= ⎣value⎦;
			If min = lower then
			[
				minInclusive :=
					minInclusive ∧ [ ⎣value⎦ is inclusive ];
			]
			else
			[
				If min < lower then
				[
					min := lower;
					minInclusive := ⎣value⎦ is inclusive;
				];
			];
			upper ::= ⎡value⎤;
			If max = upper then
			[
				maxInclusive :=
					maxInclusive ∨ [ ⎡value⎤ is inclusive ];
			]
			else
			[
				If max < upper then
				[
					max := upper;
					maxInclusive := ⎡value⎤ is inclusive;
				];
			];
			true
		];
		if (min = max) ∧ [ minInclusive = maxInclusive ] then
		[
			min's type
		]
		else
		[
			integer range
				from min (inclusive=minInclusive)
				to max (inclusive=maxInclusive)
		]
	] : extended integer meta
];

/**
 * Given integer ranges [a1,n1], [a2,n2], [a3,n3], etc., the maximum
 * value will lie between [a1 max a2 max a3 max ..., n1 max n2 max n3 max ...].
 * Answer an instance type if possible.
 *
 * Parameters:
 *    numbers - The static types of the operand expressions.
 * Returns:
 *    The strongest possible integer range for the maximum value.
 */
Semantic restriction "max_" is maximum semantic restriction;
Semantic restriction "«_‡max»" is maximum semantic restriction;

/**
 * Given only floats, the maximum must be a float.
 *
 * Parameters:
 *    number - The static types of the operand expressions.
 * Returns:
 *    `float`.
 */
Semantic restriction "max_" is extremum semantic restriction (float);
Semantic restriction "«_‡max»" is extremum semantic restriction (float);

/**
 * Given only doubles, the maximum must be a double.
 *
 * Parameters:
 *    number - The static types of the operand expressions.
 * Returns:
 *    `double`.
 */
Semantic restriction "max_" is extremum semantic restriction (double);
Semantic restriction "«_‡max»" is extremum semantic restriction (double);

/**
 * Is `a` greater than `b`?
 * 
 * Parameters:
 *    a - A number.
 *    b - A number.
 * Returns:
 *    `true` if `a` is greater than `b`, `false` otherwise.
 */
Public stable method "_>_" is
[
	a : number,
	b : number
|
	b < a
] : boolean;

/**
 * Is `a` greater than or equal to `b`?
 * 
 * Parameters:
 *    a - A number.
 *    b - A number.
 * Returns:
 *    `true` if `a` is greater than or equal to `b`, `false` otherwise.
 */
Public stable method "_≥_" is
[
	a : number,
	b : number
|
	b ≤ a
] : boolean;

/* Make addition and subtraction left-associative. */
Invoke
[
	cast ::= [ t : {string|whole number} | t ];
	names ::= cast <"_+_", "_-_">→set into cast;
	Grammatical restriction names is <∅, names>;
]
with <>;

Public abstract method "_is finite" is
	function accepting <number> and returning boolean;
Method "_is finite" is stable at
	function accepting <number> and returning boolean;

/**
 * Is the argument finite?
 * 
 * Parameters:
 *    a - A double.
 * Returns:
 *    `true` if the argument is finite, `false` otherwise.
 */
Method "_is finite" is
[
	a : double
|
	¬a→extended integer ∈ {-∞, ∞}
];

/**
 * Is the argument finite?
 * 
 * Parameters:
 *    a - A float.
 * Returns:
 *    `true` if the argument is finite, `false` otherwise.
 */
Method "_is finite" is
[
	a : float
|
	¬a→extended integer ∈ {-∞, ∞}
];

/**
 * Is the argument finite?
 * 
 * Parameters:
 *    a - An extended integer.
 * Returns:
 *    `true` if the argument is finite, `false` otherwise.
 */
Method "_is finite" is
[
	a : extended integer
|
	false
] : boolean;

/**
 * Is the argument finite?
 * 
 * Parameters:
 *    a - An integer.
 * Returns:
 *    `true` if the argument is finite, `false` otherwise.
 */
Method "_is finite" is
[
	a : integer
|
	true
] : true's type;

Public abstract method "_is infinite" is
	function accepting <number> and returning boolean;
Method "_is infinite" is stable at
	function accepting <number> and returning boolean;

/**
 * Is the argument infinite?
 * 
 * Parameters:
 *    a - A double.
 * Returns:
 *    `true` if the argument is infinite, `false` otherwise.
 */
Method "_is infinite" is
[
	a : double
|
	a→extended integer ∈ {-∞, ∞}
];

/**
 * Is the argument infinite?
 * 
 * Parameters:
 *    a - A float.
 * Returns:
 *    `true` if the argument is infinite, `false` otherwise.
 */
Method "_is infinite" is
[
	a : float
|
	a→extended integer ∈ {-∞, ∞}
];

/**
 * Is the argument infinite?
 * 
 * Parameters:
 *    a - An extended integer.
 * Returns:
 *    `true` if the argument is infinite, `false` otherwise.
 */
Method "_is infinite" is
[
	a : extended integer
|
	true
] : boolean;

/**
 * Is the argument infinite?
 * 
 * Parameters:
 *    a - An integer.
 * Returns:
 *    `true` if the argument is infinite, `false` otherwise.
 */
Method "_is infinite" is
[
	a : integer
|
	false
] : false's type;

/**
 * Construct and answer a function that affects type promotions for the various
 * numeric types. This function is intended for use by semantic restrictions
 * of binary arithmetic operators.
 *
 * Parameters:
 *    operator - A function that performs one of the basic arithmetic
 *       operations and answers the result.
 * Returns:
 *    A function that handles type promotions for the given operator.
 */
Public method "type promotion function for_" is
[
	operator : function accepting <number, number> and returning number
|
	[
		a : number's type,
		b : number's type
	|
		if |a| = 1 ∧ [ |b| = 1 ] then
		[
			/* The exact values are known statically. Calculate it exactly. */
			(invoke operator with <a's instance, b's instance>)'s type
		]
		else
		[
			if a ⊆ double ∨ [ b ⊆ double ] then
			[
				/* At least one is known to be double, which forces the result
				 * to be a double.
				 */
				double
			]
			else
			[
				if a = number ∨ [ b = number ] then
				[
					/* Neither is known to be a double, and at least one is as
					 * weak as a number.  The weak one might be a double at run
					 * time, so we can't limit the output type any more.
					 */
					number
				]
				else
				[
					/* Neither one is as weak as number. */
					if a ⊆ float ∨ [ b ⊆ float ] then
					[
						/* Either {float,float} or {float,int}, which each
						 * produce a float.
						 */
						float
					]
					else
					[
						if a ⊆ extended integer ∧ [ b ⊆ extended integer ]
						then [ extended integer ]
						else [ number ]
					]
				]
			]
		]
	]
];

/* These messages describe arithmetic failure (integers only). */
cannotAddMessage ::= "terms not to be unlike infinities";
cannotSubtractMessage ::= "terms not to be like infinities";
cannotMultiplyMessage ::= "terms not be 0 and ±∞";
cannotDivideByZeroMessage ::= "denominator not to be 0";
cannotDivideTwoInfinitiesMessage ::=
	"either numerator or denominator to be finite";

Semantic restriction "_+_" is type promotion function for
[
	a : number,
	b : number
|
	If {a, b} = {-∞, ∞} then
	[
		Reject parse, expected: cannotAddMessage
	];
	a + b
];

Semantic restriction "_-_" is type promotion function for
[
	a : number,
	b : number
|
	If {a, b} ∈ {{-∞}, {∞}} then
	[
		Reject parse, expected: cannotSubtractMessage
	];
	a - b
];

Semantic restriction "_×_" is type promotion function for
[
	a : number,
	b : number
|
	terms ::= {a, b};
	If terms = {0, ∞} ∨ [ terms = {0, -∞} ] then
	[
		Reject parse, expected: cannotMultiplyMessage
	];
	a × b
];

Semantic restriction "_÷_" is type promotion function for
[
	a : number,
	b : number
|
	If b = 0 ∧ [ a's type ⊆ extended integer ] then
	[
		Reject parse, expected: cannotDivideByZeroMessage
	];
	infinities ::= {∞, -∞};
	If a ∈ infinities ∧ [ b ∈ infinities ] then
	[
		Reject parse, expected: cannotDivideTwoInfinitiesMessage
	];
	a ÷ b
];
