/*
 * Tuples.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Tuples"
Versions
	"dev"
Extends
	"Collections",
	"Early Tuples"
Uses
	"Bootstrap",
	"Control Structures",
	"Definers",
	"Early Assertions",
	"Early Functions",
	"Early Maps",
	"Enumeration Support",
	"Literals",
	"Logic",
	"Math",
	"Types",
	"Variables"
Names
	"all indices of_where_",
	"distinct_",
	"first index of_where_",
	"flatten_",
	"last index of_where_",
	"left fold_through_",
	"right fold_through_",
	"split_after_",
	"split_before_",
	"stripe_at_",
	"zip_",
	"∑_",
	"∏_",
	"_contains_",
	"_ends with_",
	"_of_",
	"_starts with_",
	"_to_",
	"_'s⁇head",
	"_'s⁇last",
	"_'s⁇tail",
	"_[_.._]→_",
	"«_‡zip»"
Body

/**
 * Is the specified tuple empty?
 *
 * Parameters:
 *    aTuple - A tuple.
 * Returns:
 *    `true` if the argument is empty, `false` otherwise.
 */
Stable method "_is empty" is
[
	aTuple : tuple
|
	|aTuple| = 0
] : boolean;

/**
 * Iteratively apply `action` to each consecutive element of `aTuple`.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    action - A function that accepts the elements of the tuple.
 */
Method "For each_do_" is
[
	aTuple : tuple,
	action : [⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			Invoke action with <aTuple[index]>;
			↑index++;
			Restart loop
		];
	]();
] : ⊤;

/**
 * Iteratively apply `action` to each consecutive element of `aTuple`.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    action - A function that accepts 1) an element of the tuple and 2) the
 *       index of that element.
 */
Method "For each_do_" is
[
	aTuple : tuple,
	action : [⊥, ⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			Invoke action with <aTuple[index], index>;
			↑index++;
			Restart loop
		];
	]();
] : ⊤;

/**
 * Helper method for semantic restrictions: If `action` does not accept the
 * type union of all element types of `tupleType` and their indices, then reject
 * the current parse.
 * 
 * Parameters:
 *    action - A function type whose first parameter must correspond to the
 *       type union of the element types of `tupleType` and whose second
 *       parameter, if provided, must correspond to `indices`.
 *    tupleType - A tuple type.
 */
Method "Require:_accepts_" is
[
	action : function meta,
	tupleType : tuple meta
|
	If ⎣action's parameters' type⎦ < 1 then
	[
		Reject parse, expected:
			"repeatedly applied function to accept at least one argument"
	];
	union ::= ∪ tupleType[1..|tupleType's leading types| + 1];
	If action[1] ≠ ⊥ ∧ [ ¬union ⊆ action[1] ] then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all elements of the tuple ⊆ "
			++ “tupleType”
			++ " (but it only accepts "
			++ “action[1]”
			++ ")"
	];
	If ⎣action's parameters' type⎦ = 2
		∧ [ action[2] ≠ ⊥
		∧ [ ¬[1..⎡tupleType⎤ + 1) ⊆ action[2] ] ]
	then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all indices of the tuple ⊆ "
			++ “tupleType”
			++ " (but it only accepts "
			++ “action[2]”
			++ ")"
	];
] : ⊤;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * If the tuple is certainly nonempty and the function certainly does not
 * complete if applied, then answer ⊥.
 */
Semantic restriction "For each_do_" is
[
	tupleType : tuple meta,
	action : function meta
|
	Require: action accepts tupleType;
	if ⎣tupleType⎦ > 0 ∧ [ action's return type = ⊥ ] then
	[
		⊥
	]
	else
	[
		⊤
	]
];

/**
 * Iteratively apply `transformer` to each consecutive element of `aTuple`,
 * collecting the results into a new tuple (and preserving ordering of the
 * transformed elements). Answer this tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    transformer - A function that accepts the elements of the tuple.
 * Returns:
 *    A tuple of results of applications of `transformer` to the elements of
 *    `aTuple`.
 */
Method "map_through_" is
[
	aTuple : tuple,
	transformer : [⊥]→any
|
	index : natural number := 1;
	result : tuple := <>;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			result :=
				eject ↑result ++ <invoke transformer with <aTuple[index]>>;
			↑index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Iteratively apply `transformer` to each consecutive element of `aTuple`,
 * collecting the results into a new tuple (and preserving ordering of the
 * transformed elements). Answer this tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    transformer - A function that accepts 1) an element of the tuple and 2)
 *       the index of that element.
 * Returns:
 *    A tuple of results of applications of `transformer` to the elements and
 *    indices of `aTuple`.
 */
Method "map_through_" is
[
	aTuple : tuple,
	transformer : [⊥, ⊥]→any
|
	index : natural number := 1;
	result : tuple := <>;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			result := eject ↑result
				++ <invoke transformer with <aTuple[index], index>>;
			↑index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * If the tuple is certainly nonempty, then the function cannot answer ⊥.
 */
Semantic restriction "map_through_" is
[
	tupleType : tuple meta,
	transformer : […]→any's type
|
	Require: transformer accepts tupleType;
	If ⎣tupleType⎦ > 0 then
	[
		If transformer's return type = ⊥ then
		[
			Reject parse, expected:
				"repeatedly applied function to have a return type other than\
				\| ⊥"
		];
	];
	<<>, transformer's return type… | ||tupleType||>
];

/**
 * Iteratively apply `predicate` to each consecutive element of `aTuple`,
 * collecting those elements for which `predicate` answers `true` into a new
 * tuple (and preserving ordering). Answer the new tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple and answers
 *       `true` iff they should be accumulated into the output tuple.
 * Returns:
 *    A tuple containing exactly those elements of `aTuple` for which
 *    `predicate` answered `true`.
 */
Method "filter_by_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop;
		If index ≤ end then
		[
			element ::= aTuple[index];
			If invoke predicate with <element> then
			[
				result := eject ↑result ++ <element>;
			];
			↑index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Iteratively apply `predicate` to each consecutive element and index of
 * `aTuple`, collecting those elements for which `predicate` answers `true` into
 * a new tuple (and preserving ordering). Answer the new tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts 1) an element of the tuple and 2)
 *       the index of that element and which answers `true` iff the elements
 *       should be accumulated into the output tuple.
 * Returns:
 *    A tuple containing exactly those elements of `aTuple` for which
 *    `predicate` answered `true`.
 */
Method "filter_by_" is
[
	aTuple : tuple,
	predicate : [⊥, ⊥]→boolean
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop;
		If index ≤ end then
		[
			element ::= aTuple[index];
			If invoke predicate with <element, index> then
			[
				result := eject ↑result ++ <element>;
			];
			↑index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 */
Semantic restriction "filter_by_" is
[
	tupleType : tuple meta,
	predicate : […]→boolean's type
|
	Require: predicate accepts tupleType;
	if predicate's return type = true's type then
	[
		tupleType
	]
	else
	[
		union ::= ∪ tupleType[1..|tupleType's leading types| + 1];
		sizes ::=
			if predicate's return type = false's type then [ 0's type ]
			else [ [0..⎡tupleType⎤ + 1) ];
		<<>, union…|sizes>
	]
];

/**
 * Iteratively apply `accumulator` to the consecutive elements of `aTuple` in
 * order to transform and filter its elements into a new tuple. When
 * `accumulator` is invoked, it is passed a "keeper" function. The keeper
 * function may be invoked to "save" a particular value, i.e., a value that will
 * be copied into the output tuple. The keeper function will save at most one
 * value per element of `aTuple`, i.e., each time that `accumulator` is invoked,
 * it may invoke the keeper function at most one time. Answer the new tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    accumulator - A function that accepts 1) an element from `aTuple` and 2)
 *       a keeper function. The keeper function accepts an argument of the type
 *       that should be saved.
 * Returns:
 *    A tuple whose elements are those saved by the `accumulator`.
 */
Method "map and filter_by_" is
[
	aTuple : tuple,
	accumulator : [⊥, ⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop;
		If index ≤ end then
		[
			hasAlreadyKept : boolean := false;
			Invoke accumulator with
			<
				aTuple[index],
				[
					transformed : any
				|
					If ¬hasAlreadyKept then
					[
						result := eject ↑result ++ <transformed>;
						hasAlreadyKept := true;
					];
				]
			>;
			↑index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Iteratively apply `accumulator` to the consecutive elements and indices of
 * `aTuple` in order to transform and filter its elements into a new tuple. When
 * `accumulator` is invoked, it is passed a "keeper" function. The keeper
 * function may be invoked to "save" a particular value, i.e., a value that will
 * be copied into the output tuple. The keeper function will save at most one
 * value per element of `aTuple`, i.e., each time that `accumulator` is invoked,
 * it may invoke the keeper function at most one time. Answer the new tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    accumulator - A function that accepts 1) an element from `aTuple`, 2) the
 *       index of that element, and 3) a keeper function. The keeper function
 *       accepts an argument of the type that should be saved.
 * Returns:
 *    A tuple whose elements are those saved by the `accumulator`.
 */
Method "map and filter_by_" is
[
	aTuple : tuple,
	accumulator : [⊥, ⊥, ⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop;
		If index ≤ end then
		[
			hasAlreadyKept : boolean := false;
			Invoke accumulator with
			<
				aTuple[index],
				index,
				[
					transformed : any
				|
					If ¬hasAlreadyKept then
					[
						result := eject ↑result ++ <transformed>;
						hasAlreadyKept := true;
					];
				]
			>;
			↑index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Ensure that the function will accept all elements of the tuple and also an
 * appropriately typed keeper function.
 */
Semantic restriction "map and filter_by_" is
[
	tupleType : tuple meta,
	accumulator : [⊥, ⊥]→⊤'s type
|
	union ::= ∪ tupleType[1..|tupleType's leading types| + 1];
	If accumulator[1] ≠ ⊥ ∧ [ ¬union ⊆ accumulator[1] ] then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all elements of the tuple ⊆ "
			++ “tupleType”
			++ " (but it only accepts "
			++ “accumulator[1]”
			++ ")"
	];
	Require: accumulator's keeper is valid;
	If accumulator's return type ≠ ⊤ then
	[
		Reject parse, expected:
			"repeatedly applied function to have return type ⊤"
	];
	<
		<>,
		cast accumulator[2] into [ t : function meta | t[1] ]…
		| [0..⎡tupleType⎤ + 1)
	>
];

/**
 * Ensure that the function will accept all elements and indices of the tuple
 * and also an appropriately typed keeper function.
 */
Semantic restriction "map and filter_by_" is
[
	tupleType : tuple meta,
	accumulator : [⊥, ⊥, ⊥]→⊤'s type
|
	union ::= ∪ tupleType[1..|tupleType's leading types| + 1];
	If accumulator[1] ≠ ⊥ ∧ [ ¬union ⊆ accumulator[1] ] then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all elements of the tuple ⊆ "
			++ “tupleType”
			++ " (but it only accepts "
			++ “accumulator[1]”
			++ ")"
	];
	If accumulator[2] ≠ ⊥
		∧ [ ¬[1..⎡tupleType⎤ + 1) ⊆ accumulator[2] ]
	then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all indices of the tuple ⊆ "
			++ “tupleType”
			++ " (but it only accepts "
			++ “accumulator[2]”
			++ ")"
	];
	Require: accumulator's keeper is valid;
	If accumulator's return type ≠ ⊤ then
	[
		Reject parse, expected:
			"repeatedly applied function to have return type ⊤"
	];
	<
		<>,
		cast accumulator[2] into [ t : function meta | t[1] ]…
		| [0..⎡tupleType⎤ + 1)
	>
];

/**
 * Compute and answer whether any of the elements of `aTuple` satisfies the
 * specified function. Do not examine more elements than necessary.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple and answers
 *       a boolean.
 * Returns:
 *    `true` if `predicate` answers `true` for any element of `aTuple`, `false`
 *    otherwise.
 */
Method "any of_satisfies_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	$body : boolean;
	For each aTuple do
	[
		element : any
	|
		If invoke predicate with <element> then
		[
			Exit body with true
		];
	];
	false
] : boolean;

/**
 * Compute and answer whether any of the elements (and indices) of `aTuple`
 * satisfy the specified function. Do not examine more elements than necessary.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts 1) an element of the tuple and 2) the
 *       index of that element.
 * Returns:
 *    `true` if `predicate` answers `true` for any element of `aTuple`, `false`
 *    otherwise.
 */
Method "any of_satisfies_" is
[
	aTuple : tuple,
	predicate : [⊥, ⊥]→boolean
|
	$body : boolean;
	For each aTuple do
	[
		element : any,
		index : natural number
	|
		If invoke predicate with <element, index> then
		[
			Exit body with true
		];
	];
	false
] : boolean;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 */
Semantic restriction "any of_satisfies_" is
[
	tupleType : tuple meta,
	predicate : […]→boolean's type
|
	Require: predicate accepts tupleType;
	predicate's return type
];

/**
 * Compute and answer whether each of the elements of `aTuple` satisfies the
 * specified function. Do not examine more elements than necessary.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple and answers
 *       a boolean.
 * Returns:
 *    `true` if `predicate` answers `true` for each element of `aTuple`, `false`
 *    otherwise.
 */
Method "each of_satisfies_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	$body : boolean;
	For each aTuple do
	[
		element : any
	|
		Unless invoke predicate with <element> then
		[
			Exit body with false
		];
	];
	true
] : boolean;

/**
 * Compute and answer whether each of the elements (and indices) of `aTuple`
 * satisfy the specified function. Do not examine more elements than necessary.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts 1) an element of the tuple and 2) the
 *       index of that element and answers a boolean.
 * Returns:
 *    `true` if `predicate` answers `true` for each element of `aTuple`, `false`
 *    otherwise.
 */
Method "each of_satisfies_" is
[
	aTuple : tuple,
	predicate : [⊥, ⊥]→boolean
|
	$body : boolean;
	For each aTuple do
	[
		element : any,
		index : natural number
	|
		Unless invoke predicate with <element, index> then
		[
			Exit body with false
		];
	];
	true
] : boolean;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 */
Semantic restriction "each of_satisfies_" is
[
	tupleType : tuple meta,
	predicate : […]→boolean's type
|
	Require: predicate accepts tupleType;
	predicate's return type
];

/**
 * Compute and answer the count of elements of `aTuple` that satisfy the given
 * predicate.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple and answers
 *       `true` if the element should be represented in the resulting count.
 * Returns:
 *    The number of elements of `aTuple` for which `predicate` answers `true`.
 */
Method "count of_where_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	|filter aTuple by predicate|
] : whole number;

/**
 * Compute and answer the count of elements (and indices) of `aTuple` that
 * satisfy the given predicate.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts 1) an element of the tuple and 2) the
 *       index of that element and answers `true` if the element should be
 *       represented in the resulting count.
 * Returns:
 *    The number of elements of `aTuple` for which `predicate` answers `true`.
 */
Method "count of_where_" is
[
	aTuple : tuple,
	predicate : [⊥, ⊥]→boolean
|
	|filter aTuple by predicate|
] : whole number;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 */
Semantic restriction "count of_where_" is
[
	tupleType : tuple meta,
	predicate : […]→boolean's type
|
	Require: predicate accepts tupleType;
	[0..⎡tupleType⎤ + 1)
];

/**
 * Compute and answer the distinct elements of `aTuple`, preserving order.
 * 
 * Parameters:
 *    aTuple - A tuple.
 * Returns:
 *    A tuple that contains only the distinct elements of `aTuple`, and in the
 *    order in which they were encountered.
 */
Public stable method "distinct_" is
[
	aTuple : tuple
|
	seen : set := ∅;
	filter aTuple by
	[
		element : any
	|
		if ¬element ∈ seen then
		[
			seen := eject ↑seen + element;
			true
		]
		else
		[
			false
		]
	]
] : tuple;

/* No decent semantic restrictions can be written yet for `distinct_` and
 * `_→set`. An efficient algorithm involves construction and evaluation of a
 * chromatic polynomial over the type intersection graph of the tuple type's
 * element types (the vertices represent the element types and an edge between
 * two vertices indicates that the type intersection of the element types is ⊥).
 * We cannot conveniently build graphs yet. We need object types and objects
 * first.
 */

/**
 * Answer a function that computes the zip of a tuple of tuples.
 * 
 * Returns:
 *    The requested function.
 */
Private method "zip function" is
[
	[
		tuples : <tuple…|1..>
	|
		accumulator : <tuple…|> := <>;
		limit ::= min map tuples through [ aTuple : tuple | |aTuple| ];
		From 1 to limit do
		[
			index : natural number
		|
			group : tuple := <>;
			For each tuples do
			[
				aTuple : tuple
			|
				group := eject ↑group ++ <aTuple[index]>;
			];
			accumulator := eject ↑accumulator ++ <group>;
		];
		accumulator
	] : tuple
] : [<tuple…|1..>]→tuple;

/**
 * Compute and answer the zip of the specified tuples. Given N input tuples, the
 * output is the tuple whose i-th element contains the i-th element from each
 * consecutive input tuple. The size of the output equals to the smallest size
 * of the inputs. Each of the output's tuples has length equal to the number of
 * inputs.
 * 
 * Parameters:
 *    tuples - A tuple of tuples.
 * Returns:
 *    The zip of the input tuples.
 */
Public method "zip_" is zip function;

/**
 * Compute and answer the zip of the specified tuples. Given N input tuples, the
 * output is the tuple whose i-th element contains the i-th element from each
 * consecutive input tuple. The size of the output equals to the smallest size
 * of the inputs. Each of the output's tuples has length equal to the number of
 * inputs.
 * 
 * Parameters:
 *    tuples - A tuple of tuples.
 * Returns:
 *    The zip of the input tuples.
 */
Public method "«_‡zip»" is zip function;

/* Don't parse `«_‡zip»` recursively. */
Grammatical restriction {"«_‡zip»"} is <{"«_‡zip»"}>;

/**
 * Answer the semantic restriction function for zipping tuples.
 * 
 * Returns:
 *    The semantic restriction function.
 */
Private method "zip semantic restriction" is
[
	[
		tuplesType : <tuple…|1..>'s type
	|
		/* Leverage an instance type if possible. */
		if |tuplesType| = 1 then
		[
			(zip tuplesType's instance)'s type
		]
		else
		[
			types ::= cast tuplesType[1..relevant |tuplesType|]
				into [ t : <tuple meta…|1..> | t ];
			/* Find the smallest of the lower bounds of the inputs. */
			lower ::=
				min map types through
				[
					tupleType : tuple meta
				|
					⎣tupleType⎦
				];
			/* Find the smallest of the upper bounds of the inputs. */
			upper ::=
				min map types through
				[
					tupleType : tuple meta
				|
					⎡tupleType⎤
				];
			/* Find the maximum number of element types to scan. */
			limit ::=
				max map types through
				[
					tupleType : tuple meta
				|
					|tupleType's leading types| + 1
				];
			resultTypes : <tuple meta…|> := <>;
			/* Examine the relevant element types of all inputs. */
			From 1 to limit do
			[
				index : natural number
			|
				zipped : tuple of any meta := <>;
				/* Examine the `index`-th element type of each input. Accumulate
				 * the results into `zipped`.
				 */
				For each types do
				[
					tupleType : tuple meta
				|
					zipped := eject ↑zipped ++ <tupleType[index]>;
				];
				nonempty ::= cast zipped
					into [ t : <any meta…|1..> | t ];
				zippedType ::=
					<nonempty[1..|nonempty| - 1], nonempty[|nonempty|]…
						| ||tuplesType||>;
				resultTypes := eject ↑resultTypes ++ <zippedType>;
			];
			nonempty ::= cast resultTypes into [ t : <tuple meta…|1..> | t ];
			resultSizes ::= [lower..upper + 1);
			<nonempty[1..|nonempty| - 1], nonempty[|nonempty|]… | resultSizes>
		]
	] : type
] : [<tuple…|1..>'s type]→type;

Semantic restriction "zip_" is zip semantic restriction;
Semantic restriction "«_‡zip»" is zip semantic restriction;

/**
 * Reduce `aTuple` via the binary function, traversing the tuple from left to
 * right. Answer the result of the reduction.
 *
 * Parameters:
 *    aTuple - A nonempty tuple.
 *    transformer - A binary function whose second parameter type matches its
 *       return type. The first parameter type must be general enough to accept
 *       each element of `aTuple`.
 * Returns:
 *    The only element of `aTuple` if `aTuple` contains only one element.
 *    Otherwise, the result of iteratively applying `transformer` to 1) the
 *    left-to-right consecutive elements of `aTuple` and 2) the previous results
 *    of applying `transformer`.
 */
Public method "left fold_through_" is
[
	aTuple : <any…|1..>,
	transformer : [⊥, ⊥]→any
|
	result : any := aTuple[1];
	From 2 to |aTuple| do
	[
		index : natural number
	|
		result := invoke transformer with <aTuple[index], eject ↑result>;
	];
	result
] : any;

/**
 * Left fold has the following requirements:
 *
 * - The function's first parameter must accept every element of the tuple
 *   except for the first (with which it will not be applied at this position).
 * - The function's second parameter must accept the tuple's first element and
 *   also every value producible by the function.
 *
 * Left fold answers either the tuple's first element or the value produced by
 * the final application of the function.
 */
Semantic restriction "left fold_through_" is
[
	tupleType : <any…|1..>'s type,
	transformer : [⊥, ⊥]→any's type
|
	headType ::= tupleType[1];
	restType ::= if |tupleType's leading types| > 0
		then [ ∪ tupleType[2..|tupleType's leading types| + 1] ]
		else [ headType ];
	returnType ::= transformer's return type;
	finalType ::= headType ∪ returnType;
	If transformer[1] ≠ ⊥ ∧ [ ¬restType ⊆ transformer[1] ] then
	[
		Reject parse, expected:
			"repeatedly applied function's first parameter to accept all\
			\| non-first elements of the tuple ⊆ "
			++ “restType”
			++ " (but it only accepts "
			++ “transformer[1]”
			++ ")"
	];
	If transformer[2] ≠ ⊥ ∧ [ ¬finalType ⊆ transformer[2] ] then
	[
		Reject parse, expected:
			"repeatedly applied function's second parameter to accept the\
			\| type union ⊆ "
			++ “finalType”
			++ " of the first element ⊆ "
			++ “headType”
			++ " of the tuple and its own return type ⊆ "
			++ “returnType”
			++ " (but it only accepts "
			++ “transformer[2]”
			++ ")"
	];
	finalType
];

/**
 * Reduce `aTuple` via the binary function, traversing the tuple from right to
 * left. Answer the result of the reduction.
 *
 * Parameters:
 *    aTuple - A nonempty tuple.
 *    transformer - A binary function whose second parameter type matches its
 *       return type. The first parameter type must be general enough to accept
 *       each element of `aTuple`.
 * Returns:
 *    The only element of `aTuple` if `aTuple` contains only one element.
 *    Otherwise, the result of iteratively applying `transformer` to 1) the
 *    right-to-left consecutive elements of `aTuple` and 2) the previous results
 *    of applying `transformer`.
 */
Public method "right fold_through_" is
[
	aTuple : <any…|1..>,
	transformer : [⊥, ⊥]→any
|
	result : any := aTuple[|aTuple|];
	From |aTuple| - 1 to 1 by -1 do
	[
		index : natural number
	|
		result := invoke transformer with <aTuple[index], eject ↑result>;
	];
	result
] : any;

/**
 * Right fold has the following requirements:
 *
 * - The function's first parameter must accept every element of the tuple
 *   except for the last (with which it will not be applied at this position).
 * - The function's second parameter must accept the tuple's last element and
 *   also every value producible by the function.
 *
 * Right fold answers either the tuple's last element or the value produced by
 * the final application of the function.
 */
Semantic restriction "right fold_through_" is
[
	tupleType : <any…|1..>'s type,
	transformer : [⊥, ⊥]→any's type
|
	sizes ::= ||tupleType||;

	lastIndexStart ::= 1 max relevant |tupleType|;
	lastIndexEnd ::= lastIndexStart
		max (⎡sizes⎤ min (|tupleType's leading types| + 1));
	lastType ::= ∪ tupleType[lastIndexStart..lastIndexEnd];
	restType ::= ∪ tupleType[1..lastIndexEnd - 1];
	returnType ::= transformer's return type;
	finalType ::= lastType ∪ returnType;
	If transformer[1] ≠ ⊥ ∧ [ ¬restType ⊆ transformer[1] ] then
	[
		Reject parse, expected:
			"repeatedly applied function's first parameter to accept all\
			\| non-last elements of the tuple ⊆ "
			++ “restType”
			++ " (but it only accepts "
			++ “transformer[1]”
			++ ")"
	];
	If transformer[2] ≠ ⊥ ∧ [ ¬finalType ⊆ transformer[2] ] then
	[
		Reject parse, expected:
			"repeatedly applied function's second parameter to accept the\
			\| type union ⊆ "
			++ “finalType”
			++ " of the last element ⊆ "
			++ “lastType”
			++ " of the tuple and its own return type ⊆ "
			++ “returnType”
			++ " (but it only accepts "
			++ “transformer[2]”
			++ ")"
	];
	finalType
];

/**
 * Compute and answer the index of the first element of `aTuple` that satisfies
 * the specified predicate.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple.
 * Returns:
 *    The index of the first satisfactory element, or 0 if no element satisfied
 *    the predicate.
 */
Public method "first index of_where_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	$body : natural number;
	From 1 to |aTuple| do
	[
		index : natural number
	|
		If invoke predicate with <aTuple[index]> then
		[
			Exit body with index
		];
	];
	0
] : whole number;

/**
 * Ensure that the function will accept all elements of the tuple.
 */
Semantic restriction "first index of_where_" is
[
	tupleType : tuple meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts tupleType;
	[0..⎡tupleType⎤ + 1)
];

/**
 * Compute and answer the index of the last element of `aTuple` that satisfies
 * the specified predicate.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple.
 * Returns:
 *    The index of the last satisfactory element, or 0 if no element satisfied
 *    the predicate.
 */
Public method "last index of_where_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	$body : natural number;
	From |aTuple| to 1 by -1 do
	[
		index : natural number
	|
		If invoke predicate with <aTuple[index]> then
		[
			Exit body with index
		];
	];
	0
] : whole number;

/**
 * Ensure that the function will accept all elements of the tuple.
 */
Semantic restriction "last index of_where_" is
[
	tupleType : tuple meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts tupleType;
	[0..⎡tupleType⎤ + 1)
];
	
	
/**
 * Compute and answer the index of the last element of `aTuple` that satisfies
 * the specified predicate.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple.
 * Returns:
 *    The index of the last satisfactory element, or 0 if no element satisfied
 *    the predicate.
 */
Public method "all indices of_where_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	indices : <whole number…|0..∞> := <>;
	From 1 to |aTuple| by 1 do
	[
		index : natural number
	|
		If invoke predicate with <aTuple[index]> then
		[
			indices := indices ++ <index>;
		];
	];
	indices
] : <whole number…|0..∞>;

/**
 * Ensure that the function will accept all elements of the tuple.
 * 
 * Parameters:
 *    tupleType -
 *    predicate -
 * Returns:
 *    `[0..⎡tupleType⎤ + 1)`.
 */
Semantic restriction "all indices of_where_" is
[
	tupleType : tuple meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts tupleType;
	[0..⎡tupleType⎤ + 1)
];

/**
 * Construct and answer a tuple whose elements are each `value`.
 * 
 * Parameters:
 *    count - The number of elements in the resulting tuple.
 *    value - The repeated value.
 * Returns:
 *    A tuple containing `count` occurrences of `value`.
 */
Public stable method "_of_" is
[
	count : whole number,
	value : any
|
	accumulator : tuple := <>;
	Repeat
	[
		accumulator := eject ↑accumulator ++ <value>;
	]
	count times;
	accumulator
];

Semantic restriction "_of_" is
[
	countType : whole number's type,
	valueType : any meta
|
	<<>, valueType…|countType>
];

/**
 * Construct and answer a tuple that contains the consecutive integers from
 * `start` (inclusive) up to `end` (inclusive), counting up by 1. If
 * `end < start`, then answer the empty tuple.
 * 
 * Parameters:
 *    start - The first value of the resulting tuple.
 *    end - The last value of the resulting tuple.
 * Returns:
 *    The interval from `start` (inclusive) up to `end` (inclusive).
 */
Public stable method "_to_" is
[
	start : integer,
	end : integer
|
	accumulator : <integer…|> := <>;
	From start to end do
	[
		value : integer
	|
		accumulator := eject ↑accumulator ++ <value>;
	];
	accumulator
] : <integer…|>;

/**
 * Construct and answer a string that contains the consecutive characters from
 * `start` (inclusive) to `end` (inclusive). If
 * `start→code point ≤ end→code point`, then
 * `result[i]→code point < result[i+1]→code point`; otherwise,
 * `result[i]→code point > result[i+1]→code point`.
 * 
 * Parameters:
 *    start - The first value of the resulting tuple.
 *    end - The last value of the resulting tuple.
 * Returns:
 *    The interval from `start` (inclusive) to `end` (inclusive).
 */
Public stable method "_to_" is
[
	start : character,
	end : character
|
	accumulator : string := <>;
	startCodePoint ::= start→code point;
	endCodePoint ::= end→code point;
	From startCodePoint to endCodePoint do
	[
		value : code point
	|
		accumulator := eject ↑accumulator ++ <value→character>;
	];
	accumulator
] : string;

/**
 * Leverage the uncertainty of `start` to produce good leading types when the
 * upper bound of the result's cardinality can be determined.
 */
Semantic restriction "_to_" is
[
	start : integer's type,
	end : integer's type
|
	min ::= ⎣start⎦;
	max ::= ⎡end⎤;
	uncertainty ::= ⎡start⎤ - ⎣start⎦;
	sizes ::= [0 max (⎣end⎦ - ⎡start⎤ + 1) .. max - min + 2);
	if uncertainty is finite ∧ [ ⎡sizes⎤ is finite ] then
	[
		finiteMin ::= cast min into [ t : integer | t ];
		finiteMax ::= cast max into [ t : integer | t ];
		types ::=
			map finiteMin to finiteMax through
			[
				x : integer
			|
				[x .. (finiteMax min (x + uncertainty)) + 1)
			];
		cast types
		into [t : <integer's type…|1..> | <t[1..|t|-1], t[|t|]…|sizes>]
		else [<>'s type]
	]
	else
	[
		<<>, [min..max + 1)…|sizes>
	]
];

/**
 * Is `value` an element of `aTuple`?
 * 
 * Parameters:
 *    value - An arbitrary value.
 *    aTuple -  A tuple.
 * Returns:
 *    `true` if `value` is an element of `aTuple`, `false` otherwise.
 */
Stable method "_∈_" is
[
	value : any,
	aTuple : tuple
|
	any of aTuple satisfies [ element : any | element = value ]
] : boolean;

Semantic restriction "_∈_" is
[
	valueType : any meta,
	tupleType : tuple meta
|
	if valueType ∩ (∪ tupleType[1..relevant |tupleType|]) = ⊥ then
	[
		false's type
	]
	else
	[
		/* Can't strengthen. */
		⊤
	]
];

/**
 * Is `subtuple` a subsequence of `aTuple`?
 * 
 * Parameters:
 *    subtuple - The search tuple.
 *    aTuple - The tuple which should be searched for `subtuple`.
 * Returns:
 *    `true` if some subsequence of `aTuple` equals `subtuple`, `false`
 *    otherwise.
 */
Method "_⊆_" is
[
	subtuple : tuple,
	aTuple : tuple
|
	matched : boolean := false;
	From 1 to |aTuple| - |subtuple| + 1 do
	[
		index : natural number
	|
		matched := aTuple[index..index + |subtuple| - 1] = subtuple;
		¬matched
	];
	matched
] : boolean;

/**
 * Is `subtuple` a subsequence of `aTuple`?
 * 
 * Parameters:
 *    aTuple - The tuple which should be searched for `subtuple`.
 *    subtuple - The search tuple.
 * Returns:
 *    `true` if some subsequence of `aTuple` equals `subtuple`, `false`
 *    otherwise.
 */
Method "_⊇_" is
[
	aTuple : tuple,
	subtuple : tuple
|
	subtuple ⊆ aTuple
] : boolean;

/**
 * Answer a function suitable for use as the semantic restriction for
 * subsequence containment.
 *
 * Returns:
 *    A function suitable for use as the semantic restriction of `_⊆_` and
 *    `_⊇_`.
 */
Private method "subsequence restriction function" is
[
	[
		subtuple : tuple meta,
		aTuple : tuple meta
	|
		if |subtuple| = 1 ∧ [ |aTuple| = 1 ] then
		[
			(subtuple's instance ⊆ aTuple's instance)'s type
		]
		else if [ ⎣subtuple⎦ > ⎡aTuple⎤ ] then
		[
			false's type
		]
		else
		[
			subtupleElementType ::=
				∪ subtuple[1..|subtuple's leading types| + 1];
			elementType ::= ∪ aTuple[1..|aTuple's leading types| + 1];
			if subtupleElementType ∩ elementType = ⊥ then
			[
				false's type
			]
			/* Can't strengthen. */
			else
			[
				⊤
			]
		]
	] : type
] : [tuple meta, tuple meta]→type;

/**
 * Does `aTuple` start with the subsequence `prefix`?
 * 
 * Parameters:
 *    aTuple - The tuple whose prefix should be checked against `prefix`.
 *    prefix - The search tuple.
 * Returns:
 *    `true` if `aTuple` starts with the subsequence `prefix`, `false`
 *    otherwise.
 */
Public method "_starts with_" is
[
	aTuple : tuple,
	prefix : tuple
|
	aTuple[..|prefix| min |aTuple|] = prefix
] : boolean;

/**
 * Does `aTuple` end with the subsequence `suffix`?
 * 
 * Parameters:
 *    aTuple - The tuple whose suffix should be checked against `suffix`.
 *    suffix - The search tuple.
 * Returns:
 *    `true` if `aTuple` ends with the subsequence `suffix`, `false`
 *    otherwise.
 */
Public method "_ends with_" is
[
	aTuple : tuple,
	suffix : tuple
|
	aTuple[1 max (|aTuple| - (|suffix| min |aTuple|) + 1)..] = suffix
] : boolean;

/**
 * If `subtuple` is guaranteed longer than `aTuple` or if the element types of
 * `subtuple` and `aTuple` are completely disjoint, then `subtuple`'s instance
 * cannot possibly be a subsequence of `aTuple`'s instance.
 */
Semantic restriction "_⊆_" is subsequence restriction function;

/**
 * If `subtuple` is guaranteed longer than `aTuple` or if the element types of
 * `subtuple` and `aTuple` are completely disjoint, then `subtuple`'s instance
 * cannot possibly be a subsequence of `aTuple`'s instance.
 */
Semantic restriction "_⊇_" is
[
	aTuple : tuple meta,
	subtuple : tuple meta
|
	subsequence restriction function(subtuple, aTuple)
];

/**
 * If `subtuple` is guaranteed longer than `aTuple` or if the element types of
 * `subtuple` and `aTuple` are completely disjoint, then `subtuple`'s instance
 * cannot possibly be a subsequence of `aTuple`'s instance.
 */
Semantic restriction "_starts with_" is
[
	aTuple : tuple meta,
	subtuple : tuple meta
|
	subsequence restriction function(subtuple, aTuple)
];

/**
 * If `subtuple` is guaranteed longer than `aTuple` or if the element types of
 * `subtuple` and `aTuple` are completely disjoint, then `subtuple`'s instance
 * cannot possibly be a subsequence of `aTuple`'s instance.
 */
Semantic restriction "_ends with_" is
[
	aTuple : tuple meta,
	subtuple : tuple meta
|
	subsequence restriction function(subtuple, aTuple)
];

/**
 * Split a `aTuple` into two tuples between `pivot` and `pivot + 1` and answer
 * a 2-tuple containing the results.
 *
 * Parameters:
 *    aTuple - A tuple.
 *    pivot - The index (inclusive) at which to split `aTuple`.
 * Returns:
 *    A 2-tuple. The first tuple contains the first `pivot` elements of
 *    `aTuple`. The second tuple contains the remaining elements of `aTuple`.
 */
Public stable method "split_after_" is
[
	aTuple : tuple,
	pivot : whole number
|
	<aTuple[..pivot], aTuple[pivot + 1..]>
] : <tuple…|2>;

/**
 * Construct the strongest possible 2-tuple type for the given arguments. The
 * first element type is a tuple type whose elements are drawn from the original
 * tuple type. The second element type is a tuple type whose element type are
 * smears (i.e., type unions) of the trailing element types of the original
 * tuple type. The pivot is used to determine the cardinality ranges of the
 * these element types.
 */
Semantic restriction "split_after_" is
[
	tupleType : tuple meta,
	pivot : whole number's type
|
	If ⎣pivot⎦ > ⎡tupleType⎤ then
	[
		Reject parse, expected:
			"pivot ∈ "
			++ “pivot”
			++ " ever to be valid for the tuple ∈ "
			++ “tupleType”
	];
	pivotPlusOne ::= cast pivot + 1's type
		into [ t : natural number's type | t ];
	firstType ::= tuple type of tupleType[1's type..pivot];
	secondType ::= tuple type of tupleType[pivotPlusOne..||tupleType||];
	<firstType, secondType…|2>
];

/**
 * Split a `aTuple` into two tuples between `pivot - 1` and `pivot` and answer
 * a 2-tuple containing the results.
 *
 * Parameters:
 *    aTuple - A tuple.
 *    pivot - The index (exclusive) at which to split `aTuple`.
 * Returns:
 *    A 2-tuple. The first tuple contains the first `pivot - 1` elements of
 *    `aTuple`. The second tuple contains the remaining elements of `aTuple`.
 */
Public stable method "split_before_" is
[
	aTuple : tuple,
	pivot : natural number
|
	<aTuple[..pivot - 1], aTuple[pivot..]>
] : <tuple…|2>;

/**
 * Construct the strongest possible 2-tuple type for the given arguments. The
 * first element type is a tuple type whose elements are drawn from the original
 * tuple type. The second element type is a tuple type whose element type are
 * smears (i.e., type unions) of the trailing element types of the original
 * tuple type. The pivot is used to determine the cardinality ranges of the
 * these element types.
 */
Semantic restriction "split_before_" is
[
	tupleType : tuple meta,
	pivot : natural number's type
|
	If ⎣pivot⎦ > ⎡tupleType⎤ + 1 then
	[
		Reject parse, expected:
			"pivot ∈ "
			++ “pivot”
			++ " ever to be valid for the tuple ∈ "
			++ “tupleType”
	];
	pivotMinusOne ::= cast pivot - 1's type
		into [ t : whole number's type | t ];
	firstType ::= tuple type of tupleType[1's type..pivotMinusOne];
	secondType ::= tuple type of tupleType[pivot..||tupleType||];
	<firstType, secondType…|2>
];

/**
 * Split a `aTuple` into two tuples.
 *
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts each element of the tuple. It must
 *       answer `true` when the pivot position has been reached. The function
 *       will not be applied again answer it has answered `true`.
 * Returns:
 *    A 2-tuple. The first tuple contains the elements of `aTuple` to which
 *    `predicate` was applied. The second tuple contains the remaining elements
 *    of `aTuple`.
 */
Method "split_before_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	firstIndex ::= first index of aTuple where predicate;
	splitIndex ::=
		if firstIndex = 0
		then [ |aTuple| ]
		else [ cast firstIndex - 1 into [ t : whole number | t ] ];
	split aTuple after splitIndex
] : <tuple…|2>;

/**
 * Construct the strongest possible 2-tuple type for the given arguments. The
 * first element type is a tuple type whose elements are drawn from the original
 * tuple type. The second element type is a tuple type whose element type are
 * smears (i.e., type unions) of the trailing element types of the original
 * tuple type. The cardinality of each tuple varies from 0 to the upper bound of
 * `tupleType`'s cardinality range.
 */
Semantic restriction "split_before_" is
[
	tupleType : tuple meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts tupleType;
	returnType ::= predicate's return type;
	if ⎡tupleType⎤ = 0 then
	[
		<<>, <>>'s type
	]
	else
	[
		sizes ::= ||tupleType||;
		upper ::= [0..⎡sizes⎤ + 1);
		firstType ::=
			<tupleType's leading types, tupleType's default type…|upper>;
		secondType ::=
			tuple type of tupleType[[1..⎡sizes⎤ + 1)..upper];
		<firstType, secondType…|2>
	]
];

/**
 * Compute and answer the specified stripe of `aTuple`.
 * 
 * Parameters:
 *    aTuple - A tuple of non-empty tuples.
 *    index - The stripe index.
 * Returns:
 *    A tuple comprising the `index`-th elements of each element of `aTuple`.
 */
Public stable method "stripe_at_" is
[
	aTuple : <<any…|1..>…|>,
	index : natural number
|
	map aTuple through [ inner : <any…|1..> | inner[index] ]
] : tuple;

/**
 * Reject the parse if the stripe index could never be valid.
 */
Semantic restriction "stripe_at_" is
[
	tupleType : <<any…|1..>…|>'s type,
	index : natural number's type
|
	uncertainty ::= cast ⎡index⎤ - ⎣index⎦
		into [ t : whole number | t ];
	stripeTypes : <any meta…|> := <>;
	From 1 to |tupleType's leading types| + 1 do
	[
		typeIndex : natural number
	|
		innerType ::= tupleType[typeIndex];
		If ⎣index⎦ > ⎡innerType⎤ then
		[
			Reject parse, expected:
				"a subscript ("
				++ “⎣index⎦”
				++ " ≤ theSubscript ≤ "
				++ “⎡index⎤”
				++ ") that could ever be valid ("
				++ “⎣innerType⎦”
				++ " ≤ |theTuple| ≤ "
				++ “⎡innerType⎤”
				++ ")"
		];
		union : any meta := ⊥;
		limit ::= uncertainty min (|innerType's leading types| + 1);
		From 0 to limit do
		[
			delta : whole number
		|
			innerIndex ::= cast ⎣index⎦ + delta
				into [ t : natural number | t ];
			union := eject ↑union ∪ innerType[innerIndex];
		];
		stripeTypes := eject ↑stripeTypes ++ <union>;
	];
	nonemptyTypes ::= cast stripeTypes into [ t : <any meta…|1..> | t ];
	<nonemptyTypes[1..|nonemptyTypes| - 1], nonemptyTypes[|nonemptyTypes|]…
		| ||tupleType||>
];

Method "_[_]→_" is stable at [tuple, natural number, any]→tuple;

/**
 * Tuple element replacement affects only those elements whose subscripts are
 * instances of `indexType`. If multiple subscripts could be affected, then
 * update the element types via type union with `valueType`. If only a single
 * subscript could be affected, then simply replace the corresponding element
 * type with `valueType`. Leverage instance types if possible.
 */
Semantic restriction "_[_]→_" is
[
	tupleType : tuple meta,
	indexType : natural number's type,
	valueType : any meta
|
	indexLower ::= cast ⎣indexType⎦ into
		[ t : natural number | t ];
	If indexLower > ⎡tupleType⎤ then
	[
		Reject parse, expected:
			"a subscript ("
			++ “⎣indexType⎦”
			++ " ≤ theSubscript ≤ "
			++ “⎡indexType⎤”
			++ ") that could ever be valid ("
			++ “⎣tupleType⎦”
			++ " ≤ |theTuple| ≤ "
			++ “⎡tupleType⎤”
			++ ")"
	];
	indexUpper ::= ⎡indexType⎤;
	leadingTypes : <any meta…|> := tupleType's leading types;
	defaultType : any meta := tupleType's default type;
	/* Update any leading types possibly affected by `index`. */
	If indexLower ≤ |leadingTypes| then
	[
		limit ::= indexUpper min |leadingTypes|;
		From indexLower to limit do
		[
			leadingIndex : natural number
		|
			original ::= leadingTypes[leadingIndex];
			/* If only one possible element is affected (because the lower and
			 * upper bound of `index` are equal), then we can simply replace the
			 * element type with `valueType`. Otherwise we have to weaken the
			 * affected elements via type union with `valueType`.
			 */
			replacement ::= if |{indexLower, indexUpper}| = 1
				then [ valueType ]
				else [ original ∪ valueType ];
			newLeadingTypes ::= leadingTypes[leadingIndex]→replacement;
			leadingTypes := cast newLeadingTypes into [ t : <any meta…|> | t ];
		];
	];
	/* Extend the leading types. */
	If indexUpper > |leadingTypes| then
	[
		/* If the lower bound of `index` is greater than the number of leading
		 * types, i.e., the leading types are unaffected by this operation *and*
		 * there may be intervening element types between the last leading type
		 * and the first element type affected, then pad the leading types with
		 * the default type up to the lower bound (exclusive) of `index`.
		 */
		padCount ::= indexLower - |leadingTypes| - 1;
		If padCount > 0 then
		[
			count ::= cast padCount into [ t : natural number | t ];
			leadingTypes := eject ↑leadingTypes ++ count of defaultType;
		];
		/* If the upper bound of `index` is less than the maximum length of the
		 * tuple, then some elements of the result tuple may have the original
		 * default type. Extend the leading types to account for the new
		 * element.
		 */
		If indexUpper < ⎡tupleType⎤ then
		[
			newType ::= if |{indexLower, indexUpper}| = 1
				then [ valueType ]
				else [ defaultType ∪ valueType ];
			delta ::= if indexLower ≤ |leadingTypes| then [ 0 ] else [ 1 ];
			count ::= cast indexUpper - (|leadingTypes| max indexLower)
				into [ t : whole number | t + delta ];
			leadingTypes := eject ↑leadingTypes ++ count of newType;
		]
		/* The upper bound of `index` exceeds the minimum length of the tuple,
		 * so just update the default type.
		 */
		else
		[
			defaultType := eject ↑defaultType ∪ valueType;
		];
	];
	<leadingTypes, defaultType… | ||tupleType||>
];

/**
 * Compute and answer a tuple that is the result of replacing the specified
 * slice of `aTuple` with `replacement`.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    sliceStart - The subscript of the first element of the target slice.
 *    sliceEnd - The subscript of the last element of the target slice.
 *    replacement - The tuple that should be spliced into `aTuple` instead of
 *       the specified slice.
 * Returns:
 *    A variant of `aTuple` whose elements from `sliceStart` (inclusive) to
 *    `sliceEnd` (inclusive) have been replaced with those of `replacement`.
 *    Elements before `sliceStart` and after `sliceEnd` will be present in the
 *    answer.
 */
Public stable method "_[_.._]→_" is
[
	aTuple : tuple,
	sliceStart : natural number,
	sliceEnd : whole number,
	replacement : tuple
|
	If sliceEnd < sliceStart - 1 then
	[
		early failure function(subscript out of bounds code)
	];
	aTuple[..sliceStart - 1] ++ replacement ++ aTuple[sliceEnd + 1..]
] : tuple;

/**
 * Reject the parse if the target slice would never be valid.
 */
Semantic restriction "_[_.._]→_" is
[
	aTuple : tuple meta,
	sliceStart : natural number's type,
	sliceEnd : whole number's type,
	replacement : tuple meta
|
	Require: aTuple[sliceStart..sliceEnd] is ever valid;
	prefixEnd ::= cast sliceStart - 1's type
		into [ t : whole number's type | t ];
	prefix ::= tuple type of aTuple[1's type..prefixEnd];
	suffixStart ::= cast sliceEnd + 1's type
		into [ t : natural number's type | t ];
	suffix ::= tuple type of aTuple[suffixStart..||aTuple||];
	prefix ++ replacement ++ suffix
];

/**
 * Flatten a tuple of tuples by a single level.
 *
 * Parameters:
 *    aTupleOfTuples - A tuple of tuples to flatten.
 * Returns:
 *    A flattened tuple.
 */
Public stable method "flatten_" is
[
	aTupleOfTuples : <tuple…|>
|
	newTuple : tuple := <>;
	For each aTupleOfTuples do 
	[
		t : tuple 
	|
		newTuple := newTuple ++ t;
	];
	newTuple
] : tuple;

Semantic restriction "flatten_" is
[
	aTupleOfTuplesType : <tuple…|>'s type
|
	leadingTypes ::= cast aTupleOfTuplesType's leading types into
		[t : <tuple's type…|> | t];
	defaultType ::= aTupleOfTuplesType's default type;
	leadingAndDefaultTypes ::= leadingTypes ++ <defaultType>;
	tupleTypes : <tuple's type…|> := <>;
	totalUpperBound : [0..∞] := 0;
	totalLowerBound : whole number := 0;
	For each leadingAndDefaultTypes do
	[
		t : tuple's type
	|
		tupleTypes := tupleTypes ++ 
			cast t's leading types into [r : <tuple's type…|> | r] ++
			<cast t's default type into [r : tuple's type | r]>;
		totalUpperBound := totalUpperBound + ⎡t⎤;
		totalLowerBound := totalLowerBound + ⎣t⎦;
	];
	card ::= [totalLowerBound..totalUpperBound);
	firstLower : [0..∞);
	finalDefaultType : any's type; 
	finalLeadingTypes ::= if |leadingTypes| ≥ 1 then
	[
		firstLower := ⎣leadingTypes[1]⎦;
		if firstLower > 0 then 
		[
			finalDefaultType := 
				∪ (tupleTypes's type)[firstLower + 1..|tupleTypes|]; 
			leadingTypes[1]'s leading types[1..firstLower]
		]
		else 
		[
			finalDefaultType := 
				∪ (tupleTypes's type)[firstLower + 1..|tupleTypes|];
			<>
		]
	]
	else [<>];
	<finalLeadingTypes,finalDefaultType…|card>
];

/**
 * Obtain the first element of the specified tuple.
 *
 * Parameters:
 *    aTuple - A tuple.
 * Returns:
 *    The first element of `aTuple`.
 */
Public stable method "_'s⁇head" is
[
	aTuple : <any…|1..>
|
	aTuple[1]
] : any;

Semantic restriction "_'s⁇head" is
[
	aTupleType : <any…|1..>'s type
|
	aTupleType[1]
];

/**
 * Construct and answer a tuple slice that contains all but the first element of
 * the specified tuple. If the argument contains only one element, then answer
 * an empty tuple.
 *
 * Parameters:
 *    aTuple - A nonempty tuple.
 * Returns:
 *    The requested tuple slice.
 */
Public stable abstract method "_'s⁇tail" is [<any…|1..>]→tuple;

/**
 * Construct and answer a tuple slice that contains all but the first element of
 * the specified tuple.
 *
 * Parameters:
 *    aTuple - A tuple containing a single element.
 * Returns:
 *    An empty tuple.
 */
Method "_'s⁇tail" is
[
	aTuple : <any…|1>
|
	<>
] : <>'s type;

/**
 * Construct and answer a tuple slice that contains all but the first element of
 * the specified tuple.
 *
 * Parameters:
 *    aTuple - A tuple containing at least two elements.
 * Returns:
 *    The requested tuple slice.
 */
Method "_'s⁇tail" is
[
	aTuple : <any…|2..>
|
	aTuple[2..]
] : tuple;

Semantic restriction "_'s⁇tail" is
[
	aTupleType : <any…|1..>'s type
|
	leadingTypes ::= aTupleType's leading types;
	defaultType ::= aTupleType's default type;
	sizeLeadingTypes ::= |leadingTypes|;
	bound ::= ⎡aTupleType⎤;
	lower ::= ⎣aTupleType⎦ - 1;
	if sizeLeadingTypes > 1 then
	[
		<leadingTypes[2..sizeLeadingTypes], defaultType…|[lower..bound)>
	]
	else
	[
		<defaultType…|lower..bound-1>
	]
];

/**
 * Obtain the last element of the specified tuple.
 *
 * Parameters:
 *    aTuple - A tuple.
 * Returns:
 *    The last element of a `aTuple`.
 */
Public stable method "_'s⁇last" is
[
	aTuple : <any…|1..>
|
	aTuple[|aTuple|]
] : any;

Semantic restriction "_'s⁇last" is
[
	aTupleType : <any…|1..>'s type
|
	upper ::= ⎡aTupleType⎤ min (|aTupleType's leading types| + 1);
	∪ aTupleType[⎣aTupleType⎦..upper]
];

/**
 * Sum the elements of the specified tuple of integers.
 *
 * Parameters:
 *    intTuple - A tuple of integers.
 * Returns:
 *    An integer.
 */
Public stable method "∑_" is
[
	intTuple : <integer…|1..∞>
|
	left fold intTuple through [ i : integer, ri : integer | i + ri ]
] : integer;

/**
 * Strengthen the return type
 *
 * Parameters:
 *    intTupleType - a tuple of integer's type.
 *
 * Returns:
 *    A number.
 */
Semantic restriction "∑_" is
[
	intTupleType : <integer…|1..∞>'s type
|
	leading ::= intTupleType's leading types;
	defaultType ::= intTupleType's default type;
	leadingSize ::= |leading|;
	lowIndex ::= leadingSize min ⎣leading's type⎦;
	lowBound ::=
		if leadingSize > 0 then
		[
			(∑ (cast (map leading[1..lowIndex] through
			[
				i : any meta
			|
				x ::= cast i into [it : integer's type | it];
				cast (⎣x⎦) into [n : integer | n]
			]) into [iTuple : <integer…|1..∞> | iTuple])) +
				((⎣intTupleType⎦ - lowIndex) max 0) ×
				⎣defaultType⎦
		]
		else
		[
			((⎣intTupleType⎦) max 0) × ⎣defaultType⎦
		];
	upBound ::=
		if leadingSize > 0 then 
		[
			(∑ (cast (map leading[1..lowIndex] through
			[
				i : any meta
			|
				x ::= cast i into [it : integer's type | it];
				cast (⎡x⎤) into [n : integer | n]
			]) into [iTuple : <integer…|1..∞> | iTuple])) +
				⎡intTupleType's default type⎤ ×
				(⎡intTupleType⎤ - leadingSize)
		]
		else
		[
			⎡intTupleType's default type⎤ × (⎡intTupleType⎤ - leadingSize)
		];
	[lowBound..upBound+1)
];

/**
 * Take the product of the elements of a tuple of integers.
 *
 * Parameters:
 *    intTuple - a tuple of integers.
 *    
 * Returns:
 *    An integer.
 */
Public stable method "∏_" is
[
	intTuple : <integer…|1..∞>
|
	left fold intTuple through 
	[
		i : integer,
		ri : integer
	|
		i × ri
	]
]: integer;

/**
 * Strengthen the return type
 *
 * Parameters:
 *    intTupleType - a tuple of integer's type.
 *
 * Returns:
 *    A number.
 *//* TODO [RAA]
Semantic restriction "∏_" is
[
	intTupleType : <integer…|1..∞>'s type
|
	leading ::= intTupleType's leading types;
	defaultType ::= intTupleType's default type;
	leadingSize ::= |leading|;
	lowIndex ::= leadingSize min ⎣leading's type⎦;
	lowBound ::= if leadingSize > 0 then 
	[
		m ::=  map leading[1..lowIndex] through
		[
			i : any's type
		|
			x::=cast i into [it : integer's type | it];
Print: "x=";
Print: “x”;
			y::= cast (⎣x⎦) into [n : integer | n]
		];
		∏ (cast x into [iTuple : <integer…|1..∞> | iTuple] )); 
Print: "y=";
Print: “y”;

		z::=y × (⎣defaultType⎦ ^ 
				((⎣intTupleType⎦ - lowIndex) max 0));
Print: "z=";
Print: “z”;
		z
			
	]
	else
	[
		⎣defaultType⎦ ^ 
				((⎣intTupleType⎦ - lowIndex) max 0)
	];
	upBound ::= if leadingSize > 0 then 
	[
		(∏ (cast (map leading[1..lowIndex] through
		[
			i : any's type
		|
			x ::= cast i into [it : integer's type | it];
			cast (⎡x⎤) into [n : integer | n]
		]) into [iTuple : <integer…|1..∞> | iTuple] )) × 
			((⎡intTupleType's default type⎤) ^
			(⎡intTupleType⎤ - leadingSize))
	]
	else
	[
		((⎡intTupleType's default type⎤) ^
			(⎡intTupleType⎤ - leadingSize))
	];
	[lowBound..upBound+1)
];*/