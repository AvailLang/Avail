/*
 * Tuples.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Tuples"
Versions
	"dev"
Extends
	"Collections",
	"Early Tuples"
Uses
	"Bootstrap",
	"Control Structures",
	"Definers",
	"Early Assertions",
	"Early Error Codes",
	"Early Functions",
	"Early Maps",
	"Enumeration Support",
	"Literals",
	"Logic",
	"Math",
	"Types",
	"Variables"
Names
	"all indices of_where_",
	"distinct_",
	"drop from_until_",
	"drop from_while_",
	"drop_from_",
	"first index of_where_",
	"flatten_",
	"last index of_where_",
	"left fold_through_",
	"quicksort_",
	"quicksort_with_",
	"right fold_through_",
	"split_after_",
	"split_before_",
	"stripe_at_",
	"take from_until_",
	"take from_while_",
	"take_from_",
	"zip_",
	"Σ_",
	"∏_",
	"_ends with_",
	"_occurrences⁇of_",
	"_starts with_",
	"_to_",
	"_to_by_",
	"_'s⁇head",
	"_'s⁇last",
	"_'s⁇tail",
	"_[_.._]else_",
	"_[_..]else_",
	"_[.._]else_",
	"_[_.._]→_",
	"_[_↔_]",
	"«_‡zip»"
Body

/**
 * Is the specified tuple empty?
 *
 * Parameters:
 *    aTuple - A tuple.
 * Returns:
 *    `true` if the argument is empty, `false` otherwise.
 */
Stable method "_is empty" is
[
	aTuple : tuple
|
	|aTuple| = 0
] : boolean;

/**
 * Iteratively apply `action` to each consecutive element of `aTuple`.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    action - A function that accepts the elements of the tuple.
 */
Method "For each of⁇_do_" is
[
	aTuple : tuple,
	action : [⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			action(aTuple[index]);
			↑index++;
			Restart loop
		];
	]();
] : ⊤;

/**
 * Iteratively apply `action` to each consecutive element of `aTuple`.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    action - A function that accepts 1) an element of the tuple and 2) the
 *       index of that element.
 */
Method "For each of⁇_do_" is
[
	aTuple : tuple,
	action : [⊥, ⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			action(aTuple[index], index);
			↑index++;
			Restart loop
		];
	]();
] : ⊤;

/**
 * Helper method for semantic restrictions: If `action` does not accept the
 * type union of all element types of `tupleType` and their indices, then reject
 * the current parse.
 * 
 * Parameters:
 *    action - A function type whose first parameter must correspond to the
 *       type union of the element types of `tupleType` and whose second
 *       parameter, if provided, must correspond to `indices`.
 *    tupleType - A tuple type.
 */
Method "Require:_accepts_" is
[
	action : function meta,
	tupleType : tuple meta
|
	If ⎣action's parameters' type⎦ < 1 then
	[
		Reject parse, expected:
			"repeatedly applied function to accept at least one argument"
	];
	union ::= ∪ tupleType[1..|tupleType's leading types| + 1];
	If action[1] ≠ ⊥ ∧ [ ¬union ⊆ action[1] ] then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all elements of the tuple ⊆ "
			++ “tupleType”
			++ " (but it only accepts "
			++ “action[1]”
			++ ")"
	];
	If ⎣action's parameters' type⎦ = 2
		∧ [ action[2] ≠ ⊥
		∧ [ ¬[1..⎡tupleType⎤ + 1) ⊆ action[2] ] ]
	then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all indices of the tuple ⊆ "
			++ “tupleType”
			++ " (but it only accepts "
			++ “action[2]”
			++ ")"
	];
] : ⊤;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * If the tuple is certainly nonempty and the function certainly does not
 * complete if applied, then answer ⊥.
 */
Semantic restriction "For each of⁇_do_" is
[
	tupleType : tuple meta,
	action : function meta
|
	Require: action accepts tupleType;
	if ⎣tupleType⎦ > 0 ∧ [ action's return type = ⊥ ] then
	[
		⊥
	]
	else
	[
		⊤
	]
];

/**
 * Iteratively apply `transformer` to each consecutive element of `aTuple`,
 * collecting the results into a new tuple (and preserving ordering of the
 * transformed elements). Answer this tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    transformer - A function that accepts the elements of the tuple.
 * Returns:
 *    A tuple of results of applications of `transformer` to the elements of
 *    `aTuple`.
 */
Method "map_through_" is
[
	aTuple : tuple,
	transformer : [⊥]→any
|
	index : natural number := 1;
	result : tuple := <>;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			result := eject ↑result ++ <transformer(aTuple[index])>;
			↑index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Iteratively apply `transformer` to each consecutive element of `aTuple`,
 * collecting the results into a new tuple (and preserving ordering of the
 * transformed elements). Answer this tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    transformer - A function that accepts 1) an element of the tuple and 2)
 *       the index of that element.
 * Returns:
 *    A tuple of results of applications of `transformer` to the elements and
 *    indices of `aTuple`.
 */
Method "map_through_" is
[
	aTuple : tuple,
	transformer : [⊥, ⊥]→any
|
	index : natural number := 1;
	result : tuple := <>;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			result := eject ↑result ++ <transformer(aTuple[index], index)>;
			↑index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * If the tuple is certainly nonempty, then the function cannot answer ⊥.
 */
Semantic restriction "map_through_" is
[
	tupleType : tuple meta,
	transformer : […]→any's type
|
	Require: transformer accepts tupleType;
	If ⎣tupleType⎦ > 0 then
	[
		If transformer's return type = ⊥ then
		[
			Reject parse, expected:
				"repeatedly applied function to have a return type other than\
				\| ⊥"
		];
	];
	<<>, transformer's return type… | ||tupleType||>
];

/**
 * Iteratively apply `predicate` to each consecutive element of `aTuple`,
 * collecting those elements for which `predicate` answers `true` into a new
 * tuple (and preserving ordering). Answer the new tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple and answers
 *       `true` iff they should be accumulated into the output tuple.
 * Returns:
 *    A tuple containing exactly those elements of `aTuple` for which
 *    `predicate` answered `true`.
 */
Method "filter_by_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop;
		If index ≤ end then
		[
			element ::= aTuple[index];
			If predicate(element) then
			[
				result := eject ↑result ++ <element>;
			];
			↑index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Iteratively apply `predicate` to each consecutive element and index of
 * `aTuple`, collecting those elements for which `predicate` answers `true` into
 * a new tuple (and preserving ordering). Answer the new tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts 1) an element of the tuple and 2)
 *       the index of that element and which answers `true` iff the elements
 *       should be accumulated into the output tuple.
 * Returns:
 *    A tuple containing exactly those elements of `aTuple` for which
 *    `predicate` answered `true`.
 */
Method "filter_by_" is
[
	aTuple : tuple,
	predicate : [⊥, ⊥]→boolean
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop;
		If index ≤ end then
		[
			element ::= aTuple[index];
			If predicate(element, index) then
			[
				result := eject ↑result ++ <element>;
			];
			↑index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 */
Semantic restriction "filter_by_" is
[
	tupleType : tuple meta,
	predicate : […]→boolean's type
|
	Require: predicate accepts tupleType;
	if predicate's return type = true's type then
	[
		tupleType
	]
	else
	[
		union ::= ∪ tupleType[1..|tupleType's leading types| + 1];
		sizes ::=
			if predicate's return type = false's type then [ 0's type ]
			else [ [0..⎡tupleType⎤ + 1) ];
		<<>, union…|sizes>
	]
];

/**
 * Iteratively apply `accumulator` to the consecutive elements of `aTuple` in
 * order to transform and filter its elements into a new tuple. When
 * `accumulator` is invoked, it is passed a "keeper" function. The keeper
 * function may be invoked to "save" a particular value, i.e., a value that will
 * be copied into the output tuple. The keeper function will save at most one
 * value per element of `aTuple`, i.e., each time that `accumulator` is invoked,
 * it may invoke the keeper function at most one time. Answer the new tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    accumulator - A function that accepts 1) an element from `aTuple` and 2)
 *       a keeper function. The keeper function accepts an argument of the type
 *       that should be saved.
 * Returns:
 *    A tuple whose elements are those saved by the `accumulator`.
 */
Method "map and filter_by_" is
[
	aTuple : tuple,
	accumulator : [⊥, ⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop;
		If index ≤ end then
		[
			hasAlreadyKept : boolean := false;
			accumulator
			(
				aTuple[index],
				[
					transformed : any
				|
					If ¬hasAlreadyKept then
					[
						result := eject ↑result ++ <transformed>;
						hasAlreadyKept := true;
					];
				]
			);
			↑index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Iteratively apply `accumulator` to the consecutive elements and indices of
 * `aTuple` in order to transform and filter its elements into a new tuple. When
 * `accumulator` is invoked, it is passed a "keeper" function. The keeper
 * function may be invoked to "save" a particular value, i.e., a value that will
 * be copied into the output tuple. The keeper function will save at most one
 * value per element of `aTuple`, i.e., each time that `accumulator` is invoked,
 * it may invoke the keeper function at most one time. Answer the new tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    accumulator - A function that accepts 1) an element from `aTuple`, 2) the
 *       index of that element, and 3) a keeper function. The keeper function
 *       accepts an argument of the type that should be saved.
 * Returns:
 *    A tuple whose elements are those saved by the `accumulator`.
 */
Method "map and filter_by_" is
[
	aTuple : tuple,
	accumulator : [⊥, ⊥, ⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop;
		If index ≤ end then
		[
			hasAlreadyKept : boolean := false;
			accumulator
			(
				aTuple[index],
				index,
				[
					transformed : any
				|
					If ¬hasAlreadyKept then
					[
						result := eject ↑result ++ <transformed>;
						hasAlreadyKept := true;
					];
				]
			);
			↑index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Ensure that the function will accept all elements of the tuple and also an
 * appropriately typed keeper function.
 */
Semantic restriction "map and filter_by_" is
[
	tupleType : tuple meta,
	accumulator : [⊥, ⊥]→⊤'s type
|
	union ::= ∪ tupleType[1..|tupleType's leading types| + 1];
	If accumulator[1] ≠ ⊥ ∧ [ ¬union ⊆ accumulator[1] ] then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all elements of the tuple ⊆ "
			++ “tupleType”
			++ " (but it only accepts "
			++ “accumulator[1]”
			++ ")"
	];
	Require: accumulator's keeper is valid;
	If accumulator's return type ≠ ⊤ then
	[
		Reject parse, expected:
			"repeatedly applied function to have return type ⊤"
	];
	<
		<>,
		cast accumulator[2] into [ t : function meta | t[1] ]…
		| [0..⎡tupleType⎤ + 1)
	>
];

/**
 * Ensure that the function will accept all elements and indices of the tuple
 * and also an appropriately typed keeper function.
 */
Semantic restriction "map and filter_by_" is
[
	tupleType : tuple meta,
	accumulator : [⊥, ⊥, ⊥]→⊤'s type
|
	union ::= ∪ tupleType[1..|tupleType's leading types| + 1];
	If accumulator[1] ≠ ⊥ ∧ [ ¬union ⊆ accumulator[1] ] then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all elements of the tuple ⊆ "
			++ “tupleType”
			++ " (but it only accepts "
			++ “accumulator[1]”
			++ ")"
	];
	If accumulator[2] ≠ ⊥
		∧ [ ¬[1..⎡tupleType⎤ + 1) ⊆ accumulator[2] ]
	then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all indices of the tuple ⊆ "
			++ “tupleType”
			++ " (but it only accepts "
			++ “accumulator[2]”
			++ ")"
	];
	Require: accumulator's keeper is valid;
	If accumulator's return type ≠ ⊤ then
	[
		Reject parse, expected:
			"repeatedly applied function to have return type ⊤"
	];
	<
		<>,
		cast accumulator[2] into [ t : function meta | t[1] ]…
		| [0..⎡tupleType⎤ + 1)
	>
];

/**
 * Compute and answer whether any of the elements of `aTuple` satisfies the
 * specified function. Do not examine more elements than necessary.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple and answers
 *       a boolean.
 * Returns:
 *    `true` if `predicate` answers `true` for any element of `aTuple`, `false`
 *    otherwise.
 */
Method "any of_satisfies_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	$body : boolean;
	For each aTuple do
	[
		element : any
	|
		If predicate(element) then
		[
			Exit body with true
		];
	];
	false
] : boolean;

/**
 * Compute and answer whether any of the elements (and indices) of `aTuple`
 * satisfy the specified function. Do not examine more elements than necessary.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts 1) an element of the tuple and 2) the
 *       index of that element.
 * Returns:
 *    `true` if `predicate` answers `true` for any element of `aTuple`, `false`
 *    otherwise.
 */
Method "any of_satisfies_" is
[
	aTuple : tuple,
	predicate : [⊥, ⊥]→boolean
|
	$body : boolean;
	For each aTuple do
	[
		element : any,
		index : natural number
	|
		If predicate(element, index) then
		[
			Exit body with true
		];
	];
	false
] : boolean;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 */
Semantic restriction "any of_satisfies_" is
[
	tupleType : tuple meta,
	predicate : […]→boolean's type
|
	Require: predicate accepts tupleType;
	predicate's return type
];

/**
 * Compute and answer whether each of the elements of `aTuple` satisfies the
 * specified function. Do not examine more elements than necessary.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple and answers
 *       a boolean.
 * Returns:
 *    `true` if `predicate` answers `true` for each element of `aTuple`, `false`
 *    otherwise.
 */
Method "each of_satisfies_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	$body : boolean;
	For each aTuple do
	[
		element : any
	|
		Unless predicate(element) then
		[
			Exit body with false
		];
	];
	true
] : boolean;

/**
 * Compute and answer whether each of the elements (and indices) of `aTuple`
 * satisfy the specified function. Do not examine more elements than necessary.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts 1) an element of the tuple and 2) the
 *       index of that element and answers a boolean.
 * Returns:
 *    `true` if `predicate` answers `true` for each element of `aTuple`, `false`
 *    otherwise.
 */
Method "each of_satisfies_" is
[
	aTuple : tuple,
	predicate : [⊥, ⊥]→boolean
|
	$body : boolean;
	For each aTuple do
	[
		element : any,
		index : natural number
	|
		Unless predicate(element, index) then
		[
			Exit body with false
		];
	];
	true
] : boolean;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 */
Semantic restriction "each of_satisfies_" is
[
	tupleType : tuple meta,
	predicate : […]→boolean's type
|
	Require: predicate accepts tupleType;
	predicate's return type
];

/**
 * Compute and answer the count of elements of `aTuple` that satisfy the given
 * predicate.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple and answers
 *       `true` if the element should be represented in the resulting count.
 * Returns:
 *    The number of elements of `aTuple` for which `predicate` answers `true`.
 */
Method "count of_where_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	|filter aTuple by predicate|
] : whole number;

/**
 * Compute and answer the count of elements (and indices) of `aTuple` that
 * satisfy the given predicate.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts 1) an element of the tuple and 2) the
 *       index of that element and answers `true` if the element should be
 *       represented in the resulting count.
 * Returns:
 *    The number of elements of `aTuple` for which `predicate` answers `true`.
 */
Method "count of_where_" is
[
	aTuple : tuple,
	predicate : [⊥, ⊥]→boolean
|
	|filter aTuple by predicate|
] : whole number;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 */
Semantic restriction "count of_where_" is
[
	tupleType : tuple meta,
	predicate : […]→boolean's type
|
	Require: predicate accepts tupleType;
	[0..⎡tupleType⎤ + 1)
];

/**
 * Compute and answer the distinct elements of `aTuple`, preserving order.
 * 
 * Parameters:
 *    aTuple - A tuple.
 * Returns:
 *    A tuple that contains only the distinct elements of `aTuple`, and in the
 *    order in which they were encountered.
 */
Public stable method "distinct_" is
[
	aTuple : tuple
|
	seen : set := ∅;
	filter aTuple by
	[
		element : any
	|
		if ¬element ∈ seen then
		[
			seen := eject ↑seen + element;
			true
		]
		else
		[
			false
		]
	]
] : tuple;

/* No decent semantic restrictions can be written yet for `distinct_` and
 * `_→set`. An efficient algorithm involves construction and evaluation of a
 * chromatic polynomial over the type intersection graph of the tuple type's
 * element types (the vertices represent the element types and an edge between
 * two vertices indicates that the type intersection of the element types is ⊥).
 * We cannot conveniently build graphs yet. We need object types and objects
 * first.
 */

/**
 * Answer a function that computes the zip of a tuple of tuples.
 * 
 * Returns:
 *    The requested function.
 */
Private method "zip function" is
[
	[
		tuples : <tuple…|1..>
	|
		accumulator : <tuple…|> := <>;
		limit ::= min map tuples through [ aTuple : tuple | |aTuple| ];
		From 1 to limit do
		[
			index : natural number
		|
			group : tuple := <>;
			For each tuples do
			[
				aTuple : tuple
			|
				group := eject ↑group ++ <aTuple[index]>;
			];
			accumulator := eject ↑accumulator ++ <group>;
		];
		accumulator
	] : tuple
] : [<tuple…|1..>]→tuple;

/**
 * Compute and answer the zip of the specified tuples. Given N input tuples, the
 * output is the tuple whose i-th element contains the i-th element from each
 * consecutive input tuple. The size of the output equals to the smallest size
 * of the inputs. Each of the output's tuples has length equal to the number of
 * inputs.
 * 
 * Parameters:
 *    tuples - A tuple of tuples.
 * Returns:
 *    The zip of the input tuples.
 */
Public method "zip_" is zip function;

/**
 * Compute and answer the zip of the specified tuples. Given N input tuples, the
 * output is the tuple whose i-th element contains the i-th element from each
 * consecutive input tuple. The size of the output equals to the smallest size
 * of the inputs. Each of the output's tuples has length equal to the number of
 * inputs.
 * 
 * Parameters:
 *    tuples - A tuple of tuples.
 * Returns:
 *    The zip of the input tuples.
 */
Public method "«_‡zip»" is zip function;

/* Don't parse `«_‡zip»` recursively. */
Grammatical restriction {"«_‡zip»"} is <{"«_‡zip»"}>;

/**
 * Answer the semantic restriction function for zipping tuples.
 * 
 * Returns:
 *    The semantic restriction function.
 */
Private method "zip semantic restriction" is
[
	[
		tuplesType : <tuple…|1..>'s type
	|
		/* Leverage an instance type if possible. */
		if |tuplesType| = 1 then
		[
			(zip tuplesType's instance)'s type
		]
		else
		[
			types ::= cast tuplesType[1..relevant |tuplesType|]
				into [ t : <tuple meta…|1..> | t ];
			/* Find the smallest of the lower bounds of the inputs. */
			lower ::=
				min map types through
				[
					tupleType : tuple meta
				|
					⎣tupleType⎦
				];
			/* Find the smallest of the upper bounds of the inputs. */
			upper ::=
				min map types through
				[
					tupleType : tuple meta
				|
					⎡tupleType⎤
				];
			/* Find the maximum number of element types to scan. */
			limit ::=
				max map types through
				[
					tupleType : tuple meta
				|
					|tupleType's leading types| + 1
				];
			resultTypes : <tuple meta…|> := <>;
			/* Examine the relevant element types of all inputs. */
			From 1 to limit do
			[
				index : natural number
			|
				zipped : tuple of any meta := <>;
				/* Examine the `index`-th element type of each input. Accumulate
				 * the results into `zipped`.
				 */
				For each types do
				[
					tupleType : tuple meta
				|
					zipped := eject ↑zipped ++ <tupleType[index]>;
				];
				nonempty ::= cast zipped
					into [ t : <any meta…|1..> | t ];
				zippedType ::=
					<nonempty[1..|nonempty| - 1], nonempty[|nonempty|]…
						| ||tuplesType||>;
				resultTypes := eject ↑resultTypes ++ <zippedType>;
			];
			nonempty ::= cast resultTypes into [ t : <tuple meta…|1..> | t ];
			resultSizes ::= [lower..upper + 1);
			<nonempty[1..|nonempty| - 1], nonempty[|nonempty|]… | resultSizes>
		]
	] : type
] : [<tuple…|1..>'s type]→type;

Semantic restriction "zip_" is zip semantic restriction;
Semantic restriction "«_‡zip»" is zip semantic restriction;

/**
 * Reduce `aTuple` via the binary function, traversing the tuple from left to
 * right. Answer the result of the reduction.
 *
 * Parameters:
 *    aTuple - A nonempty tuple.
 *    transformer - A binary function whose second parameter type matches its
 *       return type. The first parameter type must be general enough to accept
 *       each element of `aTuple`.
 * Returns:
 *    The only element of `aTuple` if `aTuple` contains only one element.
 *    Otherwise, the result of iteratively applying `transformer` to 1) the
 *    left-to-right consecutive elements of `aTuple` and 2) the previous results
 *    of applying `transformer`.
 */
Public method "left fold_through_" is
[
	aTuple : <any…|1..>,
	transformer : [⊥, ⊥]→any
|
	result : any := aTuple[1];
	From 2 to |aTuple| do
	[
		index : natural number
	|
		result := transformer(aTuple[index], eject ↑result);
	];
	result
] : any;

/**
 * Left fold has the following requirements:
 *
 * - The function's first parameter must accept every element of the tuple
 *   except for the first (with which it will not be applied at this position).
 * - The function's second parameter must accept the tuple's first element and
 *   also every value producible by the function.
 *
 * Left fold answers either the tuple's first element or the value produced by
 * the final application of the function.
 */
Semantic restriction "left fold_through_" is
[
	tupleType : <any…|1..>'s type,
	transformer : [⊥, ⊥]→any's type
|
	headType ::= tupleType[1];
	restType ::= if |tupleType's leading types| > 0
		then [ ∪ tupleType[2..|tupleType's leading types| + 1] ]
		else [ headType ];
	returnType ::= transformer's return type;
	finalType ::= headType ∪ returnType;
	If transformer[1] ≠ ⊥ ∧ [ ¬restType ⊆ transformer[1] ] then
	[
		Reject parse, expected:
			"repeatedly applied function's first parameter to accept all\
			\| non-first elements of the tuple ⊆ "
			++ “restType”
			++ " (but it only accepts "
			++ “transformer[1]”
			++ ")"
	];
	If transformer[2] ≠ ⊥ ∧ [ ¬finalType ⊆ transformer[2] ] then
	[
		Reject parse, expected:
			"repeatedly applied function's second parameter to accept the\
			\| type union ⊆ "
			++ “finalType”
			++ " of the first element ⊆ "
			++ “headType”
			++ " of the tuple and its own return type ⊆ "
			++ “returnType”
			++ " (but it only accepts "
			++ “transformer[2]”
			++ ")"
	];
	finalType
];

/**
 * Reduce `aTuple` via the binary function, traversing the tuple from right to
 * left. Answer the result of the reduction.
 *
 * Parameters:
 *    aTuple - A nonempty tuple.
 *    transformer - A binary function whose second parameter type matches its
 *       return type. The first parameter type must be general enough to accept
 *       each element of `aTuple`.
 * Returns:
 *    The only element of `aTuple` if `aTuple` contains only one element.
 *    Otherwise, the result of iteratively applying `transformer` to 1) the
 *    right-to-left consecutive elements of `aTuple` and 2) the previous results
 *    of applying `transformer`.
 */
Public method "right fold_through_" is
[
	aTuple : <any…|1..>,
	transformer : [⊥, ⊥]→any
|
	result : any := aTuple[|aTuple|];
	From |aTuple| - 1 to 1 by -1 do
	[
		index : natural number
	|
		result := transformer(aTuple[index], eject ↑result);
	];
	result
] : any;

/**
 * Right fold has the following requirements:
 *
 * - The function's first parameter must accept every element of the tuple
 *   except for the last (with which it will not be applied at this position).
 * - The function's second parameter must accept the tuple's last element and
 *   also every value producible by the function.
 *
 * Right fold answers either the tuple's last element or the value produced by
 * the final application of the function.
 */
Semantic restriction "right fold_through_" is
[
	tupleType : <any…|1..>'s type,
	transformer : [⊥, ⊥]→any's type
|
	sizes ::= ||tupleType||;

	lastIndexStart ::= 1 max relevant |tupleType|;
	lastIndexEnd ::= lastIndexStart
		max (⎡sizes⎤ min (|tupleType's leading types| + 1));
	lastType ::= ∪ tupleType[lastIndexStart..lastIndexEnd];
	restType ::= ∪ tupleType[1..lastIndexEnd - 1];
	returnType ::= transformer's return type;
	finalType ::= lastType ∪ returnType;
	If transformer[1] ≠ ⊥ ∧ [ ¬restType ⊆ transformer[1] ] then
	[
		Reject parse, expected:
			"repeatedly applied function's first parameter to accept all\
			\| non-last elements of the tuple ⊆ "
			++ “restType”
			++ " (but it only accepts "
			++ “transformer[1]”
			++ ")"
	];
	If transformer[2] ≠ ⊥ ∧ [ ¬finalType ⊆ transformer[2] ] then
	[
		Reject parse, expected:
			"repeatedly applied function's second parameter to accept the\
			\| type union ⊆ "
			++ “finalType”
			++ " of the last element ⊆ "
			++ “lastType”
			++ " of the tuple and its own return type ⊆ "
			++ “returnType”
			++ " (but it only accepts "
			++ “transformer[2]”
			++ ")"
	];
	finalType
];

/**
 * Compute and answer the index of the first element of `aTuple` that satisfies
 * the specified predicate.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple.
 * Returns:
 *    The index of the first satisfactory element, or 0 if no element satisfied
 *    the predicate.
 */
Public method "first index of_where_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	$body : natural number;
	From 1 to |aTuple| do
	[
		index : natural number
	|
		If predicate(aTuple[index]) then
		[
			Exit body with index
		];
	];
	0
] : whole number;

/**
 * Ensure that the function will accept all elements of the tuple.
 */
Semantic restriction "first index of_where_" is
[
	tupleType : tuple meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts tupleType;
	[0..⎡tupleType⎤ + 1)
];

/**
 * Compute and answer the index of the last element of `aTuple` that satisfies
 * the specified predicate.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple.
 * Returns:
 *    The index of the last satisfactory element, or 0 if no element satisfied
 *    the predicate.
 */
Public method "last index of_where_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	$body : natural number;
	From |aTuple| to 1 by -1 do
	[
		index : natural number
	|
		If predicate(aTuple[index]) then
		[
			Exit body with index
		];
	];
	0
] : whole number;

/**
 * Ensure that the function will accept all elements of the tuple.
 */
Semantic restriction "last index of_where_" is
[
	tupleType : tuple meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts tupleType;
	[0..⎡tupleType⎤ + 1)
];
	
	
/**
 * Compute and answer the indices of all the elements of `aTuple` that satisfies
 * the specified predicate.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple.
 * Returns:
 *    The indices of all the satisfactory elements of the predicate.
 */
Public method "all indices of_where_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	indices : <natural number…|0..∞> := <>;
	From 1 to |aTuple| by 1 do
	[
		index : natural number
	|
		If predicate(aTuple[index]) then
		[
			indices := indices ++ <index>;
		];
	];
	indices
] : <natural number…|0..∞>;

/**
 * Ensure that the function will accept all elements of the tuple.
 * 
 * Parameters:
 *    tupleType - the type of the input tuple
 *    predicateType - the type of the predicate input
 * Returns:
 *    The most specific tuple type.
 */
Semantic restriction "all indices of_where_" is
[
	tupleType : tuple meta,
	predicateType : [⊥]→boolean's type
|
	Require: predicateType accepts tupleType;
	<natural number…|0..⎡tupleType⎤ + 1>
];

/**
 * Construct and answer a tuple whose elements are each `value`.
 * 
 * Parameters:
 *    count - The number of elements in the resulting tuple.
 *    value - The repeated value.
 * Returns:
 *    A tuple containing `count` occurrences of `value`.
 */
Public stable method "_occurrences⁇of_" is
[
	count : whole number,
	value : any
|
	accumulator : tuple := <>;
	Repeat
	[
		accumulator := eject ↑accumulator ++ <value>;
	]
	count times;
	accumulator
];

Semantic restriction "_occurrences⁇of_" is
[
	countType : whole number's type,
	valueType : any meta
|
	<<>, valueType…|countType>
];

/**
 * Construct and answer a tuple that contains the consecutive integers from
 * `start` (inclusive) up to `end` (inclusive), counting up by 1. If
 * `end < start`, then answer the empty tuple.
 * 
 * Parameters:
 *    start - The first value of the resulting tuple.
 *    end - The last value of the resulting tuple.
 * Returns:
 *    The interval from `start` (inclusive) up to `end` (inclusive).
 */
Public stable method "_to_" is
[
	start : integer,
	end : integer
|
	accumulator : <integer…|> := <>;
	From start to end do
	[
		value : integer
	|
		accumulator := eject ↑accumulator ++ <value>;
	];
	accumulator
] : <integer…|>;

/**
 * Construct and answer a string that contains the consecutive characters from
 * `start` (inclusive) to `end` (inclusive). If
 * `start's code point ≤ end's code point`, then
 * `result[i]'s code point < result[i+1]'s code point`; otherwise,
 * `result[i]'s code point > result[i+1]'s code point`.
 * 
 * Parameters:
 *    start - The first value of the resulting tuple.
 *    end - The last value of the resulting tuple.
 * Returns:
 *    The interval from `start` (inclusive) to `end` (inclusive).
 */
Public stable method "_to_" is
[
	start : character,
	end : character
|
	accumulator : string := <>;
	startCodePoint ::= start's code point;
	endCodePoint ::= end's code point;
	From startCodePoint to endCodePoint do
	[
		value : code point
	|
		accumulator := eject ↑accumulator ++ <value→character>;
	];
	accumulator
] : string;

/**
 * Leverage the uncertainty of `start` to produce good leading types when the
 * upper bound of the result's cardinality can be determined.
 */
Semantic restriction "_to_" is
[
	start : integer's type,
	end : integer's type
|
	min ::= ⎣start⎦;
	max ::= ⎡end⎤;
	uncertainty ::= ⎡start⎤ - ⎣start⎦;
	sizes ::= [0 max (⎣end⎦ - ⎡start⎤ + 1) .. max - min + 2);
	if uncertainty is finite
		∧ [ sizes ≠ ⊥
		∧ [ ⎡sizes⎤ is finite ] ] then
	[
		finiteMin ::= cast min into [ t : integer | t ];
		finiteMax ::= cast max into [ t : integer | t ];
		types ::=
			map finiteMin to finiteMax through
			[
				x : integer
			|
				[x .. (finiteMax min (x + uncertainty)) + 1)
			];
		cast types
		into [t : <integer's type…|1..> | <t[1..|t|-1], t[|t|]…|sizes>]
		else [<>'s type]
	]
	else
	[
		<<>, [min..max + 1)…|sizes>
	]
];

/**
 * Construct and answer an interval including elements that lie between {@param
 * "start"} and {@param "end"}. The actual values included are those which
 * differ from {@param "start"} by a multiple of {@param "delta"}. If {@param
 * "delta"} is positive, then the result will include no values greater than
 * {@param "end"}; if {@param "delta"} is negative, then the result will include
 * no values less than {@param "end"}.
 *
 * @method "_to_by_"
 * @param "start" "integer"
 *        The first value of the resulting tuple.
 * @param "end" "integer"
 *        The largest (or smallest) allowed value of the resulting tuple. It
 *        will not be the last value of the resulting tuple unless the
 *        difference between {@param "start"} and {@param "end"} is a multiple
 *        of {@param "delta"}.
 * @param "delta" "integer"
 *        The difference between two successive elements of the resulting tuple.
 * @returns "tuple"
 *          A tuple containing elements on the specified interval.
 * @raises "incorrect-argument-type"
 *         If {@param "delta"} is {@code 0}.
 */
Public stable method "_to_by_" is
[
	start : integer,
	end : integer,
	delta : integer
|
	accumulator : <integer…|> := <>;
	From start to end by delta do
	[
		value : integer
	|
		accumulator := eject ↑accumulator ++ <value>;
	];
	accumulator
] : <integer…|>;

Public method "_to_by_" is
[
	start : integer,
	end : integer,
	delta : 0's type
|
	early failure function(incorrect-argument-type code)
] : ⊥;

/**
 * Leverage the uncertainty of `start` to produce good leading types when the
 * upper bound of the result's cardinality can be determined.
 */
Semantic restriction "_to_by_" is
[
	start : integer's type,
	end : integer's type,
	delta : integer's type
|
	min : extended integer;
	max : extended integer;
	sizes : whole number's type;
	If delta ⊆ [0..∞) then
	[
		min := ⎣start⎦;
		max := ⎡end⎤;
		sizes := [0 max (⎣end⎦ - ⎡start⎤ + 1) .. max - min + 2);
	]
	else if [delta ⊆ (-∞..-1]] then
	[
		min := ⎣end⎦;
		max := ⎡start⎤;
		sizes := [0 max (⎣start⎦ - ⎡end⎤ + 1) .. max - min + 2);
	]
	else
	[
		min := ⎣start⎦ min ⎣end⎦;
		max := ⎡start⎤ max ⎡end⎤;
		sizes := [0 .. max - min + 2);
	];
	<<>, [min..max + 1)…|sizes>
];

/**
 * Is `value` an element of `aTuple`?
 * 
 * Parameters:
 *    value - An arbitrary value.
 *    aTuple -  A tuple.
 * Returns:
 *    `true` if `value` is an element of `aTuple`, `false` otherwise.
 */
Stable method "_∈_" is
[
	value : any,
	aTuple : tuple
|
	any of aTuple satisfies [ element : any | element = value ]
] : boolean;

Semantic restriction "_∈_" is
[
	valueType : any meta,
	tupleType : tuple meta
|
	if valueType ∩ (∪ tupleType[1..relevant |tupleType|]) = ⊥ then
	[
		false's type
	]
	else
	[
		/* Can't strengthen. */
		⊤
	]
];

/**
 * Is `subtuple` a subsequence of `aTuple`?
 * 
 * Parameters:
 *    subtuple - The search tuple.
 *    aTuple - The tuple which should be searched for `subtuple`.
 * Returns:
 *    `true` if some subsequence of `aTuple` equals `subtuple`, `false`
 *    otherwise.
 */
Method "_⊆_" is
[
	subtuple : tuple,
	aTuple : tuple
|
	matched : boolean := false;
	From 1 to |aTuple| - |subtuple| + 1 do
	[
		index : natural number
	|
		matched := aTuple[index..index + |subtuple| - 1] = subtuple;
		¬matched
	];
	matched
] : boolean;

/**
 * Is `subtuple` a subsequence of `aTuple`?
 * 
 * Parameters:
 *    aTuple - The tuple which should be searched for `subtuple`.
 *    subtuple - The search tuple.
 * Returns:
 *    `true` if some subsequence of `aTuple` equals `subtuple`, `false`
 *    otherwise.
 */
Method "_⊇_" is
[
	aTuple : tuple,
	subtuple : tuple
|
	subtuple ⊆ aTuple
] : boolean;

/**
 * Answer a function suitable for use as the semantic restriction for
 * subsequence containment.
 *
 * Returns:
 *    A function suitable for use as the semantic restriction of `_⊆_` and
 *    `_⊇_`.
 */
Private method "subsequence restriction function" is
[
	[
		subtuple : tuple meta,
		aTuple : tuple meta
	|
		if |subtuple| = 1 ∧ [ |aTuple| = 1 ] then
		[
			(subtuple's instance ⊆ aTuple's instance)'s type
		]
		else if [ ⎣subtuple⎦ > ⎡aTuple⎤ ] then
		[
			false's type
		]
		else
		[
			subtupleElementType ::=
				∪ subtuple[1..|subtuple's leading types| + 1];
			elementType ::= ∪ aTuple[1..|aTuple's leading types| + 1];
			if subtupleElementType ∩ elementType = ⊥ then
			[
				false's type
			]
			/* Can't strengthen. */
			else
			[
				⊤
			]
		]
	] : type
] : [tuple meta, tuple meta]→type;

/**
 * Does `aTuple` start with the subsequence `prefix`?
 * 
 * Parameters:
 *    aTuple - The tuple whose prefix should be checked against `prefix`.
 *    prefix - The search tuple.
 * Returns:
 *    `true` if `aTuple` starts with the subsequence `prefix`, `false`
 *    otherwise.
 */
Public method "_starts with_" is
[
	aTuple : tuple,
	prefix : tuple
|
	aTuple[..|prefix| min |aTuple|] = prefix
] : boolean;

/**
 * Does `aTuple` end with the subsequence `suffix`?
 * 
 * Parameters:
 *    aTuple - The tuple whose suffix should be checked against `suffix`.
 *    suffix - The search tuple.
 * Returns:
 *    `true` if `aTuple` ends with the subsequence `suffix`, `false`
 *    otherwise.
 */
Public method "_ends with_" is
[
	aTuple : tuple,
	suffix : tuple
|
	aTuple[1 max (|aTuple| - (|suffix| min |aTuple|) + 1)..] = suffix
] : boolean;

/**
 * If `subtuple` is guaranteed longer than `aTuple` or if the element types of
 * `subtuple` and `aTuple` are completely disjoint, then `subtuple`'s instance
 * cannot possibly be a subsequence of `aTuple`'s instance.
 */
Semantic restriction "_⊆_" is subsequence restriction function;

/**
 * If `subtuple` is guaranteed longer than `aTuple` or if the element types of
 * `subtuple` and `aTuple` are completely disjoint, then `subtuple`'s instance
 * cannot possibly be a subsequence of `aTuple`'s instance.
 */
Semantic restriction "_⊇_" is
[
	aTuple : tuple meta,
	subtuple : tuple meta
|
	subsequence restriction function(subtuple, aTuple)
];

/**
 * If `subtuple` is guaranteed longer than `aTuple` or if the element types of
 * `subtuple` and `aTuple` are completely disjoint, then `subtuple`'s instance
 * cannot possibly be a subsequence of `aTuple`'s instance.
 */
Semantic restriction "_starts with_" is
[
	aTuple : tuple meta,
	subtuple : tuple meta
|
	subsequence restriction function(subtuple, aTuple)
];

/**
 * If `subtuple` is guaranteed longer than `aTuple` or if the element types of
 * `subtuple` and `aTuple` are completely disjoint, then `subtuple`'s instance
 * cannot possibly be a subsequence of `aTuple`'s instance.
 */
Semantic restriction "_ends with_" is
[
	aTuple : tuple meta,
	subtuple : tuple meta
|
	subsequence restriction function(subtuple, aTuple)
];

/**
 * Split a `aTuple` into two tuples between `pivot` and `pivot + 1` and answer
 * a 2-tuple containing the results.
 *
 * Parameters:
 *    aTuple - A tuple.
 *    pivot - The index (inclusive) at which to split `aTuple`.
 * Returns:
 *    A 2-tuple. The first tuple contains the first `pivot` elements of
 *    `aTuple`. The second tuple contains the remaining elements of `aTuple`.
 */
Public stable method "split_after_" is
[
	aTuple : tuple,
	pivot : whole number
|
	<aTuple[..pivot], aTuple[pivot + 1..]>
] : <tuple…|2>;

/**
 * Construct the strongest possible 2-tuple type for the given arguments. The
 * first element type is a tuple type whose elements are drawn from the original
 * tuple type. The second element type is a tuple type whose element type are
 * smears (i.e., type unions) of the trailing element types of the original
 * tuple type. The pivot is used to determine the cardinality ranges of the
 * these element types.
 */
Semantic restriction "split_after_" is
[
	tupleType : tuple meta,
	pivot : whole number's type
|
	If ⎣pivot⎦ > ⎡tupleType⎤ then
	[
		Reject parse, expected:
			"pivot ∈ "
			++ “pivot”
			++ " ever to be valid for the tuple ∈ "
			++ “tupleType”
	];
	pivotPlusOne ::= cast pivot + 1's type
		into [ t : natural number's type | t ];
	firstType ::= tuple type of tupleType[1's type..pivot];
	secondType ::= tuple type of tupleType[pivotPlusOne..||tupleType||];
	<firstType, secondType…|2>
];

/**
 * Split a `aTuple` into two tuples between `pivot - 1` and `pivot` and answer
 * a 2-tuple containing the results.
 *
 * Parameters:
 *    aTuple - A tuple.
 *    pivot - The index (exclusive) at which to split `aTuple`.
 * Returns:
 *    A 2-tuple. The first tuple contains the first `pivot - 1` elements of
 *    `aTuple`. The second tuple contains the remaining elements of `aTuple`.
 */
Public stable method "split_before_" is
[
	aTuple : tuple,
	pivot : natural number
|
	<aTuple[..pivot - 1], aTuple[pivot..]>
] : <tuple…|2>;

/**
 * Construct the strongest possible 2-tuple type for the given arguments. The
 * first element type is a tuple type whose elements are drawn from the original
 * tuple type. The second element type is a tuple type whose element type are
 * smears (i.e., type unions) of the trailing element types of the original
 * tuple type. The pivot is used to determine the cardinality ranges of the
 * these element types.
 */
Semantic restriction "split_before_" is
[
	tupleType : tuple meta,
	pivot : natural number's type
|
	If ⎣pivot⎦ > ⎡tupleType⎤ + 1 then
	[
		Reject parse, expected:
			"pivot ∈ "
			++ “pivot”
			++ " ever to be valid for the tuple ∈ "
			++ “tupleType”
	];
	pivotMinusOne ::= cast pivot - 1's type
		into [ t : whole number's type | t ];
	firstType ::= tuple type of tupleType[1's type..pivotMinusOne];
	secondType ::= tuple type of tupleType[pivot..||tupleType||];
	<firstType, secondType…|2>
];

/**
 * Split a `aTuple` into two tuples.
 *
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts each element of the tuple. It must
 *       answer `true` when the pivot position has been reached. The function
 *       will not be applied again answer it has answered `true`.
 * Returns:
 *    A 2-tuple. The first tuple contains the elements of `aTuple` to which
 *    `predicate` was applied. The second tuple contains the remaining elements
 *    of `aTuple`.
 */
Method "split_before_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	firstIndex ::= first index of aTuple where predicate;
	splitIndex ::=
		if firstIndex = 0
		then [ |aTuple| ]
		else [ cast firstIndex - 1 into [ t : whole number | t ] ];
	split aTuple after splitIndex
] : <tuple…|2>;

/**
 * Construct the strongest possible 2-tuple type for the given arguments. The
 * first element type is a tuple type whose elements are drawn from the original
 * tuple type. The second element type is a tuple type whose element type are
 * smears (i.e., type unions) of the trailing element types of the original
 * tuple type. The cardinality of each tuple varies from 0 to the upper bound of
 * `tupleType`'s cardinality range.
 */
Semantic restriction "split_before_" is
[
	tupleType : tuple meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts tupleType;
	returnType ::= predicate's return type;
	if ⎡tupleType⎤ = 0 then
	[
		<<>, <>>'s type
	]
	else
	[
		sizes ::= ||tupleType||;
		upper ::= [0..⎡sizes⎤ + 1);
		firstType ::=
			<tupleType's leading types, tupleType's default type…|upper>;
		secondType ::=
			tuple type of tupleType[[1..⎡sizes⎤ + 1)..upper];
		<firstType, secondType…|2>
	]
];

/**
 * Compute and answer the specified stripe of `aTuple`.
 * 
 * Parameters:
 *    aTuple - A tuple of non-empty tuples.
 *    index - The stripe index.
 * Returns:
 *    A tuple comprising the `index`-th elements of each element of `aTuple`.
 */
Public stable method "stripe_at_" is
[
	aTuple : <<any…|1..>…|>,
	index : natural number
|
	map aTuple through [ inner : <any…|1..> | inner[index] ]
] : tuple;

/**
 * Reject the parse if the stripe index could never be valid.
 */
Semantic restriction "stripe_at_" is
[
	tupleType : <<any…|1..>…|>'s type,
	index : natural number's type
|
	uncertainty ::= cast ⎡index⎤ - ⎣index⎦
		into [ t : whole number | t ];
	stripeTypes : <any meta…|> := <>;
	From 1 to |tupleType's leading types| + 1 do
	[
		typeIndex : natural number
	|
		innerType ::= tupleType[typeIndex];
		If ⎣index⎦ > ⎡innerType⎤ then
		[
			Reject parse, expected:
				"a subscript ("
				++ “⎣index⎦”
				++ " ≤ theSubscript ≤ "
				++ “⎡index⎤”
				++ ") that could ever be valid ("
				++ “⎣innerType⎦”
				++ " ≤ |theTuple| ≤ "
				++ “⎡innerType⎤”
				++ ")"
		];
		union : any meta := ⊥;
		limit ::= uncertainty min (|innerType's leading types| + 1);
		From 0 to limit do
		[
			delta : whole number
		|
			innerIndex ::= cast ⎣index⎦ + delta
				into [ t : natural number | t ];
			union := eject ↑union ∪ innerType[innerIndex];
		];
		stripeTypes := eject ↑stripeTypes ++ <union>;
	];
	nonemptyTypes ::= cast stripeTypes into [ t : <any meta…|1..> | t ];
	<nonemptyTypes[1..|nonemptyTypes| - 1], nonemptyTypes[|nonemptyTypes|]…
		| ||tupleType||>
];

/**
 * Answer a tuple containing the first `count` elements of `aTuple`.
 * 
 * Parameters:
 *    count - The size of the requested tuple.
 *    aTuple - The source tuple.
 * Returns:
 *    A tuple containing the first `count` elements of `aTuple`, preserving the
 *    original order.
 */
Public stable method "take_from_" is
[
	count : whole number,
	aTuple : tuple
|
	aTuple[1..count]
] : tuple;

Semantic restriction "take_from_" is
[
	count : whole number's type,
	tupleType : tuple's type
|
	tuple type of tupleType[1's type..count]
];

/**
 * Answer a tuple containing the prefix of `aTuple` that answered `true` to
 * `predicate`.
 *
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that can accept each element of the specified
 *       tuple. It should answer `true` to keep the element (and continue
 *       scanning) or `false` to abort.
 * Returns:
 *    A tuple containing the prefix of `aTuple` that satisfied `predicate`.
 */
Public method "take from_while_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	firstIndex ::= first index of aTuple where
		[value : any | ¬predicate(value)];
	splitIndex ::=
		if firstIndex = 0
		then [ |aTuple| ]
		else [ cast firstIndex - 1 into [ t : whole number | t ] ];
	aTuple[1..splitIndex]
] : tuple;

/**
 * Answer a semantic restriction suitable for use by the predicated-based
 * take/drop methods.
 *
 * Returns:
 *    The requested function.
 */
Private method "take|drop-while|until semantic restriction" is
[
	[
		tupleType : tuple meta,
		predicate : [⊥]→boolean's type
	|
		Require: predicate accepts tupleType;
		<∪ tupleType[1..|tupleType's leading types| + 1]…|0..⎡tupleType⎤>
	]
];

Semantic restriction "take from_while_" is take-while semantic restriction;

/**
 * Answer a tuple containing the prefix of `aTuple` that answered `false` to
 * `predicate`.
 *
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that can accept each element of the specified
 *       tuple. It should answer `false` to keep the element (and continue
 *       scanning) or `true` to abort.
 * Returns:
 *    A tuple containing the prefix of `aTuple` that satisfied `predicate`.
 */
Public method "take from_until_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	firstIndex ::= first index of aTuple where predicate;
	splitIndex ::=
		if firstIndex = 0
		then [ |aTuple| ]
		else [ cast firstIndex - 1 into [ t : whole number | t ] ];
	aTuple[1..splitIndex]
] : tuple;

Semantic restriction "take from_until_" is take-until semantic restriction;

/**
 * Compute and answer the suffix of `aTuple` that begins with the element that
 * answers `false` to `predicate`.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that can accept each element of the specified
 *       tuple. It should answer `true` to discard the element (and continue
 *       scanning) or `false` to abort.
 * Returns:
 *    The requested suffix.
 */
Public method "drop from_while_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	firstIndex ::= first index of aTuple where
		[value : any | ¬predicate(value)];
	splitIndex ::=
		if firstIndex = 0
		then [ |aTuple| + 1 ]
		else [ cast firstIndex into [ t : natural number | t ] ];
	aTuple[splitIndex..]
] : tuple;

Semantic restriction "drop from_while_" is drop-while semantic restriction;

/**
 * Compute and answer the suffix of `aTuple` that begins with the element that
 * answers `true` to `predicate`.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that can accept each element of the specified
 *       tuple. It should answer `false` to discard the element (and continue
 *       scanning) or `true` to abort.
 * Returns:
 *    The requested suffix.
 */
Public method "drop from_until_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	firstIndex ::= first index of aTuple where predicate;
	splitIndex ::=
		if firstIndex = 0
		then [ |aTuple| + 1 ]
		else [ cast firstIndex into [ t : natural number | t ] ];
	aTuple[splitIndex..]
] : tuple;

Semantic restriction "drop from_until_" is drop-until semantic restriction;

/**
 * Answer a tuple containing every element of `aTuple` except for the first
 * `count` elements.
 * 
 * Parameters:
 *    count - The size of the prefix of `aTuple` that should be omitted from the
 *       result tuple.
 *    aTuple - The source tuple.
 * Returns:
 *    A tuple containing every element but the first `count` elements of
 *    `aTuple`, preserving the original order.
 */
Public stable method "drop_from_" is
[
	count : whole number,
	aTuple : tuple
|
	aTuple[count + 1..]
] : tuple;

Semantic restriction "drop_from_" is
[
	count : whole number's type,
	tupleType : tuple's type
|
	startType ::= cast count + 1's type into [ t : [1..∞)'s type | t ];
	tuple type of tupleType[startType..||tupleType||]
];

Method "_[_]→_" is stable at [tuple, natural number, any]→tuple;

/**
 * Tuple element replacement affects only those elements whose subscripts are
 * instances of `indexType`. If multiple subscripts could be affected, then
 * update the element types via type union with `valueType`. If only a single
 * subscript could be affected, then simply replace the corresponding element
 * type with `valueType`. Leverage instance types if possible.
 */
Semantic restriction "_[_]→_" is
[
	tupleType : tuple meta,
	indexType : natural number's type,
	valueType : any meta
|
	indexLower ::= cast ⎣indexType⎦ into
		[ t : natural number | t ];
	If indexLower > ⎡tupleType⎤ then
	[
		Reject parse, expected:
			"a subscript ("
			++ “⎣indexType⎦”
			++ " ≤ theSubscript ≤ "
			++ “⎡indexType⎤”
			++ ") that could ever be valid ("
			++ “⎣tupleType⎦”
			++ " ≤ |theTuple| ≤ "
			++ “⎡tupleType⎤”
			++ ")"
	];
	indexUpper ::= ⎡indexType⎤;
	leadingTypes : <any meta…|> := tupleType's leading types;
	defaultType : any meta := tupleType's default type;
	/* Update any leading types possibly affected by `index`. */
	If indexLower ≤ |leadingTypes| then
	[
		limit ::= indexUpper min |leadingTypes|;
		From indexLower to limit do
		[
			leadingIndex : natural number
		|
			original ::= leadingTypes[leadingIndex];
			/* If only one possible element is affected (because the lower and
			 * upper bound of `index` are equal), then we can simply replace the
			 * element type with `valueType`. Otherwise we have to weaken the
			 * affected elements via type union with `valueType`.
			 */
			replacement ::= if |{indexLower, indexUpper}| = 1
				then [ valueType ]
				else [ original ∪ valueType ];
			newLeadingTypes ::= leadingTypes[leadingIndex]→replacement;
			leadingTypes := cast newLeadingTypes into [ t : <any meta…|> | t ];
		];
	];
	/* Extend the leading types. */
	If indexUpper > |leadingTypes| then
	[
		/* If the lower bound of `index` is greater than the number of leading
		 * types, i.e., the leading types are unaffected by this operation *and*
		 * there may be intervening element types between the last leading type
		 * and the first element type affected, then pad the leading types with
		 * the default type up to the lower bound (exclusive) of `index`.
		 */
		padCount ::= indexLower - |leadingTypes| - 1;
		If padCount > 0 then
		[
			count ::= cast padCount into [ t : natural number | t ];
			leadingTypes := eject ↑leadingTypes ++ count of defaultType;
		];
		/* If the upper bound of `index` is less than the maximum length of the
		 * tuple, then some elements of the result tuple may have the original
		 * default type. Extend the leading types to account for the new
		 * element.
		 */
		If indexUpper < ⎡tupleType⎤ then
		[
			newType ::= if |{indexLower, indexUpper}| = 1
				then [ valueType ]
				else [ defaultType ∪ valueType ];
			delta ::= if indexLower ≤ |leadingTypes| then [ 0 ] else [ 1 ];
			count ::= cast indexUpper - (|leadingTypes| max indexLower)
				into [ t : whole number | t + delta ];
			leadingTypes := eject ↑leadingTypes ++ count of newType;
		]
		/* The upper bound of `index` exceeds the minimum length of the tuple,
		 * so just update the default type.
		 */
		else
		[
			defaultType := eject ↑defaultType ∪ valueType;
		];
	];
	<leadingTypes, defaultType… | ||tupleType||>
];

/**
 * Compute and answer a tuple that is the result of replacing the specified
 * slice of `aTuple` with `replacement`.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    sliceStart - The subscript of the first element of the target slice.
 *    sliceEnd - The subscript of the last element of the target slice.
 *    replacement - The tuple that should be spliced into `aTuple` instead of
 *       the specified slice.
 * Returns:
 *    A variant of `aTuple` whose elements from `sliceStart` (inclusive) to
 *    `sliceEnd` (inclusive) have been replaced with those of `replacement`.
 *    Elements before `sliceStart` and after `sliceEnd` will be present in the
 *    answer.
 */
Public stable method "_[_.._]→_" is
[
	aTuple : tuple,
	sliceStart : natural number,
	sliceEnd : whole number,
	replacement : tuple
|
	If sliceEnd < sliceStart - 1 then
	[
		early failure function(subscript-out-of-bounds code)
	];
	aTuple[..sliceStart - 1] ++ replacement ++ aTuple[sliceEnd + 1..]
] : tuple;

/**
 * Reject the parse if the target slice would never be valid.
 */
Semantic restriction "_[_.._]→_" is
[
	aTuple : tuple meta,
	sliceStart : natural number's type,
	sliceEnd : whole number's type,
	replacement : tuple meta
|
	Require: aTuple[sliceStart..sliceEnd] is ever valid;
	prefixEnd ::= cast sliceStart - 1's type
		into [ t : whole number's type | t ];
	prefix ::= tuple type of aTuple[1's type..prefixEnd];
	suffixStart ::= cast sliceEnd + 1's type
		into [ t : natural number's type | t ];
	suffix ::= tuple type of aTuple[suffixStart..||aTuple||];
	prefix ++ replacement ++ suffix
];

/**
 * Compute and answer that is the result of swapping the elements of {@param
 * "aTuple"} at {@param "index1"} and {@param "index2"}.
 *
 * @method "_[_↔_]"
 * @param "aTuple" "tuple"
 *        A tuple.
 * @param "index1" "natural number"
 *        A subscript.
 * @param "index2" "natural number"
 *        A subscript.
 * @returns "tuple"
 *          A variant of {@param "aTuple"} whose elements at indices {@param
 *          "index1"} and {@param "index2"} have been exchanged. No other
 *          elements are affected.
 */
Public stable method "_[_↔_]" is
[
	aTuple : tuple,
	index1 : natural number,
	index2 : natural number
|
	element2 ::= aTuple[index2];
	temp ::= aTuple[index2]→aTuple[index1];
	temp[index1]→element2
] : tuple;

Semantic restriction "_[_↔_]" is
[
	aTuple : tuple's type,
	index1 : natural number's type,
	index2 : natural number's type
|
	If ⎣index1⎦ > ⎡aTuple⎤ then
	[
		Reject parse, expected:
			"a subscript ("
			++ “⎣index1⎦”
			++ " ≤ theSubscript ≤ "
			++ “⎡index1⎤”
			++ ") that could ever be valid ("
			++ “⎣aTuple⎦”
			++ " ≤ |theTuple| ≤ "
			++ “⎡aTuple⎤”
			++ ")"
	];
	If ⎣index2⎦ > ⎡aTuple⎤ then
	[
		Reject parse, expected:
			"a subscript ("
			++ “⎣index2⎦”
			++ " ≤ theSubscript ≤ "
			++ “⎡index2⎤”
			++ ") that could ever be valid ("
			++ “⎣aTuple⎦”
			++ " ≤ |theTuple| ≤ "
			++ “⎡aTuple⎤”
			++ ")"
	];
	limit ::= cast ⎣index1⎦ min ⎣index2⎦ into [t : natural number | t];
	leadingTypes ::= aTuple[1..limit - 1];
	defaultType ::= ∪ aTuple[limit..|aTuple's leading types| + 1];
	<leadingTypes, defaultType… | ||aTuple||>
];

/**
 * Flatten a tuple of tuples by a single level.
 *
 * Parameters:
 *    aTuple - A tuple of tuples to flatten.
 * Returns:
 *    A flattened tuple.
 */
Public stable method "flatten_" is
[
	aTuple : <tuple…|>
|
	newTuple : tuple := <>;
	For each aTuple do 
	[
		t : tuple 
	|
		newTuple := eject ↑newTuple ++ t;
	];
	newTuple
] : tuple;

/**
 * Obtain the first element of the specified tuple.
 *
 * Parameters:
 *    aTuple - A tuple.
 * Returns:
 *    The first element of `aTuple`.
 */
Public stable method "_'s⁇head" is
[
	aTuple : <any…|1..>
|
	aTuple[1]
] : any;

Semantic restriction "_'s⁇head" is
[
	aTupleType : <any…|1..>'s type
|
	aTupleType[1]
];

/**
 * Construct and answer a tuple slice that contains all but the first element of
 * the specified tuple. If the argument contains only one element, then answer
 * an empty tuple.
 *
 * Parameters:
 *    aTuple - A nonempty tuple.
 * Returns:
 *    The requested tuple slice.
 */
Public stable abstract method "_'s⁇tail" is [<any…|1..>]→tuple;

/**
 * Construct and answer a tuple slice that contains all but the first element of
 * the specified tuple.
 *
 * Parameters:
 *    aTuple - A tuple containing a single element.
 * Returns:
 *    An empty tuple.
 */
Method "_'s⁇tail" is
[
	aTuple : <any…|1>
|
	<>
] : <>'s type;

/**
 * Construct and answer a tuple slice that contains all but the first element of
 * the specified tuple.
 *
 * Parameters:
 *    aTuple - A tuple containing at least two elements.
 * Returns:
 *    The requested tuple slice.
 */
Method "_'s⁇tail" is
[
	aTuple : <any…|2..>
|
	aTuple[2..]
] : tuple;

Semantic restriction "_'s⁇tail" is
[
	aTupleType : <any…|1..>'s type
|
	leadingTypes ::= aTupleType's leading types;
	defaultType ::= aTupleType's default type;
	sizeLeadingTypes ::= |leadingTypes|;
	bound ::= ⎡aTupleType⎤;
	lower ::= ⎣aTupleType⎦ - 1;
	if sizeLeadingTypes > 1 then
	[
		<leadingTypes[2..sizeLeadingTypes], defaultType…|[lower..bound)>
	]
	else
	[
		<defaultType…|lower..bound-1>
	]
];

/**
 * Obtain the last element of the specified tuple.
 *
 * Parameters:
 *    aTuple - A tuple.
 * Returns:
 *    The last element of a `aTuple`.
 */
Public stable method "_'s⁇last" is
[
	aTuple : <any…|1..>
|
	aTuple[|aTuple|]
] : any;

Semantic restriction "_'s⁇last" is
[
	aTupleType : <any…|1..>'s type
|
	upper ::= ⎡aTupleType⎤ min (|aTupleType's leading types| + 1);
	∪ aTupleType[⎣aTupleType⎦..upper]
];

/**
 * Sum the elements of the specified tuple of integers.
 *
 * Parameters:
 *    intTuple - A tuple of integers.
 * Returns:
 *    An integer.
 */
Public stable method "Σ_" is
[
	intTuple : <extended integer…|1..∞>
|
	left fold intTuple through
		[i : extended integer, ri : extended integer | i + ri]
] : extended integer;

/**
 * Compute and answer the best bounds of the specified summation.
 *
 * @method "Σ_"
 * @param "intTupleType" "<extended integer…|1..∞>'s type"
 *        A tuple type whose default type is {@type "extended integer"}.
 * @returns "extended integer's type"
 *          The strongest integer range that can be computed for the argument.
 */
Method "Σ_" is
[
	intTupleType : <extended integer…|1..∞>'s type
|
	leading ::= intTupleType's leading types;
	defaultType ::= intTupleType's default type;
	leadingSize ::= |leading|;
	lowIndex ::= leadingSize min ⎣leading's type⎦;
	lowBound ::=
		if leadingSize > 0 then
		[
			t ::= cast leading[1..lowIndex]
				into [t : <extended integer meta…|1..> | t];
			(Σ map t through [i : extended integer meta | ⎣i⎦])
				+ ((⎣intTupleType⎦ - lowIndex) max 0)
				× ⎣defaultType⎦
		]
		else
		[
			⎣intTupleType⎦ × ⎣defaultType⎦
		];
	upBound ::=
		if leadingSize > 0 then 
		[
			t ::= cast leading[1..lowIndex]
				into [t : <extended integer meta…|1..> | t];
			(Σ map t through [i : extended integer meta | ⎡i⎤])
				+ ⎡intTupleType's default type⎤
				× (⎡intTupleType⎤ - leadingSize)
		]
		else
		[
			⎡intTupleType's default type⎤ × (⎡intTupleType⎤ - leadingSize)
		];
	[lowBound..upBound]
] : extended integer's type;

/**
 * Strengthen the return type
 *
 * Parameters:
 *    intTupleType - a tuple of integer's type.
 *
 * Returns:
 *    A number.
 */
Semantic restriction "Σ_" is
[
	intTupleType : <extended integer…|1..∞>'s type
|
	Σ intTupleType
];

/**
 * Take the product of the elements of a tuple of integers.
 *
 * Parameters:
 *    intTuple - a tuple of integers.
 *    
 * Returns:
 *    An integer.
 */
Public stable method "∏_" is
[
	intTuple : <integer…|1..∞>
|
	left fold intTuple through 
	[
		i : integer,
		ri : integer
	|
		i × ri
	]
]: integer;

/**
 * Strengthen the return type
 *
 * Parameters:
 *    intTupleType - a tuple of integer's type.
 *
 * Returns:
 *    A number.
 *//* TODO [RAA]
Semantic restriction "∏_" is
[
	intTupleType : <integer…|1..∞>'s type
|
	leading ::= intTupleType's leading types;
	defaultType ::= intTupleType's default type;
	leadingSize ::= |leading|;
	lowIndex ::= leadingSize min ⎣leading's type⎦;
	lowBound ::= if leadingSize > 0 then 
	[
		m ::=  map leading[1..lowIndex] through
		[
			i : any's type
		|
			x::=cast i into [it : integer's type | it];
Print: "x=";
Print: “x”;
			y::= cast (⎣x⎦) into [n : integer | n]
		];
		∏ (cast x into [iTuple : <integer…|1..∞> | iTuple] )); 
Print: "y=";
Print: “y”;

		z::=y × (⎣defaultType⎦ ^ 
				((⎣intTupleType⎦ - lowIndex) max 0));
Print: "z=";
Print: “z”;
		z
			
	]
	else
	[
		⎣defaultType⎦ ^ 
				((⎣intTupleType⎦ - lowIndex) max 0)
	];
	upBound ::= if leadingSize > 0 then 
	[
		(∏ (cast (map leading[1..lowIndex] through
		[
			i : any's type
		|
			x ::= cast i into [it : integer's type | it];
			cast (⎡x⎤) into [n : integer | n]
		]) into [iTuple : <integer…|1..∞> | iTuple] )) × 
			((⎡intTupleType's default type⎤) ^
			(⎡intTupleType⎤ - leadingSize))
	]
	else
	[
		((⎡intTupleType's default type⎤) ^
			(⎡intTupleType⎤ - leadingSize))
	];
	[lowBound..upBound+1)
];*/

/**
 * Construct and answer a sorted variant of {@param "numbers"} using the
 * quicksort algorithm.
 *
 * When overriding {@method "quicksort_"}, only target tuple types that contain
 * at least two elements. Not only do the trivial cases of 0 and 1 elements have
 * a simple universal implementation, the 0-element (i.e., empty tuple) case
 * causes ambiguous resolution if multiple overrides exist that will accept it.
 *
 * @method "quicksort_"
 * @param "numbers" "<number…|>"
 *        A tuple of numbers.
 * @returns "<number…|>"
 *          A tuple of numbers in ascending order.
 */
Public abstract method "quicksort_" is [<number…|>]→<number…|>;

/* Give quicksort higher precedence than concatenation. */
Grammatical restriction "quicksort_" is <{"«_‡++»"}>;

Semantic restriction "quicksort_" is
[
	tupleType : tuple meta
|
	union ::= ∪ tupleType[1..|tupleType's leading types|+1];
	<<>, union… | ||tupleType||>
];

Method "quicksort_" is
[
	trivial : <⊥…|0>
|
	trivial
] : <number…|0>;

Method "quicksort_" is
[
	trivial : <number…|1>
|
	trivial
] : <number…|1>;

Seal method "quicksort_" at <<any…|0..1>>;

Method "quicksort_" is
[
	numbers : <number…|2..>
|
	/* Choose the median of the first, middle, and last elements as the
	 * pivot.
	 */
	size ::= |numbers|;
	halfSize ::= |numbers| ÷ 2;
	pivotIndex : natural number :=
		if numbers[1] > numbers[size] then [1]
		else [size];
	pivotIndex :=
		if numbers[pivotIndex] < numbers[halfSize] then [pivotIndex]
		else [halfSize];
	pivot ::= numbers[pivotIndex];
	withoutPivot ::= numbers[..pivotIndex-1] ++ numbers[pivotIndex+1..];
	lesser ::= filter withoutPivot by [n : number | n ≤ pivot];
	greater ::= filter withoutPivot by [n : number | n > pivot];
	quicksort lesser ++ <pivot> ++ quicksort greater
];

/**
 * Construct and answer a sorted variant of {@param "aTuple"} using the
 * quicksort algorithm and specified comparison function.
 *
 * @method "quicksort_with_"
 * @param "aTuple" "tuple"
 *        A tuple.
 * @param "comparator" "[⊥, ⊥]→boolean"
 *        A comparison function that accepts two elements of {@param "aTuple"}
 *        and answers {@code "true"} if the first ≤ second and {@code "false"}
 *        otherwise.
 * @returns "tuple"
 *          A sorted variant of {@param "aTuple"}.
 */
Public abstract method "quicksort_with_" is [tuple, [⊥, ⊥]→boolean]→tuple;

Semantic restriction "quicksort_with_" is
[
	tupleType : tuple meta,
	comparator : [⊥, ⊥]→boolean's type
|
	union ::= ∪ tupleType[1..|tupleType's leading types|+1];
	If comparator[1] ≠ ⊥ ∧ [¬union ⊆ comparator[1]] then
	[
		Reject parse, expected:
			"first parameter of comparison function to accept all elements ∈ "
			++ “union”
			++ " of the specified tuple (but it only accepts "
			++ “comparator[1]”
			++ ")"
	];
	If comparator[2] ≠ ⊥ ∧ [¬union ⊆ comparator[2]] then
	[
		Reject parse, expected:
			"second parameter of comparison function to accept all elements ∈ "
			++ “union”
			++ " of the specified tuple (but it only accepts "
			++ “comparator[2]”
			++ ")"
	];
	<<>, union… | ||tupleType||>
];

Method "quicksort_with_" is
[
	trivial : <any…|0..1>,
	comparator : [⊥, ⊥]→boolean
|
	trivial
] : <any…|0..1>;

Method "quicksort_with_" is
[
	aTuple : <any…|2..>,
	comparator : [⊥, ⊥]→boolean
|
	/* Choose the median of the first, middle, and last elements as the
	 * pivot.
	 */
	size ::= |aTuple|;
	halfSize ::= |aTuple| ÷ 2;
	pivotIndex : natural number :=
		if comparator(aTuple[1], aTuple[size])
		then [1]
		else [size];
	pivotIndex :=
		if ¬comparator(aTuple[pivotIndex], aTuple[halfSize])
		then [pivotIndex]
		else [halfSize];
	pivot ::= aTuple[pivotIndex];
	withoutPivot ::= aTuple[..pivotIndex-1] ++ aTuple[pivotIndex+1..];
	lesser ::= filter withoutPivot by
		[a : any | comparator(a, pivot)];
	greater ::= filter withoutPivot by
		[a : any | ¬comparator(a, pivot)];
	quicksort lesser with comparator
		++ <pivot>
		++ quicksort greater with comparator
];

Seal method "quicksort_with_" at <tuple, [⊥, ⊥]→boolean>;

/**
 * Construct and answer a tuple like {@param "aTuple"}, but with the leftmost
 * occurrence of {@param "doomed"} removed.
 *
 * @method "_-_"
 * @param "aTuple" "tuple"
 *        A tuple.
 * @param "doomed" "any"
 *        A value.
 * @returns "tuple"
 *          The requested tuple, which will be {@param "aTuple"} if there were
 *          no occurrences of {@param "doomed"}.
 */
Method "_-_" is
[
	aTuple : tuple,
	doomed : any
|
	index ::= first index of aTuple where [a : any | a = doomed];
	cast index into [i : natural number | aTuple[..i-1] ++ aTuple[i+1..]]
	else [aTuple]
] : tuple;

Semantic restriction "_-_" is
[
	tupleType : tuple meta,
	element : any meta
|
	allDisjoint : boolean := true;
	From 1 to |tuple's leading types| + 1 do
	[
		index : natural number
	|
		If tupleType[index] ∩ element ≠ ⊥ then
		[
			allDisjoint := false;
		];
		allDisjoint
	];
	If allDisjoint then
	[
		tupleType
	]
	else
	[
		union ::= ∪ tupleType[1..|tupleType's leading types|+1];
		<union… | 0 max (⎣tupleType⎦-1).. ⎡tupleType⎤>
	]
];

/**
 * If {@param "start"} and {@param "end"} are valid subscripts representing a 
 * valid range for {@param "aTuple"}, then answer the corresponding element. 
 * Otherwise, answer the result obtained by applying {@param "else"}.
 *
 * @method "_[_.._]else_"
 * @param "aTuple" "tuple"
 *        A {@type "tuple"}.
 * @param "start" "integer"
 *        An {@type "integer"}.
 * @param "end" "integer"
 *        An {@type "integer"}.
 * @param "else" "[]→any"
 *        The function to apply if {@param "start"} through {@param "end} is not
 *        a valid range of {@param "aTuple"}.
 * @returns "any"
 *          The {@param "start"}-th throught the {@param "end"}-th elements of 
 *          {@param "aTuple"}, or the result of applying {@param "else"} 
 *          (if {@param "index"} is invalid).
 */
Public method "_[_.._]else_" is
[
	aTuple : tuple,
	start : integer,
	end : integer,
	else : function accepting <> and returning any
|
	if start ∈ [1..|aTuple| + 1] ∧ [end  ∈ [0..|aTuple|] ∧ [start - 1 ≤ end]]
	then [aTuple[cast start into [t : natural number | t]..
		cast end into [t : whole number | t]]]
	else else
] : any;

Semantic restriction "_[_.._]else_" is
[
	tupleType : tuple meta,
	start : integer's type,
	end : integer's type,
	else : (function accepting <> and returning any)'s type
|
	if ⎣start⎦- 1 > ⎡tupleType⎤ ∨ [⎡start⎤ < 1 ∨ [⎣end⎦ > ⎡tupleType⎤ ∨ 
		[⎡end⎤ < 0 ∨ [⎣start⎦- 1 > ⎡end⎤]]]] then
	[
		else's return type
	]
	else
	[
		min ::= cast ⎣start⎦ max 1
			into [t : natural number | t];
		max ::= cast ⎡end⎤ min (|tupleType's leading types| + 1)
			into [t : whole number | t];
		if min - 1 = max then [ <>'s type]
		else 
		[
			union ::= tuple type of tupleType[min's type..max's type];
			if [min..max] ⊆ [1..⎣tupleType⎦] then
			[
				union
			]
			else
			[
				union ∪ else's return type
			]
		]
	]
];

/**
 * If {@param "end"} is a valid subscript representing the end of a  
 * valid range for {@param "aTuple"}, then answer the corresponding element. 
 * Otherwise, answer the result obtained by applying {@param "else"}.
 *
 * @method "_[.._]else_"
 * @param "aTuple" "tuple"
 *        A {@type "tuple"}.
 * @param "end" "integer"
 *        An {@type "integer"}.
 * @param "else" "[]→any"
 *        The function to apply if 1 through {@param "end} is not
 *        a valid range of {@param "aTuple"}.
 * @returns "any"
 *          The first through the {@param "end"}-th element of 
 *          {@param "aTuple"}, or the result of applying {@param "else"} 
 *          (if {@param "index"} is invalid).
 */
Public method "_[.._]else_" is
[
	aTuple : tuple,
	end : integer,
	else : function accepting <> and returning any
|
	aTuple[1..end] else else
] : any;

Semantic restriction "_[.._]else_" is
[
	tupleType : tuple meta,
	end : integer's type,
	else : (function accepting <> and returning any)'s type
|
	if ⎣end⎦ > ⎡tupleType⎤ ∨ [⎡end⎤ < 0 ] then
	[
		else's return type
	]
	else
	[
		max ::= cast ⎡end⎤ min (|tupleType's leading types| + 1)
			into [t : whole number | t];
		if max = 0 then [ <>'s type]
		else 
		[
			union ::= tuple type of tupleType[1's type..max's type];
			if [1..max] ⊆ [1..⎣tupleType⎦] then
			[
				union
			]
			else
			[
				union ∪ else's return type
			]
		]
	]
];

/**
 * If {@param "start"} is a valid subscript representing the start of a  
 * valid range for {@param "aTuple"}, then answer the corresponding element. 
 * Otherwise, answer the result obtained by applying {@param "else"}.
 *
 * @method "_[_..]else_"
 * @param "aTuple" "tuple"
 *        A {@type "tuple"}.
 * @param "start" "integer"
 *        An {@type "integer"}.
 * @param "else" "[]→any"
 *        The function to apply if {@param "start"} through the end of aTuple 
 *        is not a valid range of {@param "aTuple"}.
 * @returns "any"
 *          The {@param "start"}-th through the last element of 
 *          {@param "aTuple"}, or the result of applying {@param "else"} 
 *          (if {@param "start"} is invalid).
 */
Public method "_[_..]else_" is
[
	aTuple : tuple,
	start : integer,
	else : function accepting <> and returning any
|
	aTuple[start..|aTuple|] else else
] : any;

Semantic restriction "_[_..]else_" is
[
	tupleType : tuple meta,
	start : integer's type,
	else : (function accepting <> and returning any)'s type
|
	if ⎣start⎦ - 1 > ⎡tupleType⎤ ∨ [⎡start⎤ < 1 ] then
	[
		else's return type
	]
	else
	[
		min ::= cast ⎣start⎦ max 1
			into [t : natural number | t];
		max ::= cast ⎡tupleType⎤
			into [t : whole number | t];
		if min - 1 = max then [ <>'s type]
		else 
		[
			union ::= tuple type of tupleType[min's type..max's type];
			if [min..max] ⊆ [1..⎣tupleType⎦] then
			[
				union
			]
			else
			[
				union ∪ else's return type
			]
		]
	]
];
