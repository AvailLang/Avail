/*
 * Tuples.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Tuples"
Versions
	"dev"
Extends
	"Collections",
	"Early Tuples"
Uses
	"Bootstrap",
	"Control Structures",
	"Early Functions",
	"Early Types",
	"Enumeration Support",
	"Literals",
	"Logic",
	"Math",
	"Variables"
Names
	"first index of_where_",
	"last index of_where_",
	"zip_",
	"_of_",
	"«_‡zip»"
Body

/**
 * Is the specified tuple empty?
 *
 * Parameters:
 *    aTuple - A tuple.
 * Returns:
 *    `true` if the argument is empty, `false` otherwise.
 */
Method "_is empty" is
[
	aTuple : tuple
|
	|aTuple| = 0;
];

/**
 * Iteratively apply `action` to each consecutive element of `aTuple`.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    action - A function that accepts the elements of the tuple.
 */
Method "For each_do_" is
[
	aTuple : tuple,
	action : [⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			Invoke action with <aTuple[index]>;
			↑index++;
			Restart loop;
		];
	]();
] : ⊤;

/**
 * Iteratively apply `action` to each consecutive element of `aTuple`.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    action - A function that accepts 1) an element of the tuple and 2) the
 *       index of that element.
 */
Method "For each_do_" is
[
	aTuple : tuple,
	action : [⊥, ⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			Invoke action with <aTuple[index], index>;
			↑index++;
			Restart loop;
		];
	]();
] : ⊤;

/**
 * Helper method for semantic restrictions: If `action` does not accept the
 * type union of all element types of `tupleType` and their indices, then reject
 * the current parse.
 * 
 * Parameters:
 *    action - A function type whose first parameter must correspond to the
 *       type union of the element types of `tupleType` and whose second
 *       parameter, if provided, must correspond to `indices`.
 *    tupleType - A tuple type.
 */
Method "Require:_accepts_" is
[
	action : function meta,
	tupleType : tuple meta
|
	If ||action's parameters' type||'s lower bound < 1 then
	[
		Reject parse, expected:
			"repeatedly applied function to accept at least one argument";
	];
	union ::= ∪ tupleType[1..|tupleType's leading types| + 1];
	If action[1] ≠ ⊥ ∧ [ ¬union ⊆ action[1]; ] then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all elements of the tuple ∈ "
			++ primitive description of tupleType
			++ " (but it only accepts "
			++ primitive description of action[1]
			++ ")";
	];
	If ||action's parameters' type||'s lower bound = 2
		∧ [ action[2] ≠ ⊥
		∧ [ ¬[1..||tupleType||'s upper bound + 1) ⊆ action[2]; ]; ]
	then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all indices of the tuple ∈ "
			++ primitive description of tupleType
			++ " (but it only accepts "
			++ primitive description of action[2]
			++ ")";
	];
] : ⊤;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * If the tuple is certainly nonempty and the function certainly does not
 * complete if applied, then answer ⊥.
 * 
 * Parameters:
 *    tupleType -
 *    action -
 * Returns:
 *    Either ⊤ or ⊥.
 */
Semantic restriction "For each_do_" is
[
	tupleType : tuple meta,
	action : function meta
|
	Require: action accepts tupleType;
	if ||tupleType||'s lower bound > 0 ∧ [ action's return type = ⊥; ] then
	[
		⊥;
	]
	else
	[
		⊤;
	];
];

/**
 * Iteratively apply `transformer` to each consecutive element of `aTuple`,
 * collecting the results into a new tuple (and preserving ordering of the
 * transformed elements). Answer this tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    transformer - A function that accepts the elements of the tuple.
 * Returns:
 *    A tuple of results of applications of `transformer` to the elements of
 *    `aTuple`.
 */
Method "map_through_" is
[
	aTuple : tuple,
	transformer : [⊥]→any
|
	index : natural number := 1;
	result : tuple := <>;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			result :=
				eject ↑result ++ <invoke transformer with <aTuple[index]>>;
			↑index++;
			Restart loop;
		];
	]();
	result;
] : tuple;

/**
 * Iteratively apply `transformer` to each consecutive element of `aTuple`,
 * collecting the results into a new tuple (and preserving ordering of the
 * transformed elements). Answer this tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    transformer - A function that accepts 1) an element of the tuple and 2)
 *       the index of that element.
 * Returns:
 *    A tuple of results of applications of `transformer` to the elements and
 *    indices of `aTuple`.
 */
Method "map_through_" is
[
	aTuple : tuple,
	transformer : [⊥, ⊥]→any
|
	index : natural number := 1;
	result : tuple := <>;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			result := eject ↑result
				++ <invoke transformer with <aTuple[index], index>>;
			↑index++;
			Restart loop;
		];
	]();
	result;
] : tuple;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * If the tuple is certainly nonempty, then the function cannot answer ⊥.
 * 
 * Parameters:
 *    tupleType -
 *    transformer -
 * Returns:
 *    A tuple type with no leading types whose default type is the return type
 *    of `transformer` and whose cardinality is the same as `tupleType`'s.
 */
Semantic restriction "map_through_" is
[
	tupleType : tuple meta,
	transformer : […]→any's type
|
	Require: transformer accepts tupleType;
	If ||tupleType||'s lower bound > 0 then
	[
		If transformer's return type = ⊥ then
		[
			Reject parse, expected:
				"repeatedly applied function to have a return type other than\
				\| ⊥";
		];
	];
	<<>, transformer's return type… | ||tupleType||>;
];

/**
 * Iteratively apply `predicate` to each consecutive element of `aTuple`,
 * collecting those elements for which `predicate` answers `true` into a new
 * tuple (and preserving ordering). Answer the new tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple and answers
 *       `true` iff they should be accumulated into the output tuple.
 * Returns:
 *    A tuple containing exactly those elements of `aTuple` for which
 *    `predicate` answered `true`.
 */
Method "filter_by_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop;
		If index ≤ end then
		[
			element ::= aTuple[index];
			If invoke predicate with <element> then
			[
				result := eject ↑result ++ <element>;
			];
			↑index++;
			Restart loop;
		];
	]();
	result;
] : tuple;

/**
 * Iteratively apply `predicate` to each consecutive element and index of
 * `aTuple`, collecting those elements for which `predicate` answers `true` into
 * a new tuple (and preserving ordering). Answer the new tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts 1) an element of the tuple and 2)
 *       the index of that element and which answers `true` iff the elements
 *       should be accumulated into the output tuple.
 * Returns:
 *    A tuple containing exactly those elements of `aTuple` for which
 *    `predicate` answered `true`.
 */
Method "filter_by_" is
[
	aTuple : tuple,
	predicate : [⊥, ⊥]→boolean
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop;
		If index ≤ end then
		[
			element ::= aTuple[index];
			If invoke predicate with <element, index> then
			[
				result := eject ↑result ++ <element>;
			];
			↑index++;
			Restart loop;
		];
	]();
	result;
] : tuple;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * 
 * Parameters:
 *    tupleType -
 *    predicate -
 * Returns:
 *    The most specific possible tuple type.
 */
Semantic restriction "filter_by_" is
[
	tupleType : tuple meta,
	predicate : […]→boolean's type
|
	Require: predicate accepts tupleType;
	if predicate's return type = true's type then
	[
		tupleType;
	]
	else
	[
		union ::= ∪ tupleType[1..|tupleType's leading types| + 1];
		sizes ::=
			if predicate's return type = false's type then [ 0's type; ]
			else [ [0..||tupleType||'s upper bound + 1); ];
		<<>, union…|sizes>;
	];
];

/**
 * Iteratively apply `accumulator` to the consecutive elements of `aTuple` in
 * order to transform and filter its elements into a new tuple. When
 * `accumulator` is invoked, it is passed a "keeper" function. The keeper
 * function may be invoked to "save" a particular value, i.e., a value that will
 * be copied into the output tuple. The keeper function will save at most one
 * value per element of `aTuple`, i.e., each time that `accumulator` is invoked,
 * it may invoke the keeper function at most one time. Answer the new tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    accumulator - A function that accepts 1) an element from `aTuple` and 2)
 *       a keeper function. The keeper function accepts an argument of the type
 *       that should be saved.
 * Returns:
 *    A tuple whose elements are those saved by the `accumulator`.
 */
Method "map and filter_by_" is
[
	aTuple : tuple,
	accumulator : [⊥, ⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop;
		If index ≤ end then
		[
			hasAlreadyKept : boolean := false;
			Invoke accumulator with
			<
				aTuple[index],
				[
					transformed : any
				|
					If ¬hasAlreadyKept then
					[
						result := eject ↑result ++ <transformed>;
						hasAlreadyKept := true;
					];
				]
			>;
			↑index++;
			Restart loop;
		];
	]();
	result;
] : tuple;

/**
 * Iteratively apply `accumulator` to the consecutive elements and indices of
 * `aTuple` in order to transform and filter its elements into a new tuple. When
 * `accumulator` is invoked, it is passed a "keeper" function. The keeper
 * function may be invoked to "save" a particular value, i.e., a value that will
 * be copied into the output tuple. The keeper function will save at most one
 * value per element of `aTuple`, i.e., each time that `accumulator` is invoked,
 * it may invoke the keeper function at most one time. Answer the new tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    accumulator - A function that accepts 1) an element from `aTuple`, 2) the
 *       index of that element, and 3) a keeper function. The keeper function
 *       accepts an argument of the type that should be saved.
 * Returns:
 *    A tuple whose elements are those saved by the `accumulator`.
 */
Method "map and filter_by_" is
[
	aTuple : tuple,
	accumulator : [⊥, ⊥, ⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop;
		If index ≤ end then
		[
			hasAlreadyKept : boolean := false;
			Invoke accumulator with
			<
				aTuple[index],
				index,
				[
					transformed : any
				|
					If ¬hasAlreadyKept then
					[
						result := eject ↑result ++ <transformed>;
						hasAlreadyKept := true;
					];
				]
			>;
			↑index++;
			Restart loop;
		];
	]();
	result;
] : tuple;

/**
 * Ensure that the function will accept all elements of the tuple and also an
 * appropriately typed keeper function.
 *
 * Parameters:
 *    tupleType -
 *    accumulator -
 * Returns:
 *    A tuple type with no leading types whose default type is the argument type
 *    of the keeper function and whose cardinality is
 *    `[0..||tupleType||'s upper bound + 1)`.
 */
Semantic restriction "map and filter_by_" is
[
	tupleType : tuple meta,
	accumulator : […]→⊤'s type
|
	Require: accumulator accepts tupleType;
	Require: accumulator's keeper is valid;
	If accumulator's return type ≠ ⊤ then
	[
		Reject parse, expected:
			"repeatedly applied function to have return type ⊤";
	];
	<
		<>,
		cast accumulator[2] into [ t : function meta | t[1]; ]…
		| [0..||tupleType||'s upper bound + 1)
	>;
];

/**
 * Compute and answer whether any of the elements of `aTuple` satisfies the
 * specified function. Do not examine more elements than necessary.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple and answers
 *       a boolean.
 * Returns:
 *    `true` if `predicate` answers `true` for any element of `aTuple`, `false`
 *    otherwise.
 */
Method "any of_satisfies_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	$body : boolean;
	For each aTuple do
	[
		element : any
	|
		If invoke predicate with <element> then
		[
			Exit body with true;
		];
	];
	false;
] : boolean;

/**
 * Compute and answer whether any of the elements (and indices) of `aTuple`
 * satisfy the specified function. Do not examine more elements than necessary.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts 1) an element of the tuple and 2) the
 *       index of that element.
 * Returns:
 *    `true` if `predicate` answers `true` for any element of `aTuple`, `false`
 *    otherwise.
 */
Method "any of_satisfies_" is
[
	aTuple : tuple,
	predicate : [⊥, ⊥]→boolean
|
	$body : boolean;
	For each aTuple do
	[
		element : any,
		index : natural number
	|
		If invoke predicate with <element, index> then
		[
			Exit body with true;
		];
	];
	false;
] : boolean;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * 
 * Parameters:
 *    tupleType -
 *    predicate -
 * Returns:
 *    The function's return type.
 */
Semantic restriction "any of_satisfies_" is
[
	tupleType : tuple meta,
	predicate : […]→boolean's type
|
	Require: predicate accepts tupleType;
	predicate's return type;
];

/**
 * Compute and answer whether each of the elements of `aTuple` satisfies the
 * specified function. Do not examine more elements than necessary.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple and answers
 *       a boolean.
 * Returns:
 *    `true` if `predicate` answers `true` for each element of `aTuple`, `false`
 *    otherwise.
 */
Method "each of_satisfies_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	$body : boolean;
	For each aTuple do
	[
		element : any
	|
		Unless invoke predicate with <element> then
		[
			Exit body with false;
		];
	];
	true;
] : boolean;

/**
 * Compute and answer whether each of the elements (and indices) of `aTuple`
 * satisfy the specified function. Do not examine more elements than necessary.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts 1) an element of the tuple and 2) the
 *       index of that element and answers a boolean.
 * Returns:
 *    `true` if `predicate` answers `true` for each element of `aTuple`, `false`
 *    otherwise.
 */
Method "each of_satisfies_" is
[
	aTuple : tuple,
	predicate : [⊥, ⊥]→boolean
|
	$body : boolean;
	For each aTuple do
	[
		element : any,
		index : natural number
	|
		Unless invoke predicate with <element, index> then
		[
			Exit body with false;
		];
	];
	true;
] : boolean;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * 
 * Parameters:
 *    tupleType -
 *    predicate -
 * Returns:
 *    The function's return type.
 */
Semantic restriction "each of_satisfies_" is
[
	tupleType : tuple meta,
	predicate : […]→boolean's type
|
	Require: predicate accepts tupleType;
	predicate's return type;
];

/**
 * Compute and answer the count of elements of `aTuple` that satisfy the given
 * predicate.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple and answers
 *       `true` if the element should be represented in the resulting count.
 * Returns:
 *    The number of elements of `aTuple` for which `predicate` answers `true`.
 */
Method "count of_where_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	|filter aTuple by predicate|;
] : whole number;

/**
 * Compute and answer the count of elements (and indices) of `aTuple` that
 * satisfy the given predicate.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts 1) an element of the tuple and 2) the
 *       index of that element and answers `true` if the element should be
 *       represented in the resulting count.
 * Returns:
 *    The number of elements of `aTuple` for which `predicate` answers `true`.
 */
Method "count of_where_" is
[
	aTuple : tuple,
	predicate : [⊥, ⊥]→boolean
|
	|filter aTuple by predicate|;
] : whole number;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * 
 * Parameters:
 *    tupleType -
 *    predicate -
 * Returns:
 *    `[0..||tupleType||'s upper bound + 1)`.
 */
Semantic restriction "count of_where_" is
[
	tupleType : tuple meta,
	predicate : […]→boolean's type
|
	Require: predicate accepts tupleType;
	[0..||tupleType||'s upper bound + 1);
];

/**
 * Answer a function that computes the zip of a tuple of tuples.
 * 
 * Returns:
 *    The requested function.
 */
Method "zip function" is
[
	[
		tuples : <tuple…|1..>
	|
		accumulator : <tuple…|> := <>;
		limit ::= min map tuples through [ aTuple : tuple | |aTuple|; ];
		From 1 to limit do
		[
			index : natural number
		|
			group : tuple := <>;
			For each tuples do
			[
				aTuple : tuple
			|
				group := eject ↑group ++ <aTuple[index]>;
			];
			accumulator := eject ↑accumulator ++ <group>;
		];
		accumulator;
	] : tuple;
] : [<tuple…|1..>]→tuple;

/**
 * Compute and answer the zip of the specified tuples. Given N input tuples, the
 * output is the tuple whose i-th element contains the i-th element from each
 * consecutive input tuple. The size of the output equals to the smallest size
 * of the inputs. Each of the output's tuples has length equal to the number of
 * inputs.
 * 
 * Parameters:
 *    tuples - A tuple of tuples.
 * Returns:
 *    The zip of the input tuples.
 */
Method "zip_" is zip function;

/**
 * Compute and answer the zip of the specified tuples. Given N input tuples, the
 * output is the tuple whose i-th element contains the i-th element from each
 * consecutive input tuple. The size of the output equals to the smallest size
 * of the inputs. Each of the output's tuples has length equal to the number of
 * inputs.
 * 
 * Parameters:
 *    tuples - A tuple of tuples.
 * Returns:
 *    The zip of the input tuples.
 */
Method "«_‡zip»" is zip function;

/* Don't parse `«_‡zip»` recursively. */
Grammatical restriction {"«_‡zip»"} is <{"«_‡zip»"}>;

/**
 * Answer the semantic restriction function for zipping tuples.
 * 
 * Returns:
 *    The semantic restriction function.
 */
Method "zip semantic restriction" is
[
	[
		tuplesType : <tuple…|1..>'s type
	|
		if |tuplesType| = 1 then
		[
			(zip tuplesType's instance)'s type;
		]
		else
		[
			types ::= cast tuplesType[1..relevant |tuplesType|]
				into [ t : <tuple meta…|1..> | t; ];
			lower ::=
				min map types through
				[
					tupleType : tuple meta
				|
					||tupleType||'s lower bound;
				];
			upper ::=
				min map types through
				[
					tupleType : tuple meta
				|
					||tupleType||'s upper bound;
				];
			limit ::=
				max map types through
				[
					tupleType : tuple meta
				|
					|tupleType's leading types| + 1;
				];
			resultTypes : <tuple meta…|> := <>;
			From 1 to limit do
			[
				index : natural number
			|
				zipped : tuple of any meta := <>;
				For each types do
				[
					tupleType : tuple meta
				|
					zipped := eject ↑zipped ++ <tupleType[index]>;
				];
				nonempty ::= cast zipped
					into [ t : <any meta…|1..> | t; ];
				zippedType ::=
					<nonempty[1..|nonempty| - 1], nonempty[|nonempty|]…
						| ||tuplesType||>;
				resultTypes := eject ↑resultTypes ++ <zippedType>;
			];
			nonempty ::= cast resultTypes into [ t : <tuple meta…|1..> | t; ];
			resultSizes ::= [lower..upper + 1);
			<nonempty[1..|nonempty| - 1], nonempty[|nonempty|]… | resultSizes>;
		];
	] : type;
] : [<tuple…|1..>'s type]→type;

/**
 * Compute the resulting tuple type of a zip.
 * 
 * Parameters:
 *    tupleType - A tuple type whose default type is `tuple`.
 * Returns:
 *    The strongest possible tuple type.
 */
Semantic restriction "zip_" is zip semantic restriction;

/**
 * Compute the resulting tuple type of a zip.
 * 
 * Parameters:
 *    tupleType - A tuple type whose default type is `tuple`.
 * Returns:
 *    The strongest possible tuple type.
 */
Semantic restriction "«_‡zip»" is zip semantic restriction;

/**
 * Compute and answer the index of the first element of `aTuple` that satisfies
 * the specified predicate.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple.
 * Returns:
 *    The index of the first satisfactory element, or 0 if no element satisfied
 *    the predicate.
 */
Method "first index of_where_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	$body : natural number;
	From 1 to |aTuple| do
	[
		index : natural number
	|
		If invoke predicate with <aTuple[index]> then
		[
			Exit body with index;
		];
	];
	0;
] : whole number;

/**
 * Ensure that the function will accept all elements of the tuple.
 * 
 * Parameters:
 *    tupleType -
 *    predicate -
 * Returns:
 *    `[0..||tupleType||'s upper bound + 1)`.
 */
Semantic restriction "first index of_where_" is
[
	tupleType : tuple meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts tupleType;
	[0..||tupleType||'s upper bound + 1);
];

/**
 * Compute and answer the index of the last element of `aTuple` that satisfies
 * the specified predicate.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple.
 * Returns:
 *    The index of the last satisfactory element, or 0 if no element satisfied
 *    the predicate.
 */
Method "last index of_where_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	$body : natural number;
	From |aTuple| to 1 by -1 do
	[
		index : natural number
	|
		If invoke predicate with <aTuple[index]> then
		[
			Exit body with index;
		];
	];
	0;
] : whole number;

/**
 * Ensure that the function will accept all elements of the tuple.
 * 
 * Parameters:
 *    tupleType -
 *    predicate -
 * Returns:
 *    `[0..||tupleType||'s upper bound + 1)`.
 */
Semantic restriction "last index of_where_" is
[
	tupleType : tuple meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts tupleType;
	[0..||tupleType||'s upper bound + 1);
];

/**
 * Construct and answer a tuple whose elements are each `value`.
 * 
 * Parameters:
 *    count - The number of elements in the resulting tuple.
 *    value - The repeated value.
 * Returns:
 *    A tuple containing `count` occurrences of `value`.
 */
Method "_of_" is
[
	count : whole number,
	value : any
|
	accumulator : tuple := <>;
	Repeat
	[
		accumulator := eject ↑accumulator ++ <value>;
	]
	count times;
	accumulator;
];

/**
 * Strengthen `_of_`.
 * 
 * Parameters:
 *    countType -
 *    valueType -
 * Returns:
 *    The strongest available tuple type.
 */
Semantic restriction "_of_" is
[
	countType : whole number's type,
	valueType : any meta
|
	if |countType| = 1 ∧ [ |valueType| = 1; ] then
	[
		(countType's instance of (valueType's instance))'s type;
	]
	else
	[
		<<>, valueType…|countType>;
	];
];

/**
 * Is `value` an element of `aTuple`?
 * 
 * Parameters:
 *    value - An arbitrary value.
 *    aTuple -  A tuple.
 * Returns:
 *    `true` if `value` is an element of `aTuple`, `false` otherwise.
 */
Method "_∈_" is
[
	value : any,
	aTuple : tuple
|
	any of aTuple satisfies [ element : any | element = value; ];
] : boolean;

/**
 * Strength `_∈_`.
 * 
 * Parameters:
 *    valueType -
 *    mapType -
 * Returns:
 *    The strongest possible boolean type.
 */
Semantic restriction "_∈_" is
[
	valueType : any meta,
	tupleType : tuple meta
|
	if |valueType| = 1 ∧ [ |tupleType| = 1; ] then
	[
		(valueType's instance ∈ tupleType's instance)'s type;
	]
	else if [ valueType ∩ (∪ tupleType[1..relevant |tupleType|]) = ⊥; ] then
	[
		false's type;
	]
	else
	[
		/* Can't strengthen. */
		⊤;
	];
];
