/*
 * Tuples.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Tuples"
Versions
	"dev"
Extends
	"Collections",
	"Early Tuples"
Uses
	"Bootstrap",
	"Control Structures",
	"Early Functions",
	"Early Maps",
	"Early Types",
	"Enumeration Support",
	"Literals",
	"Logic",
	"Math",
	"Variables"
Names
	"count for_",
	"distinct_",
	"first index of_where_",
	"group_by_",
	"last index of_where_",
	"left fold_through_",
	"right fold_through_",
	"split_after_",
	"split_before_",
	"stripe_at_",
	"zip_",
	"_of_",
	"_to_",
	"«_‡zip»"
Body

/**
 * Is the specified tuple empty?
 *
 * Parameters:
 *    aTuple - A tuple.
 * Returns:
 *    `true` if the argument is empty, `false` otherwise.
 */
Method "_is empty" is
[
	aTuple : tuple
|
	|aTuple| = 0
];

/**
 * Iteratively apply `action` to each consecutive element of `aTuple`.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    action - A function that accepts the elements of the tuple.
 */
Method "For each_do_" is
[
	aTuple : tuple,
	action : [⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			Invoke action with <aTuple[index]>;
			↑index++;
			Restart loop
		];
	]();
] : ⊤;

/**
 * Iteratively apply `action` to each consecutive element of `aTuple`.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    action - A function that accepts 1) an element of the tuple and 2) the
 *       index of that element.
 */
Method "For each_do_" is
[
	aTuple : tuple,
	action : [⊥, ⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			Invoke action with <aTuple[index], index>;
			↑index++;
			Restart loop
		];
	]();
] : ⊤;

/**
 * Helper method for semantic restrictions: If `action` does not accept the
 * type union of all element types of `tupleType` and their indices, then reject
 * the current parse.
 * 
 * Parameters:
 *    action - A function type whose first parameter must correspond to the
 *       type union of the element types of `tupleType` and whose second
 *       parameter, if provided, must correspond to `indices`.
 *    tupleType - A tuple type.
 */
Method "Require:_accepts_" is
[
	action : function meta,
	tupleType : tuple meta
|
	If ||action's parameters' type||'s lower bound < 1 then
	[
		Reject parse, expected:
			"repeatedly applied function to accept at least one argument"
	];
	union ::= ∪ tupleType[1..|tupleType's leading types| + 1];
	If action[1] ≠ ⊥ ∧ [ ¬union ⊆ action[1] ] then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all elements of the tuple ⊆ "
			++ primitive description of tupleType
			++ " (but it only accepts "
			++ primitive description of action[1]
			++ ")"
	];
	If ||action's parameters' type||'s lower bound = 2
		∧ [ action[2] ≠ ⊥
		∧ [ ¬[1..||tupleType||'s upper bound + 1) ⊆ action[2] ] ]
	then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all indices of the tuple ⊆ "
			++ primitive description of tupleType
			++ " (but it only accepts "
			++ primitive description of action[2]
			++ ")"
	];
] : ⊤;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * If the tuple is certainly nonempty and the function certainly does not
 * complete if applied, then answer ⊥.
 * 
 * Parameters:
 *    tupleType -
 *    action -
 * Returns:
 *    Either ⊤ or ⊥.
 */
Semantic restriction "For each_do_" is
[
	tupleType : tuple meta,
	action : function meta
|
	Require: action accepts tupleType;
	if ||tupleType||'s lower bound > 0 ∧ [ action's return type = ⊥ ] then
	[
		⊥
	]
	else
	[
		⊤
	]
];

/**
 * Iteratively apply `transformer` to each consecutive element of `aTuple`,
 * collecting the results into a new tuple (and preserving ordering of the
 * transformed elements). Answer this tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    transformer - A function that accepts the elements of the tuple.
 * Returns:
 *    A tuple of results of applications of `transformer` to the elements of
 *    `aTuple`.
 */
Method "map_through_" is
[
	aTuple : tuple,
	transformer : [⊥]→any
|
	index : natural number := 1;
	result : tuple := <>;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			result :=
				eject ↑result ++ <invoke transformer with <aTuple[index]>>;
			↑index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Iteratively apply `transformer` to each consecutive element of `aTuple`,
 * collecting the results into a new tuple (and preserving ordering of the
 * transformed elements). Answer this tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    transformer - A function that accepts 1) an element of the tuple and 2)
 *       the index of that element.
 * Returns:
 *    A tuple of results of applications of `transformer` to the elements and
 *    indices of `aTuple`.
 */
Method "map_through_" is
[
	aTuple : tuple,
	transformer : [⊥, ⊥]→any
|
	index : natural number := 1;
	result : tuple := <>;
	end ::= |aTuple|;
	[
		$loop;
		If index ≤ end then
		[
			result := eject ↑result
				++ <invoke transformer with <aTuple[index], index>>;
			↑index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * If the tuple is certainly nonempty, then the function cannot answer ⊥.
 * 
 * Parameters:
 *    tupleType -
 *    transformer -
 * Returns:
 *    A tuple type with no leading types whose default type is the return type
 *    of `transformer` and whose cardinality is the same as `tupleType`'s.
 */
Semantic restriction "map_through_" is
[
	tupleType : tuple meta,
	transformer : […]→any's type
|
	Require: transformer accepts tupleType;
	If ||tupleType||'s lower bound > 0 then
	[
		If transformer's return type = ⊥ then
		[
			Reject parse, expected:
				"repeatedly applied function to have a return type other than\
				\| ⊥"
		];
	];
	<<>, transformer's return type… | ||tupleType||>
];

/**
 * Iteratively apply `predicate` to each consecutive element of `aTuple`,
 * collecting those elements for which `predicate` answers `true` into a new
 * tuple (and preserving ordering). Answer the new tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple and answers
 *       `true` iff they should be accumulated into the output tuple.
 * Returns:
 *    A tuple containing exactly those elements of `aTuple` for which
 *    `predicate` answered `true`.
 */
Method "filter_by_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop;
		If index ≤ end then
		[
			element ::= aTuple[index];
			If invoke predicate with <element> then
			[
				result := eject ↑result ++ <element>;
			];
			↑index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Iteratively apply `predicate` to each consecutive element and index of
 * `aTuple`, collecting those elements for which `predicate` answers `true` into
 * a new tuple (and preserving ordering). Answer the new tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts 1) an element of the tuple and 2)
 *       the index of that element and which answers `true` iff the elements
 *       should be accumulated into the output tuple.
 * Returns:
 *    A tuple containing exactly those elements of `aTuple` for which
 *    `predicate` answered `true`.
 */
Method "filter_by_" is
[
	aTuple : tuple,
	predicate : [⊥, ⊥]→boolean
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop;
		If index ≤ end then
		[
			element ::= aTuple[index];
			If invoke predicate with <element, index> then
			[
				result := eject ↑result ++ <element>;
			];
			↑index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * 
 * Parameters:
 *    tupleType -
 *    predicate -
 * Returns:
 *    The most specific possible tuple type.
 */
Semantic restriction "filter_by_" is
[
	tupleType : tuple meta,
	predicate : […]→boolean's type
|
	Require: predicate accepts tupleType;
	if predicate's return type = true's type then
	[
		tupleType
	]
	else
	[
		union ::= ∪ tupleType[1..|tupleType's leading types| + 1];
		sizes ::=
			if predicate's return type = false's type then [ 0's type ]
			else [ [0..||tupleType||'s upper bound + 1) ];
		<<>, union…|sizes>
	]
];

/**
 * Iteratively apply `accumulator` to the consecutive elements of `aTuple` in
 * order to transform and filter its elements into a new tuple. When
 * `accumulator` is invoked, it is passed a "keeper" function. The keeper
 * function may be invoked to "save" a particular value, i.e., a value that will
 * be copied into the output tuple. The keeper function will save at most one
 * value per element of `aTuple`, i.e., each time that `accumulator` is invoked,
 * it may invoke the keeper function at most one time. Answer the new tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    accumulator - A function that accepts 1) an element from `aTuple` and 2)
 *       a keeper function. The keeper function accepts an argument of the type
 *       that should be saved.
 * Returns:
 *    A tuple whose elements are those saved by the `accumulator`.
 */
Method "map and filter_by_" is
[
	aTuple : tuple,
	accumulator : [⊥, ⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop;
		If index ≤ end then
		[
			hasAlreadyKept : boolean := false;
			Invoke accumulator with
			<
				aTuple[index],
				[
					transformed : any
				|
					If ¬hasAlreadyKept then
					[
						result := eject ↑result ++ <transformed>;
						hasAlreadyKept := true;
					];
				]
			>;
			↑index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Iteratively apply `accumulator` to the consecutive elements and indices of
 * `aTuple` in order to transform and filter its elements into a new tuple. When
 * `accumulator` is invoked, it is passed a "keeper" function. The keeper
 * function may be invoked to "save" a particular value, i.e., a value that will
 * be copied into the output tuple. The keeper function will save at most one
 * value per element of `aTuple`, i.e., each time that `accumulator` is invoked,
 * it may invoke the keeper function at most one time. Answer the new tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    accumulator - A function that accepts 1) an element from `aTuple`, 2) the
 *       index of that element, and 3) a keeper function. The keeper function
 *       accepts an argument of the type that should be saved.
 * Returns:
 *    A tuple whose elements are those saved by the `accumulator`.
 */
Method "map and filter_by_" is
[
	aTuple : tuple,
	accumulator : [⊥, ⊥, ⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop;
		If index ≤ end then
		[
			hasAlreadyKept : boolean := false;
			Invoke accumulator with
			<
				aTuple[index],
				index,
				[
					transformed : any
				|
					If ¬hasAlreadyKept then
					[
						result := eject ↑result ++ <transformed>;
						hasAlreadyKept := true;
					];
				]
			>;
			↑index++;
			Restart loop
		];
	]();
	result
] : tuple;

/**
 * Ensure that the function will accept all elements of the tuple and also an
 * appropriately typed keeper function.
 *
 * Parameters:
 *    tupleType -
 *    accumulator -
 * Returns:
 *    A tuple type with no leading types whose default type is the argument type
 *    of the keeper function and whose cardinality is
 *    `[0..||tupleType||'s upper bound + 1)`.
 */
Semantic restriction "map and filter_by_" is
[
	tupleType : tuple meta,
	accumulator : […]→⊤'s type
|
	Require: accumulator accepts tupleType;
	Require: accumulator's keeper is valid;
	If accumulator's return type ≠ ⊤ then
	[
		Reject parse, expected:
			"repeatedly applied function to have return type ⊤"
	];
	<
		<>,
		cast accumulator[2] into [ t : function meta | t[1] ]…
		| [0..||tupleType||'s upper bound + 1)
	>
];

/**
 * Compute and answer whether any of the elements of `aTuple` satisfies the
 * specified function. Do not examine more elements than necessary.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple and answers
 *       a boolean.
 * Returns:
 *    `true` if `predicate` answers `true` for any element of `aTuple`, `false`
 *    otherwise.
 */
Method "any of_satisfies_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	$body : boolean;
	For each aTuple do
	[
		element : any
	|
		If invoke predicate with <element> then
		[
			Exit body with true
		];
	];
	false
] : boolean;

/**
 * Compute and answer whether any of the elements (and indices) of `aTuple`
 * satisfy the specified function. Do not examine more elements than necessary.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts 1) an element of the tuple and 2) the
 *       index of that element.
 * Returns:
 *    `true` if `predicate` answers `true` for any element of `aTuple`, `false`
 *    otherwise.
 */
Method "any of_satisfies_" is
[
	aTuple : tuple,
	predicate : [⊥, ⊥]→boolean
|
	$body : boolean;
	For each aTuple do
	[
		element : any,
		index : natural number
	|
		If invoke predicate with <element, index> then
		[
			Exit body with true
		];
	];
	false
] : boolean;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * 
 * Parameters:
 *    tupleType -
 *    predicate -
 * Returns:
 *    The function's return type.
 */
Semantic restriction "any of_satisfies_" is
[
	tupleType : tuple meta,
	predicate : […]→boolean's type
|
	Require: predicate accepts tupleType;
	predicate's return type
];

/**
 * Compute and answer whether each of the elements of `aTuple` satisfies the
 * specified function. Do not examine more elements than necessary.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple and answers
 *       a boolean.
 * Returns:
 *    `true` if `predicate` answers `true` for each element of `aTuple`, `false`
 *    otherwise.
 */
Method "each of_satisfies_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	$body : boolean;
	For each aTuple do
	[
		element : any
	|
		Unless invoke predicate with <element> then
		[
			Exit body with false
		];
	];
	true
] : boolean;

/**
 * Compute and answer whether each of the elements (and indices) of `aTuple`
 * satisfy the specified function. Do not examine more elements than necessary.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts 1) an element of the tuple and 2) the
 *       index of that element and answers a boolean.
 * Returns:
 *    `true` if `predicate` answers `true` for each element of `aTuple`, `false`
 *    otherwise.
 */
Method "each of_satisfies_" is
[
	aTuple : tuple,
	predicate : [⊥, ⊥]→boolean
|
	$body : boolean;
	For each aTuple do
	[
		element : any,
		index : natural number
	|
		Unless invoke predicate with <element, index> then
		[
			Exit body with false
		];
	];
	true
] : boolean;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * 
 * Parameters:
 *    tupleType -
 *    predicate -
 * Returns:
 *    The function's return type.
 */
Semantic restriction "each of_satisfies_" is
[
	tupleType : tuple meta,
	predicate : […]→boolean's type
|
	Require: predicate accepts tupleType;
	predicate's return type
];

/**
 * Compute and answer the count of elements of `aTuple` that satisfy the given
 * predicate.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple and answers
 *       `true` if the element should be represented in the resulting count.
 * Returns:
 *    The number of elements of `aTuple` for which `predicate` answers `true`.
 */
Method "count of_where_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	|filter aTuple by predicate|
] : whole number;

/**
 * Compute and answer the count of elements (and indices) of `aTuple` that
 * satisfy the given predicate.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts 1) an element of the tuple and 2) the
 *       index of that element and answers `true` if the element should be
 *       represented in the resulting count.
 * Returns:
 *    The number of elements of `aTuple` for which `predicate` answers `true`.
 */
Method "count of_where_" is
[
	aTuple : tuple,
	predicate : [⊥, ⊥]→boolean
|
	|filter aTuple by predicate|
] : whole number;

/**
 * Ensure that the function will accept all elements and indices of the tuple.
 * 
 * Parameters:
 *    tupleType -
 *    predicate -
 * Returns:
 *    `[0..||tupleType||'s upper bound + 1)`.
 */
Semantic restriction "count of_where_" is
[
	tupleType : tuple meta,
	predicate : […]→boolean's type
|
	Require: predicate accepts tupleType;
	[0..||tupleType||'s upper bound + 1)
];

/**
 * Compute and answer the distinct elements of `aTuple`, preserving order.
 * 
 * Parameters:
 *    aTuple - A tuple.
 * Returns:
 *    A tuple that contains only the distinct elements of `aTuple`, and in the
 *    order in which they were encountered.
 */
Method "distinct_" is
[
	aTuple : tuple
|
	seen : set := ∅;
	filter aTuple by
	[
		element : any
	|
		if ¬element ∈ seen then
		[
			seen := eject ↑seen + element;
			true
		]
		else
		[
			false
		]
	]
] : tuple;

/* No decent semantic restrictions can be written yet for `distinct_` and
 * `_→set`. An efficient algorithm involves construction and evaluation of a
 * chromatic polynomial over the type intersection graph of the tuple type's
 * element types (the vertices represent the element types and an edge between
 * two vertices indicates that the type intersection of the element types is ⊥).
 * We cannot conveniently build graphs yet. We need object types and objects
 * first.
 */

/**
 * Answer a function that computes the zip of a tuple of tuples.
 * 
 * Returns:
 *    The requested function.
 */
Method "zip function" is
[
	[
		tuples : <tuple…|1..>
	|
		accumulator : <tuple…|> := <>;
		limit ::= min map tuples through [ aTuple : tuple | |aTuple| ];
		From 1 to limit do
		[
			index : natural number
		|
			group : tuple := <>;
			For each tuples do
			[
				aTuple : tuple
			|
				group := eject ↑group ++ <aTuple[index]>;
			];
			accumulator := eject ↑accumulator ++ <group>;
		];
		accumulator
	] : tuple
] : [<tuple…|1..>]→tuple;

/**
 * Compute and answer the zip of the specified tuples. Given N input tuples, the
 * output is the tuple whose i-th element contains the i-th element from each
 * consecutive input tuple. The size of the output equals to the smallest size
 * of the inputs. Each of the output's tuples has length equal to the number of
 * inputs.
 * 
 * Parameters:
 *    tuples - A tuple of tuples.
 * Returns:
 *    The zip of the input tuples.
 */
Method "zip_" is zip function;

/**
 * Compute and answer the zip of the specified tuples. Given N input tuples, the
 * output is the tuple whose i-th element contains the i-th element from each
 * consecutive input tuple. The size of the output equals to the smallest size
 * of the inputs. Each of the output's tuples has length equal to the number of
 * inputs.
 * 
 * Parameters:
 *    tuples - A tuple of tuples.
 * Returns:
 *    The zip of the input tuples.
 */
Method "«_‡zip»" is zip function;

/* Don't parse `«_‡zip»` recursively. */
Grammatical restriction {"«_‡zip»"} is <{"«_‡zip»"}>;

/**
 * Answer the semantic restriction function for zipping tuples.
 * 
 * Returns:
 *    The semantic restriction function.
 */
Method "zip semantic restriction" is
[
	[
		tuplesType : <tuple…|1..>'s type
	|
		/* Leverage an instance type if possible. */
		if |tuplesType| = 1 then
		[
			(zip tuplesType's instance)'s type
		]
		else
		[
			types ::= cast tuplesType[1..relevant |tuplesType|]
				into [ t : <tuple meta…|1..> | t ];
			/* Find the smallest of the lower bounds of the inputs. */
			lower ::=
				min map types through
				[
					tupleType : tuple meta
				|
					||tupleType||'s lower bound
				];
			/* Find the smallest of the upper bounds of the inputs. */
			upper ::=
				min map types through
				[
					tupleType : tuple meta
				|
					||tupleType||'s upper bound
				];
			/* Find the maximum number of element types to scan. */
			limit ::=
				max map types through
				[
					tupleType : tuple meta
				|
					|tupleType's leading types| + 1
				];
			resultTypes : <tuple meta…|> := <>;
			/* Examine the relevant element types of all inputs. */
			From 1 to limit do
			[
				index : natural number
			|
				zipped : tuple of any meta := <>;
				/* Examine the `index`-th element type of each input. Accumulate
				 * the results into `zipped`.
				 */
				For each types do
				[
					tupleType : tuple meta
				|
					zipped := eject ↑zipped ++ <tupleType[index]>;
				];
				nonempty ::= cast zipped
					into [ t : <any meta…|1..> | t ];
				zippedType ::=
					<nonempty[1..|nonempty| - 1], nonempty[|nonempty|]…
						| ||tuplesType||>;
				resultTypes := eject ↑resultTypes ++ <zippedType>;
			];
			nonempty ::= cast resultTypes into [ t : <tuple meta…|1..> | t ];
			resultSizes ::= [lower..upper + 1);
			<nonempty[1..|nonempty| - 1], nonempty[|nonempty|]… | resultSizes>
		]
	] : type
] : [<tuple…|1..>'s type]→type;

/**
 * Compute the resulting tuple type of a zip.
 * 
 * Parameters:
 *    tupleType - A tuple type whose default type is `tuple`.
 * Returns:
 *    The strongest possible tuple type.
 */
Semantic restriction "zip_" is zip semantic restriction;

/**
 * Compute the resulting tuple type of a zip.
 * 
 * Parameters:
 *    tupleType - A tuple type whose default type is `tuple`.
 * Returns:
 *    The strongest possible tuple type.
 */
Semantic restriction "«_‡zip»" is zip semantic restriction;

/**
 * Reduce `aTuple` via the binary function, traversing the tuple from left to
 * right. Answer the result of the reduction.
 *
 * Parameters:
 *    aTuple - A nonempty tuple.
 *    transformer - A binary function whose second parameter type matches its
 *       return type. The first parameter type must be general enough to accept
 *       each element of `aTuple`.
 * Returns:
 *    The only element of `aTuple` if `aTuple` contains only one element.
 *    Otherwise, the result of iteratively applying `transformer` to 1) the
 *    left-to-right consecutive elements of `aTuple` and 2) the previous results
 *    of applying `transformer`.
 */
Method "left fold_through_" is
[
	aTuple : <any…|1..>,
	transformer : [⊥, ⊥]→any
|
	result : any := aTuple[1];
	From 2 to |aTuple| do
	[
		index : natural number
	|
		result := invoke transformer with <aTuple[index], eject ↑result>;
	];
	result
] : any;

/**
 * Left fold has the following requirements:
 *
 * - The function's first parameter must accept every element of the tuple
 *   except for the first (with which it will not be applied at this position).
 * - The function's second parameter must accept the tuple's first element and
 *   also every value producible by the function.
 *
 * Left fold answers either the tuple's first element or the value produced by
 * the final application of the function.
 * 
 * Parameters:
 *    tupleType -
 *    transformer -
 * Returns:
 *    The type union of the tuple's non-first element types and the function's
 *    return types.
 */
Semantic restriction "left fold_through_" is
[
	tupleType : <any…|1..>'s type,
	transformer : [⊥, ⊥]→any's type
|
	headType ::= tupleType[1];
	restType ::= if |tupleType's leading types| > 0
		then [ ∪ tupleType[2..|tupleType's leading types| + 1] ]
		else [ headType ];
	returnType ::= transformer's return type;
	finalType ::= headType ∪ returnType;
	If transformer[1] ≠ ⊥ ∧ [ ¬restType ⊆ transformer[1] ] then
	[
		Reject parse, expected:
			"repeatedly applied function's first parameter to accept all\
			\| non-first elements of the tuple ⊆ "
			++ primitive description of restType
			++ " (but it only accepts "
			++ primitive description of transformer[1]
			++ ")"
	];
	If transformer[2] ≠ ⊥ ∧ [ ¬finalType ⊆ transformer[2] ] then
	[
		Reject parse, expected:
			"repeatedly applied function's second parameter to accept the\
			\| type union ⊆ "
			++ primitive description of finalType
			++ " of the first element ⊆ "
			++ primitive description of headType
			++ " of the tuple and its own return type ⊆ "
			++ primitive description of returnType
			++ " (but it only accepts "
			++ primitive description of transformer[2]
			++ ")"
	];
	finalType
];

/**
 * Reduce `aTuple` via the binary function, traversing the tuple from right to
 * left. Answer the result of the reduction.
 *
 * Parameters:
 *    aTuple - A nonempty tuple.
 *    transformer - A binary function whose second parameter type matches its
 *       return type. The first parameter type must be general enough to accept
 *       each element of `aTuple`.
 * Returns:
 *    The only element of `aTuple` if `aTuple` contains only one element.
 *    Otherwise, the result of iteratively applying `transformer` to 1) the
 *    right-to-left consecutive elements of `aTuple` and 2) the previous results
 *    of applying `transformer`.
 */
Method "right fold_through_" is
[
	aTuple : <any…|1..>,
	transformer : [⊥, ⊥]→any
|
	result : any := aTuple[|aTuple|];
	From |aTuple| - 1 to 1 by -1 do
	[
		index : natural number
	|
		result := invoke transformer with <aTuple[index], eject ↑result>;
	];
	result
] : any;

/**
 * Right fold has the following requirements:
 *
 * - The function's first parameter must accept every element of the tuple
 *   except for the last (with which it will not be applied at this position).
 * - The function's second parameter must accept the tuple's last element and
 *   also every value producible by the function.
 *
 * Right fold answers either the tuple's last element or the value produced by
 * the final application of the function.
 * 
 * Parameters:
 *    tupleType -
 *    transformer -
 * Returns:
 *    The type union of the tuple's non-last element types and the function's
 *    return types.
 */
Semantic restriction "right fold_through_" is
[
	tupleType : <any…|1..>'s type,
	transformer : [⊥, ⊥]→any's type
|
	sizes ::= ||tupleType||;

	lastIndexStart ::= 1 max relevant |tupleType|;
	lastIndexEnd ::= lastIndexStart
		max (sizes' upper bound min (|tupleType's leading types| + 1));
	lastType ::= ∪ tupleType[lastIndexStart..lastIndexEnd];
	restType ::= ∪ tupleType[1..lastIndexEnd - 1];
	returnType ::= transformer's return type;
	finalType ::= lastType ∪ returnType;
	If transformer[1] ≠ ⊥ ∧ [ ¬restType ⊆ transformer[1] ] then
	[
		Reject parse, expected:
			"repeatedly applied function's first parameter to accept all\
			\| non-last elements of the tuple ⊆ "
			++ primitive description of restType
			++ " (but it only accepts "
			++ primitive description of transformer[1]
			++ ")"
	];
	If transformer[2] ≠ ⊥ ∧ [ ¬finalType ⊆ transformer[2] ] then
	[
		Reject parse, expected:
			"repeatedly applied function's second parameter to accept the\
			\| type union ⊆ "
			++ primitive description of finalType
			++ " of the last element ⊆ "
			++ primitive description of lastType
			++ " of the tuple and its own return type ⊆ "
			++ primitive description of returnType
			++ " (but it only accepts "
			++ primitive description of transformer[2]
			++ ")"
	];
	finalType
];

/**
 * Compute and answer the index of the first element of `aTuple` that satisfies
 * the specified predicate.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple.
 * Returns:
 *    The index of the first satisfactory element, or 0 if no element satisfied
 *    the predicate.
 */
Method "first index of_where_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	$body : natural number;
	From 1 to |aTuple| do
	[
		index : natural number
	|
		If invoke predicate with <aTuple[index]> then
		[
			Exit body with index
		];
	];
	0
] : whole number;

/**
 * Ensure that the function will accept all elements of the tuple.
 * 
 * Parameters:
 *    tupleType -
 *    predicate -
 * Returns:
 *    `[0..||tupleType||'s upper bound + 1)`.
 */
Semantic restriction "first index of_where_" is
[
	tupleType : tuple meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts tupleType;
	[0..||tupleType||'s upper bound + 1)
];

/**
 * Compute and answer the index of the last element of `aTuple` that satisfies
 * the specified predicate.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple.
 * Returns:
 *    The index of the last satisfactory element, or 0 if no element satisfied
 *    the predicate.
 */
Method "last index of_where_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	$body : natural number;
	From |aTuple| to 1 by -1 do
	[
		index : natural number
	|
		If invoke predicate with <aTuple[index]> then
		[
			Exit body with index
		];
	];
	0
] : whole number;

/**
 * Ensure that the function will accept all elements of the tuple.
 * 
 * Parameters:
 *    tupleType -
 *    predicate -
 * Returns:
 *    `[0..||tupleType||'s upper bound + 1)`.
 */
Semantic restriction "last index of_where_" is
[
	tupleType : tuple meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts tupleType;
	[0..||tupleType||'s upper bound + 1)
];

/**
 * Construct and answer a tuple whose elements are each `value`.
 * 
 * Parameters:
 *    count - The number of elements in the resulting tuple.
 *    value - The repeated value.
 * Returns:
 *    A tuple containing `count` occurrences of `value`.
 */
Method "_of_" is
[
	count : whole number,
	value : any
|
	accumulator : tuple := <>;
	Repeat
	[
		accumulator := eject ↑accumulator ++ <value>;
	]
	count times;
	accumulator
];

/**
 * Strengthen `_of_`.
 * 
 * Parameters:
 *    countType -
 *    valueType -
 * Returns:
 *    The strongest available tuple type.
 */
Semantic restriction "_of_" is
[
	countType : whole number's type,
	valueType : any meta
|
	if |countType| = 1 ∧ [ |valueType| = 1 ] then
	[
		(countType's instance of (valueType's instance))'s type
	]
	else
	[
		<<>, valueType…|countType>
	]
];

/**
 * Construct and answer a tuple that contains the consecutive integers from
 * `start` (inclusive) to `end` (inclusive). If `start ≤ end`, then
 * `result[i] < result[i+1]`; otherwise, `result[i] > result[i+1]`.
 * 
 * Parameters:
 *    start - The first value of the resulting tuple.
 *    end - The last value of the resulting tuple.
 * Returns:
 *    The interval from `start` (inclusive) to `end` (inclusive).
 */
Method "_to_" is
[
	start : integer,
	end : integer
|
	accumulator : <integer…|> := <>;
	step ::= if start ≤ end then [ 1 ] else [ -1 ];
	From start to end by step do
	[
		value : integer
	|
		accumulator := eject ↑accumulator ++ <value>;
	];
	cast accumulator into [ t : <integer…|1..> | t ]
] : <integer…|1..>;

/**
 * Construct and answer the tuple type that best describes a particular interval
 * construction. Provide an instance when `start` and `end` are precisely known.
 * Leverage the uncertainty of `start` to produce good leading types when the
 * upper bound of the result's cardinality can be determined.
 * 
 * Parameters:
 *    start -
 *    end -
 * Returns:
 *    The strongest possible tuple type.
 */
Semantic restriction "_to_" is
[
	start : integer's type,
	end : integer's type
|
	/* If `start` and `end` are known precisely, then answer the instance type
	 * of the result.
	 */
	if |start| = 1 ∧ [ |end| = 1 ] then
	[
		(start's instance to end's instance)'s type
	]
	else
	[
		uncertainty ::= start's upper bound - start's lower bound;
		min : extended integer;
		max : extended integer;
		sizes : whole number's type;
		/* There are three cases: the interval is definitely ascending ... */
		if start's upper bound ≤ end's lower bound then
		[
			min := start's lower bound;
			max := end's upper bound;
			sizes := [0 max (end's lower bound - start's upper bound + 1)
				.. max - min + 2);
			if uncertainty is finite ∧ [ sizes' upper bound is finite ]
			then
			[
				finiteMin ::= cast min into [ t : integer | t ];
				finiteMax ::= cast max into [ t : integer | t ];
				types ::=
					map finiteMin to finiteMax through
					[
						x : integer
					|
						[x .. (finiteMax min (x + uncertainty)) + 1)
					];
				<types[1..|types| - 1], types[|types|]…|sizes>
			]
			else
			[
				<<>, [min..max + 1)…|sizes>
			]
		]
		/* ... the interval is definitely descending ... */
		else if [ start's lower bound ≥ end's upper bound ] then
		[
			min := end's lower bound;
			max := start's upper bound;
			sizes := [0 max (start's lower bound - end's upper bound + 1)
				.. max - min + 2);
			if uncertainty is finite ∧ [ sizes' upper bound is finite ]
			then
			[
				finiteMin ::= cast min into [ t : integer | t ];
				finiteMax ::= cast max into [ t : integer | t ];
				types ::=
					map finiteMax to finiteMin through
					[
						x : integer
					|
						[finiteMin max (x - uncertainty) .. x + 1)
					];
				<types[1..|types| - 1], types[|types|]…|sizes>
			]
			else
			[
				<<>, [min..max + 1)…|sizes>
			]
		]
		/* ... or the interval's directionality is unknown. In this last case,
		 * the best that we can do is to produce the type union of the ranges
		 * and answer a tuple type with this default type.
		 */
		else
		[
			upper ::= |(end's upper bound - start's lower bound)
				max (start's upper bound - end's lower bound)|;
			<<>, start ∪ end…|[1..upper + 2)>
		]
	]
];

/**
 * Construct and answer a string that contains the consecutive characters from
 * `start` (inclusive) to `end` (inclusive). If
 * `start→code point ≤ end→code point`, then
 * `result[i]→code point < result[i+1]→code point`; otherwise,
 * `result[i]→code point > result[i+1]→code point`.
 * 
 * Parameters:
 *    start - The first value of the resulting tuple.
 *    end - The last value of the resulting tuple.
 * Returns:
 *    The interval from `start` (inclusive) to `end` (inclusive).
 */
Method "_to_" is
[
	start : character,
	end : character
|
	accumulator : string := <>;
	startCodePoint ::= start→code point;
	endCodePoint ::= end→code point;
	step ::= if startCodePoint ≤ endCodePoint then [ 1 ] else [ -1 ];
	From startCodePoint to endCodePoint by step do
	[
		value : code point
	|
		accumulator := eject ↑accumulator ++ <value→character>;
	];
	cast accumulator into [ t : <character…|1..> | t ]
] : <character…|1..>;

/**
 * `_to_` for characters can only be strengthened when both arguments are
 * enumerations.
 * 
 * Parameters:
 *    startType -
 *    endType -
 * Returns:
 *    The strongest possible tuple type for the given argument types.
 */
Semantic restriction "_to_" is
[
	startType : character's type,
	endType : character's type
|
	if |startType| = 1 ∧ [ |endType| = 1 ] then
	[
		(startType's instance to endType's instance)'s type
	]
	/* TODO: A case can be added for non-instance enumerations. This isn't
	 * expected to be very useful, so it's low priority.
	 */
	else
	[
		/* Can't strengthen. */
		⊤
	]
];

/**
 * Is `value` an element of `aTuple`?
 * 
 * Parameters:
 *    value - An arbitrary value.
 *    aTuple -  A tuple.
 * Returns:
 *    `true` if `value` is an element of `aTuple`, `false` otherwise.
 */
Method "_∈_" is
[
	value : any,
	aTuple : tuple
|
	any of aTuple satisfies [ element : any | element = value ]
] : boolean;

/**
 * Strength `_∈_`.
 * 
 * Parameters:
 *    valueType -
 *    mapType -
 * Returns:
 *    The strongest possible boolean type.
 */
Semantic restriction "_∈_" is
[
	valueType : any meta,
	tupleType : tuple meta
|
	if |valueType| = 1 ∧ [ |tupleType| = 1 ] then
	[
		(valueType's instance ∈ tupleType's instance)'s type
	]
	else if [ valueType ∩ (∪ tupleType[1..relevant |tupleType|]) = ⊥ ] then
	[
		false's type
	]
	else
	[
		/* Can't strengthen. */
		⊤
	]
];

/**
 * Split a `aTuple` into two tuples between `pivot` and `pivot + 1` and answer
 * a 2-tuple containing the results.
 *
 * Parameters:
 *    aTuple - A tuple.
 *    pivot - The index (inclusive) at which to split `aTuple`.
 * Returns:
 *    A 2-tuple. The first tuple contains the first `pivot` elements of
 *    `aTuple`. The second tuple contains the remaining elements of `aTuple`.
 */
Method "split_after_" is
[
	aTuple : tuple,
	pivot : whole number
|
	<aTuple[..pivot], aTuple[pivot + 1..]>
] : <tuple…|2>;

/**
 * Construct the strongest possible 2-tuple type for the given arguments. The
 * first element type is a tuple type whose elements are drawn from the original
 * tuple type. The second element type is a tuple type whose element type are
 * smears (i.e., type unions) of the trailing element types of the original
 * tuple type. The pivot is used to determine the cardinality ranges of the
 * these element types.
 * 
 * Parameters:
 *    tupleType - A tuple type.
 *    pivot - The range of possible values of the actual pivot.
 * Returns:
 *    The strongest possible 2-tuple type for the given arguments.
 */
Semantic restriction "split_after_" is
[
	tupleType : tuple meta,
	pivot : whole number's type
|
	If pivot's lower bound > ||tupleType||'s upper bound then
	[
		Reject parse, expected:
			"pivot ∈ "
			++ primitive description of pivot
			++ " ever to be valid for the tuple ∈ "
			++ primitive description of tupleType
	];
	if |tupleType| = 1 ∧ [ |pivot| = 1 ] then
	[
		(split tupleType's instance after pivot's instance)'s type
	]
	else
	[
		pivotPlusOne ::= cast pivot + 1's type
			into [ t : natural number's type | t ];
		firstType ::= tuple type of tupleType[1's type..pivot];
		secondType ::= tuple type of tupleType[pivotPlusOne..||tupleType||];
		<firstType, secondType…|2>
	]
];

/**
 * Split a `aTuple` into two tuples between `pivot - 1` and `pivot` and answer
 * a 2-tuple containing the results.
 *
 * Parameters:
 *    aTuple - A tuple.
 *    pivot - The index (exclusive) at which to split `aTuple`.
 * Returns:
 *    A 2-tuple. The first tuple contains the first `pivot - 1` elements of
 *    `aTuple`. The second tuple contains the remaining elements of `aTuple`.
 */
Method "split_before_" is
[
	aTuple : tuple,
	pivot : natural number
|
	<aTuple[..pivot - 1], aTuple[pivot..]>
] : <tuple…|2>;

/**
 * Construct the strongest possible 2-tuple type for the given arguments. The
 * first element type is a tuple type whose elements are drawn from the original
 * tuple type. The second element type is a tuple type whose element type are
 * smears (i.e., type unions) of the trailing element types of the original
 * tuple type. The pivot is used to determine the cardinality ranges of the
 * these element types.
 * 
 * Parameters:
 *    tupleType - A tuple type.
 *    pivot - The range of possible values of the actual pivot.
 * Returns:
 *    The strongest possible 2-tuple type for the given arguments.
 */
Semantic restriction "split_before_" is
[
	tupleType : tuple meta,
	pivot : natural number's type
|
	If pivot's lower bound > ||tupleType||'s upper bound + 1 then
	[
		Reject parse, expected:
			"pivot ∈ "
			++ primitive description of pivot
			++ " ever to be valid for the tuple ∈ "
			++ primitive description of tupleType
	];
	if |tupleType| = 1 ∧ [ |pivot| = 1 ] then
	[
		(split tupleType's instance before pivot's instance)'s type
	]
	else
	[
		pivotMinusOne ::= cast pivot - 1's type
			into [ t : whole number's type | t ];
		firstType ::= tuple type of tupleType[1's type..pivotMinusOne];
		secondType ::= tuple type of tupleType[pivot..||tupleType||];
		<firstType, secondType…|2>
	]
];

/**
 * Split a `aTuple` into two tuples.
 *
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts each element of the tuple. It must
 *       answer `true` when the pivot position has been reached. The function
 *       will not be applied again answer it has answered `true`.
 * Returns:
 *    A 2-tuple. The first tuple contains the elements of `aTuple` to which
 *    `predicate` was applied. The second tuple contains the remaining elements
 *    of `aTuple`.
 */
Method "split_before_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	firstIndex ::= first index of aTuple where predicate;
	splitIndex ::=
		if firstIndex = 0
		then [ |aTuple| ]
		else [ cast firstIndex - 1 into [ t : whole number | t ] ];
	split aTuple after splitIndex
] : <tuple…|2>;

/**
 * Construct the strongest possible 2-tuple type for the given arguments. The
 * first element type is a tuple type whose elements are drawn from the original
 * tuple type. The second element type is a tuple type whose element type are
 * smears (i.e., type unions) of the trailing element types of the original
 * tuple type. The cardinality of each tuple varies from 0 to the upper bound of
 * `tupleType`'s cardinality range.
 * 
 * Parameters:
 *    tupleType - A tuple type.
 *    predicate - A function type.
 * Returns:
 *    The strongest possible 2-tuple type for the given arguments.
 */
Semantic restriction "split_before_" is
[
	tupleType : tuple meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts tupleType;
	returnType ::= predicate's return type;
	if ||tupleType||'s upper bound = 0 then
	[
		<<>, <>>'s type
	]
	else
	[
		sizes ::= ||tupleType||;
		upper ::= [0..sizes' upper bound + 1);
		firstType ::=
			<tupleType's leading types, tupleType's default type…|upper>;
		secondType ::=
			tuple type of tupleType[[1..sizes' upper bound + 1)..upper];
		<firstType, secondType…|2>
	]
];

/**
 * Compute and answer the specified stripe of `aTuple`.
 * 
 * Parameters:
 *    aTuple - A tuple of non-empty tuples.
 *    index - The stripe index.
 * Returns:
 *    A tuple comprising the `index`-th elements of each element of `aTuple`.
 */
Method "stripe_at_" is
[
	aTuple : <<any…|1..>…|>,
	index : natural number
|
	map aTuple through [ inner : <any…|1..> | inner[index] ]
] : tuple;

/**
 * Strengthen `stripe_at_`.
 * 
 * Parameters:
 *    tupleType -
 *    index -
 * Returns:
 *    The strongest possible tuple type for the given argument types.
 */
Semantic restriction "stripe_at_" is
[
	tupleType : <<any…|1..>…|>'s type,
	index : natural number's type
|
	if |tupleType| = 1  ∧ [ |index| = 1 ] then
	[
		(stripe tupleType's instance at index's instance)'s type
	]
	else
	[
		uncertainty ::= cast index's upper bound - index's lower bound
			into [ t : whole number | t ];
		stripeTypes : <any meta…|> := <>;
		From 1 to |tupleType's leading types| + 1 do
		[
			typeIndex : natural number
		|
			innerType ::= tupleType[typeIndex];
			If index's lower bound > ||innerType||'s upper bound then
			[
				Reject parse, expected:
					"a subscript ("
					++ primitive description of index's lower bound
					++ " ≤ theSubscript ≤ "
					++ primitive description of index's upper bound
					++ ") that could ever be valid ("
					++ primitive description of ||innerType||'s lower bound
					++ " ≤ |theTuple| ≤ "
					++ primitive description of ||innerType||'s upper bound
					++ ")"
			];
			union : any meta := ⊥;
			limit ::= uncertainty min (|innerType's leading types| + 1);
			From 0 to limit do
			[
				delta : whole number
			|
				innerIndex ::= cast index's lower bound + delta
					into [ t : natural number | t ];
				union := eject ↑union ∪ innerType[innerIndex];
			];
			stripeTypes := eject ↑stripeTypes ++ <union>;
		];
		nonemptyTypes ::= cast stripeTypes into [ t : <any meta…|1..> | t ];
		<nonemptyTypes[1..|nonemptyTypes| - 1], nonemptyTypes[|nonemptyTypes|]…
			| ||tupleType||>
	]
];

/**
 * Tuple element replacement affects only those elements whose subscripts are
 * instances of `indexType`. If multiple subscripts could be affected, then
 * update the element types via type union with `valueType`. If only a single
 * subscript could be affected, then simply replace the corresponding element
 * type with `valueType`. Leverage instance types if possible.
 * 
 * Parameters:
 *    tupleType -
 *    indexType -
 *    valueType -
 * Returns:
 *    The strongest possible tuple type for the given argument types.
 */
Semantic restriction "_[_]→_" is
[
	tupleType : tuple meta,
	indexType : natural number's type,
	valueType : any meta
|
	$body : tuple meta;
	indexLower ::= cast indexType's lower bound into
		[ t : natural number | t ];
	If indexLower > ||tupleType||'s upper bound then
	[
		Reject parse, expected:
			"a subscript ("
			++ primitive description of indexType's lower bound
			++ " ≤ theSubscript ≤ "
			++ primitive description of indexType's upper bound
			++ ") that could ever be valid ("
			++ primitive description of ||tupleType||'s lower bound
			++ " ≤ |theTuple| ≤ "
			++ primitive description of ||tupleType||'s upper bound
			++ ")"
	];
	/* Use instance types if possible. */
	If {|tupleType|, |indexType|, |valueType|} = {1} then
	[
		aTuple ::= tupleType's instance;
		index ::= indexType's instance;
		value ::= valueType's instance;
		Exit body with (aTuple[index]→value)'s type
	];
	indexUpper ::= indexType's upper bound;
	leadingTypes : <any meta…|> := tupleType's leading types;
	defaultType : any meta := tupleType's default type;
	/* Update any leading types possibly affected by `index`. */
	If indexLower ≤ |leadingTypes| then
	[
		limit ::= indexUpper min |leadingTypes|;
		From indexLower to limit do
		[
			leadingIndex : natural number
		|
			original ::= leadingTypes[leadingIndex];
			/* If only possible element is affected (because the lower and upper
			 * bound of `index` are equal), then we can simply replace the
			 * element type with `valueType`. Otherwise we have to weaken the
			 * affected elements via type union with `valueType`.
			 */
			replacement ::= if |{indexLower, indexUpper}| = 1
				then [ valueType ]
				else [ original ∪ valueType ];
			newLeadingTypes ::= leadingTypes[leadingIndex]→replacement;
			leadingTypes := cast newLeadingTypes into [ t : <any meta…|> | t ];
		];
	];
	/* Extend the leading types. */
	If indexUpper > |leadingTypes| then
	[
		/* If the lower bound of `index` is greater than the number of leading
		 * types, i.e., the leading types are unaffected by this operation *and*
		 * there may be intervening element types between the last leading type
		 * and the first element type affected, then pad the leading types with
		 * the default type up to the lower bound (exclusive) of `index`.
		 */
		padCount ::= indexLower - |leadingTypes| - 1;
		If padCount > 0 then
		[
			count ::= cast padCount into [ t : natural number | t ];
			leadingTypes := eject ↑leadingTypes ++ count of defaultType;
		];
		/* If the upper bound of `index` is less than the maximum length of the
		 * tuple, then some elements of the result tuple may have the original
		 * default type. Extend the leading types to account for the new
		 * element.
		 */
		If indexUpper < ||tupleType||'s upper bound then
		[
			newType ::= if |{indexLower, indexUpper}| = 1
				then [ valueType ]
				else [ defaultType ∪ valueType ];
			delta ::= if indexLower ≤ |leadingTypes| then [ 0 ] else [ 1 ];
			count ::= cast indexUpper - (|leadingTypes| max indexLower)
				into [ t : whole number | t + delta ];
			leadingTypes := eject ↑leadingTypes ++ count of newType;
		]
		/* The upper bound of `index` exceeds the minimum length of the tuple,
		 * so just update the default type.
		 */
		else
		[
			defaultType := eject ↑defaultType ∪ valueType;
		];
	];
	<leadingTypes, defaultType… | ||tupleType||>
];

/**
 * Categorize the elements of `aTuple` via `decider`.
 *
 * Parameters:
 *    aTuple - The tuple to categorize.
 *    discriminator - A function that accepts each element of the set and
 *       answers a value that represents the group to which the element belongs.
 * Returns:
 *    A map whose keys describe groups and whose elements are the groups
 *    themselves, i.e., the tuples of elements that constitute the described
 *    group.
 */
Method "group_by_" is
[
	aTuple : tuple,
	discriminator : [⊥]→any
|
	groups : {any→tuple|} := {};
	For each aTuple do
	[
		element : any
	|
		key ::= invoke discriminator with <element>;
		group ::= groups[key] else [ <> ] ++ <element>;
		groups := eject ↑groups + key→group;
	];
	groups
] : map;

/**
 * Strengthen return type.
 *
 * Parameters:
 *    aTupleType - The set to categorize's type.
 *    discriminator - A function that accepts each element of the set and
 *       answers a value that represents the group to which the element belongs.
 * Returns:
 *    Most specific map type.
 */
Semantic restriction "group_by_" is
[
	aTupleType : tuple's type,
	discriminatorType : [⊥]→any's type
 |
 	Require: discriminatorType accepts aTupleType;
	 	tupleCardinality ::= ||aTupleType||;
	 	tupleUpperBound ::= tupleCardinality's upper bound;
	 	defaultType ::= ∪ aTupleType[1..|aTupleType's leading types| + 1];
		keyType ::= discriminatorType's return type;
		
	 	lowerBound ::= if tupleCardinality's lower bound = 0 then [0] else [1];
		upperBound ::= if tupleUpperBound > |keyType| 
			then [|keyType|]
			else [tupleUpperBound];
	
	 	valueType ::= <defaultType… | 1..tupleUpperBound>;
	
	 	{keyType→valueType | lowerBound..upperBound}
 ];
 
/**
 * Count the elements of a tuple.
 *
 * Parameters:
 *    aTuple - the tuple whose elements you will count
 * Returns:
 *    a map with keys that are the elements of the tuple that maps to the values
 *    that are the counts that each element occurs in the tuple.
 */
 Method "count for_" is
[
 	aTuple : tuple
 |
 	groups ::= group aTuple by [a: any | a];
 	map groups through [k : any, t : tuple | |t|]
] : map;
 
/**
 * Strengthen return type.
 *
 * Parameters:
 *    aTupleType - the tuple whose elements you will count
 * Returns:
 *    a map type with keys that are the elements of the tuple that maps to the 
 *    values that are the counts that each element occurs in the tuple.
 */
Semantic restriction "count for_" is
[
 	aTupleType : tuple's type
 |
 	if |aTupleType| = 1 then
 		[(count for aTupleType's instance)'s type]
 	else 
 	[
 	   keyType ::= ∪ aTupleType[1..|aTupleType's leading types| + 1];
 	   tupleCardinality ::= ||aTupleType||;
 	   lowerBound ::= if tupleCardinality's lower bound = 0 
 	     then [0] else [1];
 	   upperBound ::= tupleCardinality's upper bound;
 	   {keyType→whole number|lowerBound..upperBound}
	]
];

/**
 * Flatten a tuple of tuples one level 
 *
 * Parameters:
 *    aTupleOfTuples - a tuple of tuples to flatten.
 * Returns:
 *    a flattened tuple.
 */
Method "flatten_" is
[
 	aTupleOfTuples : <tuple…|>
 |
 	newTuple : tuple := <>;
 	For each aTupleOfTuples do [t : tuple | 
        newTuple := newTuple ++ t;
 	];
 	newTuple
]:tuple;

