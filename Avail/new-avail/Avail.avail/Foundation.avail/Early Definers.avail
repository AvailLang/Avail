/*
 * Early Definers.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Early Definers"
Versions
	"dev"
Uses
	"Bootstrap",
	"Early Literals"
Names
	"Private method_is_",
	"Public method_is_",
	"Public atom is_"
Body

/**
 * Define a new public method. The semantic restriction ensures that the method
 * is named in the current module's "Names" section. This should not be used to
 * extend existing methods.
 * 
 * Parameters:
 *    methodName - The name of the method.
 *    function - A new implementation of the method.
 */
Method "Public method_is_" is
[
	methodName : string,
	function : function
|
	Primitive 253 (failureCode : natural number);
	Invoke early failure function with <failureCode>;
] : ⊤;

/**
 * Ensure that the new method is introduced by the module's "Names" section.
 *
 * Parameters:
 *    methodName -
 *    function -
 * Returns:
 *    ⊤.
 */
Semantic restriction "Public method_is_" is
[
	nameType : string's type,
	functionType : function meta
|
	If |nameType| = 1 then
	[
		publicNames ::= current module's public names;
		methodName ::= nameType's instances→tuple[1];
		If methodName ∈ publicNames then
		[
			/* This is the happy path: do nothing. */
		]
		else
		[
			Invoke
			[
				name : string
			|
				messageTuple ::= concatenate <
					"public method \"",
					name,
					"\" to be included in the module's \"Names\" section">;
				Invoke
				[
					messageString : string
				|
					Reject parse, expected: messageString
				]
				with <messageTuple>;
			]
			with <methodName>;
		];
	];
	⊤
];

/**
 * Define a new private method. The semantic restriction ensures that the method
 * is not named in the module's "Names" section. This should not be used to
 * extend existing methods.
 * 
 * Parameters:
 *    methodName - The name of the method.
 *    function - A new implementation of the method.
 */
Public method "Private method_is_" is
[
	methodName : string,
	function : function
|
	Primitive 253 (failureCode : natural number);
	Invoke early failure function with <failureCode>;
] : ⊤;

/**
 * Ensure that the new method is not introduced by the module's "Names" section.
 *
 * Parameters:
 *    methodName -
 *    function -
 * Returns:
 *    ⊤.
 */
Semantic restriction "Private method_is_" is
[
	nameType : string's type,
	functionType : function meta
|
	If |nameType| = 1 then
	[
		publicNames ::= current module's public names;
		methodName ::= nameType's instances→tuple[1];
		If methodName ∈ publicNames then
		[
			Invoke
			[
				name : string
			|
				messageTuple ::= concatenate <
					"private method \"",
					name,
					"\" not to be included in the module's \"Names\" section">;
				Invoke
				[
					messageString : string
				|
					Reject parse, expected: messageString
				]
				with <messageTuple>;
			]
			with <methodName>;
		]
		else
		[
			/* This is the happy path: do nothing. */
		];
	];
	⊤
];

/**
 * Define a new public atom. The implementation does nothing, but the semantic
 * restriction ensures that the argument is indeed public.
 * 
 * Parameters:
 *    anAtom - An atom introduced by the current module.
 */
Public method "Public atom is_" is
[
	anAtom : atom
|
	/* No implementation required. */
];

/**
 * Ensure that the new atom is introduced by the module's "Names" section.
 *
 * Parameters:
 *    atomType -
 * Returns:
 *    ⊤.
 */
Semantic restriction "Public atom is_" is
[
	atomType : atom's type
|
	If |atomType| = 1 then
	[
		publicNames ::= current module's public names;
		atomName : string;
		Invoke
		[
			name : string
		|
			atomName := name;
		]
		with <atomType's instances→tuple[1]>;
		If atomName ∈ publicNames then
		[
			/* This is the happy path: do nothing. */
		]
		else
		[
			Invoke
			[
				name : string
			|
				messageTuple ::= concatenate <
					"public atom \"",
					name,
					"\" to be included in the module's \"Names\" section">;
				Invoke
				[
					messageString : string
				|
					Reject parse, expected: messageString
				]
				with <messageTuple>;
			]
			with <atomName>;
		];
	];
	⊤
];

/**
 * Define the indicated grammatical restrictions. Each element `e` of
 * `exclusions`, itself a set of method names, corresponds to an argument
 * position `n` of `methodName`. The compiler rejects parses of source text that
 * invoke methods named in `e` when they occur grammatically at argument
 * position `n` of an invocation of the method named by `methodName`.
 *
 * Note that "argument position" corresponds to a blank, not to a top-level
 * repeating sequence (indicated by guillemet notation).
 *
 * Parameters:
 *    methodsName - The name of the method which should be restricted.
 *    exclusions - A tuple of sets of method names. The method names in the
 *       `n`-th set are restricted from occurring grammatically at the `n`-th
 *       argument position of any invocation of the method named by
 *       `methodName`.
 */
Method "Grammatical restriction_is_" is
[
	methodName : string,
	exclusions : tuple of set of string
|
	Invoke
	[
		methodsToRestrict : set of string
	|
		Grammatical restriction methodsToRestrict is exclusions;
	]
	with <{methodName}>;
] : ⊤;
