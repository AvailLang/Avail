/*
 * Literals.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Literals"
Versions
	"dev"
Extends
	"Early Literals"
Uses
	"Assertions",
	"Bootstrap",
	"Early Control Structures",
	"Early Logic",
	"Early Math"
Names
	"{«_‡,»}",
	"{«_→_‡,»}"
Body

/**
 * If a lexical tuple is built only from expressions with statically well-known
 * runtime values, then answer the instance type of the tuple that contains
 * those statically known elements. This gives lexical tuples of literals and
 * statically well-known elements the same force as lexical literals, e.g.,
 * numbers and strings.
 *
 * Parameters:
 *    elements -
 * Returns:
 *    The most specific possible type of the lexical tuple, possibly an instance
 *    type.
 */
Semantic restriction "<«_‡,»>" is
[
	elements : tuple meta
|
	/* Since the argument is derived from a lexically constructed tuple, then
	 * the cardinality of the argument is guaranteed to be a fixed, finite
	 * value. Therefore asking for either the lower or upper bound would be
	 * equivalent.
	 */
	limit ::= |elements|'s upper bound;
	accumulator : tuple := <>;
	From 1 to limit do
	[
		index : natural number
	|
		cast elements[index] into
		[
			t : enumeration meta
		|
			instances ::= t's instances;
			Assert |instances| = 1;
			instance ::= instances→tuple[1];
			accumulator := concatenate <accumulator, <instance>>;
			true;
		]
		else
		[
			false;
		];
	];
	if |accumulator| = limit then
	[
		accumulator's type;
	]
	else
	[
		elements;
	];
];

/**
 * Strengthen the tuple subscript operation. The strongest available static type
 * is the type union of the elements within the slice indicated by the range of
 * the subscript. Forbid any access that could never be correct, i.e., the
 * minimum value of the subscript exceeds the maximum cardinality of the tuple.
 *
 * Parameters:
 *    aTuple -
 *    index -
 * Returns:
 *    The type union of the elements accessible by an actual subscript of the
 *    specified type.
 */
Semantic restriction "_[_]" is
[
	aTuple : tuple meta,
	index : natural number's type
|
	if |aTuple|'s upper bound ≤ index's lower bound then
	[
		messageTuple ::= concatenate <
			"a subscript (",
			primitive description of index's lower bound,
			" ≤ theSubscript ≤ ",
			primitive description of index's upper bound,
			") that could ever be valid (",
			primitive description of |aTuple|'s lower bound,
			" ≤ |theTuple| ≤ ",
			primitive description of |aTuple|'s upper bound,
			")">;
		message ::= cast messageTuple into [ t : string | t; ];
		Reject parse, expected: message;
	];
	union : type := ⊥;
	limit ::= cast |aTuple's leading types| + 1
		into [ t : natural number | t; ];
	startIndex ::= cast index's lower bound min limit
		into [ t : natural number | t; ];
	endIndex ::= index's upper bound min limit;
	From startIndex to endIndex do
	[
		i : natural number
	|
		union := union ∪ aTuple[i];
		true;
	];
	union;
];

/**
 * Construct and answer a set from the lexically specified expressions.
 *
 * Parameters:
 *    elements - A tuple, lexically constructed by the compiler, whose elements
 *       should be unique members of the answer.
 * Returns:
 *    The requested set.
 */
Method "{«_‡,»}" is
[
	elements : <<>, any…|natural number>
|
	elements→set;
] : set;

/**
 * If a lexical set is built only from expressions with statically well-known
 * runtime values, then answer the instance type of the set that contains
 * those statically known elements. This gives lexical sets of literals and
 * statically well-known elements the same force as lexical literals, e.g.,
 * numbers and strings.
 *
 * Parameters:
 *    elements -
 * Returns:
 *    The most specific possible type of the lexical set, possibly an instance
 *    type.
 */
Semantic restriction "{«_‡,»}" is
[
	elements : <<>, any…|natural number>'s type
|
	/* Since the argument is derived from a lexically constructed tuple, then
	 * the cardinality of the argument is guaranteed to be a fixed, finite
	 * value. Therefore asking for either the lower or upper bound would be
	 * equivalent.
	 */
	limit ::= |elements|'s upper bound;
	accumulator : tuple := <>;
	/* Check to see if the elements are instance types. */
	From 1 to limit do
	[
		index : natural number
	|
		element ::= elements[index];
		cast element into
		[
			t : enumeration meta
		|
			instances ::= t's instances;
			Assert |instances| = 1;
			instance ::= instances→tuple[1];
			accumulator := concatenate <accumulator, <instance>>;
			true;
		]
		else
		[
			false;
		];
	];
	/* If the elements were all instance types, then answer an instance type. */
	if |accumulator| = limit then
	[
		(accumulator→set)'s type;
	]
	/* Otherwise, the answer cannot be an instance type. Compute the most
	 * precise possible set type.
	 */
	else
	[
		/* Build a tuple of distinct types encountered during a traversal of
		 * `elements`. Two types are distinct in this sense if they have no
		 * common descendents more general than ⊥. This establishes a lower
		 * bound on the answer's cardinality requirement.
		 *
		 * Also note what types have been encountered along the way. At the end
		 * they will be put into a set to effect deduplication of exact type
		 * matches. This set establishes an upper bound on the answer's
		 * cardinality requirement.
		 */
		types : tuple of type := <elements[1]>;
		distinct : tuple of type := <elements[1]>;
		From 2 to limit do
		[
			outerIndex : natural number
		|
			element ::= elements[outerIndex];
			types := cast concatenate <types, <element>>
				into [ t : tuple of type | t; ];
			isDistinct : boolean := true;
			From 1 to |distinct| do
			[
				innerIndex : natural number
			|
				if ¬(element ∩ distinct[innerIndex] = ⊥) then
				[
					isDistinct := false;
					false;
				]
				else
				[
					true;
				];
			];
			if isDistinct then
			[
				distinct := cast concatenate <distinct, <element>> into
					[ t : tuple of type | t; ];
			];
			true;
		];
		typeSet ::= types→set;
		lower ::= |distinct|;
		upper ::= cast |typeSet| + 1 into [ i : natural number | i; ];
		{∪ types | [lower..upper)};
	];
];

/**
 * Construct and answer a map from the lexically specified key-value bindings.
 * 
 * Parameters:
 *    bindings - The key-value bindings that constitute the answer.
 * Returns:
 *    A map comprising the specified key-value bindings.
 */
Method "{«_→_‡,»}" is
[
	bindings : key-value tuple
|
	bindings→map;
] : map;

/**
 * If a lexical map is built only from expressions with statically well-known
 * runtime values, then answer the instance type of the map that contains
 * those statically known elements. This gives lexical maps of literals and
 * statically well-known elements the same force as lexical literals, e.g.,
 * numbers and strings.
 *
 * Parameters:
 *    elements -
 * Returns:
 *    The most specific possible type of the lexical set, possibly an instance
 *    type.
 */
Semantic restriction "{«_→_‡,»}" is
[
	bindings : key-value tuple's type
|
	/* Since the argument is derived from a lexically constructed tuple, then
	 * the cardinality of the argument is guaranteed to be a fixed, finite
	 * value. Therefore asking for either the lower or upper bound would be
	 * equivalent.
	 */
	limit ::= |bindings|'s upper bound;
	accumulator : <<>, <<>, any…|[2..2]>… |whole number> := <>;
	/* Check to see if keys and values are all instance types. */
	From 1 to limit do
	[
		index : natural number
	|
		binding ::= cast bindings[index] into [ t: tuple meta | t; ];
		cast binding[1] into
		[
			k : enumeration meta
		|
			instancesK ::= k's instances;
			Assert |instancesK| = 1;
			instanceK ::= instancesK→tuple[1];
			cast binding[2] into
			[
				v : enumeration meta
			|
				instancesV ::= v's instances;
				Assert |instancesV| = 1;
				instanceV ::= instancesV→tuple[1];
				accumulator :=
					cast concatenate <accumulator, <<instanceK, instanceV>>>
					into [ t : <<>, <<>, any…|[2..2]>… |whole number> | t; ];
				true;
			]
			else
			[
				false;
			];
		]
		else
		[
			false;
		];
	];
	/* If the keys and values were all instance types, then answer an instance
	 * type.
	 */
	if |accumulator| = limit then
	[
		(accumulator→map)'s type;
	]
	/* Otherwise, the answer cannot be an instance type. Compute the most
	 * precise possible map type.
	 */
	else
	[
		/* Build a tuple of distinct key types encountered during a traversal of
		 * `bindings`. Two key types are distinct in this sense if they have no
		 * common descendents more general than ⊥. This establishes a lower
		 * bound on the answer's cardinality requirement.
		 *
		 * Also note what key types have been encountered along the way. At the
		 * end they will be put into a set to effect deduplication of exact type
		 * matches. This set establishes an upper bound on the answer's
		 * cardinality requirement.
		 */
		firstBinding ::= cast bindings[1] into [ t : tuple meta | t; ];
		firstKeyType ::= firstBinding[1];
		distinct : tuple of type := <firstKeyType>;
		keyTypes : tuple of type := <firstKeyType>;
		valueTypes : tuple of type := <firstBinding[2]>;
		From 2 to limit do
		[
			outerIndex : natural number
		|
			binding ::= cast bindings[outerIndex] into [ t : tuple meta | t; ];
			keyType ::= binding[1];
			keyTypes := cast concatenate <keyTypes, <keyType>>
				into [ t : tuple of type | t; ];
			valueTypes := cast concatenate <valueTypes, <binding[2]>>
				into [ t : tuple of type | t; ];
			isDistinct : boolean := true;
			From 1 to |distinct| do
			[
				innerIndex : natural number
			|
				if ¬(keyType ∩ distinct[innerIndex] = ⊥) then
				[
					isDistinct := false;
					false;
				]
				else
				[
					true;
				];
			];
			if isDistinct then
			[
				distinct := cast concatenate <distinct, <keyType>>
					into [ t : tuple of type | t; ];
			];
			true;
		];
		keyTypeSet ::= keyTypes→set;
		lower ::= |distinct|;
		upper ::= cast |keyTypeSet| + 1 into [ i : natural number | i; ];
		{∪ keyTypes → ∪ valueTypes | [lower..upper)};
	];
];
