/*
 * Literals.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Literals"
Versions
	"dev"
Extends
	"Early Literals"
Uses
	"Bootstrap",
	"Early Control Structures",
	"Early Logic",
	"Early Math",
	"Enumeration Support",
	"Variables"
Names
	"{«_‡,»}",
	"{«_→_‡,»}"
Body

/**
 * If a lexical tuple is built only from expressions with statically well-known
 * runtime values, then answer the instance type of the tuple that contains
 * those statically known elements. This gives lexical tuples of literals and
 * statically well-known elements the same force as lexical literals, e.g.,
 * numbers and strings.
 *
 * Parameters:
 *    elements -
 * Returns:
 *    The most specific possible type of the lexical tuple, possibly an instance
 *    type.
 */
Semantic restriction "<«_‡,»>" is
[
	elements : tuple meta
|
	/* Since the argument is derived from a lexically constructed tuple, then
	 * the cardinality of the argument is guaranteed to be a fixed, finite
	 * value. Therefore asking for either the lower or upper bound would be
	 * equivalent.
	 */
	limit ::= ||elements||'s upper bound;
	accumulator : tuple := <>;
	From 1 to limit do
	[
		index : natural number
	|
		if |elements[index]| ≠ ∞ then
		[
			instance ::= elements[index]'s instance;
			/* Do not blithely construct a literal-force tuple if any of the
			 * instances are themselves types. This prevents expressions like
			 * `<elements[index]>` from asserting the type `<any>'s type` rather
			 * than `<any's type…|1>`, which frequently leads to (absurd)
			 * runtime type errors, e.g., if elements[index] has the static type
			 * [0..5], then the return type verification nybblecode would fail
			 * because `<[0..5]>` is not a subtype of `<any>`.
			 */
			if instance's type ⊆ type then
			[
				false;
			]
			else
			[
				accumulator := concatenate <eject ↑accumulator, <instance>>;
				true;
			];
		]
		else
		[
			false;
		];
	];
	if |accumulator| = limit then
	[
		accumulator's type;
	]
	else
	[
		elements;
	];
];

/**
 * Strengthen the tuple subscript operation. The strongest available static type
 * is the type union of the elements within the slice indicated by the range of
 * the subscript. Forbid any access that could never be correct, i.e., the
 * minimum value of the subscript exceeds the maximum cardinality of the tuple.
 *
 * Parameters:
 *    aTuple -
 *    index -
 * Returns:
 *    The type union of the elements accessible by an actual subscript of the
 *    specified type.
 */
Semantic restriction "_[_]" is
[
	aTupleType : tuple meta,
	index : natural number's type
|
	If ||aTupleType||'s upper bound < index's lower bound then
	[
		messageTuple ::= concatenate <
			"a subscript (",
			primitive description of index's lower bound,
			" ≤ theSubscript ≤ ",
			primitive description of index's upper bound,
			") that could ever be valid (",
			primitive description of ||aTupleType||'s lower bound,
			" ≤ |theTuple| ≤ ",
			primitive description of ||aTupleType||'s upper bound,
			")">;
		message ::= cast messageTuple into [ t : string | t; ];
		Reject parse, expected: message;
	];
	union : type := ⊥;
	limit ::= cast |aTupleType's leading types| + 1
		into [ t : natural number | t; ];
	startIndex ::= index's lower bound min limit;
	endIndex ::= index's upper bound min limit;
	From startIndex to endIndex do
	[
		i : natural number
	|
		union := union ∪ aTupleType[i];
		true;
	];
	union;
];

/**
 * Strengthen the tuple type subscript operation. The strongest available static
 * type is the instance type of the type union of the elements within the slice
 * indicated by the range of the subscript. Forbid any access that could never
 * be correct, i.e., the minimum value of the subscript exceeds the maximum
 * cardinality of the tuple.
 *
 * Parameters:
 *    aTuple -
 *    index -
 * Returns:
 *    The instance type of the type union of the elements accessible by an
 *    actual subscript of the specified type.
 */
Semantic restriction "_[_]" is
[
	aTupleMeta : tuple meta's type,
	index : natural number's type
|
	aTupleType ::= aTupleMeta's instance;
	If ||aTupleType||'s upper bound < index's lower bound then
	[
		messageTuple ::= concatenate <
			"a subscript (",
			primitive description of index's lower bound,
			" ≤ theSubscript ≤ ",
			primitive description of index's upper bound,
			") that could ever be valid (",
			primitive description of ||aTupleType||'s lower bound,
			" ≤ |theTuple| ≤ ",
			primitive description of ||aTupleType||'s upper bound,
			")">;
		message ::= cast messageTuple into [ t : string | t; ];
		Reject parse, expected: message;
	];
	union : type := ⊥;
	limit ::= cast |aTupleType's leading types| + 1
		into [ t : natural number | t; ];
	startIndex ::= index's lower bound min limit;
	endIndex ::= index's upper bound min limit;
	From startIndex to endIndex do
	[
		i : natural number
	|
		union := union ∪ aTupleType[i];
		true;
	];
	union's type;
];

/**
 * Construct and answer a set from the lexically specified expressions.
 *
 * Parameters:
 *    elements - A tuple, lexically constructed by the compiler, whose elements
 *       should be unique members of the answer.
 * Returns:
 *    The requested set.
 */
Method "{«_‡,»}" is
[
	elements : <<>, any…|natural number>
|
	elements→set;
] : set;

/* Disambiguate `∪_` and `∪_[_.._]` by forbidding `_[_.._]` as the only argument
 * of the former.
 */
Invoke
[
	cast ::= [ t : {string|whole number} | t; ];
	names ::= cast <"∪_">→set into cast;
	exclusions ::= cast <"_[_.._]">→set into cast;
	Grammatical restriction names is <exclusions>;
]
with <>;

/**
 * If a lexical set is built only from expressions with statically well-known
 * runtime values, then answer the instance type of the set that contains
 * those statically known elements. This gives lexical sets of literals and
 * statically well-known elements the same force as lexical literals, e.g.,
 * numbers and strings.
 *
 * Parameters:
 *    elements -
 * Returns:
 *    The most specific possible type of the lexical set, possibly an instance
 *    type.
 */
Semantic restriction "{«_‡,»}" is
[
	elements : <<>, any…|natural number>'s type
|
	/* Since the argument is derived from a lexically constructed tuple, then
	 * the cardinality of the argument is guaranteed to be a fixed, finite
	 * value. Therefore asking for either the lower or upper bound would be
	 * equivalent.
	 */
	limit ::= ||elements||'s upper bound;
	accumulator : tuple := <>;
	/* Check to see if the elements are instance types. */
	From 1 to limit do
	[
		index : natural number
	|
		element ::= elements[index];
		if |elements[index]| ≠ ∞ then
		[
			instance ::= elements[index]'s instance;
			/* Do not blithely construct a literal-force tuple if any of the
			 * instances are themselves types. This prevents expressions like
			 * `{elements[index]}` from asserting the type `{any}'s type` rather
			 * than `{any's type|1}`, which frequently leads to (absurd)
			 * runtime type errors, e.g., if elements[index] has the static type
			 * [0..5], then the return type verification nybblecode would fail
			 * because `{[0..5]}` is not a subtype of `{any}`.
			 */
			if instance's type ⊆ type then
			[
				false;
			]
			else
			[
				accumulator := concatenate <eject ↑accumulator, <instance>>;
				true;
			];
		]
		else
		[
			false;
		];
	];
	/* If the elements were all instance types, then answer an instance type. */
	if |accumulator| = limit then
	[
		(accumulator→set)'s type;
	]
	/* Otherwise, the answer cannot be an instance type. Compute the most
	 * precise possible set type.
	 */
	else
	[
		/* Build a tuple of distinct types encountered during a traversal of
		 * `elements`. Two types are distinct in this sense if they have no
		 * common descendents more general than ⊥. This establishes a lower
		 * bound on the answer's cardinality requirement.
		 *
		 * Also note what types have been encountered along the way. At the end
		 * they will be put into a set to effect deduplication of exact type
		 * matches. This set establishes an upper bound on the answer's
		 * cardinality requirement.
		 */
		types : tuple of type := <elements[1]>;
		distinct : tuple of type := <elements[1]>;
		From 2 to limit do
		[
			outerIndex : natural number
		|
			element ::= elements[outerIndex];
			types := cast concatenate <eject ↑types, <element>>
				into [ t : tuple of type | t; ];
			isDistinct : boolean := true;
			From 1 to |distinct| do
			[
				innerIndex : natural number
			|
				if element ∩ distinct[innerIndex] ≠ ⊥ then
				[
					isDistinct := false;
					false;
				]
				else
				[
					true;
				];
			];
			If isDistinct then
			[
				distinct := cast concatenate <eject ↑distinct, <element>> into
					[ t : tuple of type | t; ];
			];
			true;
		];
		lower ::= |distinct|;
		upper ::= cast |types| + 1 into [ i : natural number | i; ];
		union ::= cast ∪ types into [ t : any's type | t; ];
		{union | [lower..upper)};
	];
];

/**
 * Construct and answer a map from the lexically specified key-value bindings.
 * 
 * Parameters:
 *    bindings - The key-value bindings that constitute the answer.
 * Returns:
 *    A map comprising the specified key-value bindings.
 */
Method "{«_→_‡,»}" is
[
	bindings : key-value tuple
|
	bindings→map;
] : map;

/**
 * If a lexical map is built only from expressions with statically well-known
 * runtime values, then answer the instance type of the map that contains
 * those statically known elements. This gives lexical maps of literals and
 * statically well-known elements the same force as lexical literals, e.g.,
 * numbers and strings.
 *
 * Parameters:
 *    elements -
 * Returns:
 *    The most specific possible type of the lexical set, possibly an instance
 *    type.
 */
Semantic restriction "{«_→_‡,»}" is
[
	bindings : key-value tuple's type
|
	/* Since the argument is derived from a lexically constructed tuple, then
	 * the cardinality of the argument is guaranteed to be a fixed, finite
	 * value. Therefore asking for either the lower or upper bound would be
	 * equivalent.
	 */
	limit ::= ||bindings||'s upper bound;
	accumulator : <<>, <<>, any…|[2..2]>… |whole number> := <>;
	/* Check to see if keys and values are all instance types. */
	From 1 to limit do
	[
		index : natural number
	|
		binding ::= bindings[index];
		if |binding[1]| ≠ ∞ then
		[
			instanceK ::= binding[1]'s instance;
			if |binding[2]| ≠ ∞ then
			[
				instanceV ::= binding[2]'s instance;
				/* Do not blithely construct a literal-force tuple if any of the
				 * instances are themselves types. This prevents expressions
				 * like `{index→elements[index]}` from asserting the type
				 * `{natural number→any}'s type` rather than
				 * `{natural number's type→any's type|1}`, which frequently
				 * leads to (absurd) runtime type errors.
				 */
				if instanceK's type ⊆ type ∨ [ instanceV's type ⊆ type; ] then
				[
					false;
				]
				else
				[
					accumulator :=
						cast concatenate
							<eject ↑accumulator, <<instanceK, instanceV>>>
						into
						[
							t : <<>, <<>, any…|[2..2]>… |whole number>
						|
							t;
						];
					true;
				];
			]
			else
			[
				false;
			];
		]
		else
		[
			false;
		];
	];
	/* If the keys and values were all instance types, then answer an instance
	 * type.
	 */
	if |accumulator| = limit then
	[
		(accumulator→map)'s type;
	]
	/* Otherwise, the answer cannot be an instance type. Compute the most
	 * precise possible map type.
	 */
	else
	[
		/* Build a tuple of distinct key types encountered during a traversal of
		 * `bindings`. Two key types are distinct in this sense if they have no
		 * common descendents more general than ⊥. This establishes a lower
		 * bound on the answer's cardinality requirement.
		 *
		 * Also note what key types have been encountered along the way. At the
		 * end they will be put into a set to effect deduplication of exact type
		 * matches. This set establishes an upper bound on the answer's
		 * cardinality requirement.
		 */
		firstBinding ::= bindings[1];
		firstKeyType ::= firstBinding[1];
		distinct : tuple of type := <firstKeyType>;
		keyTypes : tuple of type := <firstKeyType>;
		valueTypes : tuple of type := <firstBinding[2]>;
		From 2 to limit do
		[
			outerIndex : natural number
		|
			binding ::= bindings[outerIndex];
			keyType ::= binding[1];
			keyTypes := cast concatenate <eject ↑keyTypes, <keyType>>
				into [ t : tuple of type | t; ];
			valueTypes := cast concatenate <eject ↑valueTypes, <binding[2]>>
				into [ t : tuple of type | t; ];
			isDistinct : boolean := true;
			From 1 to |distinct| do
			[
				innerIndex : natural number
			|
				if keyType ∩ distinct[innerIndex] ≠ ⊥ then
				[
					isDistinct := false;
					false;
				]
				else
				[
					true;
				];
			];
			If isDistinct then
			[
				distinct := cast concatenate <eject ↑distinct, <keyType>>
					into [ t : tuple of type | t; ];
			];
			true;
		];
		lower ::= |distinct|;
		upper ::= cast |keyTypes| + 1 into [ i : natural number | i; ];
		unionK ::= cast ∪ keyTypes into [ t : any's type | t; ];
		unionV ::= cast ∪ valueTypes into [ t : any's type | t; ];
		{unionK → unionV | [lower..upper)};
	];
];

/**
 * Strengthen the cardinality of a tuple to the range of cardinalities supported
 * by its tuple type.
 * 
 * Parameters:
 *    aTupleType -
 * Returns:
 *    The range of cardinalities supported by the argument.
 */
Semantic restriction "|_|" is
[
	aTupleType : tuple meta
|
	sizes ::= ||aTupleType||;
	upper ::= cast sizes' upper bound + 1 into [ t : [0..∞] | t; ];
	[sizes' lower bound..upper);
];

/**
 * Strengthen the cardinality of a set to the range of cardinalities supported
 * by its set type.
 * 
 * Parameters:
 *    aSetType -
 * Returns:
 *    The range of cardinalities supported by the argument.
 */
Semantic restriction "|_|" is
[
	aSetType : set meta
|
	sizes ::= ||aSetType||;
	upper ::= cast sizes' upper bound + 1 into [ t : [0..∞] | t; ];
	[sizes' lower bound..upper);
];

/**
 * Strengthen the cardinality of a map to the range of cardinalities supported
 * by its map type.
 * 
 * Parameters:
 *    aMapType -
 * Returns:
 *    The range of cardinalities supported by the argument.
 */
Semantic restriction "|_|" is
[
	aMapType : map meta
|
	sizes ::= ||aMapType||;
	upper ::= cast sizes' upper bound + 1 into [ t : [0..∞] | t; ];
	[sizes' lower bound..upper);
];
