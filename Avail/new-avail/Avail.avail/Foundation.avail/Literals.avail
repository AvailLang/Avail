/*
 * Literals.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Literals"
Versions
	"dev"
Extends
	"Early Literals"
Uses
	"Assertions",
	"Bootstrap",
	"Early Control Structures",
	"Early Logic"
Names
	"[_.._]",
	"[_.._)",
	"(_.._]",
	"(_.._)",
	"{«_‡,»}",
	"{«_→_‡,»}"
Body

/**
 * Answer the semantic restriction function that should be used for each of
 * `_'s lower bound` and `_'s upper bound`.
 *
 * Returns:
 *    A function that strengthens the integer range bounds methods.
 */
Method "integer range bound semantic restriction function" is
[
	[
		range : extended integer meta's type
	|
		instances ::= cast range's instances
			into [ t : {extended integer meta|whole number} | t; ];
		Assert |instances| = 1;
		instance ::= cast instances→tuple[1] into
			[ t : extended integer meta | t; ];
		instance;
	];
];

/**
 * Strengthen the bound to have the same static type as the argument. Note that
 * this is the strongest possible type because the argument's subtypes have
 * lower and upper bounds drawn from the argument's entire range.
 *
 * Parameters:
 *    range -
 * Returns:
 *    The same type as the argument to `_'s lower bound`.
 */
Semantic restriction "_'s lower bound" is
	integer range bound semantic restriction function;

/**
 * Strengthen the bound to have the same static type as the argument. Note that
 * this is the strongest possible type because the argument's subtypes have
 * lower and upper bounds drawn from the argument's entire range.
 *
 * Parameters:
 *    range -
 * Returns:
 *    The same type as the argument to `_'s upper bound`.
 */
Semantic restriction "_'s upper bound" is
	integer range bound semantic restriction function;

/**
 * Construct and answer an integer range type with the specified bounds.
 * 
 * Parameters:
 *    lowerBound - The lower bound, inclusive.
 *    upperBound - The upper bound, inclusive.
 * Returns:
 *    The requested integer range.
 */
Method "[_.._]" is
[
	lowerBound : extended integer,
	upperBound : extended integer
|
	integer range
		from lowerBound (inclusive=true)
		to upperBound (inclusive=true);
] : extended integer meta;

/**
 * Strengthen integer range types.
 *
 * Parameters:
 *    lowerBound -
 *    upperBound -
 * Returns:
 *    The most specific possible type of the integer range type expression.
 */
Semantic restriction "[_.._]" is
[
	lowerBound : extended integer meta,
	upperBound : extended integer meta
|
	(integer range
		from lowerBound's lower bound (inclusive=true)
		to upperBound's upper bound (inclusive=true))'s type;
];

/**
 * Construct and answer an integer range type with the specified bounds.
 * 
 * Parameters:
 *    lowerBound - The lower bound, inclusive.
 *    upperBound - The upper bound, exclusive.
 * Returns:
 *    The requested integer range.
 */
Method "[_.._)" is
[
	lowerBound : extended integer,
	upperBound : extended integer
|
	integer range
		from lowerBound (inclusive=true)
		to upperBound (inclusive=false);
] : extended integer meta;

/**
 * Strengthen integer range types.
 *
 * Parameters:
 *    lowerBound -
 *    upperBound -
 * Returns:
 *    The most specific possible type of the integer range type expression.
 */
Semantic restriction "[_.._)" is
[
	lowerBound : extended integer meta,
	upperBound : extended integer meta
|
	(integer range
		from lowerBound's lower bound (inclusive=true)
		to upperBound's upper bound (inclusive=false))'s type;
];

/**
 * Construct and answer an integer range type with the specified bounds.
 * 
 * Parameters:
 *    lowerBound - The lower bound, exclusive.
 *    upperBound - The upper bound, inclusive.
 * Returns:
 *    The requested integer range.
 */
Method "(_.._]" is
[
	lowerBound : extended integer,
	upperBound : extended integer
|
	integer range
		from lowerBound (inclusive=false)
		to upperBound (inclusive=true);
] : extended integer meta;

/**
 * Strengthen integer range types.
 *
 * Parameters:
 *    lowerBound -
 *    upperBound -
 * Returns:
 *    The most specific possible type of the integer range type expression.
 */
Semantic restriction "(_.._]" is
[
	lowerBound : extended integer meta,
	upperBound : extended integer meta
|
	(integer range
		from lowerBound's lower bound (inclusive=false)
		to upperBound's upper bound (inclusive=true))'s type;
];

/**
 * Construct and answer an integer range type with the specified bounds.
 * 
 * Parameters:
 *    lowerBound - The lower bound, exclusive.
 *    upperBound - The upper bound, exclusive.
 * Returns:
 *    The requested integer range.
 */
Method "(_.._)" is
[
	lowerBound : extended integer,
	upperBound : extended integer
|
	integer range
		from lowerBound (inclusive=false)
		to upperBound (inclusive=false);
] : extended integer meta;

/**
 * Strengthen integer range types.
 *
 * Parameters:
 *    lowerBound -
 *    upperBound -
 * Returns:
 *    The most specific possible type of the integer range type expression.
 */
Semantic restriction "(_.._)" is
[
	lowerBound : extended integer meta,
	upperBound : extended integer meta
|
	(integer range
		from lowerBound's lower bound (inclusive=false)
		to upperBound's upper bound (inclusive=false))'s type;
];

/**
 * If a lexical tuple is built only from expressions with statically well-known
 * runtime values, then answer the instance type of the tuple that contains
 * those statically known elements. This gives lexical tuples of literals and
 * statically well-known elements the same force as lexical literals, e.g.,
 * numbers and strings.
 *
 * Parameters:
 *    elements -
 * Returns:
 *    The most specific possible type of the lexical tuple, possibly an instance
 *    type.
 */
Semantic restriction "<«_‡,»>" is
[
	elements : tuple meta
|
	/* Since the argument is derived from a lexically constructed tuple, then
	 * the cardinality of the argument is guaranteed to be a fixed, finite
	 * value. Therefore asking for either the lower or upper bound would be
	 * equivalent.
	 */
	limit ::= |elements|'s upper bound;
	accumulator : tuple := <>;
	From 1 to limit do
	[
		index : natural number
	|
		cast elements[index] into
		[
			t : enumeration meta
		|
			instances ::= t's instances;
			Assert |instances| = 1;
			instance ::= instances→tuple[1];
			accumulator := concatenate <accumulator, <instance>>;
			true;
		]
		else
		[
			false;
		];
	];
	if |accumulator| = limit then
	[
		accumulator's type;
	]
	else
	[
		elements;
	];
];

/**
 * Construct and answer a set from the lexically specified expressions.
 *
 * Parameters:
 *    elements - A tuple, lexically constructed by the compiler, whose elements
 *       should be unique members of the answer.
 * Returns:
 *    The requested set.
 */
Method "{«_‡,»}" is
[
	elements : <<>, any…|natural number>
|
	elements→set;
] : set;

/* Disambiguate `∪_` and `∪_[_.._]` by forbidding `_[_.._]` as the only argument
 * of the former.
 */
invoke
	[
		cast ::= [ t : {string|whole number} | t; ];
		names ::= cast <"∪_">→set into cast;
		exclusions ::= cast <"_[_.._]">→set into cast;
		Grammatical restriction names is <exclusions>;
	]
with <>;

/**
 * If a lexical set is built only from expressions with statically well-known
 * runtime values, then answer the instance type of the set that contains
 * those statically known elements. This gives lexical sets of literals and
 * statically well-known elements the same force as lexical literals, e.g.,
 * numbers and strings.
 *
 * Parameters:
 *    elements -
 * Returns:
 *    The most specific possible type of the lexical set, possibly an instance
 *    type.
 */
Semantic restriction "{«_‡,»}" is
[
	elements : <<>, any…|natural number>'s type
|
	/* Since the argument is derived from a lexically constructed tuple, then
	 * the cardinality of the argument is guaranteed to be a fixed, finite
	 * value. Therefore asking for either the lower or upper bound would be
	 * equivalent.
	 */
	limit ::= |elements|'s upper bound;
	accumulator : tuple := <>;
	/* Check to see if the elements are instance types. */
	From 1 to limit do
	[
		index : natural number
	|
		element ::= elements[index];
		cast element into
		[
			t : enumeration meta
		|
			instances ::= t's instances;
			Assert |instances| = 1;
			instance ::= instances→tuple[1];
			accumulator := concatenate <accumulator, <instance>>;
			true;
		]
		else
		[
			false;
		];
	];
	/* If the elements were all instance types, then answer an instance type. */
	if |accumulator| = limit then
	[
		(accumulator→set)'s type;
	]
	/* Otherwise, the answer cannot be an instance type. Compute the most
	 * precise possible set type.
	 */
	else
	[
		/* Build a tuple of distinct types encountered during a traversal of
		 * `elements`. Two types are distinct in this sense if they have no
		 * common descendents more general than ⊥. This establishes a lower
		 * bound on the answer's cardinality requirement.
		 *
		 * Also note what types have been encountered along the way. At the end
		 * they will be put into a set to effect deduplication of exact type
		 * matches. This set establishes an upper bound on the answer's
		 * cardinality requirement.
		 */
		types : tuple of type := <elements[1]>;
		distinct : tuple of type := <elements[1]>;
		From 2 to limit do
		[
			outerIndex : natural number
		|
			element ::= elements[outerIndex];
			types := cast concatenate <types, <element>>
				into [ t : tuple of type | t; ];
			isDistinct : boolean := true;
			From 1 to |distinct| do
			[
				innerIndex : natural number
			|
				distinctType ::= cast distinct[innerIndex]
					into [ t : type | t; ];
				if ¬(element ∩ distinctType = ⊥) then
				[
					isDistinct := false;
					false;
				]
				else
				[
					true;
				];
			];
			if isDistinct then
			[
				distinct := cast concatenate <distinct, <element>> into
					[ t : tuple of type | t; ];
			];
			true;
		];
		typeSet ::= types→set;
		lower ::= |distinct|;
		upper ::= cast |typeSet| + 1 into [ i : natural number | i; ];
		{∪ types | [lower .. upper)};
	];
];

/**
 * Construct and answer a map from the lexically specified key-value bindings.
 * 
 * Parameters:
 *    bindings - The key-value bindings that constitute the answer.
 * Returns:
 *    A map comprising the specified key-value bindings.
 */
Method "{«_→_‡,»}" is
[
	bindings : key-value tuple
|
	bindings→map;
] : map;

/**
 * If a lexical map is built only from expressions with statically well-known
 * runtime values, then answer the instance type of the map that contains
 * those statically known elements. This gives lexical maps of literals and
 * statically well-known elements the same force as lexical literals, e.g.,
 * numbers and strings.
 *
 * Parameters:
 *    elements -
 * Returns:
 *    The most specific possible type of the lexical set, possibly an instance
 *    type.
 */
Semantic restriction "{«_→_‡,»}" is
[
	bindings : key-value tuple's type
|
	/* Since the argument is derived from a lexically constructed tuple, then
	 * the cardinality of the argument is guaranteed to be a fixed, finite
	 * value. Therefore asking for either the lower or upper bound would be
	 * equivalent.
	 */
	limit ::= |bindings|'s upper bound;
	accumulator : <<>, <<>, any…|[2..2]>… |whole number> := <>;
	/* Check to see if keys and values are all instance types. */
	From 1 to limit do
	[
		index : natural number
	|
		binding ::= cast bindings[index] into [ t: tuple meta | t; ];
		cast binding[1] into
		[
			k : enumeration meta
		|
			instancesK ::= k's instances;
			Assert |instancesK| = 1;
			instanceK ::= instancesK→tuple[1];
			cast binding[2] into
			[
				v : enumeration meta
			|
				instancesV ::= v's instances;
				Assert |instancesV| = 1;
				instanceV ::= instancesV→tuple[1];
				accumulator :=
					cast concatenate <accumulator, <<instanceK, instanceV>>>
					into [ t : <<>, <<>, any…|[2..2]>… |whole number> | t; ];
				true;
			]
			else
			[
				false;
			];
		]
		else
		[
			false;
		];
	];
	/* If the keys and values were all instance types, then answer an instance
	 * type.
	 */
	if |accumulator| = limit then
	[
		(accumulator→map)'s type;
	]
	/* Otherwise, the answer cannot be an instance type. Compute the most
	 * precise possible map type.
	 */
	else
	[
		/* Build a tuple of distinct key types encountered during a traversal of
		 * `bindings`. Two key types are distinct in this sense if they have no
		 * common descendents more general than ⊥. This establishes a lower
		 * bound on the answer's cardinality requirement.
		 *
		 * Also note what key types have been encountered along the way. At the
		 * end they will be put into a set to effect deduplication of exact type
		 * matches. This set establishes an upper bound on the answer's
		 * cardinality requirement.
		 */
		firstBinding ::= cast bindings[1] into [ t : tuple meta | t; ];
		firstKeyType ::= firstBinding[1];
		distinct : tuple of type := <firstKeyType>;
		keyTypes : tuple of type := <firstKeyType>;
		valueTypes : tuple of type := <firstBinding[2]>;
		From 2 to limit do
		[
			outerIndex : natural number
		|
			binding ::= cast bindings[outerIndex] into [ t : tuple meta | t; ];
			keyType ::= binding[1];
			keyTypes := cast concatenate <keyTypes, <keyType>>
				into [ t : tuple of type | t; ];
			valueTypes := cast concatenate <valueTypes, <binding[2]>>
				into [ t : tuple of type | t; ];
			isDistinct : boolean := true;
			From 1 to |distinct| do
			[
				innerIndex : natural number
			|
				distinctType ::= cast distinct[innerIndex]
					into [ t : type | t; ];
				if ¬(keyType ∩ distinctType = ⊥) then
				[
					isDistinct := false;
					false;
				]
				else
				[
					true;
				];
			];
			if isDistinct then
			[
				distinct := cast concatenate <distinct, <keyType>>
					into [ t : tuple of type | t; ];
			];
			true;
		];
		keyTypeSet ::= keyTypes→set;
		lower ::= |distinct|;
		upper ::= cast |keyTypeSet| + 1 into [ i : natural number | i; ];
		{∪ keyTypes → ∪ valueTypes | [lower .. upper)};
	];
];
