/*
 * Early Error Codes.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Early Error Codes"
Versions
	"dev"
Uses
	"Bootstrap",
	"Early Assertions",
	"Early Control Structures",
	"Early Definers",
	"Early Logic",
	"Early Math",
	"Early Tuples",
	"Literals",
	"Variables"
Names
	"error codes"

	/* Quite a few names are introduced, but all dynamically by the
	 * "Next error code_" defining method (whose only purpose is to produce
	 * publicly available methods).
	 */
Body

/** 
 * A map from the error codes to their names (corresponding to the method
 * names).
 */
errorCodes : {natural number→string|whole number} := {};

/**
 * Answer the map from "Foundation" error codes to their names. These methods
 * correspond to the method names by which the error codes may be referenced.
 *
 * @method "error codes"
 * @returns "{natural number→string|whole number}"
 *          The requested map.
 */
Public method "error codes" is [ errorCodes ];

/**
 * Define a method named `name` that stably answers `code`.
 * 
 * @method "Next error code is_(_)"
 * @param "baseName" "string"
 *        The name of the new method (without the trailing " code").
 * @param "code" "natural number"
 *        The error code.
 */
Private method "Next error code is_(_)" is
[
	baseName : string,
	code : natural number
|
	Assert: ¬code ∈ errorCodes ("code " ++ “code” ++ " already in use");
	name ::= baseName ++ " code";
	/* Strengthen the implementation function's return type to the exact value.
	 * This involves the construction of a decorator function.
	 */
	functionType ::= function accepting <> and returning code's type;
	implementation ::= new functionType applying [ code ];
	Method name is implementation;
	errorCodes := cast eject ↑errorCodes + code→name
		into [ t : {natural number→string|natural number} | t ];
	Publish new name: name;
];

Invoke [
	numberedCodes ::= <
		<1, "cannot-add-unlike-infinities">,
		<2, "cannot-subtract-like-infinities">,
		<3, "cannot-multiply-zero-and-infinity">,
		<4, "cannot-divide-by-zero">,
		<5, "cannot-divide-infinities">,
		<6, "cannot-read-unassigned-variable">,
		<7, "cannot-store-incorrectly-typed-value">,
		<8, "cannot-swap-contents-of-differently-typed-variables">,
		<9, "no-such-fiber-variable">,
		<10, "subscript-out-of-bounds">,
		<11, "incorrect-number-of-arguments">,
		<12, "incorrect-argument-type">,
		<13, "method-return-type-not-as-forward-declared">,
		<14, "continuation-expected-stronger-type">,
		<15, "primitive-not-supported">,
		<16, "unwind-sentinel">,
		<17, "not-enumeration">,
		<18, "shift-and-truncate-requires-non-negative">,
		<19, "no-method">,
		<20, "wrong-number-of-outers">,
		<21, "key-not-found">,
		<22, "negative-size">,
		<23, "I/O-error">,
		<24, "permission-denied">,
		<25, "invalid-handle">,
		<26, "invalid-primitive-number">,
		<27, "function-disagrees-with-primitive-restriction">,
		<28, "local-type-literal-is-not-a-type">,
		<29, "outer-type-literal-is-not-a-type">,
		<30, "unhandled-exception">,
		<31, "type-restriction-must-accept-only-types">,
		<32, "incorrect-type-for-group">,
		<33, "invalid-special-object-number">,
		<34, "macro-argument-must-be-a-parse-node">,
		<35, "ambiguous-name">,
		<36, "declaration-kind-does-not-support-assignment">,
		<37, "declaration-kind-does-not-support-reference">,
		<38, "exclamation-mark-must-follow-an-alternation-group-code">,
		<39, "redefined-with-same-argument-types">,
		<40, "result-type-should-covary-with-arguments">,
		<41, "special-atom">,
		<42, "incorrect-type-for-complex-group">,
		<43, "incorrect-use-of-double-dagger">,
		<44, "unbalanced-guillemets">,
		<45, "method-name-is-not-canonical">,
		<46, "expected-operator-after-backquote">,
		<47, "incorrect-type-for-boolean-group">,
		<48, "incorrect-type-for-counting-group">,
		<49, "octothorp-must-follow-a-simple-group">,
		<50, "question-mark-must-follow-a-simple-group">,
		<51, "case-insensitive-expression-canonization">,
		<52, "tilde-must-not-follow-argument">,
		<53, "double-question-mark-must-follow-a-simple-or-simple-group">,
		<54, "alternative-must-not-contain-arguments">,
		<55, "vertical-bar-must-follow-a-simple-or-simple-group">,
		<56, "cannot-convert-not-a-number-to-integer">,
		<57, "incorrect-type-for-numbered-choice-code">,
		<70, "compilation-is-over">,
		<71, "method-implementation-lookup-failed">,
		<72, "method-is-sealed">,
		<73, "no-implementation">,
		<100, "block-contains-invalid-statements">,
		<101, "block-is-invalid">,
		<102, "block-must-not-contain-outers">,
		<103, "block-compilation-failed">,
		<105, "sequence-contains-invalid-statements">,
		<500, "Java-class-not-available">,
		<501, "pojo-type-is-abstract">,
		<502, "Java-method-not-available">,
		<504, "Java-marshaling-failed">,
		<505, "Java-field-not-available">,
		<506, "Java-field-reference-is-ambiguous">,
		<507, "cannot-modify-final-Java-field">,
		<508, "Java-method-reference-is-ambiguous">,
		<1000, "object-type-extension-contains-duplicates">,
		<1001, "object-type-extension-did-not-produce-subtype">,
		<1002, "object-instantiation-contains-duplicates">,
		<1004, "object-instantiation-did-not-produce-instance">,
		<1005, "invalid-argument">,
		<1006, "runaway-format-variable">,
		<1007, "empty-format-variable">,
		<1008, "invalid-format-metacharacter-escape">,
		<1009, "invalid-format-metacharacter-use">,
		<1010, "format-variable-interpolation-failed">,
		<1011, "invalid-format-variable">,
		<1012, "missing-format-variable-binding">
	>;
	From 1 to |numberedCodes| do [
		i : natural number
	|
		pair ::= numberedCodes[i];
		errorNumber ::= pair[1];
		errorString ::= pair[2];
		Next error code is errorString (errorNumber);
		true
	];
] with <>;

/**
 * Ensure that all VM error codes have names.
 * 
 * @method "Ensure:all VM error codes are named"
 */
Private method "Ensure:all VM error codes are named" is [];

/**
 * 
 * @method "Ensure:all VM error codes are named"
 */
Semantic restriction "Ensure:all VM error codes are named" is
[
	unnamedErrorCodes : <<>, natural number…|whole number> := <>;
	From 1 to |VM error codes| do
	[
		index : natural number
	|
		errorCode ::= VM error codes[index];
		If ¬errorCode ∈ errorCodes then
		[
			unnamedErrorCodes := eject ↑unnamedErrorCodes ++ <errorCode>;
		];
		true
	];
	If |unnamedErrorCodes| ≠ 0 then
	[
		Reject parse, expected:
			"names to be provided for the following VM error codes: "
			++ “unnamedErrorCodes”
	];
	⊤
];

Ensure: all VM error codes are named;

