/*
 * Early Error Codes.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Early Error Codes"
Versions
	"dev"
Uses
	"Bootstrap",
	"Early Assertions",
	"Early Control Structures",
	"Early Definers",
	"Early Logic",
	"Early Math",
	"Early Tuples",
	"Literals",
	"Variables"
Names
	"error codes"

	/* Quite a few names are introduced, but all dynamically by the
	 * "Next error code_" defining method (whose only purpose is to produce
	 * publicly available methods).
	 */
Body

/* A map from the error codes to their names (corresponding to the method
 * names).
 */
errorCodes : {natural number→string|whole number} := {};

/**
 * Answer the map from "Foundation" error codes to their names. These methods
 * correspond to the method names by which the error codes may be referenced.
 *
 * Returns:
 *    The requested map.
 */
Public method "error codes" is [ errorCodes ];

/**
 * Define a method named `name` that stably answers `code`.
 * 
 * Parameters:
 *    baseName - The name of the new method (without the trailing " code").
 *    code - The error code.
 */
Private method "Next error code is_(_)" is
[
	baseName : string,
	code : natural number
|
	Assert: ¬code ∈ errorCodes ("code " ++ “code” ++ " already in use");
	name ::= baseName ++ " code";
	/* Strengthen the implementation function's return type to the exact value.
	 * This involves the construction of a decorator function.
	 */
	functionType ::= function accepting <> and returning code's type;
	implementation ::= new functionType applying [ code ];
	Method name is implementation;
	errorCodes := cast eject ↑errorCodes + code→name
		into [ t : {natural number→string|natural number} | t ];
	Publish new name: name;
];

Next error code is "cannot-add-unlike-infinities" (1);
Next error code is "cannot-subtract-like-infinities" (2);
Next error code is "cannot-multiply-zero-and-infinity" (3);
Next error code is "cannot-divide-by-zero" (4);
Next error code is "cannot-divide-infinities" (5);
Next error code is "cannot-read-unassigned-variable" (6);
Next error code is "cannot-store-incorrectly-typed-value" (7);
Next error code is "cannot-swap-contents-of-differently-typed-variables" (8);
Next error code is "no-such-fiber-variable" (9);
Next error code is "subscript-out-of-bounds" (10);
Next error code is "incorrect-number-of-arguments" (11);
Next error code is "incorrect-argument-type" (12);
Next error code is "method-return-type-not-as-forward-declared" (13);
Next error code is "continuation-expected-stronger-type" (14);
Next error code is "primitive-not-supported" (15);
Next error code is "not-enumeration" (17);
Next error code is "no-method" (19);
Next error code is "wrong-number-of-outers" (20);
Next error code is "key-not-found" (21);
Next error code is "negative-size" (22);
Next error code is "I/O-error" (23);
Next error code is "permission-denied" (24);
Next error code is "invalid-handle" (25);
Next error code is "invalid-primitive-number" (26);
Next error code is "function-disagrees-with-primitive-restriction" (27);
Next error code is "local-type-literal-is-not-a-type" (28);
Next error code is "outer-type-literal-is-not-a-type" (29);
Next error code is "unhandled-exception" (30);
Next error code is "type-restriction-must-accept-only-types" (31);
Next error code is "incorrect-type-for-group" (32);
Next error code is "invalid-special-object-number" (33);
Next error code is "macro-argument-must-be-a-parse-node" (34);
Next error code is "ambiguous-name" (35);
Next error code is "declaration-kind-does-not-support-assignment" (36);
Next error code is "declaration-kind-does-not-support-reference" (37);
Next error code is "redefined-with-same-argument-types" (39);
Next error code is "result-type-should-covary-with-arguments" (40);
Next error code is "special-atom" (41);
Next error code is "incorrect-type-for-complex-group" (42);
Next error code is "incorrect-use-of-double-dagger" (43);
Next error code is "unbalanced-guillemets" (44);
Next error code is "method-name-is-not-canonical" (45);
Next error code is "expected-operator-after-backquote" (46);
Next error code is "incorrect-type-for-boolean-group" (47);
Next error code is "incorrect-type-for-counting-group" (48);
Next error code is "octothorp-must-follow-a-simple-group" (49);
Next error code is "question-mark-must-follow-a-simple-group" (50);
Next error code is "case-insensitive-expression-canonization" (51);
Next error code is "tilde-must-not-follow-argument" (52);
Next error code is "double-question-mark-must-follow-a-simple-or-simple-group" (53);
Next error code is "alternative-must-not-contain-arguments" (54);
Next error code is "vertical-bar-must-follow-a-simple-or-simple-group" (55);
Next error code is "cannot-convert-not-a-number-to-integer" (56);
Next error code is "compilation-is-over" (70);
Next error code is "method-implementation-lookup-failed" (71);
Next error code is "method-is-sealed" (72);
Next error code is "no-implementation" (73);
Next error code is "block-contains-invalid-statements" (100);
Next error code is "block-is-invalid" (101);
Next error code is "block-must-not-contain-outers" (102);
Next error code is "block-compilation-failed" (103);
Next error code is "sequence-contains-invalid-statements" (105);
Next error code is "Java-class-not-available" (500);
Next error code is "pojo-type-is-abstract" (501);
Next error code is "Java-method-not-available" (502);
Next error code is "Java-marshaling-failed" (504);
Next error code is "Java-field-not-available" (505);
Next error code is "Java-field-reference-is-ambiguous" (506);
Next error code is "cannot-modify-final-Java-field" (507);
Next error code is "Java-method-reference-is-ambiguous" (508);
Next error code is "object-type-extension-contains-duplicates" (1000);
Next error code is "object-type-extension-did-not-produce-subtype" (1001);
Next error code is "object-instantiation-contains-duplicates" (1002);
Next error code is "object-instantiation-did-not-produce-instance" (1004);
Next error code is "invalid-argument" (1005);
Next error code is "runaway-format-variable" (1006);
Next error code is "empty-format-variable" (1007);
Next error code is "invalid-format-metacharacter-escape" (1008);
Next error code is "invalid-format-metacharacter-use" (1009);
Next error code is "format-variable-interpolation-failed" (1010);
Next error code is "invalid-format-variable" (1011);
Next error code is "missing-format-variable-binding" (1012);

/**
 * Ensure that all VM error codes have names.
 */
Private method "Ensure:all VM error codes are named" is [];
Semantic restriction "Ensure:all VM error codes are named" is
[
	unnamedErrorCodes : <<>, natural number…|whole number> := <>;
	From 1 to |VM error codes| do
	[
		index : natural number
	|
		errorCode ::= VM error codes[index];
		If ¬errorCode ∈ errorCodes then
		[
			unnamedErrorCodes := eject ↑unnamedErrorCodes ++ <errorCode>;
		];
		true
	];
	If |unnamedErrorCodes| ≠ 0 then
	[
		Reject parse, expected:
			"names to be provided for the following VM error codes: "
			++ “unnamedErrorCodes”
	];
	⊤
];

Ensure: all VM error codes are named;

