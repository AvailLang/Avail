/*
 * Control Structures.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Control Structures"
Versions
	"dev"
Extends
	"Early Control Structures" =
	(
		"Cast|cast_into_else_",
		"Cast|cast_into_",
		"Ignore:_",
		"(_)"
	)
Uses
	"Bootstrap",
	"Definers",
	"Early Assertions",
	"Early Functions",
	"Early Maps",
	"Early Tuples",
	"Early Types",
	"Early Sets",
	"Enumeration Support",
	"Literals",
	"Logic",
	"Math",
	"Variables"
Names
	"Do_until_",
	"Do_until_alternate with_",
	"Do_while_",
	"Do_while_alternate with_",
	"Exit_",
	"From_to_by_do_",
	"From_to_do_",
	"Repeat_",
	"Repeat__times",
	"Unless_then_",
	"Until_",
	"Until_do_",
	"While_",
	"While_do_",
	"Cast|cast_into«_‡or»«else_»",
	"Choose|choose_from_where«_is_‡,»«,else_»",
	"here",
	"If|if_then_«else if_then_»«else_»",
	"Unless|unless_then_else_",
	"Unless|unless_then_«else unless_then_»«else_»",

	/* This is provided to support implementation of semantic restrictions of
	 * `map and filter_by_`. Not for export beyond this package.
	 */
	"Require:_'s⁇keeper is valid"
Body

/**
 * Exit the continuation. Execution proceeds as though the continuation had just
 * returned from its current function. The current continuation is completely
 * replaced by the specified continuation's resumed caller.
 *
 * Parameters:
 *    aContinuation - The continuation to exit.
 */
Public method "Exit_" is
[
	aContinuation : $[…]→⊤
|
	/* Since the continuation's return type is ⊤, the primitive will discard
	 * the argument, so it can be anything.
	 */
	Exit aContinuation with <>
] : ⊥;

/**
 * Reject the current parse unless the value supplied upon exit of a
 * continuation conforms to its function type's return type.
 */
Semantic restriction "Exit_with_" is
[
	continuationType : continuation meta,
	exitType : any meta
|
	functionType ::= continuationType's function type;
	If ¬exitType ⊆ functionType's return type then
	[
		Reject parse, expected:
			"continuation ("
			++ primitive description of continuationType
			++ ") to accept value ("
			++ primitive description of exitType
			++ ")"
	];
	⊥
];

/* These are error messages. */
sizesIncompatibleMessage ::=
	"size of argument tuple to be compatible with size of\
	\| continuation's parameter tuple";

/**
 * Reject the current parse if the argument tuple cannot possibly match the
 * continuation's parameter tuple.
 */
Semantic restriction "Restart_with_" is
[
	continuationType : continuation meta,
	argumentsType : tuple meta
|
	functionType ::= continuationType's function type;
	parametersType ::= functionType's parameters' type;
	parametersSizes ::= ||parametersType||;
	/* If `parameterSizes` = ⊥, then `parametersType` = ⊥. In this case, we
	 * cannot statically ascertain anything interesting about the function and
	 * the arguments to apply.
	 */
	If parametersSizes ≠ ⊥ then
	[
		argumentsSizes ::= ||argumentsType||;
		validSizes ::= parametersSizes ∩ argumentsSizes;
		If validSizes = ⊥ then
		[
			Reject parse, expected: sizesIncompatibleMessage
		];
	];
	⊥
];

/**
 * Answer a continuation that represents (approximately) the current
 * continuation. This facility may be used to simulate labels within (but not at
 * the start of) blocks. The answer may be restarted, but not exited, which
 * causes execution to resume at the point where the continuation is computed
 * and answered.
 * 
 * Returns:
 *    A continuation which, when restarted, causes `here` to answer the
 *    continuation again.
 */
Public method "here" is
[
	$body : $[]→⊥;
	body
] : $[]→⊥;

/**
 * Basic unconditional loop. Repeatedly invoke `action`.
 * 
 * Parameters:
 *    action - The function that should be invoked repeatedly.
 */
Public method "Repeat_" is
[
	action : []→⊤
|
	$loop;
	action();
	Restart loop
] : ⊥;

/**
 * Apply the specified function exactly `count` times.
 * 
 * Parameters:
 *    action - A function.
 *    count - The number of times to apply `action`.
 */
Public method "Repeat__times" is
[
	action : []→⊤,
	count : [0..∞]
|
	index : natural number := 1;
	[
		$loop;
		If index ≤ count then
		[
			action();
			↑index++;
			Restart loop
		];
	]();
] : ⊤;

/**
 * If `count` is ∞, then answer ⊥ (because the loop will never terminate).
 */
Semantic restriction "Repeat__times" is
[
	action : []→⊤'s type,
	count : [0..∞]'s type
|
	if ⎣count⎦ = ∞ then
	[
		⊥
	]
	else
	[
		⊤
	]
];

/**
 * Counting loop with customizable step and early exit support. Invoke `action`
 * once for every consecutive value = `start` + N × `step` ≤ `end`, aborting if
 * `action` answers `false` after an iteration.
 * 
 * Parameters:
 *    start - The start value, inclusive.
 *    end - The end value, inclusive.
 *    step - The amount by which to adjust the value after each iteration.
 *    action - A function that accepts a value in the specified range. If it
 *       answers `true`, then continue to iterate; if it answers `false`, then
 *       terminate iteration early.
 */
Abstract method "From_to_by_do_" is
	[integer, extended integer, integer, [⊥]→boolean]→⊤;

/**
 * Counting loop with customizable step and early exit support. Invoke `action`
 * once for every consecutive value = `start` + N × `step` ≤ `end`, aborting if
 * `action` answers `false` after an iteration.
 * 
 * Parameters:
 *    start - The start value, inclusive.
 *    end - The end value, inclusive.
 *    step - The amount by which to adjust the value after each iteration.
 *    action - A function that accepts a value in the specified range. If it
 *       answers `true`, then continue to iterate; if it answers `false`, then
 *       terminate iteration early.
 */
Public method "From_to_by_do_" is
[
	start : integer,
	end : extended integer,
	step : [0..∞),
	action : [⊥]→boolean
|
	value : extended integer := start;
	[
		$loop;
		If value ≤ end then
		[
			continue ::= invoke action with <value>;
			value := eject ↑value + step;
			If continue then
			[
				Restart loop
			];
		];
	]();
] : ⊤;

/**
 * Counting loop with customizable step and early exit support. Invoke `action`
 * once for every consecutive value = `start` + N × `step` ≥ `end`, aborting if
 * `action` answers `false` after an iteration.
 * 
 * Parameters:
 *    start - The start value, inclusive.
 *    end - The end value, inclusive.
 *    step - The amount by which to adjust the value after each iteration.
 *    action - A function that accepts a value in the specified range. If it
 *       answers `true`, then continue to iterate; if it answers `false`, then
 *       terminate iteration early.
 */
Public method "From_to_by_do_" is
[
	start : integer,
	end : extended integer,
	step : (-∞..-1],
	action : [⊥]→boolean
|
	value : extended integer := start;
	[
		$loop;
		If value ≥ end then
		[
			continue ::= invoke action with <value>;
			value := eject ↑value + step;
			If continue then
			[
				Restart loop
			];
		];
	]();
] : ⊤;

/**
 * If possible, then enforce that the specified function will accept all values
 * in the implied range.
 */
Semantic restriction "From_to_by_do_" is
[
	start : integer's type,
	end : extended integer's type,
	step : integer's type,
	action : [⊥]→boolean's type
|
	subscripts ::=
		if step ⊆ [0..∞) then
		[
			(⎣start⎦ - 1 .. ⎡end⎤ + 1)
		]
		else
		[
			if step ⊆ (-∞..-1] then
			[
				(⎣end⎦ - 1 .. ⎡start⎤ + 1)
			]
			else
			[
				(start ∪ end) ∩ integer
			]
		];
	If action[1] ≠ ⊥ ∧ [ ¬subscripts ⊆ action[1] ] then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all values in the range "
			++ primitive description of subscripts
			++ ", but it only accepts "
			++ primitive description of action[1]
	];
	return ::= action's return type;
	endSet ::= {⎣end⎦, ⎡end⎤};
	definitelyRuns ::=
		if step ⊆ [0..∞) then
		[
			⎡start⎤ ≤ ⎣end⎦
		]
		else
		[
			if step ⊆ (-∞..-1] then
			[
				⎣start⎦ ≥ ⎡end⎤
			]
			else
			[
				false
			]
		];
	/* These are four circumstances which lead to non-termination:
	 * 
	 * 1. The step is 0.
	 * 2. The step is positive, the end is ∞, and the action answers `true`.
	 * 3. The step is negative, the end is -∞, and the action answers `true`.
	 * 4. The action is definitely invoked and it never terminates.
	 */
	if step ⊆ [0..0]
		∨ [ (step ⊆ [0..∞) ∧ [ endSet = {∞} ∧ [ return = true's type ] ])
		∨ [ (step ⊆ (-∞..-1] ∧ [ endSet = {-∞} ∧ [ return = true's type ] ])
		∨ [ definitelyRuns ∧ [ return = ⊥ ] ] ] ]
	then
	[
		⊥
	]
	else
	[
		⊤
	]
];

/**
 * Counting loop with customizable step. Invoke `action` once for every
 * consecutive value = `start` + N × `step` ≤ `end`.
 * 
 * Parameters:
 *    start - The start value, inclusive.
 *    end - The end value, inclusive.
 *    step - The amount by which to adjust the value after each iteration.
 *    action - A function that accepts a value in the specified range.
 */
Abstract method "From_to_by_do_" is
	[integer, extended integer, integer, [⊥]→⊤]→⊤;

/**
 * Counting loop with customizable step. Invoke `action` once for every
 * consecutive value = `start` + N × `step` ≤ `end`.
 * 
 * Parameters:
 *    start - The start value, inclusive.
 *    end - The end value, inclusive.
 *    step - The amount by which to adjust the value after each iteration.
 *    action - A function that accepts a value in the specified range.
 */
Public method "From_to_by_do_" is
[
	start : integer,
	end : extended integer,
	step : [0..∞),
	action : [⊥]→⊤
|
	From start to end by step do
	[
		value : integer
	|
		Invoke action with <value>;
		true
	];
];

/**
 * Counting loop with customizable step. Invoke `action` once for every
 * consecutive value = `start` + N × `step` ≥ `end`.
 * 
 * Parameters:
 *    start - The start value, inclusive.
 *    end - The end value, inclusive.
 *    step - The amount by which to adjust the value after each iteration.
 *    action - A function that accepts a value in the specified range.
 */
Public method "From_to_by_do_" is
[
	start : integer,
	end : extended integer,
	step : (-∞..-1],
	action : [⊥]→⊤
|
	From start to end by step do
	[
		value : integer
	|
		Invoke action with <value>;
		true
	];
];

/**
 * If possible, then enforce that the specified function will accept all values
 * in the implied range.
 */
Semantic restriction "From_to_by_do_" is
[
	start : integer's type,
	end : extended integer's type,
	step : integer's type,
	action : [⊥]→⊤'s type
|
	subscripts ::=
		if step ⊆ [0..∞) then
		[
			(⎣start⎦ - 1 .. ⎡end⎤ + 1)
		]
		else
		[
			if step ⊆ (-∞..-1] then
			[
				(⎣end⎦ - 1 .. ⎡start⎤ + 1)
			]
			else
			[
				(start ∪ end) ∩ integer
			]
		];
	If action[1] ≠ ⊥ ∧ [ ¬subscripts ⊆ action[1] ] then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all values in the range "
			++ primitive description of subscripts
			++ ", but it only accepts "
			++ primitive description of action[1]
	];
	return ::= action's return type;
	endSet ::= {⎣end⎦, ⎡end⎤};
	definitelyRuns ::=
		if step ⊆ [0..∞) then
		[
			⎡start⎤ ≤ ⎣end⎦
		]
		else
		[
			if step ⊆ (-∞..-1] then
			[
				⎣start⎦ ≥ ⎡end⎤
			]
			else
			[
				false
			]
		];
	/* These are four circumstances which lead to non-termination:
	 * 
	 * 1. The step is 0.
	 * 2. The step is positive and the end is ∞.
	 * 3. The step is negative and the end is -∞.
	 * 4. The action is definitely invoked and it never terminates.
	 */
	if step ⊆ [0..0]
		∨ [ (step ⊆ [0..∞) ∧ [ endSet = {∞} ])
		∨ [ (step ⊆ (-∞..-1] ∧ [ endSet = {-∞} ])
		∨ [ definitelyRuns ∧ [ return = ⊥ ] ] ] ]
	then
	[
		⊥
	]
	else
	[
		⊤
	]
];

/**
 * Counting loop with early exit support. Invoke `action` once for every
 * consecutive number in the range established by `start` and `end`, aborting if
 * `action` answers `false` after an iteration.
 * 
 * Parameters:
 *    start - The start value, inclusive.
 *    end - The end value, inclusive.
 *    action - A function that accepts a value in the specified range. If it
 *       answers `true`, then continue to iterate; if it answers `false`, then
 *       terminate iteration early.
 */
Public method "From_to_do_" is
[
	start : integer,
	end : extended integer,
	action : [⊥]→boolean
|
	From start to end by 1 do action;
];

/**
 * If possible, then enforce that the specified function will accept all values
 * in the implied range.
 */
Semantic restriction "From_to_do_" is
[
	start : integer's type,
	end : extended integer's type,
	action : [⊥]→boolean's type
|
	subscripts ::= (⎣start⎦ - 1 .. ⎡end⎤ + 1);
	If action[1] ≠ ⊥ ∧ [ ¬subscripts ⊆ action[1] ] then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all values in the range "
			++ primitive description of subscripts
			++ ", but it only accepts "
			++ primitive description of action[1]
	];
	return ::= action's return type;
	endSet ::= {⎣end⎦, ⎡end⎤};
	definitelyRuns ::= ⎡start⎤ ≤ ⎣end⎦;
	if (endSet = {∞} ∧ [ return = true's type ])
		∨ [ definitelyRuns ∧ [ return = ⊥ ] ]
	then
	[
		⊥
	]
	else
	[
		⊤
	]
];

/**
 * Counting loop with early exit support. Invoke `action` once for every
 * consecutive number in the range established by `start` and `end`.
 * 
 * Parameters:
 *    start - The start value, inclusive.
 *    end - The end value, inclusive.
 *    action - A function that accepts a value in the specified range.
 */
Public method "From_to_do_" is
[
	start : integer,
	end : extended integer,
	action : [⊥]→⊤
|
	From start to end by 1 do
	[
		value : integer
	|
		Invoke action with <value>;
		true
	];
];

/**
 * If possible, then enforce that the specified function will accept all values
 * in the implied range.
 */
Semantic restriction "From_to_do_" is
[
	start : integer's type,
	end : extended integer's type,
	action : [⊥]→⊤'s type
|
	subscripts ::= (⎣start⎦ - 1 .. ⎡end⎤ + 1);
	If action[1] ≠ ⊥ ∧ [ ¬subscripts ⊆ action[1] ] then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all values in the range "
			++ primitive description of subscripts
			++ ", but it only accepts "
			++ primitive description of action[1]
	];
	return ::= action's return type;
	endSet ::= {⎣end⎦, ⎡end⎤};
	definitelyRuns ::= ⎡start⎤ ≤ ⎣end⎦;
	if endSet = {∞} ∨ [ definitelyRuns ∧ [ return = ⊥ ] ]
	then
	[
		⊥
	]
	else
	[
		⊤
	]
];

/**
 * Restart the continuation with the specified arguments. Execution proceeds as
 * though the continuation's caller had just invoked the continuation's current
 * function with the given arguments instead of the original arguments. The
 * current continuation (in which this primitive was invoked) is completely
 * replaced by the restarted continuation.
 *
 * Parameters:
 *    aContinuation - The continuation to restart.
 *    arguments - The new arguments with which to restart `aContinuation`.
 */
Method "_(«_‡,»)" is
[
	aContinuation : continuation,
	arguments : tuple
|
	Restart aContinuation with arguments
];

/**
 * Reject the current parse if the argument types do not conform to the
 * continuation's parameter types.
 */
Semantic restriction "_(«_‡,»)" is
[
	continuationType : continuation meta,
	argumentsType : tuple meta
|
	functionType ::= continuationType's function type;
	parametersType ::= functionType's parameters' type;
	parametersSizes ::= ||parametersType||;
	/* If `parameterSizes` = ⊥, then `parametersType` = ⊥. In this case, we
	 * cannot statically ascertain anything interesting about the function and
	 * the arguments to apply.
	 */
	If parametersSizes ≠ ⊥ then
	[
		argumentsSizes ::= ||argumentsType||;
		validSizes ::= parametersSizes ∩ argumentsSizes;
		If validSizes = ⊥ then
		[
			Reject parse, expected: sizesIncompatibleMessage
		];
		/* Verify each of the arguments. */
		From 1 to ⎣argumentsSizes⎦ do
		[
			index : natural number
		|
			If ¬argumentsType[index] ⊆ parametersType[index] then
			[
				Reject parse, expected:
					"argument #"
					++ primitive description of index
					++ " of type ("
					++ primitive description of argumentsType[index]
					++ ") to agree with corresponding continuation's "
					++ "parameter type ("
					++ primitive description of parametersType[index]
					++ ")"
			];
		];
	];
	⊥
];

/**
 * Helper method for semantic restrictions of `map and filter_by_`: If
 * `action`'s last parameter does not accept an arity-one procedure, then reject
 * the current parse.
 * 
 * Parameters:
 *    action - A function type whose last parameter type must permit a
 *       one-argument procedure.
 */
Public method "Require:_'s⁇keeper is valid" is
[
	action : function meta
|
	parametersType ::= action's parameters' type;
	parametersSizes ::= ||parametersType||;
	Assert: ⎣parametersSizes⎦ = ⎡parametersSizes⎤
		("number of parameters cannot be determined");
	parametersSize ::= cast ⎣parametersSizes⎦
		into [ t : natural number | t ];
	expectedType ::= [⊥]→⊤;
	If ¬action[parametersSize] ⊆ expectedType then
	[
		Reject parse, expected:
			"last argument ⊆ "
			++ primitive description of expectedType
			++ " (but instead it was "
			++ primitive description of action[parametersSize]
			++ ")"
	];
];

/**
 * Multiply branching conditional statement/expression. Execute the first
 * action for which the associated predicate answers `true`. If none of the
 * predicates answer `true`, then execute the "else" action. If no "else"
 * action is provided, then do not execute any of the action blocks.
 * 
 * Parameters:
 *    firstPredicate - The first predicate. This argument is a raw boolean
 *       rather than a function answering a boolean, because it must always be
 *       evalutated (and hence there is no point deferring its evaluation).
 *    firstThen - The action to perform if `firstPredicate` is `true`.
 *    elseIfTuple - A lexically constructed tuple of 2-tuples. Each 2-tuple has
 *       as its first element a predicate function and as its second element an
 *       action to perform if the predicate function answers `true`.
 *    else - A lexically constructed tuple that optionally contains the action
 *       to perform if `firstPredicate` is `false` and all predicates of
 *       `elseIfTuple` answer `false`.
 * Returns:
 *    If used as an expression, then the value of the selected action.
 */
Public method "If|if_then_«else if_then_»«else_»" is
[
	firstPredicate : boolean,
	firstThen : []→⊤,
	elseIfTuple : <<[]→boolean, []→⊤…|2>…|1..>,
	else : <[]→⊤…|0..1>
|
	if firstPredicate then
	[
		firstThen();
	]
	else
	[
		/* Choose the first of the remaining clauses for which the associated
		 * predicate is `true`.
		 */
		action : []→⊤;
		From 1 to |elseIfTuple| do
		[
			index : natural number
		|
			If elseIfTuple[index][1]() then
			[
				action := elseIfTuple[index][2];
			];
			↑action is unassigned
		];
		/* If none of the predicates answered `true`, then choose the "else"
		 * clause (if one was provided).
		 */
		If ↑action is unassigned ∧ [ |else| = 1 ] then
		[
			action := else[1];
		];
		if ↑action is unassigned then
		[
			/* Do nothing. */
		]
		else
		[
			action();
		];
	];
] : ⊤;

/**
 * Provide the strongest possible return type. If no "else" action is provided,
 * but the chain of predicates does not definitely indicate a particular action,
 * then answer ⊤. The weakest possible (but actual) strengthening is the type
 * union of the return types of all actions whose associated predicates are not
 * guaranteed to answer `false`. The greatest possible strengthening occurs when
 * an action whose predicate is guaranteed to answer `true` is preceded only by
 * actions whose predicates are guaranteed to answer `false`; in this case,
 * answer this action's return type.
 */
Semantic restriction "If|if_then_«else if_then_»«else_»" is
[
	firstPredicate : boolean's type,
	firstThen : []→⊤'s type,
	elseIfTuple : <<[]→boolean, []→⊤…|2>…|1..>'s type,
	else : <[]→⊤…|0..1>'s type
|
	/* `ambiguous` tracks whether any of the predicates cannot be proven to
	 * answer a specific value. It is set to `true` when a predicate's return
	 * type cannot be specifically established, i.e., when it is only known to
	 * be `boolean`.
	 */
	ambiguous : boolean := false;
	/* `exact` is assigned only if an exact type can be established for the
	 * current call site. In particular, this occurs when a predicate's return
	 * type is `true's type` but `ambiguous` is not set. `exact` is set in only
	 * two cases: 1) every previous predicate answers `false's type` but the
	 * current predicate answers `true's type` and 2) no preceding predicate
	 * has answered `true's type` and no "else" action has been provided.
	 */
	exact : type;
	/* `union` tracks the general type of the expression. Every predicate that
	 * answers `boolean` prior to the first predicate that answers `true's type`
	 * should have its action's return type accumulated via type union with
	 * `union`. (Every predicate/action pair after the first that answers
	 * `true's type` may be ignored, as its action's return value does not
	 * participate in the final result.)
	 */
	union : type := ⊥;
	/* Handle `firstPredicate` specially (because it is lexically distinct from
	 * `elseIfTuple`).
	 */
	If firstPredicate = true's type then
	[
		exact := firstThen's return type;
	]
	else
	[
		/* If `firstPredicate` is `boolean`, then the expression is already
		 * ambiguous. Set the flag and begin accumulating the expression's type.
		 */
		If firstPredicate = boolean then
		[
			ambiguous := true;
			union := eject ↑union ∪ firstThen's return type;
		];
		elseIfTupleSize ::= relevant |elseIfTuple|;
		/* `keepLooping` tracks whether it is necessary to continue examining
		 * predicate/action pairs. It is set to `false` when a predicate is
		 * discovered that answers `true's type`. No predicate/action pairs
		 * beyond such a one participate in determination of the result type,
		 * i.e., they are guaranteed not to execute at runtime.
		 */
		keepLooping : boolean := true;
		From 1 to elseIfTupleSize do
		[
			index : natural number
		|
			elseIf ::= elseIfTuple[index];
			predicateReturnType ::= elseIf[1]'s return type;
			actionReturnType ::= elseIf[2]'s return type;
			If ¬ambiguous ∧ [ predicateReturnType = true's type ] then
			[
				exact := actionReturnType;
			];
			keepLooping :=
				if ↑exact is assigned then
				[
					false
				]
				else
				[
					If predicateReturnType ≠ false's type then
					[
						ambiguous := true;
						union := eject ↑union ∪ actionReturnType;
					];
					/* If the predicate's return type is `true's type`, then we
					 * want to exit the loop early no matter what else has
					 * happened up to this point. No further predicate/action
					 * pairs can participate in determining a result.
					 */
					predicateReturnType ≠ (true's type)
				];
			keepLooping
		];
		/* Unless we exited the loop early (`keepLooping` = `false`), then we
		 * want to give the "else" action an opportunity to participate.
		 */
		If keepLooping then
		[
			If ⎣else⎦ = 1 then
			[
				elseReturnType ::= else[1]'s return type;
				If ¬ambiguous then
				[
					exact := elseReturnType;
				]
				else
				[
					union := eject ↑union ∪ elseReturnType;
				];
			]
			else
			[
				exact := ⊤;
			];
		];
	];
	/* Produce the final answer. */
	if ↑exact is assigned then
	[
		exact
	]
	else
	[
		if ambiguous then
		[
			union
		]
		else
		[
			⊤
		]
	]
];
/**
 * Given a predicate value and a function, invoke the specified function only if
 * the predicate is `false`. This is the inverse of `If_then_`.
 * 
 * Parameters:
 *    predicate - A predicate value.
 *    action - The function to invoke if `predicate` is `false`.
 */
Public method "Unless_then_" is
[
	predicate : boolean,
	action : []→⊤
|
	If ¬predicate then action;
] : ⊤;

/**
 * Given a predicate value and two functions, invoke one of them and answer its
 * result.
 *
 * Parameters:
 *    predicate - A predicate value.
 *    falseFunction - The function to invoke if `predicate` is `false`.
 *    trueFunction - The function to invoke if `trueFunction` is `true`.
 * Returns:
 *    If `predicate` is `false`, then the value produced by invoking
 *    `falseFunction`; otherwise, the value produced by invoking `trueFunction`.
 */
Public method "Unless|unless_then_else_" is
[
	predicate : boolean,
	falseBlock : []→⊤,
	trueBlock : []→⊤
|
	If ¬predicate then falseBlock else trueBlock;
];

/**
 * Establish a conditional expression whose static return type is the type union
 * of its two possible functions' return types.
 */
Semantic restriction "Unless|unless_then_else_" is
[
	predicate : boolean's type,
	falseFunction : []→⊤'s type,
	trueFunction : []→⊤'s type
|
	trueFunction's return type ∪ falseFunction's return type
];

/**
 * Strengthen the static return type to that of the function to invoke when the
 * predicate is false (which it is).
 */
Semantic restriction "Unless|unless_then_else_" is
[
	contradiction : false's type's type,
	falseFunction : []→⊤'s type,
	trueFunction : []→⊤'s type
|
	falseFunction's return type
];

/**
 * Strengthen the static return type to that of the function to invoke when the
 * predicate is true (which it is).
 */
Semantic restriction "Unless|unless_then_else_" is
[
	tautology : true's type's type,
	falseFunction : []→⊤'s type,
	trueFunction : []→⊤'s type
|
	trueFunction's return type
];


/**
 * Multiply branching conditional statement/expression. Execute the first
 * action for which the associated predicate answers `false`. If none of the
 * predicates answer `false`, then execute the "else" action. If no "else"
 * action is provided, then do not execute any of the action blocks.
 * 
 * Parameters:
 *    firstPredicate - The first predicate. This argument is a raw boolean
 *       rather than a function answering a boolean, because it must always be
 *       evalutated (and hence there is no point deferring its evaluation).
 *    firstThen - The action to perform if `firstPredicate` is `false`.
 *    elseUnlessTuple - A lexically constructed tuple of 2-tuples. Each 2-tuple
 *       has as its first element a predicate function and as its second element
 *       an action to perform if the predicate function answers `false`.
 *    else - A lexically constructed tuple that optionally contains the action
 *       to perform if `firstPredicate` is `true` and all predicates of
 *       `elseIfTuple` answer `true`.
 * Returns:
 *    If used as an expression, then the value of the selected action.
 */
Public method "Unless|unless_then_«else unless_then_»«else_»" is
[
	firstPredicate : boolean,
	firstThen : []→⊤,
	elseUnlessTuple : <<[]→boolean, []→⊤…|2>…|1..>,
	else : <[]→⊤…|0..1>
|
	if firstPredicate then
	[
		firstThen();
	]
	else
	[
		/* Choose the first of the remaining clauses for which the associated
		 * predicate is `false`.
		 */
		action : []→⊤;
		From 1 to |elseUnlessTuple| do
		[
			index : natural number
		|
			Unless elseUnlessTuple[index][1]() then
			[
				action := elseUnlessTuple[index][2];
			];
			↑action is unassigned
		];
		/* If none of the predicates answered `false`, then choose the "else"
		 * clause (if one was provided).
		 */
		If ↑action is unassigned ∧ [ |else| = 1 ] then
		[
			action := else[1];
		];
		if ↑action is unassigned then
		[
			/* Do nothing. */
		]
		else
		[
			action();
		];
	];
] : ⊤;

/**
 * Provide the strongest possible return type. If no "else" action is provided,
 * but the chain of predicates does not definitely indicate a particular action,
 * then answer ⊤. The weakest possible (but actual) strengthening is the type
 * union of the return types of all actions whose associated predicates are not
 * guaranteed to answer `true`. The greatest possible strengthening occurs when
 * an action whose predicate is guaranteed to answer `false` is preceded only by
 * actions whose predicates are guaranteed to answer `true`; in this case,
 * answer this action's return type.
 */
Semantic restriction "Unless|unless_then_«else unless_then_»«else_»" is
[
	firstPredicate : boolean's type,
	firstThen : []→⊤'s type,
	elseUnlessTuple : <<[]→boolean, []→⊤…|2>…|1..>'s type,
	else : <[]→⊤…|0..1>'s type
|
	/* `ambiguous` tracks whether any of the predicates cannot be proven to
	 * answer a specific value. It is set to `true` when a predicate's return
	 * type cannot be specifically established, i.e., when it is only known to
	 * be `boolean`.
	 */
	ambiguous : boolean := false;
	/* `exact` is assigned only if an exact type can be established for the
	 * current call site. In particular, this occurs when a predicate's return
	 * type is `false's type` but `ambiguous` is not set. `exact` is set in only
	 * two cases: 1) every previous predicate answers `true's type` but the
	 * current predicate answers `false's type` and 2) no preceding predicate
	 * has answered `false's type` and no "else" action has been provided.
	 */
	exact : type;
	/* `union` tracks the general type of the expression. Every predicate that
	 * answers `boolean` prior to the first predicate that answers `false's
	 * type` should have its action's return type accumulated via type union
	 * with `union`. (Every predicate/action pair after the first that answers
	 * `false's type` may be ignored, as its action's return value does not
	 * participate in the final result.)
	 */
	union : type := ⊥;
	/* Handle `firstPredicate` specially (because it is lexically distinct from
	 * `elseIfTuple`).
	 */
	If firstPredicate = false's type then
	[
		exact := firstThen's return type;
	]
	else
	[
		/* If `firstPredicate` is `boolean`, then the expression is already
		 * ambiguous. Set the flag and begin accumulating the expression's type.
		 */
		If firstPredicate = boolean then
		[
			ambiguous := true;
			union := eject ↑union ∪ firstThen's return type;
		];
		elseUnlessTupleSize ::= relevant |elseUnlessTuple|;
		/* `keepLooping` tracks whether it is necessary to continue examining
		 * predicate/action pairs. It is set to `false` when a predicate is
		 * discovered that answers `true's type`. No predicate/action pairs
		 * beyond such a one participate in determination of the result type,
		 * i.e., they are guaranteed not to execute at runtime.
		 */
		keepLooping : boolean := true;
		From 1 to elseUnlessTupleSize do
		[
			index : natural number
		|
			elseUnless ::= elseUnlessTuple[index];
			predicateReturnType ::= elseUnless[1]'s return type;
			actionReturnType ::= elseUnless[2]'s return type;
			If ¬ambiguous ∧ [ predicateReturnType = true's type ] then
			[
				exact := actionReturnType;
			];
			keepLooping :=
				if ↑exact is assigned then
				[
					false
				]
				else
				[
					If predicateReturnType ≠ true's type then
					[
						ambiguous := true;
						union := eject ↑union ∪ actionReturnType;
					];
					/* If the predicate's return type is `false's type`, then we
					 * want to exit the loop early no matter what else has
					 * happened up to this point. No further predicate/action
					 * pairs can participate in determining a result.
					 */
					predicateReturnType ≠ (false's type)
				];
			keepLooping
		];
		/* Unless we exited the loop early (`keepLooping` = `false`), then we
		 * want to give the "else" action an opportunity to participate.
		 */
		If keepLooping then
		[
			If ⎣else⎦ = 1 then
			[
				elseReturnType ::= else[1]'s return type;
				If ¬ambiguous then
				[
					exact := elseReturnType;
				]
				else
				[
					union := eject ↑union ∪ elseReturnType;
				];
			]
			else
			[
				exact := ⊤;
			];
		];
	];
	/* Produce the final answer. */
	if ↑exact is assigned then
	[
		exact
	]
	else
	[
		if ambiguous then
		[
			union
		]
		else
		[
			⊤
		]
	]
];

/**
 * Basic conditional loop. Invoke `action`. If `action` answers `true`, then
 * repeat.
 * 
 * Parameters:
 *    action - The function to apply repeatedly. It must answer `true` if it
 *       should run again.
 */
Public method "While_" is
[
	action : []→boolean
|
	$loop;
	If action() then
	[
		Restart loop
	];
] : ⊤;

/**
 * If `action` certainly answers `true`, then answer ⊥ (because the loop will
 * run forever).
 */
Semantic restriction "While_" is
[
	action : []→boolean's type
|
	if action's return type = true's type then
	[
		⊥
	]
	else
	[
		⊤
	]
];

/**
 * Basic conditional loop. Invoke `action`. If `action` answers `false`, then
 * repeat.
 * 
 * Parameters:
 *    action - The function to apply repeatedly. It must answer `false` if it
 *       should run again.
 */
Public method "Until_" is
[
	action : []→boolean
|
	$loop;
	Unless action() then
	[
		Restart loop
	];
] : ⊤;

/**
 * If `action` certainly answers `false`, then answer ⊥ (because the loop will
 * run forever).
 */
Semantic restriction "Until_" is
[
	action : []→boolean's type
|
	if action's return type = false's type then
	[
		⊥
	]
	else
	[
		⊤
	]
];

/**
 * Basic conditional loop. Invoke `predicate`. If `predicate` answers `true`,
 * then invoke `action` and repeat.
 * 
 * Parameters:
 *    predicate - The function that guards repeated application of `action`.
 *    action - The function to apply whenever `predicate` answers `true`.
 */
Public method "While_do_" is
[
	predicate : []→boolean,
	action : []→⊤
|
	$loop;
	If predicate() then
	[
		action();
		Restart loop
	];
] : ⊤;

/**
 * If `predicate` certainly answers `true`, then answer ⊥ (because the loop will
 * run forever).
 */
Semantic restriction "While_do_" is
[
	predicate : []→boolean's type,
	action : []→⊤'s type
|
	if predicate's return type = true's type then
	[
		⊥
	]
	else
	[
		⊤
	]
];

/**
 * Basic conditional loop. Invoke `predicate`. If `predicate` answers `false`,
 * then invoke `action` and repeat.
 * 
 * Parameters:
 *    predicate - The function that guards repeated application of `action`.
 *    action - The function to apply whenever `predicate` answers `false`.
 */
Public method "Until_do_" is
[
	predicate : []→boolean,
	action : []→⊤
|
	$loop;
	Unless predicate() then
	[
		action();
		Restart loop
	];
] : ⊤;

/**
 * If `predicate` certainly answers `false`, then answer ⊥ (because the loop
 * will run forever).
 */
Semantic restriction "Until_do_" is
[
	predicate : []→boolean's type,
	action : []→⊤'s type
|
	if predicate's return type = false's type then
	[
		⊥
	]
	else
	[
		⊤
	]
];

/**
 * Basic conditional loop. Invoke `action` and then `predicate`. If `predicate`
 * answers `true`, then repeat.
 * 
 * Parameters:
 *    action - The function to apply once and then again whenever `predicate`
 *       answers `true`.
 *    predicate - The function that guards repeated application of `action`.
 */
Public method "Do_while_" is
[
	action : []→⊤,
	predicate : []→boolean
|
	$loop;
	action();
	If predicate() then
	[
		Restart loop
	];
] : ⊤;

/**
 * If `action` does not terminate or `predicate` certainly answers `true`, then
 * answer ⊥ (because the loop will run forever).
 */
Semantic restriction "Do_while_" is
[
	action : []→⊤'s type,
	predicate : []→boolean's type
|
	if action's return type = ⊥
		∨ [ predicate's return type = true's type ] then
	[
		⊥
	]
	else
	[
		⊤
	]
];

/**
 * Conditional loop with alternation. Invoke `action` and then `predicate`. If
 * `predicate` answers `true`, then invoke `between`. Then repeat.
 * 
 * Parameters:
 *    action - The function to apply once and then again repeatedly while
 *       `predicate` answers `true`.
 *    predicate - The function that guards repeated application of `action`.
 *    between - The function to apply between applications of `action`.
 */
Public method "Do_while_alternate with_" is
[
	action : []→⊤,
	predicate : []→boolean,
	between : []→⊤
|
	$loop;
	action();
	If predicate() then
	[
		between();
		Restart loop
	];
];

/**
 * If `action` does not terminate or `predicate` certainly answers `true`, then
 * answer ⊥ (because the loop will run forever).
 */
Semantic restriction "Do_while_alternate with_" is
[
	action : []→⊤'s type,
	predicate : []→boolean's type,
	between : []→⊤'s type
|
	if action's return type = ⊥
		∨ [ predicate's return type = true's type ] then
	[
		⊥
	]
	else
	[
		⊤
	]
];

/**
 * Basic conditional loop. Invoke `action` and then `predicate`. If `predicate`
 * answers `false`, then repeat.
 * 
 * Parameters:
 *    action - The function to apply once and then again whenever `predicate`
 *       answers `false`.
 *    predicate - The function that guards repeated application of `action`.
 */
Public method "Do_until_" is
[
	action : []→⊤,
	predicate : []→boolean
|
	$loop;
	action();
	Unless predicate() then
	[
		Restart loop
	];
] : ⊤;

/**
 * If `action` does not terminate or `predicate` certainly answers `false`, then
 * answer ⊥ (because the loop will run forever).
 */
Semantic restriction "Do_until_" is
[
	action : []→⊤'s type,
	predicate : []→boolean's type
|
	if action's return type = ⊥
		∨ [ predicate's return type = false's type ] then
	[
		⊥
	]
	else
	[
		⊤
	]
];

/**
 * Conditional loop with alternation. Invoke `action` and then `predicate`. If
 * `predicate` answers `false`, then invoke `between`. Then repeat.
 * 
 * Parameters:
 *    action - The function to apply once and then again repeatedly while
 *       `predicate` answers `false`.
 *    predicate - The function that guards repeated application of `action`.
 *    between - The function to apply between applications of `action`.
 */
Public method "Do_until_alternate with_" is
[
	action : []→⊤,
	predicate : []→boolean,
	between : []→⊤
|
	$loop;
	action();
	Unless predicate() then
	[
		between();
		Restart loop
	];
];

/**
 * If `action` does not terminate or `predicate` certainly answers `false`, then
 * answer ⊥ (because the loop will run forever).
 */
Semantic restriction "Do_until_alternate with_" is
[
	action : []→⊤'s type,
	predicate : []→boolean's type,
	between : []→⊤'s type
|
	if action's return type = ⊥
		∨ [ predicate's return type = false's type ] then
	[
		⊥
	]
	else
	[
		⊤
	]
];

/**
 * Invoke the first function of `caseTuple` that accepts `value`. If no such
 * function is specified, then invoke `else`. If `else` is not specified, then
 * do nothing.
 * 
 * Parameters:
 *    value - An arbitrary value.
 *    caseTuple - A tuple of arity-1 functions. The first of these able to
 *       accept `value` will be applied to it.
 *    else - An optional arity-0 function. If provided, then it will be invoked
 *       iff no function of `caseTuple` is able to accept `value`.
 * Returns:
 *    The result of whatever function is applied.
 */
Public method "Cast|cast_into«_‡or»«else_»" is
[
	value : any,
	caseTuple : <[⊥]→⊤…|2..>,
	else : <[]→⊤…|0..1>
|
	index : natural number := 1;
	[
		$body;
		if index > |caseTuple| then
		[
			if |else| = 0 then
			[
				/* Do nothing. */
			]
			else
			[
				invoke else[1] with <>;
			];
		]
		else if [ value ∈ caseTuple[index]'s type[1] ] then
		[
			invoke caseTuple[index] with <value>;
		]
		else
		[
			↑index++;
			Restart body
		];
	]();
] : ⊤;

/**
 * Strengthen the return type of `Cast|cast_into«_‡,»«else_»` so that it may be
 * used as a value-producing expression. If any case is unnecessary or invalid,
 * then reject the current parse.
 */
Semantic restriction "Cast|cast_into«_‡or»«else_»" is
[
	valueType : any meta,
	caseTuple : <[⊥]→⊤…|2..>'s type,
	else : <[]→⊤…|0..1>'s type
|
	acceptSize ::= relevant |caseTuple|;
	union : type := ⊥;
	From 1 to |acceptSize| do
	[
		index : natural number
	|
		functionType ::= caseTuple[index];
		If valueType ⊆ functionType[1] then
		[
			Reject parse, expected:
				"necessary cast expression, but "
				++ primitive description of valueType
				++ " is a subtype of "
				++ primitive description of functionType[1]
		];
		If valueType ∩ (functionType[1]) = ⊥ then
		[
			Reject parse, expected:
				"allowed cast expression, but "
				++ primitive description of valueType
				++ " is not a supertype of "
				++ primitive description of functionType[1]
		];
		union := eject ↑union ∪ functionType's return type;
	];
	If ⎣else⎦ = 1 then
	[
		union := eject ↑union ∪ else[1]'s return type;
	];
	union
];

/**
 * Case statement/expression. `enum` is an enumeration. `value` must be one of
 * the instances of `enum`. Choose the case corresponding to `value` and perform
 * its associated action. If no case corresponds to `value`, then perform the
 * `else` action. `else` must be provided unless `caseTuple` specifically
 * represents each value of `enum`.
 * 
 * Parameters:
 *    value - An instance of `enum`.
 *    enum - An enumeration.
 *    caseTuple - A tuple of 2-tuples whose first element is an instance of
 *       `enum` and whose second element is an arity-0 function. This function
 *       will be performed if `value` equals the first element.
 *    else - A tuple optionally containing the function to invoke if `value`
 *       does not match any of the cases. This represents the default case.
 * Returns:
 *    The return value of the chosen function.
 */
Public method "Choose|choose_from_where«_is_‡,»«,else_»" is
[
	value : any,
	enum : type,
	caseTuple : <<any, []→⊤…|2>…|1..>,
	else : <[]→⊤…|0..1>
|
	index : natural number := 1;
	[
		$body;
		if index > |caseTuple| then
		[
			if |else| = 0 then
			[
				/* Do nothing. */
			]
			else
			[
				invoke else[1] with <>;
			];
		]
		else if [ caseTuple[index][1] = value ] then
		[
			invoke caseTuple[index][2] with <>;
		]
		else
		[
			↑index++;
			Restart body
		];
	]();
] : ⊤;

/**
 * Reject the current parse unless all of the following are true:
 *
 * - `meta`'s sole instance is an enumeration.
 * - `valueType` is an instance of `meta`.
 * - Each case's selector is a statically known value.
 * - Each case's selector is an instance of the enumeration.
 * - Every value of the enumeration is handled by a case, either explicitly or
 *   implicitly by the default case.
 * - Each case's selector occurs only once.
 */
Semantic restriction "Choose|choose_from_where«_is_‡,»«,else_»" is
[
	valueType : any meta,
	meta : type's type,
	caseTuple : <<any, []→⊤…|2>…|1..>'s type,
	else : <[]→⊤…|0..1>'s type
|
	$body : type;
	If |meta| ≠ 1 ∨ [ ¬0 < |meta's instance| < ∞ ] then
	[
		Reject parse, expected: "enumeration to be statically known"
	];
	If ¬valueType ∈ meta then
	[
		Reject parse, expected:
			"case selector ("
			++ primitive description of valueType
			++ ") to be an instance of "
			++ primitive description of meta
	];
	enum ::= meta's instance;
	caseEnum : type := ⊥;
	union : type := ⊥;
	From 1 to relevant |caseTuple| do
	[
		index : natural number
	|
		case ::= caseTuple[index];
		If |case[1]| ≠ 1 then
		[
			Reject parse, expected:
				"all cases to be statically known values, but discovered "
				++ primitive description of case[1]
		];
		instance ::= case[1]'s instance;
		If ¬instance ∈ enum then
		[
			Reject parse, expected:
				"all cases to be instances of "
				++ primitive description of enum
				++ ", but "
				++ primitive description of instance
				++ " is not"
		];
		If case[1] ⊆ caseEnum then
		[
			Reject parse, expected:
				"each case to be unique, but "
				++ primitive description of instance
				++ " occurs more than once"
		];
		caseEnum := eject ↑caseEnum ∪ case[1];
		If |valueType| = 1 ∧ [ valueType = case[1] ] then
		[
			Exit body with case[2]'s return type
		];
		If valueType ∩ (case[1]) ≠ ⊥ then
		[
			union := eject ↑union ∪ case[2]'s return type;
		];
	];
	If caseEnum ≠ enum ∧ [ ⎣else⎦ ≠ 1 ] then
	[
		allCases ::= enum's instances;
		handledCases ::= caseEnum's instances;
		unhandledCases ::= allCases \ handledCases;
		Reject parse, expected:
			"all cases to be handled, but these cases are not: "
			++ primitive description of unhandledCases
	];
	If ¬valueType ⊆ caseEnum then
	[
		union := eject ↑union ∪ else[1]'s return type;
	];
	union
];
