/*
 * Control Structures.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Control Structures"
Versions
	"dev"
Extends
	"Early Control Structures" =
	(
		"(_)",
		"Exit_",
		"cast_into_else_",
		"cast_into_"
	)
Uses
	"Assertions",
	"Bootstrap",
	"Early Functions",
	"Early Maps",
	"Early Tuples",
	"Early Types",
	"Early Sets",
	"Literals",
	"Logic",
	"Math",
	"Variables"
Names
	"For each_do_",
	"From_to_by_do_",
	"From_to_do_",
	"filter_by_",
	"map_and_filter_by_",
	"map_through_"
Body

/**
 * Counting loop with customizable step and early exit support. Invoke `action`
 * once for every consecutive value = `start` + N × `step` ≤ `end`, aborting if
 * `action` answers `false` after an iteration.
 * 
 * Parameters:
 *    start - The start value, inclusive.
 *    end - The end value, inclusive.
 *    step - The amount by which to adjust the value after each iteration.
 *    action - A function that accepts a value in the specified range. If it
 *       answers `true`, then continue to iterate; if it answers `false`, then
 *       terminate iteration early.
 */
Method "From_to_by_do_" is
[
	start : (-∞..∞),
	end : (-∞..∞],
	step : [1..∞),
	action : [⊥]→boolean
|
	value : extended integer := start;
	[
		$loop : $[]→⊤;
		If value ≤ end then
		[
			continue ::= invoke action with <value>;
			value := eject ↑value + step;
			If continue then
			[
				Restart loop;
			];
		];
	]();
] : ⊤;

/**
 * If possible, then enforce that the specified function will accept all values
 * in the implied range. If the limit is definitely `∞` and the function
 * definitely answers `true`, then strengthen the return type to ⊥.
 * 
 * Parameters:
 *    start -
 *    end -
 *    step -
 *    action -
 */
Semantic restriction "From_to_by_do_" is
[
	start : (-∞..∞)'s type,
	end : (-∞..∞]'s type,
	step : [1..∞)'s type,
	action : [⊥]→boolean's type
|
	upper ::= end's upper bound;
	If action[1] ≠ ⊥ then
	[
		lower ::= start's lower bound;
		If lower ≤ upper then
		[
			values ::= (lower - 1..upper + 1);
			If ¬values ⊆ action[1] then
			[
				Reject parse, expected:
					"repeatedly applied function to accept all integers from "
					++ primitive description of lower
					++ " to "
					++ primitive description of upper
					++ " (but it only accepts "
					++ primitive description of action[1]
					++ ")";
			];
		];
	];
	if upper = ∞
		∧ [ end's lower bound = upper
		∧ [ action's return type = true's type; ]; ] then
	[
		⊥;
	]
	else
	[
		⊤;
	];
];

/**
 * Counting loop with customizable step and early exit support. Invoke `action`
 * once for every consecutive value = `start` + N × `step` ≥ `end`, aborting if
 * `action` answers `false` after an iteration.
 * 
 * Parameters:
 *    start - The start value, inclusive.
 *    end - The end value, inclusive.
 *    step - The amount by which to adjust the value after each iteration.
 *    action - A function that accepts a value in the specified range. If it
 *       answers `true`, then continue to iterate; if it answers `false`, then
 *       terminate iteration early.
 */
Method "From_to_by_do_" is
[
	start : (-∞..∞),
	end : [-∞..∞),
	step : (-∞..-1],
	action : [⊥]→boolean
|
	value : extended integer := start;
	[
		$loop : $[]→⊤;
		If value ≥ end then
		[
			continue ::= invoke action with <value>;
			value := eject ↑value + step;
			If continue then
			[
				Restart loop;
			];
		];
	]();
] : ⊤;

/**
 * If possible, then enforce that the specified function will accept all values
 * in the implied range. If the limit is definitely `∞` and the function
 * definitely answers `true`, then strengthen the return type to ⊥.
 * 
 * Parameters:
 *    start -
 *    end -
 *    step -
 *    action -
 */
Semantic restriction "From_to_by_do_" is
[
	start : (-∞..∞)'s type,
	end : [-∞..∞)'s type,
	step : (-∞..-1]'s type,
	action : [⊥]→boolean's type
|
	upper ::= start's upper bound;
	If action[1] ≠ ⊥ then
	[
		lower ::= end's lower bound;
		If lower ≤ upper then
		[
			values ::= (lower - 1..upper + 1);
			If ¬values ⊆ action[1] then
			[
				Reject parse, expected:
					"repeatedly applied function to accept all integers from "
					++ primitive description of lower
					++ " to "
					++ primitive description of upper
					++ " (but it only accepts "
					++ primitive description of action[1]
					++ ")";
			];
		];
	];
	if upper = ∞
		∧ [ end's lower bound = upper
		∧ [ action's return type = true's type; ]; ] then
	[
		⊥;
	]
	else
	[
		⊤;
	];
];

/**
 * Counting loop with customizable step. Invoke `action` once for every
 * consecutive value = `start` + N × `step` ≤ `end`.
 * 
 * Parameters:
 *    start - The start value, inclusive.
 *    end - The end value, inclusive.
 *    step - The amount by which to adjust the value after each iteration.
 *    action - A function that accepts a value in the specified range.
 */
Method "From_to_by_do_" is
[
	start : (-∞..∞),
	end : (-∞..∞],
	step : [1..∞),
	action : [⊥]→⊤
|
	From start to end by step do
	[
		value : extended integer
	|
		invoke action with <value>;
		true;
	];
];

/**
 * If possible, then enforce that the specified function will accept all values
 * in the implied range. If the limit is definitely `∞`, then strengthen the
 * return type to ⊥.
 * 
 * Parameters:
 *    start -
 *    end -
 *    step -
 *    action -
 */
Semantic restriction "From_to_by_do_" is
[
	start : (-∞..∞)'s type,
	end : (-∞..∞]'s type,
	step : [1..∞)'s type,
	action : [⊥]→⊤'s type
|
	upper ::= end's upper bound;
	If action[1] ≠ ⊥ then
	[
		lower ::= start's lower bound;
		If lower ≤ upper then
		[
			values ::= (lower - 1..upper + 1);
			If ¬values ⊆ action[1] then
			[
				Reject parse, expected:
					"repeatedly applied function to accept all integers from "
					++ primitive description of lower
					++ " to "
					++ primitive description of upper
					++ " (but it only accepts "
					++ primitive description of action[1]
					++ ")";
			];
		];
	];
	If upper = ∞ ∧ [ end's lower bound = upper; ] then
	[
		⊥;
	]
	else
	[
		⊤;
	];
];

/**
 * Counting loop with customizable step. Invoke `action` once for every
 * consecutive value = `start` + N × `step` ≥ `end`.
 * 
 * Parameters:
 *    start - The start value, inclusive.
 *    end - The end value, inclusive.
 *    step - The amount by which to adjust the value after each iteration.
 *    action - A function that accepts a value in the specified range.
 */
Method "From_to_by_do_" is
[
	start : (-∞..∞),
	end : [-∞..∞),
	step : (-∞..-1],
	action : [⊥]→⊤
|
	From start to end by step do
	[
		value : extended integer
	|
		invoke action with <value>;
		true;
	];
];

/**
 * If possible, then enforce that the specified function will accept all values
 * in the implied range. If the limit is definitely `∞`, then strengthen the
 * return type to ⊥.
 * 
 * Parameters:
 *    start -
 *    end -
 *    step -
 *    action -
 */
Semantic restriction "From_to_by_do_" is
[
	start : (-∞..∞)'s type,
	end : [-∞..∞)'s type,
	step : (-∞..-1]'s type,
	action : [⊥]→⊤'s type
|
	upper ::= end's upper bound;
	If action[1] ≠ ⊥ then
	[
		lower ::= start's lower bound;
		If lower ≤ upper then
		[
			values ::= (lower - 1..upper + 1);
			If ¬values ⊆ action[1] then
			[
				Reject parse, expected:
					"repeatedly applied function to accept all integers from "
					++ primitive description of lower
					++ " to "
					++ primitive description of upper
					++ " (but it only accepts "
					++ primitive description of action[1]
					++ ")";
			];
		];
	];
	if upper = ∞ ∧ [ end's lower bound = upper; ] then
	[
		⊥;
	]
	else
	[
		⊤;
	];
];

/**
 * Counting loop with early exit support. Invoke `action` once for every
 * consecutive number in the range established by `start` and `end`, aborting if
 * `action` answers `false` after an iteration.
 * 
 * Parameters:
 *    start - The start value, inclusive.
 *    end - The end value, inclusive.
 *    action - A function that accepts a value in the specified range. If it
 *       answers `true`, then continue to iterate; if it answers `false`, then
 *       terminate iteration early.
 */
Method "From_to_do_" is
[
	start : (-∞..∞),
	end : (-∞..∞],
	action : [⊥]→boolean
|
	From start to end by 1 do action;
];

/**
 * If possible, then enforce that the specified function will accept all values
 * in the implied range. If the limit is definitely `∞` and the function
 * definitely answers `true`, then strengthen the return type to ⊥.
 * 
 * Parameters:
 *    start -
 *    end -
 *    action -
 */
Semantic restriction "From_to_do_" is
[
	start : (-∞..∞)'s type,
	end : [-∞..∞)'s type,
	action : [⊥]→boolean's type
|
	upper ::= end's upper bound;
	If action[1] ≠ ⊥ then
	[
		lower ::= start's lower bound;
		If lower ≤ upper then
		[
			values ::= (lower - 1..upper + 1);
			If ¬values ⊆ action[1] then
			[
				Reject parse, expected:
					"repeatedly applied function to accept all integers from "
					++ primitive description of lower
					++ " to "
					++ primitive description of upper
					++ " (but it only accepts "
					++ primitive description of action[1]
					++ ")";
			];
		];
	];
	if upper = ∞
		∧ [ end's lower bound = upper
		∧ [ action's return type = true's type; ]; ] then
	[
		⊥;
	]
	else
	[
		⊤;
	];
];

/**
 * Counting loop with early exit support. Invoke `action` once for every
 * consecutive number in the range established by `start` and `end`.
 * 
 * Parameters:
 *    start - The start value, inclusive.
 *    end - The end value, inclusive.
 *    action - A function that accepts a value in the specified range.
 */
Method "From_to_do_" is
[
	start : (-∞..∞),
	end : (-∞..∞],
	action : [⊥]→⊤
|
	From start to end by 1 do
	[
		value : extended integer
	|
		invoke action with <value>;
		true;
	];
];

/**
 * If possible, then enforce that the specified function will accept all values
 * in the implied range. If the limit is definitely `∞`, then strengthen the
 * return type to ⊥.
 * 
 * Parameters:
 *    start -
 *    end -
 *    action -
 */
Semantic restriction "From_to_do_" is
[
	start : (-∞..∞)'s type,
	end : [-∞..∞)'s type,
	action : [⊥]→⊤'s type
|
	upper ::= end's upper bound;
	If action[1] ≠ ⊥ then
	[
		lower ::= start's lower bound;
		If lower ≤ upper then
		[
			values ::= (lower - 1..upper + 1);
			If ¬values ⊆ action[1] then
			[
				Reject parse, expected:
					"repeatedly applied function to accept all integers from "
					++ primitive description of lower
					++ " to "
					++ primitive description of upper
					++ " (but it only accepts "
					++ primitive description of action[1]
					++ ")";
			];
		];
	];
	if upper = ∞ ∧ [ end's lower bound = upper; ] then
	[
		⊥;
	]
	else
	[
		⊤;
	];
];

/**
 * Iteratively apply `action` to each consecutive element of `aTuple`.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    action - A function that accepts the elements of the tuple.
 */
Method "For each_do_" is
[
	aTuple : tuple,
	action : [⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	[
		$loop : $[]→⊤;
		If index ≤ end then
		[
			invoke action with <aTuple[index]>;
			↑index++;
			Restart loop;
		];
	]();
] : ⊤;

/**
 * Helper method for semantic restrictions: If `action` does not accept the
 * type union of all element types of `tupleType`, then reject the current
 * parse.
 * 
 * Parameters:
 *    action - A function type whose first argument must correspond to the
 *       type union of the element types of `tupleType`.
 *    tupleType - A tuple type.
 */
Method "Require:_accepts_" is
[
	action : function meta,
	tupleType : tuple meta
|
	union ::= ∪ tupleType[1..|tupleType's leading types| + 1];
	If ¬union ⊆ action[1] then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all elements of the tuple ∈ "
			++ primitive description of tupleType
			++ " (but it only accepts "
			++ primitive description of action[1]
			++ ")";
	];
] : ⊤;

/**
 * Ensure that the function will accept all elements of the tuple. If the tuple
 * is certainly nonempty and the function certainly does not complete if
 * applied, then answer ⊥.
 * 
 * Parameters:
 *    tupleType -
 *    action -
 * Returns:
 *    Either ⊤ or ⊥.
 */
Semantic restriction "For each_do_" is
[
	tupleType : tuple meta,
	action : [⊥]→⊤'s type
|
	Require: action accepts tupleType;
	if ||tupleType||'s lower bound > 0 ∧ [ action's return type = ⊥; ] then
	[
		⊥;
	]
	else
	[
		⊤;
	];
];

/**
 * Iteratively apply `action` to each element of `aSet`, but in no particular
 * order.
 * 
 * Parameters:
 *    aSet - A set.
 *    action - A function that accepts the elements of the set.
 */
Method "For each_do_" is
[
	aSet : set,
	action : [⊥]→⊤
|
	index : natural number := 1;
	aTuple ::= aSet→tuple;
	end ::= |aTuple|;
	[
		$loop : $[]→⊤;
		If index ≤ end then
		[
			invoke action with <aTuple[index]>;
			↑index++;
			Restart loop;
		];
	]();
] : ⊤;

/**
 * Helper method for semantic restrictions: If `action` does not accept the
 * element types of `setType`, then reject the current parse.
 * 
 * Parameters:
 *    action - A function type whose first argument must correspond to the
 *       element type of `setType`.
 *    setType - A set type.
 */
Method "Require:_accepts_" is
[
	action : function meta,
	setType : set meta
|
	If ¬setType's element type ⊆ action[1] then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all elements of the set ∈ "
			++ primitive description of setType
			++ " (but it only accepts "
			++ primitive description of action[1]
			++ ")";
	];
] : ⊤;

/**
 * Ensure that the function will accept all elements of the set. If the set is
 * certainly nonempty and the function certainly does not complete if applied,
 * then answer ⊥.
 * 
 * Parameters:
 *    setType -
 *    action -
 * Returns:
 *    Either ⊤ or ⊥.
 */
Semantic restriction "For each_do_" is
[
	setType : set meta,
	action : [⊥]→⊤'s type
|
	Require: action accepts setType;
	if ||setType||'s lower bound > 0 ∧ [ action's return type = ⊥; ] then
	[
		⊥;
	]
	else
	[
		⊤;
	];
];

/**
 * Iteratively apply `action` to each binding of `aMap`, but in no particular
 * order.
 * 
 * Parameters:
 *    aMap - A map.
 *    action - A function that accepts the bindings of the map. The first
 *       argument is a key from the map, the second is a value from the map.
 */
Method "For each_do_" is
[
	aMap : map,
	action : [⊥, ⊥]→⊤
|
	index : natural number := 1;
	bindings ::= aMap's bindings;
	end ::= |aMap|;
	[
		$loop : $[]→⊤;
		If index ≤ end then
		[
			binding ::= bindings[index];
			invoke action with <binding[1], binding[2]>;
			↑index++;
			Restart loop;
		];
	]();
] : ⊤;

/**
 * Helper method for semantic restrictions: If `action` does not accept the
 * key and value types of `mapType`, then reject the current parse.
 * 
 * Parameters:
 *    action - A function type whose first two arguments must correspond to the
 *       key and value types of `mapType`.
 *    mapType - A map type.
 */
Method "Require:_accepts_" is
[
	action : function meta,
	mapType : map meta
|
	If ¬mapType's key type ⊆ action[1] then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all keys ∈ "
			++ primitive description of mapType's key type
			++ " (but it only accepts "
			++ primitive description of action[1]
			++ ")";
	];
	If ¬mapType's value type ⊆ action[2] then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all values ∈ "
			++ primitive description of mapType's value type
			++ " (but it only accepts "
			++ primitive description of action[2]
			++ ")";
	];
] : ⊤;

/**
 * Ensure that the function will accept all bindings of the map. If the map is
 * certainly nonempty and the function certainly does not complete if applied,
 * then answer ⊥.
 * 
 * Parameters:
 *    mapType -
 *    action -
 * Returns:
 *    Either ⊤ or ⊥.
 */
Semantic restriction "For each_do_" is
[
	mapType : map meta,
	action : [⊥, ⊥]→⊤'s type
|
	Require: action accepts mapType;
	if ||mapType||'s lower bound > 0 ∧ [ action's return type = ⊥; ] then
	[
		⊥;
	]
	else
	[
		⊤;
	];
];

/**
 * Iteratively apply `transformer` to each consecutive element of `aTuple`,
 * collecting the results into a new tuple (and preserving ordering of the
 * transformed elements). Answer this tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    transformer - A function that accepts the elements of the tuple.
 * Returns:
 *    A tuple of results of applications of `transformer` to the elements of
 *    `aTuple`.
 */
Method "map_through_" is
[
	aTuple : tuple,
	transformer : [⊥]→any
|
	index : natural number := 1;
	result : tuple := <>;
	end ::= |aTuple|;
	[
		$loop : $[]→⊤;
		If index ≤ end then
		[
			result :=
				eject ↑result ++ <invoke transformer with <aTuple[index]>>;
			↑index++;
			Restart loop;
		];
	]();
	result;
] : tuple;

/**
 * Ensure that the function will accept all elements of the tuple. If the tuple
 * is certainly nonempty, then the function cannot answer ⊥.
 * 
 * Parameters:
 *    tupleType -
 *    transformer -
 * Returns:
 *    A tuple type with no leading types whose default type is the return type
 *    of `transformer` and whose cardinality is the same as `tupleType`'s.
 */
Semantic restriction "map_through_" is
[
	tupleType : tuple meta,
	transformer : [⊥]→any's type
|
	Require: transformer accepts tupleType;
	If ||tupleType||'s lower bound > 0 then
	[
		If transformer's return type = ⊥ then
		[
			Reject parse, expected:
				"repeatedly applied function to have a return type other than\
				\| ⊥";
		];
	];
	<<>, transformer's return type… | ||tupleType||>;
];

/**
 * Iteratively apply `transformer` to each element of `aSet`, collecting the
 * results into a new tuple. The set is traversed in no particular order. Answer
 * the resultant set.
 *
 * Parameters:
 *    aSet - A set.
 *    transformer - A function that accepts the elements of the set.
 * Returns:
 *    A set of results of applications of `transformer` to the elements of
 *    `aSet`.
 */
Method "map_through_" is
[
	aSet : set,
	transformer : [⊥]→any
|
	aTuple ::= aSet→tuple;
	index : natural number := 1;
	end ::= |aTuple|;
	result : set := ∅;
	[
		$loop : $[]→⊤;
		If index ≤ end then
		[
			result := eject ↑result + invoke transformer with <aTuple[index]>;
			↑index++;
			Restart loop;
		];
	]();
	result;
] : set;

/**
 * Ensure that the function will accept all elements of the set. If the set is
 * certainly nonempty, then the function cannot answer ⊥.
 *
 * Parameters:
 *    setType -
 *    transformer -
 * Returns:
 *    A set type whose element type is the return type of `transformer` and
 *    whose cardinality is the same as `setType`'s.
 */
Semantic restriction "map_through_" is
[
	setType : set meta,
	transformer : [⊥]→any's type
|
	Require: transformer accepts setType;
	If ||setType||'s lower bound > 0 then
	[
		If transformer's return type = ⊥ then
		[
			Reject parse, expected:
				"repeatedly applied function to have a return type other than\
				\| ⊥";
		];
	];
	{transformer's return type | ||setType||};
];

/**
 * Iteratively apply `transformer` to each binding of `aMap`, in no particular
 * order, collecting the results into a new map. The resultant map has the same
 * keys as the original, but its values have been transformed via `transformer`.
 * 
 * Parameters:
 *    aMap - A map.
 *    transformer - A function that accepts the bindings of the map. The first
 *       argument is a key from the map, the second is a value from the map.
 *       This function answers a replacement value for the given binding.
 * Returns:
 *    A map of results of applications of `transformer` to the elements of
 *    `aMap`.
 */
Method "map_through_" is
[
	aMap : map,
	transformer : [⊥, ⊥]→any
|
	index : natural number := 1;
	bindings ::= aMap's bindings;
	end ::= |aMap|;
	result : map := {};
	[
		$loop : $[]→⊤;
		If index ≤ end then
		[
			binding ::= bindings[index];
			key ::= binding[1];
			value ::= binding[2];
			result := eject ↑result + key→invoke transformer with <key, value>;
			↑index++;
			Restart loop;
		];
	]();
	result;
] : map;

/**
 * Ensure that the function will accept all bindings of the map. If the map is
 * certainly nonempty, then the function cannot answer ⊥.
 *
 * Parameters:
 *    mapType -
 *    transformer -
 * Returns:
 *    A map type whose key type is the key type of `mapType`, whose value
 *    type is the return type of `transformer`, and whose cardinality is the
 *    same as `mapType`'s.
 */
Semantic restriction "map_through_" is
[
	mapType : map meta,
	transformer : [⊥, ⊥]→any's type
|
	Require: transformer accepts mapType;
	If ||mapType||'s lower bound > 0 then
	[
		If transformer's return type = ⊥ then
		[
			Reject parse, expected:
				"repeatedly applied function to have a return type other than\
				\| ⊥";
		];
	];
	{mapType's key type → transformer's return type | ||mapType||};
];

/**
 * Iteratively apply `predicate` to each consecutive element of `aTuple`,
 * collecting those elements for which `predicate` answers `true` into a new
 * tuple (and preserving ordering). Answer the new tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    predicate - A function that accepts the elements of the tuple and answers
 *       `true` iff they should be accumulated into the output tuple.
 * Returns:
 *    A tuple containing exactly those elements of `aTuple` for which
 *    `predicate` answered `true`.
 */
Method "filter_by_" is
[
	aTuple : tuple,
	predicate : [⊥]→boolean
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop : $[]→⊤;
		If index ≤ end then
		[
			element ::= aTuple[index];
			If invoke predicate with <element> then
			[
				result := eject ↑result ++ <element>;
			];
			↑index++;
			Restart loop;
		];
	]();
	result;
] : tuple;

/**
 * Ensure that the function will accept all elements of the tuple.
 * 
 * Parameters:
 *    tupleType -
 *    predicate -
 * Returns:
 *    A tuple type whose leading and default types are the same as
 *    `tupleType`'s and which has cardinality
 *    `[0..||tupleType||'s upper bound + 1)`.
 */
Semantic restriction "filter_by_" is
[
	tupleType : tuple meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts tupleType;
	<
		tupleType's leading types,
		tupleType's default type…
		| [0..||tupleType||'s upper bound + 1)
	>;
];

/**
 * Iteratively apply `predicate` to each element of `aSet`, in no particular
 * order, collecting those elements for which `predicate` answers `true` into a
 * new set. Answer the new set.
 * 
 * Parameters:
 *    aSet - A set.
 *    predicate - A function that accepts the elements of the set and answers
 *       `true` iff they should be accumulated into the output set.
 * Returns:
 *    A set containing exactly those elements of `aSet` for which
 *    `predicate` answered `true`.
 */
Method "filter_by_" is
[
	aSet : set,
	predicate : [⊥]→boolean
|
	aTuple ::= aSet→tuple;
	index : natural number := 1;
	end ::= |aTuple|;
	result : set := ∅;
	[
		$loop : $[]→⊤;
		If index ≤ end then
		[
			element ::= aTuple[index];
			If invoke predicate with <element> then
			[
				result := eject ↑result + element;
			];
			↑index++;
			Restart loop;
		];
	]();
	result;
] : set;

/**
 * Ensure that the function will accept all elements of the set.
 *
 * Parameters:
 *    setType -
 *    predicate -
 * Returns:
 *    A set type whose element type is the same as `setType`'s and which has
 *    cardinality `[0..||setType||'s upper bound + 1)`.
 */
Semantic restriction "filter_by_" is
[
	setType : set meta,
	predicate : [⊥]→boolean's type
|
	Require: predicate accepts setType;
	{setType's element type | [0..||setType||'s upper bound + 1)};
];

/**
 * Iteratively apply `predicate` to each binding of `aMap`, in no particular
 * order, collecting those bindings for which `predicate` answers `true` into a
 * new map. Answer the new map.
 *
 * Parameters:
 *    aMap - A map.
 *    predicate - A function that accepts the bindings of the map and answers
 *       `true` iff they should be accumulated into the output map.
 * Returns:
 *    A map containing exactly those bindings of `aMap` for which `predicate`
 *    answered `true`.
 */
Method "filter_by_" is
[
	aMap : map,
	predicate : [⊥, ⊥]→boolean
|
	bindings ::= aMap's bindings;
	index : natural number := 1;
	end ::= |bindings|;
	result : map := {};
	[
		$loop : $[]→⊤;
		If index ≤ end then
		[
			binding ::= bindings[index];
			key ::= binding[1];
			value ::= binding[2];
			If invoke predicate with <key, value> then
			[
				result := eject ↑result + key→value;
			];
			↑index++;
			Restart loop;
		];
	]();
	result;
] : map;

/**
 * Ensure that the function will accept all elements of the map.
 * 
 * Parameters:
 *    mapType -
 *    predicate -
 * Returns:
 *    A map type whose key and value types are the same as `mapType`'s and which
 *    has cardinality `[0..||mapType||'s upper bound + 1)`.
 */
Semantic restriction "filter_by_" is
[
	mapType : map meta,
	predicate : [⊥, ⊥]→boolean's type
|
	Require: predicate accepts mapType;
	{
		mapType's key type → mapType's value type
		| [0..||mapType||'s upper bound)
	};
];

/**
 * Iteratively apply `accumulator` to the consecutive elements of `aTuple` in
 * order to transform and filter its elements into a new tuple. When
 * `accumulator` is invoked, it is passed a "keeper" function. The keeper
 * function may be invoked to "save" a particular value, i.e., a value that will
 * be copied into the output tuple. The keeper function will save at most one
 * value per element of `aTuple`, i.e., each time that `accumulator` is invoked,
 * it may invoke the keeper function at most one time. Answer the new tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    accumulator - A function that accepts 1) an element from `aTuple` and 2)
 *       a keeper function. The keeper function accepts an argument of the type
 *       that should be saved.
 * Returns:
 *    A tuple whose elements are those saved by the `accumulator`.
 */
Method "map and filter_by_" is
[
	aTuple : tuple,
	accumulator : [⊥, ⊥]→⊤
|
	index : natural number := 1;
	end ::= |aTuple|;
	result : tuple := <>;
	[
		$loop : $[]→⊤;
		If index ≤ end then
		[
			hasAlreadyKept : boolean := false;
			invoke accumulator with <
				aTuple[index],
				[
					transformed : any
				|
					If ¬hasAlreadyKept then
					[
						result := eject ↑result ++ <transformed>;
						hasAlreadyKept := true;
					];
				]
			>;
			↑index++;
			Restart loop;
		];
	]();
	result;
] : tuple;

/**
 * Helper method for semantic restrictions: If `action`'s last parameter does
 * not accept an arity-one procedure, then reject the current parse.
 * 
 * Parameters:
 *    action - A function type whose last parameter type must permit a
 *       one-argument procedure.
 *    tupleType - A tuple type.
 */
Method "Require:_'s keeper is valid" is
[
	action : function meta
|
	parametersType ::= action's parameters' type;
	parametersSizes ::= ||parametersType||;
	Assert: parametersSizes's lower bound = parametersSizes's upper bound
		("number of parameters cannot be determined");
	parametersSize ::= cast parametersSizes's lower bound
		into [ t : natural number | t; ];
	expectedType ::= [⊥]→⊤;
	If ¬action[parametersSize] ⊆ expectedType then
	[
		Reject parse, expected:
			"last argument ⊆ "
			++ primitive description of expectedType
			++ " (but instead it was "
			++ primitive description of action[parametersSize]
			++ ")";
	];
];

/**
 * Ensure that the function will accept all arguments of the tuple and also an
 * appropriately typed keeper function.
 *
 * Parameters:
 *    tupleType -
 *    accumulator -
 * Returns:
 *    A tuple type with no leading types whose default type is the argument type
 *    of the keeper function and whose cardinality is
 *    `[0..||tupleType||'s upper bound + 1)`.
 */
Semantic restriction "map and filter_by_" is
[
	tupleType : tuple meta,
	accumulator : [⊥, ⊥]→⊤'s type
|
	Require: accumulator accepts tupleType;
	Require: accumulator's keeper is valid;
	If accumulator's return type ≠ ⊤ then
	[
		Reject parse, expected:
			"repeatedly applied function to have a return type ⊤";
	];
	<
		<>,
		cast accumulator[2] into [ t : function meta | t[1]; ]…
		| [0..||tupleType||'s upper bound + 1)
	>;
];

/**
 * Iteratively apply `accumulator` to the elements of `aSet`, in no particular
 * order, in order to transform and filter its elements into a new set. When
 * `accumulator` is invoked, it is passed a "keeper" function. The keeper
 * function may be invoked to "save" a particular value, i.e., a value that will
 * be copied into the output set. The keeper function will save at most one
 * value per element of `aSet`, i.e., each time that `accumulator` is invoked,
 * it may invoke the keeper function at most one time. Answer the new set.
 * 
 * Parameters:
 *    aSet - A set.
 *    accumulator - A function that accepts 1) an element from `aSet` and 2)
 *       a keeper function. The keeper function accepts an argument of the type
 *       that should be saved.
 * Returns:
 *    A set whose elements are those saved by the `accumulator`.
 */
Method "map and filter_by_" is
[
	aSet : set,
	accumulator : [⊥, ⊥]→⊤
|
	aTuple ::= aSet→tuple;
	index : natural number := 1;
	end ::= |aTuple|;
	result : set := ∅;
	[
		$loop : $[]→⊤;
		If index ≤ end then
		[
			hasAlreadyKept : boolean := false;
			invoke accumulator with <
				aTuple[index],
				[
					transformed : any
				|
					If ¬hasAlreadyKept then
					[
						result := eject ↑result + transformed;
						hasAlreadyKept := true;
					];
				]
			>;
			↑index++;
			Restart loop;
		];
	]();
	result;
] : set;

/**
 * Ensure that the function will accept all arguments of the set and also an
 * appropriately typed keeper function.
 *
 * Parameters:
 *    setType -
 *    accumulator -
 * Returns:
 *    A set type whose element type is the argument type of the keeper function
 *    and whose cardinality is `[0..||setType||'s upper bound + 1)`.
 */
Semantic restriction "map and filter_by_" is
[
	setType : set meta,
	accumulator : [⊥, ⊥]→⊤'s type
|
	Require: accumulator accepts setType;
	Require: accumulator's keeper is valid;
	If accumulator's return type ≠ ⊤ then
	[
		Reject parse, expected:
			"repeatedly applied function to have a return type ⊤";
	];
	{
		cast accumulator[2] into [ t : function meta | t[1]; ]
		| [0..||setType||'s upper bound + 1)
	};
];

/**
 * Iteratively apply `accumulator` to the bindings of `aMap`, in no particular
 * order, in order to transform and filter its bindings into a new map. When
 * `accumulator` is invoked, it is passed a "keeper" function. The keeper
 * function may be invoked to "save" a particular value, i.e., a value that will
 * be associated with the current key in the output set. The keeper function
 * will save at most one value per binding of `aSet`, i.e., each time that
 * `accumulator` is invoked, it may invoke the keeper function at most one time.
 * Answer the new map.
 * 
 * Parameters:
 *    aMap - A map.
 *    accumulator - A function that accepts 1) a key from `aMap`, 2) the value
 *       associated with that key, and 3) a keeper function. The keeper function
 *       accepts an argument of the (value) type that should be saved.
 * Returns:
 *    A map whose bindings are those saved by the `accumulator`.
 */
Method "map and filter_by_" is
[
	aMap : map,
	accumulator : [⊥, ⊥, ⊥]→⊤
|
	bindings ::= aMap's bindings;
	index : natural number := 1;
	end ::= |bindings|;
	result : map := {};
	[
		$loop : $[]→⊤;
		If index ≤ end then
		[
			hasAlreadyKept : boolean := false;
			binding ::= bindings[index];
			key ::= binding[1];
			value ::= binding[2];
			invoke accumulator with <
				key,
				value,
				[
					transformed : any
				|
					If ¬hasAlreadyKept then
					[
						result := eject ↑result + key→transformed;
						hasAlreadyKept := true;
					];
				]
			>;
			↑index++;
			Restart loop;
		];
	]();
	result;
] : map;

/**
 * Ensure that the function will accept all bindings of the map and also an
 * appropriately typed keeper function.
 *
 * Parameters:
 *    mapType -
 *    accumulator -
 * Returns:
 *    A map type whose key type is the key type of `mapType`, whose value type
 *    is the parameter type of the keeper function, and whose cardinality is
 *    `[0..||mapType||'s upper bound + 1)`.
 */
Semantic restriction "map and filter_by_" is
[
	mapType : map meta,
	accumulator : [⊥, ⊥, ⊥]→⊤'s type
|
	Require: accumulator accepts mapType;
	Require: accumulator's keeper is valid;
	If accumulator's return type ≠ ⊤ then
	[
		Reject parse, expected:
			"repeatedly applied function to have a return type ⊤";
	];
	valueType ::= cast accumulator[3] into [ t : function meta | t[1]; ];
	{
		mapType's key type → valueType
		| [0..||mapType||'s upper bound + 1)
	};
];
