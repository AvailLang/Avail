/*
 * Early Tuples.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Early Tuples"
Versions
	"dev"
Extends
Uses
	"Bootstrap",
	"Definers",
	"Early Control Structures",
	"Early Logic",
	"Early Math",
	"Enumeration Support",
	"Literals",
	"Variables"
Names
	"relevant`|_`|",
	"«_‡++»",
	"_[_..]",
	"_[.._]",

	/* Exported for use by Tuples. */
	"Require:_[_.._]is ever valid",
	"tuple type of_[_.._]"
Body

/**
 * Strengthen `_'s⁇default type`.
 * 
 * Parameters:
 *    meta -
 * Return:
 *    The tuple type's default type's type.
 */
Semantic restriction "_'s⁇default type" is
[
	meta : tuple meta's type
|
	meta's instance's default type's type
];

/**
 * Strengthen concatenation of tuple types. This is the most specific type whose
 * instance encompasses all possible concatenations of the two types.
 * 
 * Parameters:
 *    metaA -
 *    metaB -
 * Returns:
 *    The strengthened tuple metatype.
 */
Semantic restriction "_++_" is
[
	metaA : tuple meta's type,
	metaB : tuple meta's type
|
	typeA ::= metaA's instance;
	typeB ::= metaB's instance;
	(typeA ++ typeB)'s type
];

/* Make tuple type concatenation left-associative. */
Grammatical restriction {"_++_"} is <∅, {"_++_"}>;

/**
 * Concatenate the lexically specified tuples. Answer the result.
 * 
 * Parameters:
 *    tuples - Some tuples.
 * Returns:
 *    The result of concatenating the lexically specified tuples left-to-right.
 */
Public method "«_‡++»" is
[
	tuples : <<>, tuple…|[2..∞)>
|
	concatenate tuples
] : tuple;

/* Don't parse `«_‡++»` recursively. */
Grammatical restriction "«_‡++»" is <{"«_‡++»"}>;

/**
 * Strengthen the lexical tuple concatenation operation.
 * 
 * Parameters:
 *    tuplesType -
 * Returns:
 *    The strongest type available for the argument type.
 */
Semantic restriction "«_‡++»" is
[
	tuplesType : <<>, tuple…|[2..∞)>'s type
|
	result : tuple meta := <>'s type;
	From 1 to ⎡tuplesType⎤ do
	[
		index : natural number
	|
		result := eject ↑result ++ tuplesType[index];
		true
	];
	result
];

/**
 * Compute and answer the minimum size of `tupleType` for efficient traversal of
 * its relevant element types.
 * 
 * Parameters:
 *    tupleType - A tuple type.
 * Returns:
 *    The smaller of the lower bound of the argument's cardinality and one more
 *    than the size of its leading types.
 */
Public method "relevant`|_`|" is
[
	tupleType : tuple meta
|
	lower ::= ⎣tupleType⎦ max 0;
	count ::= |tupleType's leading types| + 1;
	cast lower min count into [ t : whole number | t ]
] : whole number;

/**
 * There are no relevant element types when the tuple type is ⊥.
 * 
 * Parameters:
 *    tupleType - ⊥.
 * Returns:
 *    0.
 */
Public method "relevant`|_`|" is
[
	tupleType : ⊥'s type
|
	0
] : 0's type;

/**
 * Check that the tuple type and start and end subscript ranges could ever be
 * statically valid. Reject the current parse if they are never valid together.
 * 
 * Parameters:
 *    aTuple - A tuple type.
 *    sliceStart - The integral range of the start subscript.
 *    sliceEnd - The integral range of the end subscript.
 */
Public method "Require:_[_.._]is ever valid" is
[
	aTuple : tuple meta,
	sliceStart : natural number's type,
	sliceEnd : whole number's type
|
	If ⎣sliceStart⎦ > ⎡aTuple⎤ then
	[
		Reject parse, expected:
			"a subscript ("
			++ primitive description of ⎣sliceStart⎦
			++ " ≤ sliceStart ≤ "
			++ primitive description of ⎡sliceStart⎤
			++ ") that could ever be valid ("
			++ primitive description of ⎣aTuple⎦
			++ " ≤ |theTuple| ≤ "
			++ primitive description of ⎡aTuple⎤
			++ ")"
	];
	If ⎣sliceEnd⎦ > ⎡aTuple⎤ then
	[
		Reject parse, expected:
			"a subscript ("
			++ primitive description of ⎣sliceEnd⎦
			++ " ≤ sliceEnd ≤ "
			++ primitive description of ⎡sliceEnd⎤
			++ ") that could ever be valid ("
			++ primitive description of ⎣aTuple⎦
			++ " ≤ |theTuple| ≤ "
			++ primitive description of ⎡aTuple⎤
			++ ")"
	];
	If ⎡sliceEnd⎤ < ⎣sliceStart⎦ - 1 then
	[
		Reject parse, expected:
			"a slice end subscript ("
			++ primitive description of ⎣sliceEnd⎦
			++ " ≤ theEndSubscript ≤ "
			++ primitive description of ⎡sliceEnd⎤
			++ ") not guaranteed more than one less than the start\
			\| subscript ("
			++ primitive description of ⎣sliceStart⎦
			++ " ≤ theStartSubscript ≤ "
			++ primitive description of ⎡sliceStart⎤
			++ ")"
	];
] : ⊤;

/**
 * Construct and answer the tuple type that represents the specified tuple
 * slice.
 * 
 * Parameters:
 *    aTupleType - A tuple type.
 *    sliceStart - The type of the slice start subscript.
 *    sliceEnd - The type of the slice end subscript.
 * Returns:
 *    The strongest tuple type that can be constructed from the argument types.
 */
Public method "tuple type of_[_.._]" is
[
	aTupleType : tuple meta,
	sliceStart : natural number's type,
	sliceEnd : whole number's type
|
	Require: aTupleType[sliceStart..sliceEnd] is ever valid;
	minStart ::= 1 max ⎣sliceStart⎦;
	maxStart ::= 1 max ⎡sliceStart⎤;
	minEnd ::= 0 max ⎣sliceEnd⎦;
	maxEnd ::= 0 max ⎡sliceEnd⎤;
	tupleEnd ::= ⎡aTupleType⎤;
	tupleDefaultTypeIndex ::= cast |aTupleType's leading types| + 1
		into [ t : natural number | t ];
	limit ::= maxEnd min tupleEnd min tupleDefaultTypeIndex;
	minLoopStart ::= (minStart min limit) max 1;
	maxLoopStart ::= (maxStart min limit) max 1;
	smearDelta ::= cast maxLoopStart - minLoopStart
		into [ t : whole number | t ];
	/* Build a tuple that represents the leading and default types of the
	 * resultant tuple type. Each element is the type union of the smear of
	 * element types within `smearDelta` of the traversal subscript.
	 */
	types : tuple of any meta := <>;
	From minLoopStart to limit do
	[
		i : natural number
	|
		union : type := ⊥;
		smearEnd ::= cast (i + smearDelta) min limit
			into [ t : natural number | t ];
		From i to smearEnd do
		[
			j : natural number
		|
			union := eject ↑union ∪ aTupleType[j];
			true
		];
		types := cast concatenate <types, <union>>
			into [ t : tuple of any meta | t ];
		true
	];
	/* Unless `types` is empty, the last element is the default type. */
	defaultType ::= cast |types|
		into [ n : natural number | types[n] ]
		else [ ⊥ ];
	resultMinEnd ::= minEnd min tupleEnd;
	resultMaxEnd ::= maxEnd min tupleEnd;
	resultStart ::= cast (resultMinEnd - maxStart + 1) max 0
		into [ t : whole number | t ];
	resultEnd ::= cast ((resultMaxEnd - minStart + 1) max 0) + 1
		into [ t : [1..∞] | t ];
	resultSizes ::= [resultStart..resultEnd);
	result ::= <types, defaultType…|resultSizes>;
	result
] : tuple meta;

Method "_[_.._]" is stable at
	function accepting <tuple, natural number, whole number>
	and returning tuple;

/**
 * Strengthen the tuple type procuded by `_[_.._]` to the strongest possible
 * given the argument types.
 *
 * Parameters:
 *    aTupleType -
 *    sliceStart -
 *    sliceEnd -
 * Returns:
 *    The strengthened tuple type.
 */
Semantic restriction "_[_.._]" is
[
	aTupleType : tuple meta,
	sliceStart : natural number's type,
	sliceEnd : whole number's type
|
	tuple type of aTupleType[sliceStart..sliceEnd]
];

/**
 * Construct and answer a slice (i.e., tuple type) that begins at subscript
 * `sliceStart` and continues to the end of the tuple type.
 * 
 * Parameters:
 *    aTupleType - A tuple type.
 *    sliceStart - The one-based start index (inclusive) of the desired slice.
 * Returns:
 *    The requested tuple.
 */
Public method "_[_..]" is
[
	aTupleType : tuple meta,
	sliceStart : natural number
|
	aTupleType[sliceStart..relevant |aTupleType|]
] : tuple of any meta;

/**
 * Construct and answer a slice (i.e., subtuple) that begins at subscript
 * `sliceStart` and continues to the end of the tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    sliceStart - The one-based start index (inclusive) of the desired slice.
 * Returns:
 *    The requested tuple.
 */
Public stable method "_[_..]" is
[
	aTuple : tuple,
	sliceStart : natural number
|
	aTuple[sliceStart..|aTuple|]
] : tuple;

/**
 * Strengthen the tuple type procuded by `_[_..]` to the strongest possible
 * given the argument types.
 *
 * Parameters:
 *    aTupleType -
 *    sliceStart -
 * Returns:
 *    The strengthened tuple type.
 */
Semantic restriction "_[_..]" is
[
	aTupleType : tuple meta,
	sliceStart : natural number's type
|
	tuple type of aTupleType[sliceStart..||aTupleType||]
];

/**
 * Construct and answer a slice (i.e., tuple type) that begins at the start of
 * the tuple type and continues to subscript `sliceEnd`.
 * 
 * Parameters:
 *    aTupleType - A tuple type.
 *    sliceEnd - The one-based end index (inclusive) of the desired slice.
 * Returns:
 *    The requested tuple.
 */
Public method "_[.._]" is
[
	aTupleType : tuple meta,
	sliceEnd : whole number
|
	aTupleType[1..sliceEnd]
] : tuple;

/**
 * Construct and answer a slice (i.e., subtuple) that begins at the start of the
 * tuple and continues to subscript `sliceEnd`.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    sliceEnd - The one-based end index (inclusive) of the desired slice.
 * Returns:
 *    The requested tuple.
 */
Public stable method "_[.._]" is
[
	aTuple : tuple,
	sliceEnd : whole number
|
	aTuple[1..sliceEnd]
] : tuple;

/**
 * Strengthen the tuple type procuded by `_[.._]` to the strongest possible
 * given the argument types.
 *
 * Parameters:
 *    aTupleType -
 *    sliceEnd -
 * Returns:
 *    The strengthened tuple type.
 */
Semantic restriction "_[.._]" is
[
	aTupleType : tuple meta,
	sliceEnd : whole number's type
|
	tuple type of aTupleType[1's type..sliceEnd]
];

/** Bind subscripting and slicing tighter than concatenation. */
Grammatical restriction {"_[_]", "_[_..]", "_[.._]"} is <{"«_‡++»"}, ∅>;
Grammatical restriction "_[_.._]" is <{"«_‡++»"}, ∅, ∅>;

Method "concatenate_" is stable at
	function accepting <tuple of tuple> and returning tuple;

Semantic restriction "concatenate_" is
[
	tupleType : tuple of tuple's type
|
	sizes ::= ||tupleType||;
	limit ::=
		if ⎡sizes⎤ is infinite then
		[
			⎣sizes⎦ max (cast |tupleType's leading types| + 1
				into [ t : natural number | t ])
		]
		else
		[
			⎡sizes⎤
		];
	result : tuple meta := <>'s type;
	From 1 to limit do
	[
		index : natural number
	|
		result := eject ↑result ++ tupleType[index];
		true
	];
	If ⎡sizes⎤ is infinite then
	[
		slice ::= result[1 ..
			cast ⎡result⎤ into [ t : whole number | t ]];
		default ::= tupleType's default type;
		union ::= ∪ default[1 ..
			cast |default's leading types| + 1 into [ t : whole number | t ]];
		result := <slice, union… | [⎣result⎦..∞)>;
	];
	result
];

Method "_→set" is stable at function accepting <tuple> and returning set;

/**
 * It's extremely hard to provide a strong bound for set conversion without
 * chromatic polynomials, and even then it's still expensive. Provide a simple
 * strengthening: the resulting element type is the type union of all tuple
 * element types.
 */
Semantic restriction "_→set" is
[
	tupleType : tuple meta
|
	/* If the tuple could be empty, then so could the set. Otherwise, the
	 * set must contain at least one element.
	 */
	lower ::= ⎣tupleType⎦ min 1;
	typeLimit ::= cast |tupleType's leading types| + 1
		into [ t : natural number | t ];
	{∪ tupleType[1..typeLimit] | [lower..⎡tupleType⎤ + 1)}
];

Method "_→map" is stable at
	function accepting <key-value tuple> and returning map;

Semantic restriction "_→map" is
[
	tupleType : key-value tuple's type
|
	/* If the tuple could be empty, then so could the map. Otherwise, the
	 * map must contain at least one element.
	 */
	lower ::= ⎣tupleType⎦ min 1;
	typeLimit ::= cast |tupleType's leading types| + 1
		into [ t : natural number | t ];
	{tupleType[1][1]→tupleType[1][2] | [lower..⎡tupleType⎤ + 1)}
];

/* Disambiguate `_→_` and `_→tuple`. */
Grammatical restriction "_→_" is <∅, {"tuple"}>;
