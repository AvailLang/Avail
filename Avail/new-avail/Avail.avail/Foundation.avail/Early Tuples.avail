/*
 * Early Tuples.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Early Tuples"
Versions
	"dev"
Extends
Uses
	"Bootstrap",
	"Early Control Structures",
	"Early Logic",
	"Early Math",
	"Enumeration Support",
	"Literals",
	"Variables"
Names
	"relevant|_|",
	"«_‡++»",
	"_[_..]",
	"_[.._]"
Body

/**
 * Strengthen `_'s⁇default type`.
 * 
 * Parameters:
 *    meta -
 * Return:
 *    The tuple type's default type's type.
 */
Semantic restriction "_'s⁇default type" is
[
	meta : tuple meta's type
|
	meta's instance's default type's type;
];

/**
 * Strengthen concatenation of tuple types. This is the most specific type whose
 * instance encompasses all possible concatenations of the two types.
 * 
 * Parameters:
 *    metaA -
 *    metaB -
 * Returns:
 *    The strengthened tuple metatype.
 */
Semantic restriction "_++_" is
[
	metaA : tuple meta's type,
	metaB : tuple meta's type
|
	typeA ::= metaA's instance;
	typeB ::= metaB's instance;
	(typeA ++ typeB)'s type;
];

/**
 * Concatenate the lexically specified tuples. Answer the result.
 * 
 * Parameters:
 *    tuples - Some tuples.
 * Returns:
 *    The result of concatenating the lexically specified tuples left-to-right.
 */
Method "«_‡++»" is
[
	tuples : <<>, tuple…|[2..∞)>
|
	concatenate tuples;
] : tuple;

/* Don't parse `«_‡++»` recursively. */
Grammatical restriction {"«_‡++»"} is <{"«_‡++»"}>;

/**
 * Strengthen the lexical tuple concatenation operation.
 * 
 * Parameters:
 *    tuplesType -
 * Returns:
 *    The strongest type available for the argument type.
 */
Semantic restriction "«_‡++»" is
[
	tuplesType : <<>, tuple…|[2..∞)>'s type
|
	result : tuple meta := <>'s type;
	exactSize ::= cast ||tuplesType||'s upper bound
		into [ t : natural number | t; ];
	From 1 to exactSize do
	[
		index : natural number
	|
		result := eject ↑result ++ tuplesType[index];
		true;
	];
	result;
];
	
/**
 * This private helper method is essentially the implementation of the semantic
 * restrictions of `_[_.._]`, `_[_..]`, and `_[.._]`.
 * 
 * Parameters:
 *    aTupleType - A tuple type.
 *    sliceStart - The type of the slice start subscript.
 *    sliceEnd - The type of the slice end subscript.
 * Returns:
 *    The strongest tuple type that can be constructed from the argument types.
 */
Method "tuple type of_[_.._]" is
[
	aTupleType : tuple meta,
	sliceStart : natural number's type,
	sliceEnd : whole number's type
|
	minStart ::= 1 max sliceStart's lower bound;
	maxStart ::= 1 max sliceStart's upper bound;
	minEnd ::= 0 max sliceEnd's lower bound;
	maxEnd ::= 0 max sliceEnd's upper bound;
	tupleEnd ::= ||aTupleType||'s upper bound;
	/* If all possible slices are out of bounds, then answer ⊥. */
	If minEnd > tupleEnd then
	[
		Reject parse, expected:
			"a subscript ("
			++ primitive description of minEnd
			++ " ≤ sliceEnd ≤ "
			++ primitive description of maxEnd
			++ ") that could ever be valid ("
			++ primitive description of ||aTupleType||'s lower bound
			++ " ≤ |theTuple| ≤ "
			++ primitive description of tupleEnd
			++ ")";
	];
	If minStart - maxEnd > 1 then
	[
		Reject parse, expected:
			"the lower bound of the slice start subscript ("
			++ primitive description of minStart
			++ ") not to exceed the upper bound of the slice end subscript ("
			++ primitive description of maxEnd
			++ ") by more than 1";
	];
	tupleDefaultTypeIndex ::= cast |aTupleType's leading types| + 1
		into [ t : natural number | t; ];
	limit ::= maxEnd min tupleEnd min tupleDefaultTypeIndex;
	minLoopStart ::= (minStart min limit) max 1;
	maxLoopStart ::= (maxStart min limit) max 1;
	smearDelta ::= cast maxLoopStart - minLoopStart
		into [ t : whole number | t; ];
	/* Build a tuple that represents the leading and default types of the
	 * resultant tuple type. Each element is the type union of the smear of
	 * element types within `smearDelta` of the traversal subscript.
	 */
	types : tuple of any meta := <>;
	From minLoopStart to limit do
	[
		i : natural number
	|
		union : type := ⊥;
		smearEnd ::= cast (i + smearDelta) min limit
			into [ t : natural number | t; ];
		From i to smearEnd do
		[
			j : natural number
		|
			union := union ∪ aTupleType[j];
			true;
		];
		types := cast concatenate <types, <union>>
			into [ t : tuple of any meta | t; ];
		true;
	];
	/* Unless `types` is empty, the last element is the default type. */
	defaultType ::= cast |types|
		into [ n : natural number | types[n]; ]
		else [ ⊥; ];
	resultMinStart ::= minStart min tupleEnd;
	resultMaxStart ::= maxStart min tupleEnd;
	resultMinEnd ::= minEnd min tupleEnd;
	resultMaxEnd ::= maxEnd min tupleEnd;
	resultStart ::= cast (resultMinEnd - resultMaxStart + 1) max 0
		into [ t : whole number | t; ];
	resultEnd ::= cast ((resultMaxEnd - resultMinStart + 1) max 0) + 1
		into [ t : [1..∞] | t; ];
	resultSizes ::= [resultStart..resultEnd);
	result ::= <types, defaultType…|resultSizes>;
	result;
] : type;

/**
 * Strengthen the tuple type procuded by `_[_.._]` to the strongest possible
 * given the argument types.
 *
 * Parameters:
 *    aTupleType -
 *    sliceStart -
 *    sliceEnd -
 * Returns:
 *    The strengthened tuple type.
 */
Semantic restriction "_[_.._]" is
[
	aTupleType : tuple meta,
	sliceStart : natural number's type,
	sliceEnd : whole number's type
|
	tuple type of aTupleType[sliceStart..sliceEnd];
];

/**
 * Construct and answer a slice (i.e., subtuple) that begins at subscript
 * `sliceStart` and continues to the end of the tuple.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    sliceStart - The one-based start index (inclusive) of the desired slice.
 * Returns:
 *    The requested tuple.
 */
Method "_[_..]" is
[
	aTuple : tuple,
	sliceStart : natural number
|
	aTuple[sliceStart..|aTuple|];
] : any;

/**
 * Strengthen the tuple type procuded by `_[_..]` to the strongest possible
 * given the argument types.
 *
 * Parameters:
 *    aTupleType -
 *    sliceStart -
 * Returns:
 *    The strengthened tuple type.
 */
Semantic restriction "_[_..]" is
[
	aTupleType : tuple meta,
	sliceStart : natural number's type
|
	tuple type of aTupleType[sliceStart..||aTupleType||];
];

/**
 * Construct and answer a slice (i.e., subtuple) that begins at the start of the
 * tuple and continues to subscript `sliceEnd`.
 * 
 * Parameters:
 *    aTuple - A tuple.
 *    sliceEnd - The one-based end index (inclusive) of the desired slice.
 * Returns:
 *    The requested tuple.
 */
Method "_[.._]" is
[
	aTuple : tuple,
	sliceEnd : whole number
|
	aTuple[1..sliceEnd];
] : any;

/**
 * Strengthen the tuple type procuded by `_[.._]` to the strongest possible
 * given the argument types.
 *
 * Parameters:
 *    aTupleType -
 *    sliceEnd -
 * Returns:
 *    The strengthened tuple type.
 */
Semantic restriction "_[.._]" is
[
	aTupleType : tuple meta,
	sliceEnd : whole number's type
|
	tuple type of aTupleType[1's type..sliceEnd];
];

/**
 * Strengthen `concatenate_`.
 * 
 * Parameters:
 *     tupleType -
 * Returns:
 *     The strongest possible type of the resulting tuple.
 */
Semantic restriction "concatenate_" is
[
	tupleType : tuple of tuple's type
|
	sizes ::= ||tupleType||;
	limit ::=
		if sizes' upper bound is infinite then
		[
			sizes' lower bound max (cast |tupleType's leading types| + 1
				into [ t : natural number | t; ]);
		]
		else
		[
			sizes' upper bound;
		];
	result : tuple meta := <>'s type;
	From 1 to limit do
	[
		index : natural number
	|
		result := eject ↑result ++ tupleType[index];
		true;
	];
	If sizes' upper bound is infinite then
	[
		slice ::= result[1 ..
			cast ||result||'s upper bound into [ t : whole number | t; ]];
		default ::= tupleType's default type;
		union ::= ∪ default[1 ..
			cast |default's leading types| + 1 into [ t : whole number | t; ]];
		result := <slice, union… | [||result||'s lower bound..∞)>;
	];
	result;
];

/**
 * Compute and answer the minimum size of `tupleType` for efficient traversal of
 * its relevant element types.
 * 
 * Parameters:
 *    tupleType - A tuple type.
 * Returns:
 *    The smaller of the argument's cardinality's lower bound and one more than
 *    the size of its leading types.
 */
Method "relevant|_|" is
[
	tupleType : tuple meta
|
	cast
		||tupleType||'s lower bound min (|tupleType's leading types| + 1)
	into [ t : whole number | t; ];
] : whole number;

/* Disambiguate `_→_` and `_→tuple`. */
Grammatical restriction {"_→_"} is <∅, {"tuple"}>;
