/*
 * Math.avail
 * Copyright ¬© 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Math"
Versions
	"dev"
Extends
	"Early Math"
Uses
	"Bootstrap",
	"Definers",
	"Early Assertions",
	"Early Control Structures",
	"Early Error Codes",
	"Early Functions",
	"Early Logic",
	"Early Sets",
	"Enumeration Support",
	"Literals",
	"Types",
	"Variables"
Names
	"log_of_",
	"_is odd",
	"_is even",
	"-_",
	"ùõë",
	"¬´_‚Ä°¬´=¬ª?¬´‚â§¬ª?¬´<¬ª?¬ª",
	"¬´_‚Ä°¬´=¬ª?¬´‚â•¬ª?¬´>¬ª?¬ª"
Body

Forward method "_mod_" is [number, number]‚Üínumber;
Public stable forward method "-_" is [number]‚Üínumber;

/* Establish grammatical rules. */
[
	ext      ::= {"¬´_‚Ä°max¬ª", "¬´_‚Ä°min¬ª"};
	sum      ::= {"_+_", "_-_"};
	product  ::= {"_√ó_", "_√∑_", "_mod_"};
	negation ::= {"-_"};
	abs      ::= {"`|_`|"};
	power    ::= {"_^_"};
	bounds   ::= {"‚é£_‚é¶", "‚é°_‚é§"};

	sumAndProduct ::= sum ‚à™ product;

	/* Establish the standard grammatical rules for arithmetic. */
	Grammatical restriction product is <sum, sumAndProduct>;
	Grammatical restriction negation is
		<sumAndProduct ‚à™ negation ‚à™ ext ‚à™ {"‚àû"}>;

	/* Establish the precedence of exponentiation. */
	Grammatical restriction power is
		<sum ‚à™ product ‚à™ negation ‚à™ power, sum ‚à™ product>;

	/* Forbid nesting of absolute value. */
	Grammatical restriction abs is <abs>;

	/* Forbid nesting of floor and ceiling. */
	Grammatical restriction bounds is <bounds>;

	/* Make each bitwise operator left-associative with itself (but leave them
	 * mutually incomparable in precedence).
	 */
	Grammatical restriction "_bit‚àß_" is <‚àÖ, {"_bit‚àß_"}>;
	Grammatical restriction "_bit‚à®_" is <‚àÖ, {"_bit‚à®_"}>;
	Grammatical restriction "_bit‚äï_" is <‚àÖ, {"_bit‚äï_"}>;
]();

/* These messages describe arithmetic failure (integers only). */
cannotAddMessage ::= "terms not to be unlike infinities";
cannotSubtractMessage ::= "terms not to be like infinities";
cannotMultiplyMessage ::= "terms not be 0 and ¬±‚àû";
cannotDivideByZeroMessage ::= "denominator not to be 0";
cannotDivideTwoInfinitiesMessage ::=
	"either numerator or denominator to be finite";
cannotRaiseZeroToZero ::= "either base or exponent not to be 0";
cannotRaiseInfinityToZero ::= "base not to be ¬±‚àû or exponent not to be 0";
cannotRaiseNegativeToInfinity ::=
	"base not to be negative or exponent not to be ¬±‚àû";

Semantic restriction "_mod_" is type promotion function for
[
	a : number,
	b : number
|
	If b = 0 ‚àß [ a ‚àà extended integer ] then
	[
		Reject parse, expected: cannotDivideByZeroMessage
	];
	infinities ::= {‚àû, -‚àû};
	If a ‚àà infinities ‚àß [ b ‚àà infinities ] then
	[
		Reject parse, expected: cannotDivideTwoInfinitiesMessage
	];
	a mod b
];

/**
 * Negate the argument. Avail's system dialect has no negative numeric literals,
 * but the associated semantic restriction effectively overcomes this limitation
 * (for literal arguments).
 * 
 * Parameters:
 *    a - A number.
 * Returns:
 *    The negation of the argument.
 */
Method "-_" is
[
	a : number
|
	0 - a
];

/**
 * Compute and answer the strongest possible type of the argument. In
 * particular, an instance type will result in a precise answer that has the
 * same force as a literal.
 * 
 * Parameters:
 *    a - A numeric type.
 * Returns:
 *    The strongest possible type.
 */
Semantic restriction "-_" is
[
	a : number's type
|
	if a ‚äÜ extended integer then
	[
	 	extended integer
	]
	else
	[
		if a ‚äÜ double then
		[
			double
		]
		else
		[
			if a ‚äÜ float then
			[
				float
			]
			else
			[
				number
			]
		]
	]
];

Stable abstract method "‚é£_‚é¶" is [number]‚Üínumber;

/**
 * Compute and answer the floor of the argument. Note that integers and
 * infinities are their own floors.
 * 
 * Parameters:
 *    value - An integral value.
 * Returns:
 *    The argument.
 */
Method "‚é£_‚é¶" is
[
	value : extended integer
|
	value
] : extended integer;

/**
 * Integers and infinities are their own floors.
 *
 * Parameters:
 *    valueType - An integral type.
 * Returns:
 *    The argument.
 */
Semantic restriction "‚é£_‚é¶" is
[
	valueType : extended integer's type
|
	valueType
];

Stable abstract method "‚é°_‚é§" is [number]‚Üínumber;

/**
 * Compute and answer the ceiling of the argument. Note that integers and
 * infinities are their own ceilings.
 * 
 * Parameters:
 *    value - An integral value.
 * Returns:
 *    The argument.
 */
Method "‚é°_‚é§" is
[
	value : extended integer
|
	value
] : extended integer;

/**
 * Integers and infinities are their own ceilings.
 *
 * Parameters:
 *    valueType - An integral type.
 * Returns:
 *    The argument.
 */
Semantic restriction "‚é°_‚é§" is
[
	valueType : extended integer's type
|
	valueType
];

/**
 * Compute and answer the remainder after dividing the dividend by the divisor.
 * 
 * Parameters:
 *    dividend - The dividend.
 *    divisor - The divisor.
 * Returns:
 *    The remainder.
 */
Method "_mod_" is
[
	dividend : number,
	divisor : number
|
	dividend - divisor √ó ‚é£dividend √∑ divisor‚é¶
] : number;

/**
 * Compute and answer the remainder after dividing the dividend by the divisor.
 * 
 * Parameters:
 *    dividend - The dividend.
 *    divisor - ‚àû.
 * Returns:
 *    The dividend.
 */
Method "_mod_" is
[
	dividend : extended integer,
	divisor : ‚àû's type
|
	dividend
] : extended integer;

/**
 * Is the argument odd?
 * 
 * Parameters:
 *    a - An integer.
 * Returns:
 *    `true` if the argument is odd, `false` otherwise.
 */
Public stable method "_is odd" is
[
	a : integer
|
	a mod 2 = 1
] : boolean;

/**
 * Is the argument even?
 * 
 * Parameters:
 *    a - An integer.
 * Returns:
 *    `true` if the argument is even, `false` otherwise.
 */
Public stable method "_is even" is
[
	a : integer
|
	a mod 2 = 0
];

/**
 * Compute and answer the integer range type of the sum of the argument types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    sums of the arguments' instances.
 */
Method "_+_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	lower ::= ‚é£a‚é¶ + ‚é£b‚é¶ - 1;
	lowerInclusive ::=
		(‚é£a‚é¶ is inclusive ‚àß [‚é£a‚é¶ is infinite])
		‚à® [‚é£b‚é¶ is inclusive ‚àß [‚é£b‚é¶ is infinite]];
	upper ::= ‚é°a‚é§ + ‚é°b‚é§ + 1;
	upperInclusive ::=
		(‚é°a‚é§ is inclusive ‚àß [‚é°a‚é§ is infinite])
		‚à® [‚é°b‚é§ is inclusive ‚àß [‚é°b‚é§ is infinite]];
	integer range
		from lower (inclusive=lowerInclusive)
		to upper (inclusive=upperInclusive)
];

/**
 * Compute and answer the integer range type of the product of the argument
 * types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    products of the arguments' instances.
 */
Method "_√ó_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	bounds ::=
	{
		{‚é£a‚é¶, ‚é°a‚é§},
		{‚é£b‚é¶, ‚é°b‚é§}
	};
	If bounds = {{0}, {‚àû}} ‚à® [ bounds = {{0}, {-‚àû}} ] then
	[
		Reject parse, expected: cannotMultiplyMessage
	]
	else
	[
		negativeA : extended integer's type := a ‚à© [-‚àû..-1];
		negativeB : extended integer's type := b ‚à© [-‚àû..-1];
		positiveA : extended integer's type := a ‚à© [1..‚àû];
		positiveB : extended integer's type := b ‚à© [1..‚àû];
		result : extended integer's type := ‚ä•;
		If positiveA ‚â† ‚ä• then
		[
			If positiveB ‚â† ‚ä• then
			[
				lower ::= ‚é£positiveA‚é¶ √ó ‚é£positiveB‚é¶;
				lowerInclusive ::= ‚é£positiveA‚é¶ is inclusive
					‚àß [ ‚é£positiveB‚é¶ is inclusive ];
				upper ::= ‚é°positiveA‚é§ √ó ‚é°positiveB‚é§;
				upperInclusive ::= ‚é°positiveA‚é§ is inclusive
					‚àß [ ‚é°positiveB‚é§ is inclusive ];
				range ::= integer range
					from lower (inclusive=lowerInclusive)
					to upper (inclusive=upperInclusive);
				result := eject ‚Üëresult ‚à™ range;
			];
			If negativeB ‚â† ‚ä• then
			[
				lower ::= ‚é°positiveA‚é§ √ó ‚é£negativeB‚é¶;
				lowerInclusive ::= ‚é°positiveA‚é§ is inclusive
					‚àß [ ‚é£negativeB‚é¶ is inclusive ];
				upper ::= ‚é£positiveA‚é¶ √ó ‚é°negativeB‚é§;
				upperInclusive ::= ‚é£positiveA‚é¶ is inclusive
					‚àß [ ‚é°negativeB‚é§ is inclusive ];
				range ::= integer range
					from lower (inclusive=lowerInclusive)
					to upper (inclusive=upperInclusive);
				result := eject ‚Üëresult ‚à™ range;
			];
		];
		If negativeA ‚â† ‚ä• then
		[
			If positiveB ‚â† ‚ä• then
			[
				lower ::= ‚é£negativeA‚é¶ √ó ‚é°positiveB‚é§;
				lowerInclusive ::= ‚é£negativeA‚é¶ is inclusive
					‚àß [ ‚é°positiveB‚é§ is inclusive ];
				upper ::= ‚é°negativeA‚é§ √ó ‚é£positiveB‚é¶;
				upperInclusive ::= ‚é°negativeA‚é§ is inclusive
					‚àß [ ‚é£positiveB‚é¶ is inclusive ];
				range ::= integer range
					from lower (inclusive=lowerInclusive)
					to upper (inclusive=upperInclusive);
				result := eject ‚Üëresult ‚à™ range;
			];
			If negativeB ‚â† ‚ä• then
			[
				lower ::= ‚é°negativeA‚é§ √ó ‚é°negativeB‚é§;
				lowerInclusive ::= ‚é°negativeA‚é§ is inclusive
					‚àß [ ‚é°negativeB‚é§ is inclusive ];
				upper ::= ‚é£negativeA‚é¶ √ó ‚é£negativeB‚é¶;
				upperInclusive ::= ‚é£negativeA‚é¶ is inclusive
					‚àß [ ‚é£negativeB‚é¶ is inclusive ];
				range ::= integer range
					from lower (inclusive=lowerInclusive)
					to upper (inclusive=upperInclusive);
				result := eject ‚Üëresult ‚à™ range;
			];
		];
		/* Zero is handled specially, to prevent multiplication of 0 and ¬±‚àû by
		 * one of the preceding clauses.
		 */
		If 0's type ‚äÜ a ‚à® [ 0's type ‚äÜ b ] then
		[
			result := eject ‚Üëresult ‚à™ 0's type;
		];
		result
	]
];

/**
 * Compute and answer the negation of the specified integral type.
 * 
 * Parameters:
 *    a - An integral type.
 * Returns:
 *    The negation of the argument, e.g., the negation of [3..5] is [-5..-3].
 */
Public method "-_" is
[
	a : extended integer's type
|
	a √ó -1's type
];

/**
 * Strengthen negation.
 * 
 * Parameters:
 *    a - An integral type.
 * Returns:
 *    The negation of the argument.
 */
Semantic restriction "-_" is
[
	a : extended integer's type
|
	- a
];

/**
 * Compute and answer the integer range type of the difference of the argument
 * types.
 * 
 * Paramters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    differences of the arguments' instances.
 */
Method "_-_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	a + (- b)
];

/**
 * Compute and answer the integer range type of the sum of the argument types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    sums of the arguments' instances.
 */
Semantic restriction "_+_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	bounds ::=
	{
		{‚é£a‚é¶, ‚é°a‚é§},
		{‚é£b‚é¶, ‚é°b‚é§}
	};
	If bounds = {{-‚àû}, {‚àû}} then
	[
		Reject parse, expected: cannotAddMessage
	];
	a + b
];

/**
 * Compute and answer the integer range type of the difference of the argument
 * types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    differences of the arguments' instances.
 */
Semantic restriction "_-_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	negated ::= - b;
	bounds ::=
	{
		{‚é£a‚é¶, ‚é°a‚é§},
		{‚é£negated‚é¶, ‚é°negated‚é§}
	};
	If bounds = {{-‚àû}, {‚àû}} then
	[
		Reject parse, expected: cannotSubtractMessage
	];
	a + negated
];

/**
 * Compute and answer the integer range type of the product of the argument
 * types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    products of the arguments' instances.
 */
Semantic restriction "_√ó_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	a √ó b
];

/**
 * Compute and answer the integer range type of the quotient.
 * 
 * Parameters:
 *    numeratorRange - An integral type.
 *    denomintor - An integer.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    quotients of `numeratorRange`'s instances and `denominator`.
 */
Method "_√∑_" is
[
	numeratorRange : extended integer's type,
	denominator : extended integer
|
	/* Produce ‚ä• if the numerator range is ‚ä• or the denominator is 0. */
	if numeratorRange = ‚ä• ‚à® [ denominator = 0 ] then
	[
		‚ä•
	]
	else
	[
		/* ¬±‚àû divided by any finite nonzero value is 0. */
		if denominator is infinite then
		[
			0's type
		]
		else
		[
			/* The denominator is finite and nonzero. The numerator may be
			 * either finite or infinite. The following handles all cases.
			 */
			numeratorMin ::= ‚é£numeratorRange‚é¶ √∑ denominator;
			lowerInclusive ::= ‚é£numeratorRange‚é¶ is inclusive;
			numeratorMax ::= ‚é°numeratorRange‚é§ √∑ denominator;
			upperInclusive ::= ‚é°numeratorRange‚é§ is inclusive;
			if denominator < 0 then
			[
				integer range
					from numeratorMax (inclusive=upperInclusive)
					to numeratorMin (inclusive=lowerInclusive)
			]
			else
			[
				integer range
					from numeratorMin (inclusive=lowerInclusive)
					to numeratorMax (inclusive=upperInclusive)
			]
		]
	]
];

/**
 * Compute and answer the integer range type of the quotient of the argument
 * types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    quotients of the arguments' instances.
 */
Semantic restriction "_√∑_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	denominatorSet ::= {‚é£b‚é¶, ‚é°b‚é§};
	If denominatorSet = {0} then
	[
		Reject parse, expected: cannotDivideByZeroMessage
	];
	numeratorSet ::= {‚é£a‚é¶, ‚é°a‚é§};
	infinities ::= {{‚àû}, {-‚àû}};
	If numeratorSet ‚àà infinities ‚àß [ denominatorSet ‚àà infinities ] then
	[
		Reject parse, expected: cannotDivideTwoInfinitiesMessage
	];
	union : extended integer's type := ‚ä•;
	negativeDenominators ::= b ‚à© [-‚àû..-1];
	If negativeDenominators ‚â† ‚ä• then
	[
		union :=
			eject ‚Üëunion ‚à™ (a √∑ negativeDenominators' genuine lower bound);
		union :=
			eject ‚Üëunion ‚à™ (a √∑ negativeDenominators' genuine upper bound);
	];
	positiveDenominators ::= b ‚à© [1..‚àû];
	If positiveDenominators ‚â† ‚ä• then
	[
		union :=
			eject ‚Üëunion ‚à™ (a √∑ positiveDenominators' genuine lower bound);
		union :=
			eject ‚Üëunion ‚à™ (a √∑ positiveDenominators' genuine upper bound);
	];
	union
];

/**
 * Compute and answer the integer range type of the remainder of the argument
 * types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    remainders of the arguments' instances.
 */
Semantic restriction "_mod_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	denominatorSet ::= {‚é£b‚é¶, ‚é°b‚é§};
	If denominatorSet = {0} then
	[
		Reject parse, expected: cannotDivideByZeroMessage
	];
	numeratorSet ::= {‚é£a‚é¶, ‚é°a‚é§};
	infinities ::= {{‚àû}, {-‚àû}};
	If numeratorSet ‚àà infinities ‚àß [ denominatorSet ‚àà infinities ] then
	[
		Reject parse, expected: cannotDivideTwoInfinitiesMessage
	];
	if ‚é£b‚é¶ = ‚é°b‚é§
		‚àß [ ‚é£a‚é¶ is finite
		‚àß [ ‚é°a‚é§ is finite
		‚àß [ ‚é£a‚é¶ √∑ ‚é£b‚é¶ = ‚é°a‚é§ √∑ ‚é£b‚é¶ ] ] ]
	then
	[
		[‚é£a‚é¶ mod ‚é£b‚é¶ .. ‚é°a‚é§ mod ‚é£b‚é¶]
	]
	else
	[
		[0..‚é°b‚é§)
	]
];

/* Disambiguate `_‚Üí_` and several conversion operations. */
Grammatical restriction "_‚Üí_" is <‚àÖ, {"double", "extended integer", "float"}>;

/**
 * Compute and answer the absolute value of the argument.
 * 
 * Parameters:
 *    a - A number.
 * Returns:
 *    The absolute value of `a`.
 */
Stable method "`|_`|" is
[
	a : number
|
	if a < 0 then [ -a ] else [ a ]
] : number;

/**
 * Preserve the numeric type of the argument.
 * 
 * Parameter:
 *    a - `double`.
 * Returns:
 *    `double`.
 */
Semantic restriction "`|_`|" is
[
	a : double's type
|
	a
];

/**
 * Preserve the numeric type of the argument.
 * 
 * Parameter:
 *    a - `float`.
 * Returns:
 *    `float`.
 */
Semantic restriction "`|_`|" is
[
	a : float's type
|
	a
];

/**
 * Strengthen the absolute value operation for integral types.
 * 
 * Parameters:
 *    a - An integral type.
 * Returns:
 *    A positive integer range that includes the absolute values of all
 *    instances of `a`.
 */
Semantic restriction "`|_`|" is
[
	a : extended integer's type
|
	([0..‚àû] ‚à© a) ‚à™ ([0..‚àû] ‚à© -a)
];

/* This table of functions is used by the inequality operations. */
predicates ::=
<
	[ a : number, b : number | a < b ],
	[ a : number, b : number | a ‚â§ b ],
	[ a : number, b : number | a = b ],
	[ a : number, b : number | a ‚â• b ],
	[ a : number, b : number | a > b ]
>;

/**
 * Compute and answer the boolean value of the sequence of equals, less than or
 * equal, and less than operators.
 * 
 * Parameters:
 *    args - A tuple whose elements are a sequence of 4-tuples following by an
 *       ending 1-tuple. The first element of these 1,4-tuples is a number.
 *       If present, the second element will be a boolean that indicates that
 *       this number should be checked for equality with the next number. If
 *       present, the third element will be a boolean that indicates that this
 *       number should be compared against the next number to see if it is less
 *       than or equal. If present, the fourth element will be a boolean that
 *       indicates this this number should be compared against the next number
 *       to see if it is strictly less.
 * Returns:
 *    `true` if the entire chain of comparisons is true, `false` otherwise.
 */
Public method "¬´_‚Ä°¬´=¬ª?¬´‚â§¬ª?¬´<¬ª?¬ª" is
[
	args : <<number, boolean‚Ä¶|1..4>‚Ä¶|3..‚àû>
|
	result : boolean := true;
	From 1 to |args| - 1 do
	[
		index : natural number
	|
		arg ::= args[index];
		Assert: |arg| = 4 ("args ‚â† <aNumber, isEqual, isLess, isLessEqual>");
		/* Determine which predicate to apply. */
		predicate : [number, number]‚Üíboolean;
		From 2 to 4 do
		[
			predicateIndex : [2..4]
		|
			if arg[predicateIndex] then
			[
				predicate := predicates[3 - (predicateIndex - 2)];
				false
			]
			else
			[
				true
			]
		];
		Assert: ¬¨‚Üëpredicate is unassigned ("no predicate was selected");
		if predicate(arg[1], args[index + 1][1]) then
		[
			true
		]
		else
		[
			result := false;
			false
		]
	];
	result
];

Private method "comparison chain semantic restriction function" is
[
	[
		args : <<number, boolean‚Ä¶|1..4>‚Ä¶|3..‚àû>'s type
	|
		exactSize ::= ‚é£args‚é¶ - 1;
		allEquals : boolean := true;
		From 1 to exactSize do
		[
			index : natural number
		|
			arg ::= args[index];
			optionCount : whole number := 0;
			From 2 to 4 do
			[
				optionIndex : [2..4]
			|
				If arg[optionIndex]'s instance then
				[
					‚ÜëoptionCount++;
				];
				true
			];
			If optionCount ‚â† 1 then
			[
				Reject parse, expected:
					"exactly one comparison operator between numeric arguments"
			];
			If ¬¨arg[2]'s instance then
			[
				allEquals := false;
			];
			true
		];
		If allEquals then
		[
			Reject parse, expected:
				"inequality chain to include at least one inequality"
		];
		‚ä§
	]
];

Semantic restriction "¬´_‚Ä°¬´=¬ª?¬´‚â§¬ª?¬´<¬ª?¬ª" is
	comparison chain semantic restriction function;

/**
 * Compute and answer the boolean value of the sequence of equals, greater than
 * or equal, and greater than operators.
 * 
 * Parameters:
 *    args - A tuple whose elements are a sequence of 4-tuples following by an
 *       ending 1-tuple. The first element of these 1,4-tuples is a number.
 *       If present, the second element will be a boolean that indicates that
 *       this number should be checked for equality with the next number. If
 *       present, the third element will be a boolean that indicates that this
 *       number should be compared against the next number to see if it is
 *       greater than or equal. If present, the fourth element will be a boolean
 *       that indicates this this number should be compared against the next
 *       number to see if it is strictly greater.
 * Returns:
 *    `true` if the entire chain of comparisons is true, `false` otherwise.
 */
Public method "¬´_‚Ä°¬´=¬ª?¬´‚â•¬ª?¬´>¬ª?¬ª" is
[
	args : <<number, boolean‚Ä¶|1..4>‚Ä¶|3..‚àû>
|
	result : boolean := true;
	From 1 to |args| - 1 do
	[
		index : natural number
	|
		arg ::= args[index];
		Assert: |arg| = 4
			("args ‚â† <aNumber, isEqual, isGreater, isGreaterEqual>");
		/* Determine which predicate to apply. */
		predicate : [number, number]‚Üíboolean;
		From 2 to 4 do
		[
			predicateIndex : [2..4]
		|
			if arg[predicateIndex] then
			[
				predicate := predicates[3 + (predicateIndex - 2)];
				false
			]
			else
			[
				true
			]
		];
		Assert: ¬¨‚Üëpredicate is unassigned ("no predicate was selected");
		if predicate(arg[1], args[index + 1][1]) then
		[
			true
		]
		else
		[
			result := false;
			false
		]
	];
	result
];

Semantic restriction "¬´_‚Ä°¬´=¬ª?¬´‚â•¬ª?¬´>¬ª?¬ª" is
	comparison chain semantic restriction function;

/**
 * Compute and answer the result of exponentiating `base` by `exponent`.
 * 
 * Parameters:
 *    base - The base.
 *    exponent - The exponent.
 * Returns:
 *    The result of raising `base` to the `exponent` power.
 */
Method "_^_" is
[
	base : number,
	exponent : number
|
	/* Uses the identity: a^b = exp(ln(a^b)) = exp(b*ln(a)). */
	Euler number ^ (exponent √ó ln (base‚Üídouble))
] : number;

/**
 * Establish type promotion rules for exponentiation. Also handle instance
 * types.
 * 
 * Parameters:
 *    a - The base's type.
 *    b - The exponent's type.
 * Returns:
 *    A numeric type that is not an integral kind. (These are dealt with by
 *    another restriction.)
 */
Semantic restriction "_^_" is type promotion function for
[
	a : number,
	b : number
|
	If b = 0 then
	[
		If a = 0 then
		[
			Reject parse, expected: cannotRaiseZeroToZero
		];
		If a ‚àà {-‚àû, ‚àû} then
		[
			Reject parse, expected: cannotRaiseInfinityToZero
		];
	];
	If a ‚àà extended integer then
	[
		If a < 0 ‚àß [ b ‚àà {-‚àû, ‚àû} ] then
		[
			Reject parse, expected: cannotRaiseNegativeToInfinity
		];
	];
	a ^ b
];

/* The remaining implementations of `_^_` are recursive, so forward declare them
 * here.
 */
Forward method "_^_" is [extended integer, whole number]‚Üíextended integer;
Forward method "_^_" is [float, whole number]‚Üífloat;
Forward method "_^_" is [double, whole number]‚Üídouble;

/**
 * Compute and answer the result of exponentiating `base` by `exponent`.
 * 
 * Parameters:
 *    base - The base.
 *    exponent - The exponent.
 * Returns:
 *    The result of raising `base` to the `exponent` power.
 */
Method "_^_" is
[
	base : extended integer,
	exponent : whole number
|
	/* TODO: [TLS] Must forbid 0^0, [-‚àû..0)^{-‚àû, ‚àû}, {-‚àû, ‚àû}^0. */
	/*  Uses the identities: b^(2x) = (b^2)^x; and: b^(2x+1) = (b^2)^x*b. */
	if exponent = 0 then
	[
		1
	]
	else
	[
		intermediate ::= (base √ó base) ^ (exponent √∑ 2);
		if exponent is odd then [ intermediate √ó base ] else [ intermediate ]
	]
] : extended integer;

/**
 * Compute and answer the result of exponentiating `base` by `exponent`.
 * 
 * Parameters:
 *    base - The base.
 *    exponent - The exponent.
 * Returns:
 *    The result of raising `base` to the `exponent` power.
 */
Method "_^_" is
[
	base : float,
	exponent : whole number
|
	/*  Uses the identities: b^(2x) = (b^2)^x; and: b^(2x+1) = (b^2)^x*b. */
	if exponent = 0 then
	[
		1.0f
	]
	else
	[
		intermediate ::= (base √ó base) ^ (exponent √∑ 2);
		if exponent is odd then [ intermediate √ó base ] else [ intermediate ]
	]
] : float;

/**
 * Compute and answer the result of exponentiating `base` by `exponent`.
 * 
 * Parameters:
 *    base - The base.
 *    exponent - The exponent.
 * Returns:
 *    The result of raising `base` to the `exponent` power.
 */
Method "_^_" is
[
	base : double,
	exponent : whole number
|
	/*  Uses the identities: b^(2x) = (b^2)^x; and: b^(2x+1) = (b^2)^x*b. */
	if exponent = 0 then
	[
		1.0d
	]
	else
	[
		intermediate ::= (base √ó base) ^ (exponent √∑ 2);
		if exponent is odd then [ intermediate √ó base ] else [ intermediate ]
	]
] : double;

/**
 * Calculate the logarithm of the specified number to the specified base.
 * 
 * Parameters:
 *    b - The logarithm base to use.
 *    n - The number to find a logarithm of.
 * Returns:
 *    The logarithm of `n` to base `b`.
 */
Public stable method "log_of_" is
[
	b : float,
	n : float
|
	(ln n) √∑ (ln b)
] : float;

/**
 * Calculate the logarithm of the specified number to the specified base.
 * 
 * Parameters:
 *    b - The logarithm base to use.
 *    n - The number to find a logarithm of.
 * Returns:
 *    The logarithm of `n` to base `b`.
 */
Stable method "log_of_" is
[
	b : double,
	n : double
|
	(ln n) √∑ (ln b)
] : double;

/**
 * Answer an approximation of ùõë, the ratio of the circumference of a circle to
 * its diameter.
 *
 * @method "ùõë"
 * @returns "3.141592653589793d's type"
 *          {@code 3.141592653589793d}.
 */
Public method "ùõë" is [3.141592653589793d];
