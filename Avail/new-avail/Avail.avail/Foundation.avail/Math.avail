/*
 * Math.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Math"
Versions
	"dev"
Extends
	"Early Math"
Uses
	"Bootstrap",
	"Early Control Structures",
	"Early Logic",
	"Early Set",
	"Early Types",
	"Enumeration Support",
	"Literals"
Names
	"_is odd",
	"_is even",
	"_mod_",
	"-_",
	"_^_"
Body

Forward method "_mod_" is [number, number]→number;
Forward method "-_" is [number]→number;
Forward method "_^_" is [number, number]→number;

/* Establish grammatical rules. */
invoke
	[
		sum      ::= {"_+_", "_-_"};
		product  ::= {"_×_", "_÷_", "_mod_"};
		negation ::= {"-_"};
		power    ::= {"_^_"};
		abs      ::= {"|_|"};

		sumAndProduct ::= sum ∪ product;

		/* Establish the standard grammatical rules for arithmetic. */
		Grammatical restriction product is <sum, sumAndProduct>;
		Grammatical restriction negation is <sumAndProduct ∪ {"∞"}>;
		Grammatical restriction power is
			<sumAndProduct ∪ negation ∪ power, sum ∪ product>;

		/* Forbid nesting of absolute value. */
		Grammatical restriction abs is <abs>;
	] : ⊤
with <>;

/**
 * Construct and answer a function that affects type promotions for the various
 * numeric types. This function is intended for use by semantic restrictions
 * of the basic arithmetic operators.
 *
 * Parameters:
 *    operator - A function that performs one of the basic arithmetic
 *       operations and answers the result.
 * Returns:
 *    A function that handles type promotions for the given operator.
 */
Method "type promotion function for_" is
[
	operator : [number, number]→number
|
	[
		a : number's type,
		b : number's type
	|
		if |a| = 1 ∧ [ |b| = 1; ] then
		[
			/* The exact values are known statically. Calculate it exactly. */
			(invoke operator with <a's instance, b's instance>)'s type;
		]
		else
		[
			if a ⊆ double ∨ [ b ⊆ double; ] then
			[
				/* At least one is known to be double, which forces the result
				 * to be a double.
				 */
				double;
			]
			else
			[
				if a = number ∨ [ b = number; ] then
				[
					/* Neither is known to be a double, and at least one is as
					 * weak as a number.  The weak one might be a double at run
					 * time, so we can't limit the output type any more.
					 */
					number;
				]
				else
				[
					/* Neither one is as weak as number. */
					if a ⊆ float ∨ [ b ⊆ float; ] then
					[
						/* Either {float,float} or {float,int}, which each
						 * produce a float.
						 */
						float;
					]
					else
					[
						if a ⊆ extended integer ∧ [ b ⊆ extended integer; ]
						then [ extended integer; ]
						else [ number; ];
					];
				];
			];
		];
	];
] : [number's type, number's type]→number's type;

/* These messages describe arithmetic failure (integers only). */
cannotAddMessage ::= "terms not to be unlike infinities";
cannotSubtractMessage ::= "terms not to be like infinities";
cannotMultiplyMessage ::= "terms not be 0 and ±∞";
cannotDivideByZeroMessage ::= "denominator not to be zero (0)";
cannotDivideTwoInfinitiesMessage ::=
	"either numerator or denominator to be finite";

Semantic restriction "_+_" is type promotion function for
[
	a : number,
	b : number
|
	if {a, b} = {-∞, ∞} then
	[
		Reject parse, expected: cannotAddMessage;
	];
	a + b;
];

Semantic restriction "_-_" is type promotion function for
[
	a : number,
	b : number
|
	if {a, b} ∈ {{-∞}, {∞}} then
	[
		Reject parse, expected: cannotSubtractMessage;
	];
	a - b;
];

Semantic restriction "_×_" is type promotion function for
[
	a : number,
	b : number
|
	terms ::= {a, b};
	if terms = {0, ∞} ∨ [ terms = {0, -∞}; ] then
	[
		Reject parse, expected: cannotMultiplyMessage;
	];
	a × b;
];

Semantic restriction "_÷_" is type promotion function for
[
	a : number,
	b : number
|
	if b = 0 ∧ [ a ∈ extended integer; ] then
	[
		Reject parse, expected: cannotDivideByZeroMessage;
	];
	infinities ::= {∞, -∞};
	if a ∈ infinities ∧ [ b ∈ infinities; ] then
	[
		Reject parse, expected: cannotDivideTwoInfinitiesMessage;
	];
	a ÷ b;
];

Semantic restriction "_mod_" is type promotion function for
[
	a : number,
	b : number
|
	if b = 0 ∧ [ a ∈ extended integer; ] then
	[
		Reject parse, expected: cannotDivideByZeroMessage;
	];
	infinities ::= {∞, -∞};
	if a ∈ infinities ∧ [ b ∈ infinities; ] then
	[
		Reject parse, expected: cannotDivideTwoInfinitiesMessage;
	];
	a mod b;
];

/**
 * Negate the argument. Avail's system dialect has no negative numeric literals,
 * but the associated semantic restriction effectively overcomes this limitation
 * (for literal arguments).
 * 
 * Parameters:
 *    a - A number.
 * Returns:
 *    The negation of the argument.
 */
Method "-_" is
[
	a : number
|
	0 - a;
];

/**
 * Compute and answer the strongest possible type of the argument. In
 * particular, an instance type will result in a precise answer that has the
 * same force as a literal.
 * 
 * Parameters:
 *    a - A numeric type.
 * Returns:
 *    The strongest possible type.
 */
Semantic restriction "-_" is
[
	a : number's type
|
	if |a| = 1 then
	[
		(0 - a's instance)'s type;
	]
	else
	[
		if a ⊆ extended integer then
		[
		 	extended integer;
		]
		else
		[
			if a ⊆ double then
			[
				double;
			]
			else
			[
				if a ⊆ float then
				[
					float;
				]
				else
				[
					number;
				];
			];
		];
	];
];

Abstract method "⎣_⎦" is [number]→number;

/**
 * Compute and answer the floor of the argument. Note that integers and
 * infinities are their own floors.
 * 
 * Parameters:
 *    value - An integral value.
 * Returns:
 *    The argument.
 */
Method "⎣_⎦" is
[
	value : extended integer
|
	value;
];

/**
 * If the exact type of the argument is know statically, then produce an exact
 * answer.
 *
 * Parameters:
 *    valueType - Any numeric type.
 * Returns:
 *    Either an instance type or `number`.
 */
Semantic restriction "⎣_⎦" is
[
	valueType : number's type
|
	if |valueType| = 1 then
	[
		⎣valueType's instance⎦'s type;
	]
	else
	[
		/* An innocuous answer that will disappear in a type intersection with
		 * the answer produced by a more specific semantic restriction.
		 */
		number;
	];
];

/**
 * Integers and infinities are their own floors.
 *
 * Parameters:
 *    valueType - An integral type.
 * Returns:
 *    The argument.
 */
Semantic restriction "⎣_⎦" is
[
	valueType : extended integer's type
|
	valueType;
];

Abstract method "⎡_⎤" is [number]→number;

/**
 * Compute and answer the ceiling of the argument. Note that integers and
 * infinities are their own ceilings.
 * 
 * Parameters:
 *    value - An integral value.
 * Returns:
 *    The argument.
 */
Method "⎡_⎤" is
[
	value : extended integer
|
	value;
];

/**
 * If the exact type of the argument is known statically, then produce an exact
 * answer.
 *
 * Parameters:
 *    valueType - Any numeric type.
 * Returns:
 *    Either an instance type or `number`.
 */
Semantic restriction "⎡_⎤" is
[
	valueType : number's type
|
	if |valueType| = 1 then
	[
		⎡valueType's instance⎤'s type;
	]
	else
	[
		/* An innocuous answer that will disappear in a type intersection with
		 * the answer produced by a more specific semantic restriction.
		 */
		number;
	];
];

/**
 * Integers and infinities are their own ceilings.
 *
 * Parameters:
 *    valueType - An integral type.
 * Returns:
 *    The argument.
 */
Semantic restriction "⎡_⎤" is
[
	valueType : extended integer's type
|
	valueType;
];

/**
 * Compute and answer the remainder after dividing the divident by the divisor.
 * 
 * Parameters:
 *    dividend - The dividend.
 *    divisor - The divisor.
 * Returns:
 *    The remainder.
 */
Method "_mod_" is
[
	dividend : number,
	divisor : number
|
	dividend - divisor × ⎣dividend ÷ divisor⎦;
];

/**
 * Compute and answer the remainder after dividing the divident by the divisor.
 * 
 * Parameters:
 *    dividend - The dividend.
 *    divisor - ∞.
 * Returns:
 *    The dividend.
 */
Method "_mod_" is
[
	dividend : extended integer,
	divisor : ∞'s type
|
	dividend;
];

/**
 * Is the argument odd?
 * 
 * Parameters:
 *    a - An integer.
 * Returns:
 *    `true` if the argument is odd, `false` otherwise.
 */
Method "_is odd" is
[
	a : integer
|
	a mod 2 = 1;
];

/**
 * If the exact type of the argument is known statically, then produce an exact
 * answer.
 *
 * Parameters:
 *    a - An integral type.
 * Returns:
 *    Either an instance type or `number`.
 */
Semantic restriction "_is odd" is
[
	a : integer's type
|
	if |a| = 1 then
	[
		a's instance is odd's type;
	]
	else
	[
		integer;
	];
];

/**
 * Is the argument even?
 * 
 * Parameters:
 *    a - An integer.
 * Returns:
 *    `true` if the argument is even, `false` otherwise.
 */
Method "_is even" is
[
	a : integer
|
	a mod 2 = 1;
];

/**
 * If the exact type of the argument is known statically, then produce an exact
 * answer.
 *
 * Parameters:
 *    a - An integral type.
 * Returns:
 *    Either an instance type or `number`.
 */
Semantic restriction "_is even" is
[
	a : integer's type
|
	if |a| = 1 then
	[
		a's instance is even's type;
	]
	else
	[
		integer;
	];
];

/* The helper methods below perform operations analogous to the arithmetic
 * operations, but on integral types instead of integers. The naming convention
 * is tmesis of the integer range operator ".." with an arithmetic operator like
 * "+", "×", or "-". This results in messages like ".+.". This is cute here, but
 * probably should not leak beyond this module.
 */

/**
 * Compute and answer the integer range type of the sum of the argument types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    sums of the arguments' instances.
 */
Method "_.+._" is
[
	a : extended integer's type,
	b : extended integer's type
|
	lower ::= a's lower bound + b's lower bound - 1;
	lowerInclusive ::=
		(a's lower bound is inclusive ∧ [a's lower bound is infinite;])
		∨ [b's lower bound is inclusive ∧ [b's lower bound is infinite;];];
	upper ::= a's upper bound + b's upper bound + 1;
	upperInclusive ::=
		(a's upper bound is inclusive ∧ [a's upper bound is infinite;])
		∨ [b's upper bound is inclusive ∧ [b's upper bound is infinite;];];
	integer range
		from lower (inclusive=lowerInclusive)
		to upper (inclusive=upperInclusive);
];

/**
 * Compute and answer the integer range type of the product of the argument
 * types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    products of the arguments' instances.
 */
Method "_.×._" is
[
	a : extended integer's type,
	b : extended integer's type
|
	bounds ::=
	{
		{a's lower bound, a's upper bound},
		{b's lower bound, b's upper bound}
	};
	if bounds = {{0}, {∞}} ∨ [ bounds = {{0}, {-∞}}; ] then
	[
		Reject parse, expected: cannotMultiplyMessage;
	]
	else
	[
		negativeA : extended integer's type := a ∩ [-∞..-1];
		negativeB : extended integer's type := b ∩ [-∞..-1];
		positiveA : extended integer's type := a ∩ [1..∞];
		positiveB : extended integer's type := b ∩ [1..∞];
		result : extended integer's type := ⊥;
		if positiveA ≠ ⊥ then
		[
			if positiveB ≠ ⊥ then
			[
				lower ::= positiveA's lower bound × positiveB's lower bound;
				lowerInclusive ::= positiveA's lower bound is inclusive
					∧ [ positiveB's lower bound is inclusive; ];
				upper ::= positiveA's upper bound × positiveB's upper bound;
				upperInclusive ::= positiveA's upper bound is inclusive
					∧ [ positiveB's upper bound is inclusive; ];
				range ::= integer range
					from lower (inclusive=lowerInclusive)
					to upper (inclusive=upperInclusive);
				result := eject &result ∪ range;
			];
			if negativeB ≠ ⊥ then
			[
				lower ::= positiveA's upper bound × negativeB's lower bound;
				lowerInclusive ::= positiveA's upper bound is inclusive
					∧ [ negativeB's lower bound is inclusive; ];
				upper ::= positiveA's lower bound × negativeB's upper bound;
				upperInclusive ::= positiveA's lower bound is inclusive
					∧ [ negativeB's upper bound is inclusive; ];
				range ::= integer range
					from lower (inclusive=lowerInclusive)
					to upper (inclusive=upperInclusive);
				result := eject &result ∪ range;
			];
		];
		if negativeA ≠ ⊥ then
		[
			if positiveB ≠ ⊥ then
			[
				lower ::= negativeA's lower bound × positiveB's upper bound;
				lowerInclusive ::= negativeA's lower bound is inclusive
					∧ [ positiveB's upper bound is inclusive; ];
				upper ::= negativeA's upper bound × positiveB's lower bound;
				upperInclusive ::= negativeA's upper bound is inclusive
					∧ [ positiveB's lower bound is inclusive; ];
				range ::= integer range
					from lower (inclusive=lowerInclusive)
					to upper (inclusive=upperInclusive);
				result := eject &result ∪ range;
			];
			if negativeB ≠ ⊥ then
			[
				lower ::= negativeA's upper bound × negativeB's upper bound;
				lowerInclusive ::= negativeA's upper bound is inclusive
					∧ [ negativeB's upper bound is inclusive; ];
				upper ::= negativeA's lower bound × negativeB's lower bound;
				upperInclusive ::= negativeA's lower bound is inclusive
					∧ [ negativeB's lower bound is inclusive; ];
				range ::= integer range
					from lower (inclusive=lowerInclusive)
					to upper (inclusive=upperInclusive);
				result := eject &result ∪ range;
			];
		];
		/* Zero is handled specially, to prevent multiplication of 0 and ±∞ by
		 * one of the preceding clauses.
		 */
		if 0's type ⊆ a ∨ [ 0's type ⊆ b; ] then
		[
			result := eject &result ∪ 0's type;
		];
		result;
	];
];

/**
 * Compute and answer the negation of the specified integral type.
 * 
 * Parameters:
 *    a - An integral type.
 * Returns:
 *    The negation of the argument, e.g., the negation of [3..5] is [-5..-3].
 */
Method ".-._" is
[
	a : extended integer's type
|
	a .×. -1's type;
];

/**
 * Strengthen negation.
 * 
 * Parameters:
 *    a - An integral type.
 * Returns:
 *    The negation of the argument.
 */
Semantic restriction "-_" is
[
	a : extended integer's type
|
	.-. a;
];

/**
 * Compute and answer the integer range type of the sum of the argument types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    sums of the arguments' instances.
 */
Semantic restriction "_+_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	bounds ::=
	{
		{a's lower bound, a's upper bound},
		{b's lower bound, b's upper bound}
	};
	if bounds = {{-∞}, {∞}} then
	[
		Reject parse, expected: cannotAddMessage;
	];
	a .+. b;
];

/**
 * Compute and answer the integer range type of the difference of the argument
 * types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    differences of the arguments' instances.
 */
Semantic restriction "_-_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	negated ::= .-. b;
	bounds ::=
	{
		{a's lower bound, a's upper bound},
		{negated's lower bound, negated's upper bound}
	};
	if bounds = {{-∞}, {∞}} then
	[
	 	Print: "got here\n";
		Reject parse, expected: cannotSubtractMessage;
	];
	a .+. negated;
];

/**
 * Compute and answer the integer range type of the product of the argument
 * types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    products of the arguments' instances.
 */
Semantic restriction "_×_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	a .×. b;
];

/**
 * Compute and answer the integer range type of the quotient.
 * 
 * Parameters:
 *    numeratorRange - An integral type.
 *    denomintor - An integer.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    quotients of `numeratorRange`'s instances and `denominator`.
 */
Method "_.÷._" is
[
	numeratorRange : extended integer's type,
	denominator : extended integer
|
	/* Produce ⊥ if the numerator range is ⊥ or the denominator is 0. */
	if numeratorRange = ⊥ ∨ [ denominator = 0; ] then
	[
		⊥;
	]
	else
	[
		/* ±∞ divided by any finite nonzero value is 0. */
		if denominator is infinite then
		[
			0's type;
		]
		else
		[
			/* The denominator is finite and nonzero. The numerator may be
			 * either finite or infinite. The following handles all cases.
			 */
			numeratorMin ::= numeratorRange's lower bound ÷ denominator;
			lowerInclusive ::= numeratorRange's lower bound is inclusive;
			numeratorMax ::= numeratorRange's upper bound ÷ denominator;
			upperInclusive ::= numeratorRange's upper bound is inclusive;
			result ::= if denominator < 0 then
				[
					integer range
						from numeratorMax (inclusive=upperInclusive)
						to numeratorMin (inclusive=lowerInclusive);
				]
				else
				[
					integer range
						from numeratorMin (inclusive=lowerInclusive)
						to numeratorMax (inclusive=upperInclusive);
				];
			result;
		];
	];
];

/**
 * Compute and answer the integer range type of the quotient of the argument
 * types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    quotients of the arguments' instances.
 */
Semantic restriction "_÷_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	denominatorSet ::= {b's lower bound, b's upper bound};
	if denominatorSet = {0} then
	[
		Reject parse, expected: cannotDivideByZeroMessage;
	];
	numeratorSet ::= {a's lower bound, a's upper bound};
	infinities ::= {{∞}, {-∞}};
	if numeratorSet ∈ infinities ∧ [ denominatorSet ∈ infinities; ] then
	[
		Reject parse, expected: cannotDivideTwoInfinitiesMessage;
	];
	union : extended integer's type := ⊥;
	negativeDenominators ::= b ∩ [-∞..-1];
	if negativeDenominators ≠ ⊥ then
	[
		union :=
			eject &union ∪ (a .÷. negativeDenominators's genuine lower bound);
		union :=
			eject &union ∪ (a .÷. negativeDenominators's genuine upper bound);
	];
	positiveDenominators ::= b ∩ [1..∞];
	if positiveDenominators ≠ ⊥ then
	[
		union :=
			eject &union ∪ (a .÷. positiveDenominators's genuine lower bound);
		union :=
			eject &union ∪ (a .÷. positiveDenominators's genuine upper bound);
	];
	union;
];

/**
 * Compute and answer the integer range type of the remainder of the argument
 * types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    remainders of the arguments' instances.
 */
Semantic restriction "_mod_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	denominatorSet ::= {b's lower bound, b's upper bound};
	if denominatorSet = {0} then
	[
		Reject parse, expected: cannotDivideByZeroMessage;
	];
	numeratorSet ::= {a's lower bound, a's upper bound};
	infinities ::= {{∞}, {-∞}};
	if numeratorSet ∈ infinities ∧ [ denominatorSet ∈ infinities; ] then
	[
		Reject parse, expected: cannotDivideTwoInfinitiesMessage;
	];
	if b's lower bound = b's upper bound
		∧ [ a's lower bound is finite
		∧ [ a's upper bound is finite
		∧ [ a's lower bound ÷ b's lower bound
			= a's upper bound ÷ b's lower bound; ]; ]; ]
	then
	[
		[a's lower bound mod b's lower bound
			.. a's upper bound mod b's lower bound];
	]
	else
	[
		[0..b's upper bound);
	];
];

Method "_^_" is
[
	base : number,
	exponent : number
|
	/* TODO */
	0;
] : number;
