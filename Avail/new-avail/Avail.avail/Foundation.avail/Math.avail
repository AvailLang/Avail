/*
 * Math.avail
 * Copyright ¬© 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Math"
Versions
	"dev"
Extends
	"Early Math"
Uses
	"Bootstrap",
	"Definers",
	"Early Assertions",
	"Early Control Structures",
	"Early Error Codes",
	"Early Functions",
	"Early Logic",
	"Early Sets",
	"Early Tuples",
	"Enumeration Support",
	"Literals",
	"Types",
	"Variables"
Names
	"log_of_",
	"_is odd",
	"_is even",
	"-_",
	"ùõë",
	"¬´_‚Ä°¬´=¬ª?¬´‚â§¬ª?¬´<¬ª?¬ª",
	"¬´_‚Ä°¬´=¬ª?¬´‚â•¬ª?¬´>¬ª?¬ª"
Body

Forward method "_mod_" is [number, number]‚Üínumber;
Public stable forward method "-_" is [number]‚Üínumber;

/* Establish grammatical rules. */
[
	ext      ::= {"¬´_‚Ä°max¬ª", "¬´_‚Ä°min¬ª"};
	sum      ::= {"_+_", "_-_"};
	product  ::= {"_√ó_", "_√∑_", "_mod_"};
	negation ::= {"-_"};
	abs      ::= {"`|_`|"};
	power    ::= {"_^_"};
	bounds   ::= {"‚é£_‚é¶", "‚é°_‚é§"};

	sumAndProduct ::= sum ‚à™ product;

	/* Establish the standard grammatical rules for arithmetic. */
	Grammatical restriction product is <sum, sumAndProduct>;
	Grammatical restriction negation is
		<sumAndProduct ‚à™ negation ‚à™ ext ‚à™ {"‚àû"}>;

	/* Establish the precedence of exponentiation. */
	Grammatical restriction power is
		<sum ‚à™ product ‚à™ negation ‚à™ power, sum ‚à™ product>;

	/* Forbid nesting of absolute value. */
	Grammatical restriction abs is <abs>;

	/* Forbid nesting of floor and ceiling. */
	Grammatical restriction bounds is <bounds>;

	/* Make each bitwise operator left-associative with itself (but leave them
	 * mutually incomparable in precedence).
	 */
	Grammatical restriction "_bit‚àß_" is <‚àÖ, {"_bit‚àß_"}>;
	Grammatical restriction "_bit‚à®_" is <‚àÖ, {"_bit‚à®_"}>;
	Grammatical restriction "_bit‚äï_" is <‚àÖ, {"_bit‚äï_"}>;
]();

/* These messages describe arithmetic failure (integers only). */
cannotAddMessage ::= "terms not to be unlike infinities";
cannotSubtractMessage ::= "terms not to be like infinities";
cannotMultiplyMessage ::= "terms not be 0 and ¬±‚àû";
cannotDivideByZeroMessage ::= "denominator not to be 0";
cannotDivideTwoInfinitiesMessage ::=
	"either numerator or denominator to be finite";
cannotRaiseZeroToZero ::= "either base or exponent not to be 0";
cannotRaiseInfinityToZero ::= "base not to be ¬±‚àû or exponent not to be 0";
cannotRaiseNegativeToInfinity ::=
	"base not to be negative or exponent not to be ¬±‚àû";

Semantic restriction "_mod_" is type promotion function for
[
	a : number,
	b : number
|
	If b = 0 ‚àß [ a ‚àà extended integer ] then
	[
		Reject parse, expected: cannotDivideByZeroMessage
	];
	infinities ::= {‚àû, -‚àû};
	If a ‚àà infinities ‚àß [ b ‚àà infinities ] then
	[
		Reject parse, expected: cannotDivideTwoInfinitiesMessage
	];
	a mod b
];

/**
 * Negate the argument. Avail's system dialect has no negative numeric literals,
 * but the associated semantic restriction effectively overcomes this limitation
 * (for literal arguments).
 * 
 * Parameters:
 *    a - A number.
 * Returns:
 *    The negation of the argument.
 */
Method "-_" is
[
	a : number
|
	0 - a
];

/**
 * Compute and answer the strongest possible type of the argument. In
 * particular, an instance type will result in a precise answer that has the
 * same force as a literal.
 * 
 * Parameters:
 *    a - A numeric type.
 * Returns:
 *    The strongest possible type.
 */
Semantic restriction "-_" is
[
	a : number's type
|
	if a ‚äÜ extended integer then
	[
	 	extended integer
	]
	else
	[
		if a ‚äÜ double then
		[
			double
		]
		else
		[
			if a ‚äÜ float then
			[
				float
			]
			else
			[
				number
			]
		]
	]
];

Stable abstract method "‚é£_‚é¶" is [number]‚Üínumber;

/**
 * Compute and answer the floor of the argument. Note that integers and
 * infinities are their own floors.
 * 
 * Parameters:
 *    value - An integral value.
 * Returns:
 *    The argument.
 */
Method "‚é£_‚é¶" is
[
	value : extended integer
|
	value
] : extended integer;

/**
 * Integers and infinities are their own floors.
 *
 * Parameters:
 *    valueType - An integral type.
 * Returns:
 *    The argument.
 */
Semantic restriction "‚é£_‚é¶" is
[
	valueType : extended integer's type
|
	valueType
];

Stable abstract method "‚é°_‚é§" is [number]‚Üínumber;

/**
 * Compute and answer the ceiling of the argument. Note that integers and
 * infinities are their own ceilings.
 * 
 * Parameters:
 *    value - An integral value.
 * Returns:
 *    The argument.
 */
Method "‚é°_‚é§" is
[
	value : extended integer
|
	value
] : extended integer;

/**
 * Integers and infinities are their own ceilings.
 *
 * Parameters:
 *    valueType - An integral type.
 * Returns:
 *    The argument.
 */
Semantic restriction "‚é°_‚é§" is
[
	valueType : extended integer's type
|
	valueType
];

/**
 * Compute and answer the remainder after dividing the dividend by the divisor.
 * 
 * Parameters:
 *    dividend - The dividend.
 *    divisor - The divisor.
 * Returns:
 *    The remainder.
 */
Method "_mod_" is
[
	dividend : number,
	divisor : number
|
	dividend - divisor √ó ‚é£dividend √∑ divisor‚é¶
] : number;

/**
 * Compute and answer the remainder after dividing the dividend by the divisor.
 * 
 * Parameters:
 *    dividend - The dividend.
 *    divisor - ‚àû.
 * Returns:
 *    The dividend.
 */
Method "_mod_" is
[
	dividend : extended integer,
	divisor : ‚àû's type
|
	dividend
] : extended integer;

/**
 * Is the argument odd?
 * 
 * Parameters:
 *    a - An integer.
 * Returns:
 *    `true` if the argument is odd, `false` otherwise.
 */
Public stable method "_is odd" is
[
	a : integer
|
	a mod 2 = 1
] : boolean;

/**
 * Is the argument even?
 * 
 * Parameters:
 *    a - An integer.
 * Returns:
 *    `true` if the argument is even, `false` otherwise.
 */
Public stable method "_is even" is
[
	a : integer
|
	a mod 2 = 0
];

/**
 * Compute and answer the integer range type of the sum of the argument types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    sums of the arguments' instances.
 */
Method "_+_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	lower ::= ‚é£a‚é¶ + ‚é£b‚é¶ - 1;
	lowerInclusive ::=
		(‚é£a‚é¶ is inclusive ‚àß [‚é£a‚é¶ is infinite])
		‚à® [‚é£b‚é¶ is inclusive ‚àß [‚é£b‚é¶ is infinite]];
	upper ::= ‚é°a‚é§ + ‚é°b‚é§ + 1;
	upperInclusive ::=
		(‚é°a‚é§ is inclusive ‚àß [‚é°a‚é§ is infinite])
		‚à® [‚é°b‚é§ is inclusive ‚àß [‚é°b‚é§ is infinite]];
	integer range
		from lower (inclusive=lowerInclusive)
		to upper (inclusive=upperInclusive)
];

/**
 * Compute and answer the integer range type of the product of the argument
 * types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    products of the arguments' instances.
 */
Method "_√ó_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	bounds ::=
	{
		{‚é£a‚é¶, ‚é°a‚é§},
		{‚é£b‚é¶, ‚é°b‚é§}
	};
	If bounds = {{0}, {‚àû}} ‚à® [ bounds = {{0}, {-‚àû}} ] then
	[
		Reject parse, expected: cannotMultiplyMessage
	]
	else
	[
		negativeA : extended integer's type := a ‚à© [-‚àû..-1];
		negativeB : extended integer's type := b ‚à© [-‚àû..-1];
		positiveA : extended integer's type := a ‚à© [1..‚àû];
		positiveB : extended integer's type := b ‚à© [1..‚àû];
		result : extended integer's type := ‚ä•;
		If positiveA ‚â† ‚ä• then
		[
			If positiveB ‚â† ‚ä• then
			[
				lower ::= ‚é£positiveA‚é¶ √ó ‚é£positiveB‚é¶;
				lowerInclusive ::= ‚é£positiveA‚é¶ is inclusive
					‚àß [ ‚é£positiveB‚é¶ is inclusive ];
				upper ::= ‚é°positiveA‚é§ √ó ‚é°positiveB‚é§;
				upperInclusive ::= ‚é°positiveA‚é§ is inclusive
					‚àß [ ‚é°positiveB‚é§ is inclusive ];
				range ::= integer range
					from lower (inclusive=lowerInclusive)
					to upper (inclusive=upperInclusive);
				result := eject ‚Üëresult ‚à™ range;
			];
			If negativeB ‚â† ‚ä• then
			[
				lower ::= ‚é°positiveA‚é§ √ó ‚é£negativeB‚é¶;
				lowerInclusive ::= ‚é°positiveA‚é§ is inclusive
					‚àß [ ‚é£negativeB‚é¶ is inclusive ];
				upper ::= ‚é£positiveA‚é¶ √ó ‚é°negativeB‚é§;
				upperInclusive ::= ‚é£positiveA‚é¶ is inclusive
					‚àß [ ‚é°negativeB‚é§ is inclusive ];
				range ::= integer range
					from lower (inclusive=lowerInclusive)
					to upper (inclusive=upperInclusive);
				result := eject ‚Üëresult ‚à™ range;
			];
		];
		If negativeA ‚â† ‚ä• then
		[
			If positiveB ‚â† ‚ä• then
			[
				lower ::= ‚é£negativeA‚é¶ √ó ‚é°positiveB‚é§;
				lowerInclusive ::= ‚é£negativeA‚é¶ is inclusive
					‚àß [ ‚é°positiveB‚é§ is inclusive ];
				upper ::= ‚é°negativeA‚é§ √ó ‚é£positiveB‚é¶;
				upperInclusive ::= ‚é°negativeA‚é§ is inclusive
					‚àß [ ‚é£positiveB‚é¶ is inclusive ];
				range ::= integer range
					from lower (inclusive=lowerInclusive)
					to upper (inclusive=upperInclusive);
				result := eject ‚Üëresult ‚à™ range;
			];
			If negativeB ‚â† ‚ä• then
			[
				lower ::= ‚é°negativeA‚é§ √ó ‚é°negativeB‚é§;
				lowerInclusive ::= ‚é°negativeA‚é§ is inclusive
					‚àß [ ‚é°negativeB‚é§ is inclusive ];
				upper ::= ‚é£negativeA‚é¶ √ó ‚é£negativeB‚é¶;
				upperInclusive ::= ‚é£negativeA‚é¶ is inclusive
					‚àß [ ‚é£negativeB‚é¶ is inclusive ];
				range ::= integer range
					from lower (inclusive=lowerInclusive)
					to upper (inclusive=upperInclusive);
				result := eject ‚Üëresult ‚à™ range;
			];
		];
		/* Zero is handled specially, to prevent multiplication of 0 and ¬±‚àû by
		 * one of the preceding clauses.
		 */
		If 0's type ‚äÜ a ‚à® [ 0's type ‚äÜ b ] then
		[
			result := eject ‚Üëresult ‚à™ 0's type;
		];
		result
	]
];

/**
 * Compute and answer the negation of the specified integral type.
 * 
 * Parameters:
 *    a - An integral type.
 * Returns:
 *    The negation of the argument, e.g., the negation of [3..5] is [-5..-3].
 */
Public method "-_" is
[
	a : extended integer's type
|
	a √ó -1's type
];

/**
 * Strengthen negation.
 * 
 * Parameters:
 *    a - An integral type.
 * Returns:
 *    The negation of the argument.
 */
Semantic restriction "-_" is
[
	a : extended integer's type
|
	- a
];

/**
 * Compute and answer the integer range type of the difference of the argument
 * types.
 * 
 * Paramters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    differences of the arguments' instances.
 */
Method "_-_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	a + (- b)
];

/**
 * Compute and answer the integer range type of the sum of the argument types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    sums of the arguments' instances.
 */
Semantic restriction "_+_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	bounds ::=
	{
		{‚é£a‚é¶, ‚é°a‚é§},
		{‚é£b‚é¶, ‚é°b‚é§}
	};
	If bounds = {{-‚àû}, {‚àû}} then
	[
		Reject parse, expected: cannotAddMessage
	];
	a + b
];

/**
 * Compute and answer the integer range type of the difference of the argument
 * types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    differences of the arguments' instances.
 */
Semantic restriction "_-_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	negated ::= - b;
	bounds ::=
	{
		{‚é£a‚é¶, ‚é°a‚é§},
		{‚é£negated‚é¶, ‚é°negated‚é§}
	};
	If bounds = {{-‚àû}, {‚àû}} then
	[
		Reject parse, expected: cannotSubtractMessage
	];
	a + negated
];

/**
 * Compute and answer the integer range type of the product of the argument
 * types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    products of the arguments' instances.
 */
Semantic restriction "_√ó_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	a √ó b
];

/**
 * Compute and answer the integer range type of the quotient.
 * 
 * Parameters:
 *    numeratorRange - An integral type.
 *    denomintor - An integer.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    quotients of `numeratorRange`'s instances and `denominator`.
 */
Method "_√∑_" is
[
	numeratorRange : extended integer's type,
	denominator : extended integer
|
	/* Produce ‚ä• if the numerator range is ‚ä• or the denominator is 0. */
	if numeratorRange = ‚ä• ‚à® [ denominator = 0 ] then
	[
		‚ä•
	]
	else
	[
		/* ¬±‚àû divided by any finite nonzero value is 0. */
		if denominator is infinite then
		[
			0's type
		]
		else
		[
			/* The denominator is finite and nonzero. The numerator may be
			 * either finite or infinite. The following handles all cases.
			 */
			numeratorMin ::= ‚é£numeratorRange‚é¶ √∑ denominator;
			lowerInclusive ::= ‚é£numeratorRange‚é¶ is inclusive;
			numeratorMax ::= ‚é°numeratorRange‚é§ √∑ denominator;
			upperInclusive ::= ‚é°numeratorRange‚é§ is inclusive;
			if denominator < 0 then
			[
				integer range
					from numeratorMax (inclusive=upperInclusive)
					to numeratorMin (inclusive=lowerInclusive)
			]
			else
			[
				integer range
					from numeratorMin (inclusive=lowerInclusive)
					to numeratorMax (inclusive=upperInclusive)
			]
		]
	]
];

/**
 * Compute and answer the integer range type of the quotient of the argument
 * types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    quotients of the arguments' instances.
 */
Semantic restriction "_√∑_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	denominatorSet ::= {‚é£b‚é¶, ‚é°b‚é§};
	If denominatorSet = {0} then
	[
		Reject parse, expected: cannotDivideByZeroMessage
	];
	numeratorSet ::= {‚é£a‚é¶, ‚é°a‚é§};
	infinities ::= {{‚àû}, {-‚àû}};
	If numeratorSet ‚àà infinities ‚àß [ denominatorSet ‚àà infinities ] then
	[
		Reject parse, expected: cannotDivideTwoInfinitiesMessage
	];
	union : extended integer's type := ‚ä•;
	negativeDenominators ::= b ‚à© [-‚àû..-1];
	If negativeDenominators ‚â† ‚ä• then
	[
		union :=
			eject ‚Üëunion ‚à™ (a √∑ negativeDenominators' genuine lower bound);
		union :=
			eject ‚Üëunion ‚à™ (a √∑ negativeDenominators' genuine upper bound);
	];
	positiveDenominators ::= b ‚à© [1..‚àû];
	If positiveDenominators ‚â† ‚ä• then
	[
		union :=
			eject ‚Üëunion ‚à™ (a √∑ positiveDenominators' genuine lower bound);
		union :=
			eject ‚Üëunion ‚à™ (a √∑ positiveDenominators' genuine upper bound);
	];
	union
];

/**
 * Compute and answer the integer range type of the remainder of the argument
 * types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    remainders of the arguments' instances.
 */
Semantic restriction "_mod_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	denominatorSet ::= {‚é£b‚é¶, ‚é°b‚é§};
	If denominatorSet = {0} then
	[
		Reject parse, expected: cannotDivideByZeroMessage
	];
	numeratorSet ::= {‚é£a‚é¶, ‚é°a‚é§};
	infinities ::= {{‚àû}, {-‚àû}};
	If numeratorSet ‚àà infinities ‚àß [ denominatorSet ‚àà infinities ] then
	[
		Reject parse, expected: cannotDivideTwoInfinitiesMessage
	];
	if ‚é£b‚é¶ = ‚é°b‚é§
		‚àß [ ‚é£a‚é¶ is finite
		‚àß [ ‚é°a‚é§ is finite
		‚àß [ ‚é£a‚é¶ √∑ ‚é£b‚é¶ = ‚é°a‚é§ √∑ ‚é£b‚é¶ ] ] ]
	then
	[
		[‚é£a‚é¶ mod ‚é£b‚é¶ .. ‚é°a‚é§ mod ‚é£b‚é¶]
	]
	else
	[
		[0..‚é°b‚é§)
	]
];

/* Disambiguate `_‚Üí_` and several conversion operations. */
Grammatical restriction "_‚Üí_" is <‚àÖ, {"double", "extended integer", "float"}>;

/**
 * Compute and answer the absolute value of the argument.
 * 
 * Parameters:
 *    a - A number.
 * Returns:
 *    The absolute value of `a`.
 */
Stable method "`|_`|" is
[
	a : number
|
	if a < 0 then [ -a ] else [ a ]
] : number;

/**
 * Preserve the numeric type of the argument.
 * 
 * Parameter:
 *    a - `double`.
 * Returns:
 *    `double`.
 */
Semantic restriction "`|_`|" is
[
	a : double's type
|
	a
];

/**
 * Preserve the numeric type of the argument.
 * 
 * Parameter:
 *    a - `float`.
 * Returns:
 *    `float`.
 */
Semantic restriction "`|_`|" is
[
	a : float's type
|
	a
];

/**
 * Strengthen the absolute value operation for integral types.
 * 
 * Parameters:
 *    a - An integral type.
 * Returns:
 *    A positive integer range that includes the absolute values of all
 *    instances of `a`.
 */
Semantic restriction "`|_`|" is
[
	a : extended integer's type
|
	([0..‚àû] ‚à© a) ‚à™ ([0..‚àû] ‚à© -a)
];

/* This table of functions is used by the inequality operations. */
predicates ::=
<
	[ a : number, b : number | a < b ],
	[ a : number, b : number | a ‚â§ b ],
	[ a : number, b : number | a = b ],
	[ a : number, b : number | a ‚â• b ],
	[ a : number, b : number | a > b ]
>;

/**
 * Compute and answer the boolean value of the sequence of equals, less than or
 * equal, and less than operators.
 * 
 * Parameters:
 *    args - A tuple whose elements are a sequence of 4-tuples following by an
 *       ending 1-tuple. The first element of these 1,4-tuples is a number.
 *       If present, the second element will be a boolean that indicates that
 *       this number should be checked for equality with the next number. If
 *       present, the third element will be a boolean that indicates that this
 *       number should be compared against the next number to see if it is less
 *       than or equal. If present, the fourth element will be a boolean that
 *       indicates this this number should be compared against the next number
 *       to see if it is strictly less.
 * Returns:
 *    `true` if the entire chain of comparisons is true, `false` otherwise.
 */
Public method "¬´_‚Ä°¬´=¬ª?¬´‚â§¬ª?¬´<¬ª?¬ª" is
[
	args : <<number, boolean‚Ä¶|1..4>‚Ä¶|3..‚àû>
|
	result : boolean := true;
	From 1 to |args| - 1 do
	[
		index : natural number
	|
		arg ::= args[index];
		Assert: |arg| = 4 ("args ‚â† <aNumber, isEqual, isLess, isLessEqual>");
		/* Determine which predicate to apply. */
		predicate : [number, number]‚Üíboolean;
		From 2 to 4 do
		[
			predicateIndex : [2..4]
		|
			if arg[predicateIndex] then
			[
				predicate := predicates[3 - (predicateIndex - 2)];
				false
			]
			else
			[
				true
			]
		];
		Assert: ¬¨‚Üëpredicate is unassigned ("no predicate was selected");
		if predicate(arg[1], args[index + 1][1]) then
		[
			true
		]
		else
		[
			result := false;
			false
		]
	];
	result
];

Private method "comparison chain semantic restriction function" is
[
	[
		args : <<number, boolean‚Ä¶|1..4>‚Ä¶|3..‚àû>'s type
	|
		exactSize ::= ‚é£args‚é¶ - 1;
		allEquals : boolean := true;
		From 1 to exactSize do
		[
			index : natural number
		|
			arg ::= args[index];
			optionCount : whole number := 0;
			From 2 to 4 do
			[
				optionIndex : [2..4]
			|
				If arg[optionIndex]'s instance then
				[
					‚ÜëoptionCount++;
				];
				true
			];
			If optionCount ‚â† 1 then
			[
				Reject parse, expected:
					"exactly one comparison operator between numeric arguments"
			];
			If ¬¨arg[2]'s instance then
			[
				allEquals := false;
			];
			true
		];
		If allEquals then
		[
			Reject parse, expected:
				"inequality chain to include at least one inequality"
		];
		‚ä§
	]
];

Semantic restriction "¬´_‚Ä°¬´=¬ª?¬´‚â§¬ª?¬´<¬ª?¬ª" is
	comparison chain semantic restriction function;

/**
 * Compute and answer the boolean value of the sequence of equals, greater than
 * or equal, and greater than operators.
 * 
 * Parameters:
 *    args - A tuple whose elements are a sequence of 4-tuples following by an
 *       ending 1-tuple. The first element of these 1,4-tuples is a number.
 *       If present, the second element will be a boolean that indicates that
 *       this number should be checked for equality with the next number. If
 *       present, the third element will be a boolean that indicates that this
 *       number should be compared against the next number to see if it is
 *       greater than or equal. If present, the fourth element will be a boolean
 *       that indicates this this number should be compared against the next
 *       number to see if it is strictly greater.
 * Returns:
 *    `true` if the entire chain of comparisons is true, `false` otherwise.
 */
Public method "¬´_‚Ä°¬´=¬ª?¬´‚â•¬ª?¬´>¬ª?¬ª" is
[
	args : <<number, boolean‚Ä¶|1..4>‚Ä¶|3..‚àû>
|
	result : boolean := true;
	From 1 to |args| - 1 do
	[
		index : natural number
	|
		arg ::= args[index];
		Assert: |arg| = 4
			("args ‚â† <aNumber, isEqual, isGreater, isGreaterEqual>");
		/* Determine which predicate to apply. */
		predicate : [number, number]‚Üíboolean;
		From 2 to 4 do
		[
			predicateIndex : [2..4]
		|
			if arg[predicateIndex] then
			[
				predicate := predicates[3 + (predicateIndex - 2)];
				false
			]
			else
			[
				true
			]
		];
		Assert: ¬¨‚Üëpredicate is unassigned ("no predicate was selected");
		if predicate(arg[1], args[index + 1][1]) then
		[
			true
		]
		else
		[
			result := false;
			false
		]
	];
	result
];

Semantic restriction "¬´_‚Ä°¬´=¬ª?¬´‚â•¬ª?¬´>¬ª?¬ª" is
	comparison chain semantic restriction function;

/**
 * Compute and answer the result of exponentiating `base` by `exponent`.
 * 
 * Parameters:
 *    base - The base.
 *    exponent - The exponent.
 * Returns:
 *    The result of raising `base` to the `exponent` power.
 */
Method "_^_" is
[
	base : number,
	exponent : number
|
	/* Uses the identity: a^b = exp(ln(a^b)) = exp(b*ln(a)). */
	Euler number ^ (exponent √ó ln (base‚Üídouble))
] : number;

/**
 * Establish type promotion rules for exponentiation. Also handle instance
 * types.
 * 
 * Parameters:
 *    a - The base's type.
 *    b - The exponent's type.
 * Returns:
 *    A numeric type that is not an integral kind. (These are dealt with by
 *    another restriction.)
 */
Semantic restriction "_^_" is type promotion function for
[
	a : number,
	b : number
|
	If b = 0 then
	[
		If a = 0 then
		[
			Reject parse, expected: cannotRaiseZeroToZero
		];
		If a ‚àà {-‚àû, ‚àû} then
		[
			Reject parse, expected: cannotRaiseInfinityToZero
		];
	];
	If a ‚àà extended integer then
	[
		If a < 0 ‚àß [ b ‚àà {-‚àû, ‚àû} ] then
		[
			Reject parse, expected: cannotRaiseNegativeToInfinity
		];
	];
	a ^ b
];

/* The remaining implementations of `_^_` are recursive, so forward declare them
 * here.
 */
Forward method "_^_" is [extended integer, whole number]‚Üíextended integer;
Forward method "_^_" is [float, whole number]‚Üífloat;
Forward method "_^_" is [double, whole number]‚Üídouble;

/**
 * Compute and answer the result of exponentiating `base` by `exponent`.
 * 
 * Parameters:
 *    base - The base.
 *    exponent - The exponent.
 * Returns:
 *    The result of raising `base` to the `exponent` power.
 */
Method "_^_" is
[
	base : extended integer,
	exponent : whole number
|
	/* TODO: [TLS] Must forbid 0^0, [-‚àû..0)^{-‚àû, ‚àû}, {-‚àû, ‚àû}^0. */
	/*  Uses the identities: b^(2x) = (b^2)^x; and: b^(2x+1) = (b^2)^x*b. */
	if exponent = 0 then
	[
		1
	]
	else
	[
		intermediate ::= (base √ó base) ^ (exponent √∑ 2);
		if exponent is odd then [ intermediate √ó base ] else [ intermediate ]
	]
] : extended integer;

/**
 * Compute and answer the result of exponentiating `base` by `exponent`.
 * 
 * Parameters:
 *    base - The base.
 *    exponent - The exponent.
 * Returns:
 *    The result of raising `base` to the `exponent` power.
 */
Method "_^_" is
[
	base : float,
	exponent : whole number
|
	/*  Uses the identities: b^(2x) = (b^2)^x; and: b^(2x+1) = (b^2)^x*b. */
	if exponent = 0 then
	[
		1.0f
	]
	else
	[
		intermediate ::= (base √ó base) ^ (exponent √∑ 2);
		if exponent is odd then [ intermediate √ó base ] else [ intermediate ]
	]
] : float;

/**
 * Compute and answer the result of exponentiating `base` by `exponent`.
 * 
 * Parameters:
 *    base - The base.
 *    exponent - The exponent.
 * Returns:
 *    The result of raising `base` to the `exponent` power.
 */
Method "_^_" is
[
	base : double,
	exponent : whole number
|
	/*  Uses the identities: b^(2x) = (b^2)^x; and: b^(2x+1) = (b^2)^x*b. */
	if exponent = 0 then
	[
		1.0d
	]
	else
	[
		intermediate ::= (base √ó base) ^ (exponent √∑ 2);
		if exponent is odd then [ intermediate √ó base ] else [ intermediate ]
	]
] : double;

/**
 * Calculate the logarithm of the specified number to the specified base.
 * 
 * Parameters:
 *    b - The logarithm base to use.
 *    n - The number to find a logarithm of.
 * Returns:
 *    The logarithm of `n` to base `b`.
 */
Public stable method "log_of_" is
[
	b : float,
	n : float
|
	(ln n) √∑ (ln b)
] : float;

/**
 * Calculate the logarithm of the specified number to the specified base.
 * 
 * Parameters:
 *    b - The logarithm base to use.
 *    n - The number to find a logarithm of.
 * Returns:
 *    The logarithm of `n` to base `b`.
 */
Stable method "log_of_" is
[
	b : double,
	n : double
|
	(ln n) √∑ (ln b)
] : double;

/**
 * Answer an approximation of ùõë, the ratio of the circumference of a circle to
 * its diameter.
 *
 * @method "ùõë"
 * @returns "3.141592653589793d's type"
 *          {@code 3.141592653589793d}.
 */
Public method "ùõë" is [3.141592653589793d];


/**
 * Strengthen the result type of bitshift.
 *
 * Parameters:
 *    baseInteger - An integer to shift.
 *    shiftFactor - How many bit positions by which to shift left (negative for
 *       a right shift).
 * Returns:
 *    The value baseInteger * (2<sup>shiftFactor</sup>).
 */
Semantic restriction "_<<_" is
[
	baseIntegerType : integer's type,
	shiftFactorType : integer's type
|
	low : extended integer := ‚àû;
	high : extended integer := -‚àû;
	innerBlock ::= [base : extended integer, shift : extended integer |
		shifted ::= cast base into
			[
				baseInteger : integer
			|
				cast shift into
				[
					shiftInteger : integer
				|
					/* Finite case. */
					baseInteger << shiftInteger
				]
				else
				[
					/* Arbitrarily large shift. */
					if shift = ‚àû then
					[
						/* Arbitrarily large left shift. */
						if baseInteger > 0 then [‚àû]
						else
						[
							if baseInteger < 0 then [-‚àû] else [0]
						]
					]
					else
					[
						/* Arbitrarily large right shift. */
						if baseInteger ‚â• 0 then [0] else [-1]
					]
				]
			]
			else
			[
				/* Arbitrarily large (¬±) number to shift. */
				cast shift into
				[
					shiftInteger : integer
				|
					/* Arbitrarily large number shifted finitely. */
					base
				]
				else
				[
					/* Both the base and the shift are arbitrarily large. */
					if shift = ‚àû then
					[
						base
					]
					else
					[
						if base = ‚àû then [0] else [-1]
					]
				]
			];
		low := low min shifted;
		high := high max shifted;
	];
	/* Feed the block some characteristic values to compute the extrema. */
	outerBlock ::= [
		base : extended integer
	|
		If 0 ‚àà shiftFactorType then [innerBlock(base, 0);];
		If -1 ‚àà shiftFactorType then [innerBlock(base, -1);];
		If 1 ‚àà shiftFactorType then [innerBlock(base, 1);];
		innerBlock(base, ‚é£shiftFactorType‚é¶);
		innerBlock(base, ‚é°shiftFactorType‚é§);
	];

	If 0 ‚àà baseIntegerType then [outerBlock(0);];
	If -1 ‚àà baseIntegerType then [outerBlock(-1);];
	If 1 ‚àà baseIntegerType then [outerBlock(1);];
	outerBlock(‚é£baseIntegerType‚é¶);
	outerBlock(‚é°baseIntegerType‚é§);
	(low - 1 .. high + 1)
] : integer's type;

/* TODO [MvG] Remove - TEMPORARY TESTS */
Assert: 1 << 0 = 1;
Assert: 1 << 1 = 2;
Assert: 1 << 2 = 4;
Assert: 3 << 3 = 24;
Assert: 0 << 0 = 0;
Assert: 0 << 3 = 0;
x : [13..19] := 17;
y : [-3..4] := 0;
z : [13 << -3 .. 19 << 4] := x << y;
Assert: z = 17;
y := 4;
Assert: x << y = 272;
y := -3;
Assert: x << y = 2;
xi : integer := x;
yi : integer := y;
z2 : integer := xi << yi;
Assert: z2 = 2;
z3 : [0..‚àû) := x << yi;
Assert: z3 = 2;
z4 : integer := xi << y;
Assert: z4 = 2;


Private forward method "_positive range pairs"
	is [whole number's type] ‚Üí <whole number's type‚Ä¶|0..‚àû>;

/**
 * Compute the ranges as for "_range pairs" (below), but with the knowledge that
 * the range is whole number or a subtype.
 */
Private method "_positive range pairs" is
[
	range : whole number's type
|
	$outer : <whole number's type‚Ä¶|0..‚àû>;
	If range = ‚ä• then
	[
		Exit outer with <>
	];
	cast ‚é£range‚é¶ into
	[
		low : [0..‚àû)
	|
		/* Find the biggest string of rightmost one-bits that can be added to
		 * low without causing any internal carry and without exceeding the
		 * range.
		 */
		lowBits : integer;
		Cast ‚é°range‚é§ into
		[
			high : [1..‚àû)
		|
			If low = 0 then
			[
				/* Range is [0..n]. */
				lowBits := high;
				[
					$here;
					If lowBits bit‚àß (lowBits + 1) ‚â† 0 then
					[
						/* Not yet of the form 2^n-1 */
						lowBits := lowBits bit‚à® (lowBits << -1);
						Restart here
					];
				]();
			]
			else
			[
				lowBits := (-1 - low) bit‚àß (low - 1);
			];
		]
		else
		[
			If ‚é°range‚é§ = 0 then
			[
				Assert: range = [0..0];
				Exit outer with <range>
			];
			Assert: ‚é°range‚é§ = ‚àû;
			If low = 0 then
			[
				Assert: range = [0..‚àû);
				Exit outer with <range>
			];
			/* Find the next higher power of two. */
			boundary : integer := low;
			[
				$here;
				If boundary bit‚àß (boundary + 1) ‚â† 0 then
				[
					boundary := boundary bit‚à® (boundary << -1);
					Restart here
				];
			]();
			Exit outer with
				[low .. boundary] positive range pairs
					++ <[boundary + 1..‚àû)>
		];
		strongLowBits : whole number :=
			cast lowBits into [x : whole number | x];
		[
			$loop : <whole number's type‚Ä¶|0..‚àû>;
			subrangeEnd ::= low + strongLowBits;
			If subrangeEnd ‚àà range then
			[
				Exit outer with
					<[low .. low + strongLowBits]>
					++ (low + strongLowBits .. ‚é°range‚é§ + 1)
						positive range pairs
			];
			Assert: strongLowBits ‚â† 0;
			strongLowBits := strongLowBits << -1;
			Restart loop
		] : <whole number's type‚Ä¶|0..‚àû> ()
	]
] : <whole number's type‚Ä¶|0..‚àû>;

/**
 * Decompose an integer type into a tuple of contiguous smaller integer types.
 * When the lower and upper bounds of a subrange are each finite, they must have
 * the form a*2^b and a*2^b + 2^b-1.  The lower bound ensures the bottom b bits
 * are zero, and the upper bound is the same but with the bottom b bits all one.
 * The low and high values may be the same, indicating a range consisting of a
 * single value.
 *
 * In the special case that the upper end of the subrange is ‚àû, the lower end
 * must be a non-negative power of two.  In the case that the lower end is -‚àû,
 * the upper end must be one less than the negation of a power of two.
 * 
 * Produce the minimum number of such ranges.
 */
Private method "_range pairs" is
[
	range : integer's type
|
	rangeKind ::= (‚é£range‚é¶ - 1 .. ‚é°range‚é§ + 1);
	pairs : <integer's type‚Ä¶|> := <>;
	complementOfNegative ::= ((-1)'s type - rangeKind) ‚à© [0..‚àû);
	subranges ::= complementOfNegative positive range pairs;
	From 1 to |subranges| do
	[
		n : natural number
	|
		subcomplement ::= Cast (-1)'s type - subranges[n]
			into [x : integer's type | x];
		pairs := <subcomplement> ++ pairs;
		true
	];
	positiveRegion ::= rangeKind ‚à© [0..‚àû);
	pairs := pairs ++ positiveRegion positive range pairs;
	pairs
] : <extended integer's type‚Ä¶|0..‚àû>;

/* TODO [MvG] Remove - TEMPORARY TESTS */
Assert: [0..0] range pairs = <[0..0]>;
Assert: [0..10] range pairs = <[0..7], [8..9], [10..10]>;
Assert: [10..20] range pairs = <[10..11], [12..15], [16..19], [20..20]>;
Assert: [-10..0] range pairs = <[-10..-9], [-8..-1], [0..0]>;
Assert: [-20..-10] range pairs = <[-20..-17], [-16..-13], [-12..-11], [-10..-10]>;
Assert: [-21..11] range pairs = <[-21..-21], [-20..-17], [-16..-1], [0..7], [8..11]>;
Assert: [0..‚àû) range pairs = <[0..‚àû)>;
Assert: [10..‚àû) range pairs = <[10..11], [12..15], [16..‚àû)>;
Assert: integer range pairs = <(-‚àû..-1], [0..‚àû)>;
Assert: enumeration of {-6, 4, 5, 6, 7} range pairs = <[-6..-5], [-4..-1], [0..7]>;



/**
 * Strengthen bitwise-and operation.
 */
Semantic restriction "_bit‚àß_" is
[
	arg1 : integer's type,
	arg2 : integer's type
|
	values : {extended integer|0..‚àû} := ‚àÖ;
	include ::=
	[
		x : extended integer,
		y : extended integer
	|
		$includeLabel : ‚ä§;
		exit ::= [
			moreValues : {extended integer|0..‚àû}
		|
			values := values ‚à™ moreValues;
			Exit includeLabel with 123
		];
		If x = ‚àû then
		[
			If y ‚â• 0 then
			[
				/* For some finite positive y, there exists a large positive
				 * number (implied by x) that has enough low zero bits to
				 * produce zero.  Similarly, there is a large positive number
				 * which is able to preserve all of y's bits.  Finally, when
				 * y is also arbitrarily large it can conspire with x to
				 * produce any whole number.
				 */
				exit({0, y})
			];
			/* Arbitrarily large positive integers can mask a negative
			 * number to ensure arbitrarily large positive integers are
			 * possible.  Other limits will determine how low a (positive)
			 * value can be produced.
			 */
			exit({x})
		];
		If x = -‚àû then
		[
			If y ‚â• 0 then
			[
				/* An arbitrarily large magnitude negative x can preserve any
				 * positive y.  It could also knock it down to zero.
				 */
				exit({0, y})
			];
			/* An arbitrarily large magnitude negative x can preserve any
			 * bits of y, but it can also zero any finite combination of
			 * bits, keeping it negative.
			 */
			exit({x, y})
		];
		If x ‚â• 0 then
		[
			/* A particular finite positive x. */
			If y ‚àà {‚àû, -‚àû} then
			[
				exit({0, x})
			];
			Cast x into
			[
				xi : integer
			|
				Cast y into
				[
					yi : integer
				|
					exit({xi bit‚àß yi})
				]
			]
		];
		/* A particular finite negative x. */
		If y = ‚àû then
		[
			exit({y})
		];
		If y = -‚àû then
		[
			exit({x, y})
		];
		Cast x into
		[
			xi : integer
		|
			Cast y into
			[
				yi : integer
			|
				exit({xi bit‚àß yi})
			]
		]
	] : ‚ä§;
	arg1Ranges ::= arg1 range pairs;
	arg2Ranges ::= arg2 range pairs;
	From 1 to |arg1Ranges| do
	[
		i1 : natural number
	|
		subrange1 ::= arg1Ranges[i1];
		From 1 to |arg2Ranges| do
		[
			i2 : natural number
		|
			subrange2 ::= arg2Ranges[i2];
			include(‚é£subrange1‚é¶, ‚é£subrange2‚é¶);
			include(‚é£subrange1‚é¶, ‚é°subrange2‚é§);
			include(‚é°subrange1‚é§, ‚é£subrange2‚é¶);
			include(‚é°subrange1‚é§, ‚é°subrange2‚é§);
			true
		];
		true
	];
	contentType ::= values' type's element type;
	(‚é£contentType‚é¶ - 1 .. ‚é°contentType‚é§ + 1)
] : integer's type;

/* TODO [MvG] Remove - TEMPORARY TESTS */
Assert: 0 bit‚àß 0 = 0;
Assert: 0 bit‚àß 1 = 0;
Assert: 1 bit‚àß 0 = 0;
Assert: 1 bit‚àß 1 = 1;
Assert: 15 bit‚àß 30 = 14;




/**
 * Strengthen the result type of bounded bitshift, primarily based on the
 * truncation bit count.

 * Given a positive integer B, a shift factor S, and a truncation bit count T,
 * shift B to the left by S bits (treating a negative factor as a right shift),
 * then truncate the result to the bottom T bits by zeroing the rest.
 *
 * Parameters:
 *    baseInteger - A non-negative integer to shift and mask.
 *    shiftFactor - How many bit positions to shift left by (negative for a
 *       right shift).
 *    truncationBits - The number of low-order bits to preserve after the shift
 *       (must be ‚â• 0).
 * Returns:
 *    The value baseInteger * (2<sup>shiftFactor</sup>) mod
 *    (2^<sup>truncationBits</sup>).
 */
Semantic restriction "_<<_keeping_bits" is
[
	baseInteger : whole number's type,
	shiftFactor : integer's type,
	truncationBits : whole number's type
|
	high : [0..‚àû] := ‚àû;
	If ‚é°baseInteger‚é§ ‚â† ‚àû ‚àß [ ‚é°shiftFactor‚é§ ‚â† ‚àû ] then
	[
		finiteBaseMax : whole number;
		‚Üì‚ÜëfiniteBaseMax ?= ‚é°baseInteger‚é§;
		finiteShiftMax : integer;
		‚Üì‚ÜëfiniteShiftMax ?= ‚é°shiftFactor‚é§;
		high := finiteBaseMax << finiteShiftMax;
	];
	finiteBaseMin : whole number;
	‚Üì‚ÜëfiniteBaseMin ?= ‚é£baseInteger‚é¶;
	finiteShiftMin : integer;
	‚Üì‚ÜëfiniteShiftMin ?= ‚é£shiftFactor‚é¶;
	low : whole number := finiteBaseMin << finiteShiftMin;
	If ‚é°truncationBits‚é§ ‚â† ‚àû then
	[
		finiteTruncationMax : whole number;
		‚Üì‚ÜëfiniteTruncationMax ?= ‚é°truncationBits‚é§;
		high := high min ((1 << finiteTruncationMax) - 1);
	];
	finiteTruncationMin : whole number;
	‚Üì‚ÜëfiniteTruncationMin ?= ‚é£truncationBits‚é¶;
	mask : whole number := (1 << finiteTruncationMin) - 1;
	low := low bit‚àß mask;
	[low..high+1)
] : whole number's type;
