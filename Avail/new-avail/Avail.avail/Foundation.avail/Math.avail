/*
 * Math.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Math"
Versions
	"dev"
Extends
	"Early Math"
Uses
	"Assertions",
	"Bootstrap",
	"Early Control Structures",
	"Early Definers",
	"Early Error Codes",
	"Early Functions",
	"Early Logic",
	"Early Sets",
	"Early Types",
	"Enumeration Support",
	"Literals",
	"Variables"
Names
	"type promotion function for_",
	"_is odd",
	"_is even",
	"_mod_",
	"-_",
	"_^_",
	"_(base_)",
	"«_‡«=»?«≤»?«<»?»",
	"«_‡«=»?«≥»?«>»?»",
	"_→integer",
	"_→extended integer"
Body

Forward method "_mod_" is [number, number]→number;
Forward method "-_" is [number]→number;

/* Establish grammatical rules. */
[
	sum      ::= {"_+_", "_-_"};
	product  ::= {"_×_", "_÷_", "_mod_"};
	negation ::= {"-_"};
	abs      ::= {"`|_`|"};
	power    ::= {"_^_"};

	sumAndProduct ::= sum ∪ product;

	/* Establish the standard grammatical rules for arithmetic. */
	Grammatical restriction product is <sum, sumAndProduct>;
	Grammatical restriction negation is <sumAndProduct ∪ {"∞"}>;
	
	/* Establish the precedence of exponentiation. */
	Grammatical restriction power is
		<sum ∪ product ∪ negation ∪ power, sum ∪ product>;

	/* Forbid nesting of absolute value. */
	Grammatical restriction abs is <abs>;
]();

/* These messages describe arithmetic failure (integers only). */
cannotAddMessage ::= "terms not to be unlike infinities";
cannotSubtractMessage ::= "terms not to be like infinities";
cannotMultiplyMessage ::= "terms not be 0 and ±∞";
cannotDivideByZeroMessage ::= "denominator not to be 0";
cannotDivideTwoInfinitiesMessage ::=
	"either numerator or denominator to be finite";
cannotRaiseZeroToZero ::= "either base or exponent not to be 0";
cannotRaiseInfinityToZero ::= "base not to be ±∞ or exponent not to be 0";
cannotRaiseNegativeToInfinity ::=
	"base not to be negative or exponent not to be ±∞";

Semantic restriction "_mod_" is type promotion function for
[
	a : number,
	b : number
|
	If b = 0 ∧ [ a ∈ extended integer ] then
	[
		Reject parse, expected: cannotDivideByZeroMessage
	];
	infinities ::= {∞, -∞};
	If a ∈ infinities ∧ [ b ∈ infinities ] then
	[
		Reject parse, expected: cannotDivideTwoInfinitiesMessage
	];
	a mod b
];

/**
 * Negate the argument. Avail's system dialect has no negative numeric literals,
 * but the associated semantic restriction effectively overcomes this limitation
 * (for literal arguments).
 * 
 * Parameters:
 *    a - A number.
 * Returns:
 *    The negation of the argument.
 */
Public method "-_" is
[
	a : number
|
	0 - a
];

/**
 * Compute and answer the strongest possible type of the argument. In
 * particular, an instance type will result in a precise answer that has the
 * same force as a literal.
 * 
 * Parameters:
 *    a - A numeric type.
 * Returns:
 *    The strongest possible type.
 */
Semantic restriction "-_" is
[
	a : number's type
|
	if |a| = 1 then
	[
		(0 - a's instance)'s type
	]
	else
	[
		if a ⊆ extended integer then
		[
		 	extended integer
		]
		else
		[
			if a ⊆ double then
			[
				double
			]
			else
			[
				if a ⊆ float then
				[
					float
				]
				else
				[
					number
				]
			]
		]
	]
];

Abstract method "⎣_⎦" is [number]→number;

/**
 * Compute and answer the floor of the argument. Note that integers and
 * infinities are their own floors.
 * 
 * Parameters:
 *    value - An integral value.
 * Returns:
 *    The argument.
 */
Method "⎣_⎦" is
[
	value : extended integer
|
	value
] : extended integer;

/**
 * If the exact type of the argument is know statically, then produce an exact
 * answer.
 *
 * Parameters:
 *    valueType - Any numeric type.
 * Returns:
 *    Either an instance type or `number`.
 */
Semantic restriction "⎣_⎦" is
[
	valueType : number's type
|
	if |valueType| = 1 then
	[
		⎣valueType's instance⎦'s type
	]
	else
	[
		/* An innocuous answer that will disappear in a type intersection with
		 * the answer produced by a more specific semantic restriction.
		 */
		number
	]
];

/**
 * Integers and infinities are their own floors.
 *
 * Parameters:
 *    valueType - An integral type.
 * Returns:
 *    The argument.
 */
Semantic restriction "⎣_⎦" is
[
	valueType : extended integer's type
|
	valueType
];

Abstract method "⎡_⎤" is [number]→number;

/**
 * Compute and answer the ceiling of the argument. Note that integers and
 * infinities are their own ceilings.
 * 
 * Parameters:
 *    value - An integral value.
 * Returns:
 *    The argument.
 */
Method "⎡_⎤" is
[
	value : extended integer
|
	value
] : extended integer;

/**
 * If the exact type of the argument is known statically, then produce an exact
 * answer.
 *
 * Parameters:
 *    valueType - Any numeric type.
 * Returns:
 *    Either an instance type or `number`.
 */
Semantic restriction "⎡_⎤" is
[
	valueType : number's type
|
	if |valueType| = 1 then
	[
		⎡valueType's instance⎤'s type
	]
	else
	[
		/* An innocuous answer that will disappear in a type intersection with
		 * the answer produced by a more specific semantic restriction.
		 */
		number
	]
];

/**
 * Integers and infinities are their own ceilings.
 *
 * Parameters:
 *    valueType - An integral type.
 * Returns:
 *    The argument.
 */
Semantic restriction "⎡_⎤" is
[
	valueType : extended integer's type
|
	valueType
];

/**
 * Compute and answer the remainder after dividing the divident by the divisor.
 * 
 * Parameters:
 *    dividend - The dividend.
 *    divisor - The divisor.
 * Returns:
 *    The remainder.
 */
Public method "_mod_" is
[
	dividend : number,
	divisor : number
|
	dividend - divisor × ⎣dividend ÷ divisor⎦
] : number;

/**
 * Compute and answer the remainder after dividing the divident by the divisor.
 * 
 * Parameters:
 *    dividend - The dividend.
 *    divisor - ∞.
 * Returns:
 *    The dividend.
 */
Public method "_mod_" is
[
	dividend : extended integer,
	divisor : ∞'s type
|
	dividend
] : extended integer;

/**
 * Is the argument odd?
 * 
 * Parameters:
 *    a - An integer.
 * Returns:
 *    `true` if the argument is odd, `false` otherwise.
 */
Public method "_is odd" is
[
	a : integer
|
	a mod 2 = 1
] : boolean;

/**
 * If the exact type of the argument is known statically, then produce an exact
 * answer.
 *
 * Parameters:
 *    a - An integral type.
 * Returns:
 *    Either an instance type or `number`.
 */
Semantic restriction "_is odd" is
[
	a : integer's type
|
	if |a| = 1 then
	[
		a's instance is odd's type
	]
	else
	[
		/* Don't strengthen. */
		⊤
	]
];

/**
 * Is the argument even?
 * 
 * Parameters:
 *    a - An integer.
 * Returns:
 *    `true` if the argument is even, `false` otherwise.
 */
Public method "_is even" is
[
	a : integer
|
	a mod 2 = 0
];

/**
 * If the exact type of the argument is known statically, then produce an exact
 * answer.
 *
 * Parameters:
 *    a - An integral type.
 * Returns:
 *    Either an instance type or `number`.
 */
Semantic restriction "_is even" is
[
	a : integer's type
|
	if |a| = 1 then
	[
		a's instance is even's type
	]
	else
	[
		/* Don't strengthen. */
		boolean
	]
];

/**
 * Compute and answer the integer range type of the sum of the argument types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    sums of the arguments' instances.
 */
Method "_+_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	lower ::= a's lower bound + b's lower bound - 1;
	lowerInclusive ::=
		(a's lower bound is inclusive ∧ [a's lower bound is infinite])
		∨ [b's lower bound is inclusive ∧ [b's lower bound is infinite]];
	upper ::= a's upper bound + b's upper bound + 1;
	upperInclusive ::=
		(a's upper bound is inclusive ∧ [a's upper bound is infinite])
		∨ [b's upper bound is inclusive ∧ [b's upper bound is infinite]];
	integer range
		from lower (inclusive=lowerInclusive)
		to upper (inclusive=upperInclusive)
];

/**
 * Compute and answer the integer range type of the product of the argument
 * types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    products of the arguments' instances.
 */
Method "_×_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	bounds ::=
	{
		{a's lower bound, a's upper bound},
		{b's lower bound, b's upper bound}
	};
	If bounds = {{0}, {∞}} ∨ [ bounds = {{0}, {-∞}} ] then
	[
		Reject parse, expected: cannotMultiplyMessage
	]
	else
	[
		negativeA : extended integer's type := a ∩ [-∞..-1];
		negativeB : extended integer's type := b ∩ [-∞..-1];
		positiveA : extended integer's type := a ∩ [1..∞];
		positiveB : extended integer's type := b ∩ [1..∞];
		result : extended integer's type := ⊥;
		If positiveA ≠ ⊥ then
		[
			If positiveB ≠ ⊥ then
			[
				lower ::= positiveA's lower bound × positiveB's lower bound;
				lowerInclusive ::= positiveA's lower bound is inclusive
					∧ [ positiveB's lower bound is inclusive ];
				upper ::= positiveA's upper bound × positiveB's upper bound;
				upperInclusive ::= positiveA's upper bound is inclusive
					∧ [ positiveB's upper bound is inclusive ];
				range ::= integer range
					from lower (inclusive=lowerInclusive)
					to upper (inclusive=upperInclusive);
				result := eject ↑result ∪ range;
			];
			If negativeB ≠ ⊥ then
			[
				lower ::= positiveA's upper bound × negativeB's lower bound;
				lowerInclusive ::= positiveA's upper bound is inclusive
					∧ [ negativeB's lower bound is inclusive ];
				upper ::= positiveA's lower bound × negativeB's upper bound;
				upperInclusive ::= positiveA's lower bound is inclusive
					∧ [ negativeB's upper bound is inclusive ];
				range ::= integer range
					from lower (inclusive=lowerInclusive)
					to upper (inclusive=upperInclusive);
				result := eject ↑result ∪ range;
			];
		];
		If negativeA ≠ ⊥ then
		[
			If positiveB ≠ ⊥ then
			[
				lower ::= negativeA's lower bound × positiveB's upper bound;
				lowerInclusive ::= negativeA's lower bound is inclusive
					∧ [ positiveB's upper bound is inclusive ];
				upper ::= negativeA's upper bound × positiveB's lower bound;
				upperInclusive ::= negativeA's upper bound is inclusive
					∧ [ positiveB's lower bound is inclusive ];
				range ::= integer range
					from lower (inclusive=lowerInclusive)
					to upper (inclusive=upperInclusive);
				result := eject ↑result ∪ range;
			];
			If negativeB ≠ ⊥ then
			[
				lower ::= negativeA's upper bound × negativeB's upper bound;
				lowerInclusive ::= negativeA's upper bound is inclusive
					∧ [ negativeB's upper bound is inclusive ];
				upper ::= negativeA's lower bound × negativeB's lower bound;
				upperInclusive ::= negativeA's lower bound is inclusive
					∧ [ negativeB's lower bound is inclusive ];
				range ::= integer range
					from lower (inclusive=lowerInclusive)
					to upper (inclusive=upperInclusive);
				result := eject ↑result ∪ range;
			];
		];
		/* Zero is handled specially, to prevent multiplication of 0 and ±∞ by
		 * one of the preceding clauses.
		 */
		If 0's type ⊆ a ∨ [ 0's type ⊆ b ] then
		[
			result := eject ↑result ∪ 0's type;
		];
		result
	]
];

/**
 * Compute and answer the negation of the specified integral type.
 * 
 * Parameters:
 *    a - An integral type.
 * Returns:
 *    The negation of the argument, e.g., the negation of [3..5] is [-5..-3].
 */
Public method "-_" is
[
	a : extended integer's type
|
	a × -1's type
];

/**
 * Strengthen negation.
 * 
 * Parameters:
 *    a - An integral type.
 * Returns:
 *    The negation of the argument.
 */
Semantic restriction "-_" is
[
	a : extended integer's type
|
	- a
];

/**
 * Compute and answer the integer range type of the difference of the argument
 * types.
 * 
 * Paramters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    differences of the arguments' instances.
 */
Method "_-_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	a + (- b)
];

/**
 * Compute and answer the integer range type of the sum of the argument types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    sums of the arguments' instances.
 */
Semantic restriction "_+_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	bounds ::=
	{
		{a's lower bound, a's upper bound},
		{b's lower bound, b's upper bound}
	};
	If bounds = {{-∞}, {∞}} then
	[
		Reject parse, expected: cannotAddMessage
	];
	a + b
];

/**
 * Compute and answer the integer range type of the difference of the argument
 * types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    differences of the arguments' instances.
 */
Semantic restriction "_-_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	negated ::= - b;
	bounds ::=
	{
		{a's lower bound, a's upper bound},
		{negated's lower bound, negated's upper bound}
	};
	If bounds = {{-∞}, {∞}} then
	[
		Reject parse, expected: cannotSubtractMessage
	];
	a + negated
];

/**
 * Compute and answer the integer range type of the product of the argument
 * types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    products of the arguments' instances.
 */
Semantic restriction "_×_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	a × b
];

/**
 * Compute and answer the integer range type of the quotient.
 * 
 * Parameters:
 *    numeratorRange - An integral type.
 *    denomintor - An integer.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    quotients of `numeratorRange`'s instances and `denominator`.
 */
Method "_÷_" is
[
	numeratorRange : extended integer's type,
	denominator : extended integer
|
	/* Produce ⊥ if the numerator range is ⊥ or the denominator is 0. */
	if numeratorRange = ⊥ ∨ [ denominator = 0 ] then
	[
		⊥
	]
	else
	[
		/* ±∞ divided by any finite nonzero value is 0. */
		if denominator is infinite then
		[
			0's type
		]
		else
		[
			/* The denominator is finite and nonzero. The numerator may be
			 * either finite or infinite. The following handles all cases.
			 */
			numeratorMin ::= numeratorRange's lower bound ÷ denominator;
			lowerInclusive ::= numeratorRange's lower bound is inclusive;
			numeratorMax ::= numeratorRange's upper bound ÷ denominator;
			upperInclusive ::= numeratorRange's upper bound is inclusive;
			if denominator < 0 then
			[
				integer range
					from numeratorMax (inclusive=upperInclusive)
					to numeratorMin (inclusive=lowerInclusive)
			]
			else
			[
				integer range
					from numeratorMin (inclusive=lowerInclusive)
					to numeratorMax (inclusive=upperInclusive)
			]
		]
	]
];

/**
 * Compute and answer the integer range type of the quotient of the argument
 * types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    quotients of the arguments' instances.
 */
Semantic restriction "_÷_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	denominatorSet ::= {b's lower bound, b's upper bound};
	If denominatorSet = {0} then
	[
		Reject parse, expected: cannotDivideByZeroMessage
	];
	numeratorSet ::= {a's lower bound, a's upper bound};
	infinities ::= {{∞}, {-∞}};
	If numeratorSet ∈ infinities ∧ [ denominatorSet ∈ infinities ] then
	[
		Reject parse, expected: cannotDivideTwoInfinitiesMessage
	];
	union : extended integer's type := ⊥;
	negativeDenominators ::= b ∩ [-∞..-1];
	If negativeDenominators ≠ ⊥ then
	[
		union :=
			eject ↑union ∪ (a ÷ negativeDenominators' genuine lower bound);
		union :=
			eject ↑union ∪ (a ÷ negativeDenominators' genuine upper bound);
	];
	positiveDenominators ::= b ∩ [1..∞];
	If positiveDenominators ≠ ⊥ then
	[
		union :=
			eject ↑union ∪ (a ÷ positiveDenominators' genuine lower bound);
		union :=
			eject ↑union ∪ (a ÷ positiveDenominators' genuine upper bound);
	];
	union
];

/**
 * Compute and answer the integer range type of the remainder of the argument
 * types.
 * 
 * Parameters:
 *    a - An integral type.
 *    b - An integral type.
 * Returns:
 *    The narrowest integer range type general enough to hold all possible
 *    remainders of the arguments' instances.
 */
Semantic restriction "_mod_" is
[
	a : extended integer's type,
	b : extended integer's type
|
	denominatorSet ::= {b's lower bound, b's upper bound};
	If denominatorSet = {0} then
	[
		Reject parse, expected: cannotDivideByZeroMessage
	];
	numeratorSet ::= {a's lower bound, a's upper bound};
	infinities ::= {{∞}, {-∞}};
	If numeratorSet ∈ infinities ∧ [ denominatorSet ∈ infinities ] then
	[
		Reject parse, expected: cannotDivideTwoInfinitiesMessage
	];
	if b's lower bound = b's upper bound
		∧ [ a's lower bound is finite
		∧ [ a's upper bound is finite
		∧ [ a's lower bound ÷ b's lower bound
			= a's upper bound ÷ b's lower bound ] ] ]
	then
	[
		[a's lower bound mod b's lower bound
			.. a's upper bound mod b's lower bound]
	]
	else
	[
		[0..b's upper bound)
	]
];

/* Disambiguate `_→_` and several conversion operations. */
Grammatical restriction {"_→_"} is <∅, {"double", "extended integer", "float"}>;

/**
 * Compute and answer the absolute value of the argument.
 * 
 * Parameters:
 *    a - A number.
 * Returns:
 *    The absolute value of `a`.
 */
Method "`|_`|" is
[
	a : number
|
	if a < 0 then [ -a ] else [ a ]
] : number;

/**
 * Preserve the numeric type of the argument.
 * 
 * Parameter:
 *    a - `double`.
 * Returns:
 *    `double`.
 */
Semantic restriction "`|_`|" is
[
	a : double's type
|
	a
];

/**
 * Preserve the numeric type of the argument.
 * 
 * Parameter:
 *    a - `float`.
 * Returns:
 *    `float`.
 */
Semantic restriction "`|_`|" is
[
	a : float's type
|
	a
];

/**
 * Strengthen the absolute value operation for integral types.
 * 
 * Parameters:
 *    a - An integral type.
 * Returns:
 *    A positive integer range that includes the absolute values of all
 *    instances of `a`.
 */
Semantic restriction "`|_`|" is
[
	a : extended integer's type
|
	if |a| = 1 then
	[
		|a's instance|'s type
	]
	else
	[
		([0..∞] ∩ a) ∪ ([0..∞] ∩ - a)
	]
];

/**
 * Compute and answer the boolean value of the sequence of equals, less than or
 * equal, and less than operators.
 * 
 * Parameters:
 *    args - A tuple whose elements are a sequence of 4-tuples following by an
 *       ending 1-tuple. The first element of these 1,4-tuples is a number.
 *       If present, the second element will be a boolean that indicates that
 *       this number should be checked for equality with the next number. If
 *       present, the third element will be a boolean that indicates that this
 *       number should be compared against the next number to see if it is less
 *       than or equal. If present, the fourth element will be a boolean that
 *       indicates this this number should be compared against the next number
 *       to see if it is strictly less.
 * Returns:
 *    `true` if the entire chain of comparisons is true, `false` otherwise.
 */
Public method "«_‡«=»?«≤»?«<»?»" is
[
	args : <<number, boolean…|1..4>…|3..∞>
|
	predicates ::=
		<
			[ a : number, b : number | a = b ],
			[ a : number, b : number | a ≤ b ],
			[ a : number, b : number | a < b ]
		>;
	result : boolean := true;
	From 1 to |args| - 1 do
	[
		index : natural number
	|
		arg ::= args[index];
		Assert: |arg| = 4 ("args ≠ <aNumber, isEqual, isLess, isLessEqual>");
		/* Determine which predicate to apply. */
		predicate : [number, number]→boolean;
		From 2 to 4 do
		[
			predicateIndex : [2..4]
		|
			if arg[predicateIndex] then
			[
				predicate := predicates[predicateIndex - 1];
				false
			]
			else
			[
				true
			]
		];
		Assert: ¬↑predicate is unassigned ("no predicate was selected");
		if predicate(arg[1], args[index + 1][1]) then
		[
			true
		]
		else
		[
			result := false;
			false
		]
	];
	result
];

Private method "comparison chain semantic restriction function" is
[
	[
		args : <<number, boolean…|1..4>…|3..∞>'s type
	|
		exactSize ::= ||args||'s lower bound - 1;
		From 1 to exactSize do
		[
			index : natural number
		|
			arg ::= args[index];
			optionCount : whole number := 0;
			From 2 to 4 do
			[
				optionIndex : [2..4]
			|
				If arg[optionIndex]'s instance then
				[
					↑optionCount++;
				];
				true
			];
			If optionCount ≠ 1 then
			[
				Reject parse, expected:
					"exactly one comparison operator between numeric arguments"
			];
			true
		];
		⊤
	]
];

Semantic restriction "«_‡«=»?«≤»?«<»?»" is
	comparison chain semantic restriction function;

/**
 * Compute and answer the boolean value of the sequence of equals, greater than
 * or equal, and greater than operators.
 * 
 * Parameters:
 *    args - A tuple whose elements are a sequence of 4-tuples following by an
 *       ending 1-tuple. The first element of these 1,4-tuples is a number.
 *       If present, the second element will be a boolean that indicates that
 *       this number should be checked for equality with the next number. If
 *       present, the third element will be a boolean that indicates that this
 *       number should be compared against the next number to see if it is
 *       greater than or equal. If present, the fourth element will be a boolean
 *       that indicates this this number should be compared against the next
 *       number to see if it is strictly greater.
 * Returns:
 *    `true` if the entire chain of comparisons is true, `false` otherwise.
 */
Public method "«_‡«=»?«≥»?«>»?»" is
[
	args : <<number, boolean…|1..4>…|3..∞>
|
	predicates ::=
		<
			[ a : number, b : number | a = b ],
			[ a : number, b : number | a ≥ b ],
			[ a : number, b : number | a > b ]
		>;
	result : boolean := true;
	From 1 to |args| - 1 do
	[
		index : natural number
	|
		arg ::= args[index];
		Assert: |arg| = 4
			("args ≠ <aNumber, isEqual, isGreater, isGreaterEqual>");
		/* Determine which predicate to apply. */
		predicate : [number, number]→boolean;
		From 2 to 4 do
		[
			predicateIndex : [2..4]
		|
			if arg[predicateIndex] then
			[
				predicate := predicates[predicateIndex - 1];
				false
			]
			else
			[
				true
			]
		];
		Assert: ¬↑predicate is unassigned ("no predicate was selected");
		if predicate(arg[1], args[index + 1][1]) then
		[
			true
		]
		else
		[
			result := false;
			false
		]
	];
	result
];

Semantic restriction "«_‡«=»?«≥»?«>»?»" is
	comparison chain semantic restriction function;

/* Disambiguate the comparison chains from the binary comparisons. */
[
	binary ::= {"_=_", "_≤_", "_<_", "_≥_", "_>_"};
	chains ::= {"«_‡«=»?«≤»?«<»?»", "«_‡«=»?«≥»?«>»?»"};
	comparisons ::= binary ∪ chains;
	Grammatical restriction binary is <comparisons, comparisons>;
	Grammatical restriction chains is <comparisons>;
]();

/**
 * Compute and answer the result of exponentiating `base` by `exponent`.
 * 
 * Parameters:
 *    base - The base.
 *    exponent - The exponent.
 * Returns:
 *    The result of raising `base` to the `exponent` power.
 */
Method "_^_" is
[
	base : number,
	exponent : number
|
	/* Uses the identity: a^b = exp(ln(a^b)) = exp(b*ln(a)). */
	Euler number ^ (exponent × ln (base→double))
] : number;

/**
 * Establish type promotion rules for exponentiation. Also handle instance
 * types.
 * 
 * Parameters:
 *    a - The base's type.
 *    b - The exponent's type.
 * Returns:
 *    A numeric type that is not an integral kind. (These are dealt with by
 *    another restriction.)
 */
Semantic restriction "_^_" is type promotion function for
[
	a : number,
	b : number
|
	If b = 0 then
	[
		If a = 0 then
		[
			Reject parse, expected: cannotRaiseZeroToZero
		];
		If a ∈ {-∞, ∞} then
		[
			Reject parse, expected: cannotRaiseInfinityToZero
		];
	];
	If a ∈ extended integer then
	[
		If a < 0 ∧ [ b ∈ {-∞, ∞} ] then
		[
			Reject parse, expected: cannotRaiseNegativeToInfinity
		];
	];
	a ^ b
];

/* The remaining implementations of `_^_` are recursive, so forward declare them
 * here.
 */
Forward method "_^_" is [extended integer, whole number]→extended integer;
Forward method "_^_" is [float, whole number]→float;
Forward method "_^_" is [double, whole number]→double;

/**
 * Compute and answer the result of exponentiating `base` by `exponent`.
 * 
 * Parameters:
 *    base - The base.
 *    exponent - The exponent.
 * Returns:
 *    The result of raising `base` to the `exponent` power.
 */
Method "_^_" is
[
	base : extended integer,
	exponent : whole number
|
	/* TODO: [TLS] Must forbid 0^0, [-∞..0)^{-∞, ∞}, {-∞, ∞}^0. */
	/*  Uses the identities: b^(2x) = (b^2)^x; and: b^(2x+1) = (b^2)^x*b. */
	if exponent = 0 then
	[
		1
	]
	else
	[
		intermediate ::= (base × base) ^ (exponent ÷ 2);
		if exponent is odd then [ intermediate × base ] else [ intermediate ]
	]
] : extended integer;

/**
 * Compute and answer the result of exponentiating `base` by `exponent`.
 * 
 * Parameters:
 *    base - The base.
 *    exponent - The exponent.
 * Returns:
 *    The result of raising `base` to the `exponent` power.
 */
Method "_^_" is
[
	base : float,
	exponent : whole number
|
	/*  Uses the identities: b^(2x) = (b^2)^x; and: b^(2x+1) = (b^2)^x*b. */
	if exponent = 0 then
	[
		1.0
	]
	else
	[
		intermediate ::= (base × base) ^ (exponent ÷ 2);
		if exponent is odd then [ intermediate × base ] else [ intermediate ]
	]
] : float;

/**
 * Compute and answer the result of exponentiating `base` by `exponent`.
 * 
 * Parameters:
 *    base - The base.
 *    exponent - The exponent.
 * Returns:
 *    The result of raising `base` to the `exponent` power.
 */
Method "_^_" is
[
	base : double,
	exponent : whole number
|
	/*  Uses the identities: b^(2x) = (b^2)^x; and: b^(2x+1) = (b^2)^x*b. */
	if exponent = 0 then
	[
		1.0d
	]
	else
	[
		intermediate ::= (base × base) ^ (exponent ÷ 2);
		if exponent is odd then [ intermediate × base ] else [ intermediate ]
	]
] : double;

digitZero ::= ¢0→code point;
digitNine ::= ¢9→code point;
lettera ::= ¢a→code point;
letterz ::= ¢z→code point;
letterA ::= ¢A→code point;
letterZ ::= ¢Z→code point;

/**
 * Variable-radix string to integer conversion.
 *
 * Parameters:
 *    digits - A `string` of digits in the base. 
 *    base - The base under which to interpret the digits.
 * Returns:
 *    The number represented by the digits as a whole number.
 */
Public method "_(base_)" is 
[
	digits : string,
	base : [2..36] 
|
	answer : integer := 0;
	From 1 to |digits| do 
	[
		index : natural number
	|
		char ::= digits[index];
		dig ::= char→code point;

		digValue ::=
			if digitZero ≤ dig ≤ digitNine then 
			[ 
				dig - digitZero
			] 
			else
			[
				if lettera ≤ dig ≤ letterz then
				[
					dig - lettera + 10
				]
				else
				[
					if letterA ≤ dig ≤ letterZ then 
					[
						dig - letterA + 10
					]
					else 
					[
						early failure function(invalid argument code)
					]
				]
			];

		If digValue ≥ base ∨ [digValue < 0] then 
			[early failure function(invalid argument code)];

		answer := answer × base + digValue;
		true
	];
	cast answer into [a: whole number | a]
];

/**
 * Strengthen "_(base_)".
 */
Semantic restriction "_(base_)" is
[
	baseType : [2..36]'s type,
	digitsType : string's type
|
	maxStringSize ::= ||digitsType||'s upper bound;
	if maxStringSize is finite then [
		/* Compute a rough bound based on the string size and base. */
		finiteMaxStringSize ::= cast maxStringSize into [w : whole number | w];
		maxBase ::= baseType's upper bound;
		[0..maxBase ^ finiteMaxStringSize)
	] else [
		whole number
	]
];
	
/**
 * Convert a string containing a number in base 10 to an integer.
 * 
 * Parameter:
 *    str - A `string` of digits in base 10.
 * Returns:
 *    The number represented by the digits as a whole number.
 */
Public method "_→integer" is
[
	str : string
|
	If |str| > 1 ∧ [str[1] = ¢0]
		then [early failure function(invalid argument code)];
	
	if str[1] = ¢- then 
	[
		stream : string := "";
	
		stream := concatenate <stream, (str[2..|str|])>;
		(-1) × (stream (base 10))
	] else 
	[
		str (base 10)
	]
]: integer;

/**
 * Convert a string containing a number in base 10 to an extended integer.
 * 
 * Parameter:
 *    str - A `string` of digits in base 10.
 * Returns:
 *    The number represented by the digits as a whole number.
 */
Public method "_→extended integer" is
[
	str : string
|
	if str = "∞" then [∞] 
	else
	[
		if str = "-∞" then [-∞]
		else [str→integer]
	]
]: extended integer;