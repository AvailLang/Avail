/*
 * Maps.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Maps"
Versions
	"dev"
Extends
	"Collections",
	"Early Maps"
Uses
	"Bootstrap",
	"Control Structures",
	"Definers",
	"Early Functions",
	"Early Tuples",
	"Enumeration Support",
	"Literals",
	"Logic",
	"Math",
	"Sets",
	"Tuples",
	"Types",
	"Variables"
Names
	"counts for_"
Body

/**
 * Is the specified map empty? 
 *
 * Parameters:
 *    aMap - A map.
 * Returns:
 *    `true` if the argument is empty, `false` otherwise.
 */
Method "_is empty" is
[
	aMap : map
|
	|aMap| = 0
];

/**
 * Iteratively apply `action` to each binding of `aMap`, but in no particular
 * order.
 * 
 * Parameters:
 *    aMap - A map.
 *    action - A function that accepts the bindings of the map. The first
 *       argument is a key from the map, the second is a value from the map.
 */
Method "For each_do_" is
[
	aMap : map,
	action : [⊥, ⊥]→⊤
|
	index : natural number := 1;
	bindings ::= aMap's bindings;
	end ::= |aMap|;
	[
		$loop;
		If index ≤ end then
		[
			binding ::= bindings[index];
			Invoke action with <binding[1], binding[2]>;
			↑index++;
			Restart loop
		];
	]();
] : ⊤;

/**
 * Helper method for semantic restrictions: If `action` does not accept the
 * key and value types of `mapType`, then reject the current parse.
 * 
 * Parameters:
 *    action - A function type whose first two arguments must correspond to the
 *       key and value types of `mapType`.
 *    mapType - A map type.
 */
Private method "Require:_accepts_" is
[
	action : function meta,
	mapType : map meta
|
	If ⎣action's parameters' type⎦ < 2 then
	[
		Reject parse, expected:
			"repeatedly applied function to accept at least two arguments"
	];
	If action[1] ≠ ⊥ ∧ [ ¬mapType's key type ⊆ action[1] ] then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all keys ∈ "
			++ “mapType's key type”
			++ " (but it only accepts "
			++ “action[1]”
			++ ")"
	];
	If action[2] ≠ ⊥ ∧ [ ¬mapType's value type ⊆ action[2] ] then
	[
		Reject parse, expected:
			"repeatedly applied function to accept all values ∈ "
			++ “mapType's value type”
			++ " (but it only accepts "
			++ “action[2]”
			++ ")"
	];
] : ⊤;

/**
 * Ensure that the function will accept all bindings of the map. If the map is
 * certainly nonempty and the function certainly does not complete if applied,
 * then answer ⊥.
 * 
 * Parameters:
 *    mapType -
 *    action -
 * Returns:
 *    Either ⊤ or ⊥.
 */
Semantic restriction "For each_do_" is
[
	mapType : map meta,
	action : [⊥, ⊥]→⊤'s type
|
	Require: action accepts mapType;
	if ⎣mapType⎦ > 0 ∧ [ action's return type = ⊥ ] then
	[
		⊥
	]
	else
	[
		⊤
	]
];

/**
 * Iteratively apply `transformer` to each binding of `aMap`, in no particular
 * order, collecting the results into a new map. The resultant map has the same
 * keys as the original, but its values have been transformed via `transformer`.
 * 
 * Parameters:
 *    aMap - A map.
 *    transformer - A function that accepts the bindings of the map. The first
 *       argument is a key from the map, the second is a value from the map.
 *       This function answers a replacement value for the given binding.
 * Returns:
 *    A map of results of applications of `transformer` to the elements of
 *    `aMap`.
 */
Method "map_through_" is
[
	aMap : map,
	transformer : [⊥, ⊥]→any
|
	index : natural number := 1;
	bindings ::= aMap's bindings;
	end ::= |aMap|;
	result : map := {};
	[
		$loop;
		If index ≤ end then
		[
			binding ::= bindings[index];
			key ::= binding[1];
			value ::= binding[2];
			result := eject ↑result + key→invoke transformer with <key, value>;
			↑index++;
			Restart loop
		];
	]();
	result
] : map;

/**
 * Ensure that the function will accept all bindings of the map. If the map is
 * certainly nonempty, then the function cannot answer ⊥.
 *
 * Parameters:
 *    mapType -
 *    transformer -
 * Returns:
 *    A map type whose key type is the key type of `mapType`, whose value
 *    type is the return type of `transformer`, and whose cardinality is the
 *    same as `mapType`'s.
 */
Semantic restriction "map_through_" is
[
	mapType : map meta,
	transformer : [⊥, ⊥]→any's type
|
	Require: transformer accepts mapType;
	If ⎣mapType⎦ > 0 then
	[
		If transformer's return type = ⊥ then
		[
			Reject parse, expected:
				"repeatedly applied function to have a return type other than\
				\| ⊥"
		];
	];
	{mapType's key type → transformer's return type | ||mapType||}
];

/**
 * Iteratively apply `predicate` to each binding of `aMap`, in no particular
 * order, collecting those bindings for which `predicate` answers `true` into a
 * new map. Answer the new map.
 *
 * Parameters:
 *    aMap - A map.
 *    predicate - A function that accepts the bindings of the map and answers
 *       `true` iff they should be accumulated into the output map.
 * Returns:
 *    A map containing exactly those bindings of `aMap` for which `predicate`
 *    answered `true`.
 */
Method "filter_by_" is
[
	aMap : map,
	predicate : [⊥, ⊥]→boolean
|
	bindings ::= aMap's bindings;
	index : natural number := 1;
	end ::= |bindings|;
	result : map := {};
	[
		$loop;
		If index ≤ end then
		[
			binding ::= bindings[index];
			key ::= binding[1];
			value ::= binding[2];
			If invoke predicate with <key, value> then
			[
				result := eject ↑result + key→value;
			];
			↑index++;
			Restart loop
		];
	]();
	result
] : map;

/**
 * Ensure that the function will accept all elements of the map.
 * 
 * Parameters:
 *    mapType -
 *    predicate -
 * Returns:
 *    A map type whose key and value types are the same as `mapType`'s and which
 *    has cardinality `[0..⎡mapType⎤ + 1)`.
 */
Semantic restriction "filter_by_" is
[
	mapType : map meta,
	predicate : [⊥, ⊥]→boolean's type
|
	Require: predicate accepts mapType;
	sizes ::=
		if predicate's return type = true's type then [ ||mapType|| ]
		else if [ predicate's return type = false's type ] then [ 0's type ]
		else [ [0..⎡mapType⎤ + 1) ];
	{mapType's key type → mapType's value type|sizes}
];

/**
 * Iteratively apply `accumulator` to the bindings of `aMap`, in no particular
 * order, in order to transform and filter its bindings into a new map. When
 * `accumulator` is invoked, it is passed a "keeper" function. The keeper
 * function may be invoked to "save" a particular value, i.e., a value that will
 * be associated with the current key in the output set. The keeper function
 * will save at most one value per binding of `aSet`, i.e., each time that
 * `accumulator` is invoked, it may invoke the keeper function at most one time.
 * Answer the new map.
 * 
 * Parameters:
 *    aMap - A map.
 *    accumulator - A function that accepts 1) a key from `aMap`, 2) the value
 *       associated with that key, and 3) a keeper function. The keeper function
 *       accepts an argument of the (value) type that should be saved.
 * Returns:
 *    A map whose bindings are those saved by the `accumulator`.
 */
Method "map and filter_by_" is
[
	aMap : map,
	accumulator : [⊥, ⊥, ⊥]→⊤
|
	bindings ::= aMap's bindings;
	index : natural number := 1;
	end ::= |bindings|;
	result : map := {};
	[
		$loop;
		If index ≤ end then
		[
			hasAlreadyKept : boolean := false;
			binding ::= bindings[index];
			key ::= binding[1];
			value ::= binding[2];
			Invoke accumulator with
			<
				key,
				value,
				[
					transformed : any
				|
					If ¬hasAlreadyKept then
					[
						result := eject ↑result + key→transformed;
						hasAlreadyKept := true;
					];
				]
			>;
			↑index++;
			Restart loop
		];
	]();
	result
] : map;

/**
 * Ensure that the function will accept all bindings of the map and also an
 * appropriately typed keeper function.
 *
 * Parameters:
 *    mapType -
 *    accumulator -
 * Returns:
 *    A map type whose key type is the key type of `mapType`, whose value type
 *    is the parameter type of the keeper function, and whose cardinality is
 *    `[0..⎡mapType⎤ + 1)`.
 */
Semantic restriction "map and filter_by_" is
[
	mapType : map meta,
	accumulator : [⊥, ⊥, ⊥]→⊤'s type
|
	Require: accumulator accepts mapType;
	Require: accumulator's keeper is valid;
	If accumulator's return type ≠ ⊤ then
	[
		Reject parse, expected:
			"repeatedly applied function to have return type ⊤"
	];
	valueType ::= cast accumulator[3] into [ t : function meta | t[1] ];
	{
		mapType's key type → valueType
		| [0..⎡mapType⎤ + 1)
	}
];

/**
 * Compute and answer whether any of the elements of `aMap` satisfies the
 * specified function. Do not examine more elements than necessary.
 * 
 * Parameters:
 *    aMap - A map.
 *    predicate - A function that accepts the elements of the map and answers
 *       a boolean.
 * Returns:
 *    `true` if `predicate` answers `true` for any element of `aMap`, `false`
 *    otherwise.
 */
Method "any of_satisfies_" is
[
	aMap : map,
	predicate : [⊥, ⊥]→boolean
|
	$body : boolean;
	For each aMap do
	[
		key : any,
		value : any
	|
		If invoke predicate with <key, value> then
		[
			Exit body with true
		];
	];
	false
] : boolean;

/**
 * Ensure that the function will accept all elements of the map.
 * 
 * Parameters:
 *    mapType -
 *    predicate -
 * Returns:
 *    The function's return type.
 */
Semantic restriction "any of_satisfies_" is
[
	mapType : map meta,
	predicate : [⊥, ⊥]→boolean's type
|
	Require: predicate accepts mapType;
	predicate's return type
];

/**
 * Compute and answer whether each of the elements of `aMap` satisfies the
 * specified function. Do not examine more elements than necessary.
 * 
 * Parameters:
 *    aMap - A map.
 *    predicate - A function that accepts the bindings of the map and answers
 *       a boolean.
 * Returns:
 *    `true` if `predicate` answers `true` for each element of `aMap`, `false`
 *    otherwise.
 */
Method "each of_satisfies_" is
[
	aMap : map,
	predicate : [⊥, ⊥]→boolean
|
	$body : boolean;
	For each aMap do
	[
		key : any,
		value : any
	|
		Unless invoke predicate with <key, value> then
		[
			Exit body with false
		];
	];
	true
] : boolean;

/**
 * Ensure that the function will accept all bindings of the map.
 * 
 * Parameters:
 *    mapType -
 *    predicate -
 * Returns:
 *    The function's return type.
 */
Semantic restriction "each of_satisfies_" is
[
	mapType : map meta,
	predicate : [⊥, ⊥]→boolean's type
|
	Require: predicate accepts mapType;
	predicate's return type
];

/**
 * Compute and answer the count of bindings of `aMap` that satisfy the given
 * predicate.
 * 
 * Parameters:
 *    aMap - A map.
 *    predicate - A function that accepts the bindings of the map and answers
 *       `true` if the binding should be represented in the resulting count.
 * Returns:
 *    The number of bindings of `aMap` for which `predicate` answers `true`.
 */
Method "count of_where_" is
[
	aMap : map,
	predicate : [⊥, ⊥]→boolean
|
	|filter aMap by predicate|
] : whole number;

/**
 * Ensure that the function will accept all bindings of the map.
 * 
 * Parameters:
 *    mapType -
 *    predicate -
 * Returns:
 *    `[0..⎡mapType⎤ + 1)`.
 */
Semantic restriction "count of_where_" is
[
	mapType : map meta,
	predicate : [⊥, ⊥]→boolean's type
|
	Require: predicate accepts mapType;
	[0..⎡mapType⎤ + 1)
];

Method "_∈_" is stable at [any, map]→boolean;
Semantic restriction "_∈_" is
[
	keyType : any meta,
	mapType : map meta
|
	mapKeyType ::= mapType's key type;
	if keyType ∩ mapKeyType = ⊥ then
	[
		false's type
	]
	else
	[
		if (¬mapKeyType ∈ type)
			∧ [|mapKeyType| = ⎣mapType⎦
			∧ [|mapKeyType| = ⎡mapType⎤
			∧ [keyType ⊆ mapKeyType]]]
		then
		[
			true's type
		]
		else
		[
			/* Can't strengthen. */
			⊤
		]
	]
];

/**
 * Categorize the elements of `aTuple` via `discriminator`.
 *
 * Parameters:
 *    aTuple - The tuple to categorize.
 *    discriminator - A function that accepts each element of the tuple and
 *       answers a value that represents the group to which the element belongs.
 * Returns:
 *    A map whose keys describe groups and whose elements are the groups
 *    themselves, i.e., the tuples of elements that constitute the described
 *    group.
 */
Method "group_by_" is
[
	aTuple : tuple,
	discriminator : [⊥]→any
|
	groups : {any→tuple|} := {};
	For each aTuple do
	[
		element : any
	|
		key ::= invoke discriminator with <element>;
		group ::= groups[key] else [ <> ] ++ <element>;
		groups := eject ↑groups + key→group;
	];
	groups
] : map;

Semantic restriction "group_by_" is
[
	aTupleType : tuple's type,
	discriminatorType : [⊥]→any's type
|
	Require: discriminatorType accepts aTupleType;
	tupleCardinality ::= ||aTupleType||;
	tupleUpperBound ::= ⎡tupleCardinality⎤;
	defaultType ::= ∪ aTupleType[1..|aTupleType's leading types| + 1];
	keyType ::= discriminatorType's return type;
	lowerBound ::= if ⎣tupleCardinality⎦ = 0 then [0] else [1];
	upperBound ::= if tupleUpperBound > |keyType| 
		then [|keyType|]
		else [tupleUpperBound];
	valueType ::= <defaultType… | 1..tupleUpperBound>;
	{keyType→valueType | lowerBound..upperBound}
];

/**
 * Categorize the elements of `aSet` via `discriminator`.
 *
 * Parameters:
 *    aSet - The set to categorize.
 *    discriminator - A function that accepts each element of the set and
 *       answers a value that represents the group to which the element belongs.
 * Returns:
 *    A map whose keys describe groups and whose elements are the groups
 *    themselves, i.e., the sets of elements that constitute the described
 *    group.
 */
Method "group_by_" is
[
	aSet : set,
	discriminator : [⊥]→any
|
	groups : {any→set|} := {};
	For each aSet do
	[
		element : any
	|
		key ::= invoke discriminator with <element>;
		group ::= groups[key] else [ ∅ ] + element;
		groups := eject ↑groups + key→group;
	];
	groups
] : map;

/**
 * Strengthen return type.
 *
 * Parameters:
 *    aSetType - The set to categorize's type.
 *    discriminator - A function that accepts each element of the set and
 *       answers a value that represents the group to which the element belongs.
 * Returns:
 *    Most specific map type.
 */
Semantic restriction "group_by_" is
[
	aSetType : set's type,
	discriminatorType : [⊥]→any's type
 |

 	Require: discriminatorType accepts aSetType;
 	
 	setCardinality ::= ||aSetType||;
 	setUpperBound ::= ⎡setCardinality⎤;
	keyType ::= discriminatorType's return type;
	
 	lowerBound ::= if ⎣setCardinality⎦ = 0 then [0] else [1];
	upperBound ::= if setUpperBound > |keyType| 
		then [|keyType|]
		else [setUpperBound];

 	valueType ::= {aSetType's element type | 1..setUpperBound};

 	{keyType→valueType | lowerBound..upperBound}
 ];

/**
 * Count the elements of a tuple.
 *
 * Parameters:
 *    aTuple - the tuple whose elements you will count
 * Returns:
 *    a map with keys that are the elements of the tuple that maps to the values
 *    that are the counts that each element occurs in the tuple.
 */
Public stable method "counts for_" is
[
	aTuple : tuple
|
	groups ::= group aTuple by [a : any | a];
	map groups through [k : any, t : tuple | |t|]
] : map;

Semantic restriction "counts for_" is
[
	aTupleType : tuple's type
|
	keyType ::= ∪ aTupleType[1..|aTupleType's leading types| + 1];
	tupleCardinality ::= ||aTupleType||;
	lowerBound ::= if ⎣tupleCardinality⎦ = 0 then [0] else [1];
	upperBound ::= ⎡tupleCardinality⎤;
	{keyType→whole number|lowerBound..upperBound}
];

/**
 * Combine two maps.  If there are duplicate keys, perform action block to
 * handle duplicates.  
 * @method "Integrate_and_with_"
 * @categories "Annals"
 * @param "baseMap" "map" base map to add new bindings to.
 * @param "supplementMap" "map" secondary map that provides new map bindings
 * @param "action" "[⊥,⊥,⊥]→map" action to perform in the event that there is a
 * 		duplicate key.  Inputs are [map,any,any]
 * @returnType "map" the resultant map
 * @raises
 */
Private method "integrate_and_with_" is
[
 	baseMap : map,
 	supplementMap : map,
 	action : [⊥,⊥,⊥]→map
 |
 	baseMapkeys ::= baseMap's keys;
 	newMap : map := baseMap;
 	For each supplementMap do
 	[
 	 	supplementKey : any,
 	 	supplementValue : any
 	 |
 	 	if baseMapkeys ∋ supplementKey then
 	 	[
 	 	 	newMap := Invoke action with 
 	 	 		<newMap,supplementKey,supplementValue>;
 	 	]
 	 	else [newMap := newMap + supplementKey→supplementValue;];
 	];
 	newMap
 ]:map;

/**
 *
 * @method "Integrate_and_with_"
 * @categories "Annals"
 * @restricts ""
 * @raises
 */
Semantic restriction "integrate_and_with_" is
[
	baseMapType : map's type,
	supplementMapType : map's type,
	actionType : [⊥,⊥,⊥]→map's type
 |
 	if ⎣actionType's parameters' type⎦ < 3 then
	[
		Reject parse, expected:
			"\nFunction to accept three arguments. Only received"
			++ “⎣actionType's parameters' type⎦”
			++ " arguments.\n\n"
	]
 	else if [¬supplementMapType ⊆ baseMapType] then
 	[
		Reject parse, expected:
			"\nIncompatible map types.  Supplemental map type is not a"
			++ " subtype of the base map type"
			++ “supplementMapType” ++ "⊈" ++ “baseMapType” ++ ".\n\n"

 	]
 	else if [actionType[1] ≠ ⊥ ∧ [ ¬baseMapType ⊆ actionType[1] ]] then
	[
		Reject parse, expected:
			"\nFunction to accept for input 1, "
			++ “baseMapType”
			++ " (but it only accepts "
			++ “actionType[1]”
			++ ")\n\n"
	]
	else if [actionType[2] ≠ ⊥ ∧ 
		[ ¬supplementMapType's key type ⊆ actionType[2] ]] 
	then
	[
		Reject parse, expected:
			"\nRepeatedly applied function to accept all key ∈ "
			++ “supplementMapType's key type”
			++ " (but it only accepts "
			++ “actionType[2]”
			++ ")\n\n"
	]
	else if [actionType[3] ≠ ⊥ ∧ 
		[ ¬supplementMapType's value type ⊆ actionType[3] ]] 
	then
	[
		Reject parse, expected:
			"\nRepeatedly applied function to accept all values ∈ "
			++ “supplementMapType's value type”
			++ " (but it only accepts "
			++ “actionType[3]”
			++ ")\n\n"
	]
	else if [⎣baseMapType⎦ > 0 ∨ [⎣supplementMapType⎦ > 0]] then
	[
		If actionType's return type = ⊥ then
		[
			Reject parse, expected:
				"Repeatedly applied function to have a return type other than"
				++ "⊥\n\n"
		];
	];
	lowerBound ::= ⎣baseMapType⎦ max ⎣supplementMapType⎦;
	upperBound ::= ⎡baseMapType⎤ + ⎡supplementMapType⎤;
	{baseMapType's key type → baseMapType's value type | lowerBound..upperBound}
];

/*	
m1 : {integer→string|} := {1→"ab",2→"bc",3→"de"};
m2 : {integer→string|} := {4→"gh",5→"ij",2→"kl"};

m3 ::= integrate m1 and m2 with 
[
 	m : {integer→string|},
 	k : integer,
 	v : string
 |
 	mNew : {integer→string|} := m - k;
 	mNew + k→v
];
Print: "m3=";
Print: “m3”;
Print: "\n";
*/