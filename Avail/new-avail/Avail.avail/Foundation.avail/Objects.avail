/*
 * Objects.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Objects"
Versions
	"dev"
Uses
	"Bootstrap",
	"Control Structures",
	"Definers",
	"Early Assertions",
	"Early Error Codes",
	"Early Functions",
	"Enumeration Support",
	"Literals",
	"Logic",
	"Maps",
	"Math",
	"Phrases",
	"Sets",
	"Tuples",
	"Types"
Names
	"a|an_«with«_:=_‡,»»",
	"extend_with«_:_‡,»",
	"«Public»?«Explicit|explicit»?\
		\|Class|class_extends_\
		\|«with field|fields««public»?«reconstructible»?_:_‡,»»\
		\|«with reconstructor|reconstructors««public»?(«_‡,»)‡,»»",
	"_as_«with«_:=_‡,»»"
Body

Method "_→object type" is stable at [field type map]→object meta;

/**
 * Strengthen object type construction. If the enumeration of keys is known,
 * then it is possible to strengthen the object metatype (to one whose keys are
 * drawn from the enumeration and which has the map's value type as the type of
 * each field type).
 * 
 * Parameters:
 *    mapType -
 * Returns:
 *    The strongest possible object metatype for the given argument types.
 */
Semantic restriction "_→object type" is
[
	mapType : field type map's type
|
	/* If the enumeration of keys is known and equals the cardinality of the
	 * map, then answer the nearest object type supertype with these keys.
	 */
	if ⎣mapType⎦ = ⎡mapType⎤
		∧ [ |mapType's key type| = ⎣mapType⎦ ] then
	[
		atoms ::= mapType's key type's instances;
		defs ::= atoms→tuple zip |atoms| of mapType's value type's instance;
		(defs→object type)'s type
	]
	/* Can't strengthen. */
	else
	[
		⊤
	]
];

Method "_→object type" is stable at [field type tuple]→object meta;
Semantic restriction "_→object type" is
[
	tupleType : field type tuple's type
|
	limit ::= |tupleType's leading types| + 1;
	/* `defs` are the guaranteed field definitions. A field definition is
	 * only certain when the field atom is certain.
	 */
	defs : field type map := {};
	/* `constraints` are augmented when a particular definition tuple's
	 * field atom is not statically known. This map is used to weaken `defs`
	 * after all definition tuples have been processed.
	 */
	constraints : field type map := {};
	/* `universal` is the type union of all field types for which the
	 * corresponding field is merely `atom`, i.e., the actual fields are not
	 * statically known. It is used to weaken `defs` after all definition
	 * tuples have been processed.
	 */
	universal : any meta := ⊥;
	From 1 to limit do
	[
		index : natural number
	|
		defTuple ::= tupleType[index];
		atomType ::= defTuple[1];
		defType ::= defTuple[2]'s instance;
		/* The field atom is known exactly. Therefore, we can confidently
		 * say that the resulting object type must contain this field.
		 */
		if |atomType| = 1 then
		[
			fieldAtom ::= atomType's instance;
			fieldType ::= defs[fieldAtom] else [ ⊥ ] ∪ defType;
			defs := eject ↑defs + fieldAtom→fieldType;
		]
		/* We know one or more fields with which this type is associated, so
		 * record this knowledge into `constraints`.
		 */
		else if [ |atomType| ≠ ∞ ] then
		[
			atoms ::= atomType's instances;
			For each atoms do
			[
				fieldAtom : atom
			|
				fieldType ::= constraints[fieldAtom] else [ ⊥ ] ∪ defType;
				constraints := eject ↑constraints + fieldAtom→fieldType;
			];
		]
		/* We don't know anything about the field. Treat the field type as a
		 * universal constraint.
		 */
		else
		[
			Assert: atomType = atom;
			universal := eject ↑universal ∪ defType;
		];
	];
	/* Weaken each value of `defs` by all applicable constraints. */
	defs := map eject ↑defs through
		[
			fieldAtom : atom,
			fieldType : any meta
		|
			fieldType ∪ constraints[fieldAtom] else [ ⊥ ] ∪ universal
		];
	(defs→object type)'s type
];

Method "_→object" is stable at [field map]→object;
Semantic restriction "_→object" is
[
	mapType : field map's type
|
	/* If the enumeration of keys is known and equals the cardinality of the
	 * map, then answer the nearest object type supertype with these keys.
	 */
	if ⎣mapType⎦ = ⎡mapType⎤
		∧ [ |mapType's key type| = ⎣mapType⎦ ] then
	[
		atoms ::= mapType's key type's instances;
		fieldAssignments ::= atoms→tuple zip |atoms| of mapType's value type;
		(fieldAssignments→object)'s type
	]
	/* Can't strengthen. */
	else
	[
		⊤
	]
];

Method "_→object" is stable at [field tuple]→object;
Semantic restriction "_→object" is
[
	tupleType : field tuple's type
|
	limit ::= |tupleType's leading types| + 1;
	/* `defs` are the guaranteed field definitions. A field definition is
	 * only certain when the field atom is certain.
	 */
	defs : field type map := {};
	/* `constraints` are augmented when a particular definition tuple's
	 * field atom is not statically known. This map is used to weaken `defs`
	 * after all definition tuples have been processed.
	 */
	constraints : field type map := {};
	/* `universal` is the type union of all field types for which the
	 * corresponding field is merely `atom`, i.e., the actual fields are not
	 * statically known. It is used to weaken `defs` after all definition
	 * tuples have been processed.
	 */
	universal : any meta := ⊥;
	From 1 to limit do
	[
		index : natural number
	|
		defTuple ::= tupleType[index];
		atomType ::= defTuple[1];
		defType ::= defTuple[2];
		/* The field atom is known exactly. Therefore, we can confidently
		 * say that the resulting object type must contain this field.
		 */
		if |atomType| = 1 then
		[
			fieldAtom ::= atomType's instance;
			fieldType ::= defs[fieldAtom] else [ ⊥ ] ∪ defType;
			defs := eject ↑defs + fieldAtom→fieldType;
		]
		/* We know one or more fields with which this type is associated, so
		 * record this knowledge into `constraints`.
		 */
		else if [ |atomType| ≠ ∞ ] then
		[
			atoms ::= atomType's instances;
			For each atoms do
			[
				fieldAtom : atom
			|
				fieldType ::= constraints[fieldAtom] else [ ⊥ ] ∪ defType;
				constraints := eject ↑constraints + fieldAtom→fieldType;
			];
		]
		/* We don't know anything about the field. Treat the field type as a
		 * universal constraint.
		 */
		else
		[
			Assert: atomType = atom;
			universal := eject ↑universal ∪ defType;
		];
	];
	/* Weaken each value of `defs` by all applicable constraints. */
	defs := map eject ↑defs through
		[
			fieldAtom : atom,
			fieldType : any meta
		|
			fieldType ∪ constraints[fieldAtom] else [ ⊥ ] ∪ universal
		];
	defs→object type
];

Method "_→map" is stable at [object]→map;
Semantic restriction "_→map" is
[
	anObjectType : object meta
|
	objectMap ::= anObjectType→map;
	/* Because we can't know what keys and types the subtypes of the
	 * argument will contain, this is as good as it gets.
	 */
	{atom→any | |objectMap|..}
];

Semantic restriction "_→tuple" is
[
	anObjectType : object meta
|
	objectMap ::= anObjectType→map;
	/* Note that we can't exploit instance types here, because coversion of an
	 * object type to a tuple is an unstable operation. Because we can't know
	 * what keys and types the subtypes of the argument will contain, this is as
	 * good as it gets.
	 */
	<<atom, any…|2>…| |objectMap|..>
];

/**
 * Construct and answer an object type which is a subtype of `supertype`
 * augmented by the specified tuple of field definitions.
 * 
 * Parameters:
 *    supertype - An object type that must be a supertype of the answer.
 *    newDefinitions - A tuple of 2-tuples. Each 2-tuple consists of 1) an atom
 *       that uniquely identifies the field and 2) the field type, i.e., the
 *       type of value that instances of the answer may store in the field. If
 *       the field atom is defined by `supertype`, then the new field type must
 *       be a subtype of the field type as defined in `supertype`, i.e., it must
 *       be covariantly specialized.
 * Returns:
 *    The requested object type.
 */
Public method "extend_with«_:_‡,»" is
[
	supertype : object meta,
	newDefinitions : <<atom, any meta…|2>…|1..>
|
	fieldAtoms ::= stripe newDefinitions at 1;
	If |fieldAtoms→set| ≠ |fieldAtoms| then
	[
		early failure function(object-type-extension-contains-duplicates code)
	];
	subtype ::= (supertype→tuple ++ newDefinitions)→object type;
	If ¬subtype ⊆ supertype then
	[
		early failure function(
			object-type-extension-did-not-produce-subtype code)
	];
	subtype
] : object meta;

/**
 * Object type extension statically requires that:
 *
 * - Every field atom of the extension is known.
 * - Each field atom of the extension appears only once during extension.
 * - Each field atom of the extension is either 1) not present in the supertype
 *   or 2) specifies a type which covaries with the field type expressed in the
 *   supertype.
 *
 * Parameters:
 *    meta - The supertype's type.
 *    newDefinitionTypes - A lexical tuple type.
 * Return:
 *    The strongest possible object metatype for the given argument types.
 */
Semantic restriction "extend_with«_:_‡,»" is
[
	meta : object meta's type,
	newDefinitionTypes : <<atom, any meta…|2>…|1..>'s type
|
	supertype ::= meta's instance;
	oldDefinitions ::= supertype→map;
	newDefinitions : field type map := {};
	From 1 to |newDefinitionTypes' leading types| + 1 do
	[
		index : natural number
	|
		def ::= newDefinitionTypes[index];
		atomType ::= def[1];
		newType ::= def[2]'s instance;
		If |atomType| ≠ 1 then
		[
			Reject parse, expected: "all field atoms to be known statically"
		];
		fieldAtom ::= atomType's instance;
		If fieldAtom ∈ newDefinitions then
		[
			Reject parse, expected:
				fieldAtom's name
				++ " to appear only once during extension (but it already\
				\| appeared with type = "
				++ “newDefinitions[fieldAtom]”
				++ ")"
		];
		oldType ::= oldDefinitions[fieldAtom] else [ any ];
		If ¬newType ⊆ oldType then
		[
			Reject parse, expected:
				"covariant specialization of "
				++ fieldAtom's name
				++ " (but new field type "
				++ “newType”
				++ " is not a subtype of "
				++ “oldType”
				++ ")"
		];
		newDefinitions := eject ↑newDefinitions + fieldAtom→newType;
	];
	((supertype→tuple ++ newDefinitions' bindings)→object type)'s type
];

/**
 * Compute and answer the accessor name for the specified field atom.
 * 
 * Parameters:
 *    fieldAtom - A field atom.
 * Returns:
 *    The name of the accessor.
 */
Private method "accessor name for_" is
[
	fieldAtom : atom
|
	"_'s⁇" ++ fieldAtom's name
] : <character…|4..>;

/**
 * Generate and install field type and field value accessors for the specified
 * object type and field atom. Generate and install a semantic restriction for
 * the field value accessor.
 * 
 * Parameters:
 *    objectType - An object type.
 *    fieldAtom - A field atom.
 */
Private method "generate and install_accessor for_" is
[
	objectType : object meta,
	fieldAtom : atom
|
	objectMap ::= objectType→map;
	methodName ::= accessor name for fieldAtom;
	methodAtom ::= atom for methodName;
	fieldType ::= objectMap[fieldAtom];
	defineClassAccessor : boolean := false;
	defineInstanceAccessor : boolean := false;
	/* If the method doesn't exist at all, then define it and install
	 * accessors.
	 */
	If ¬method exists named methodAtom then
	[
		defineClassAccessor := true;
		defineInstanceAccessor := true;
	]
	/* If the method does already exist, then install accessors for the object
	 * type iff they are not already present.
	 */
	else
	[
		theMethod ::= method for methodAtom;
		defineClassAccessor :=
			¬theMethod has implementation for <objectType's type>;
		defineInstanceAccessor :=
			¬theMethod has implementation for <objectType>;
	];
	If defineClassAccessor then
	[
		Method methodName is
			new [objectType's type]→(fieldType's type)
			applying [ x : object meta | x→map[fieldAtom] ];
		/* Install a semantic restriction if one does not already exist for this
		 * signature.
		 */
		theMethod ::= method for methodAtom;
		restrictions ::= semantic restrictions for theMethod
			given <objectType's type's type>;
		needToRestrict ::= ¬any of restrictions satisfies
			[ r : […]→type | r's type[1] = (objectType's type's type) ];
		If needToRestrict then
		[
			Semantic restriction methodName is
				new [objectType's type's type]→(any meta's type)
				applying
				[
					x : object meta's type
				|
					(x's instance→map[fieldAtom])'s type
				];
		];
	];
	If defineInstanceAccessor then
	[
		Method methodName is
			new [objectType]→fieldType
			applying [ x : object | x→map[fieldAtom] ];
		/* Install a semantic restriction if one does not already exist for this
		 * signature.
		 */
		theMethod ::= method for methodAtom;
		restrictions ::=
			semantic restrictions for theMethod given <objectType's type>;
		needToRestrict ::= ¬any of restrictions satisfies
			[ r : […]→type | r's type[1] = (objectType's type) ];
		If needToRestrict then
		[
			Semantic restriction methodName is
				new [objectType's type]→any meta
				applying [ x : object meta | x→map[fieldAtom] ];
		];
	];
] : ⊤;

/**
 * Construct and answer the name of the object reconstructor method from the
 * specified tuple of field atoms.
 * 
 * Parameters:
 *    fieldAtoms - The atoms of the fields migrated by the reconstructor.
 * Returns:
 *    The appropriate method name.
 */
Private method "reconstructor name for_" is
[
	fieldAtoms : <atom…|1..>
|
	methodName : <character…|7..> := accessor name for fieldAtoms[1] ++ ":=_";
	For each fieldAtoms' tail do
	[
		fieldAtom : atom
	|
		methodName := eject ↑methodName ++ "," ++ fieldAtom's name ++ ":=_";
	];
	methodName
] : <character…|7..>;

/**
 * Construct and answer a tuple of argument declarations for an object
 * reconstructor method (or its semantic restriction).
 * 
 * Parameters:
 *    objectType - The object type.
 *    fieldAtoms - The atoms of the fields migrated by the reconstructor.
 *    forSemanticRestriction - `true` if the argument declarations should be
 *       generated for the semantic restriction, `false` if they should be
 *       generated for the method.
 * Returns:
 *    The requested argument declarations. The first declaration is for the
 *    object type (or metatype) and the remaining correspond to the field atoms.
 */
Private method "_reconstructor arguments for_«(for semantic restriction)»?" is
[
	objectType : object meta,
	fieldAtoms : <atom…|1..>,
	forRestriction : boolean
|
	meta ::= if forRestriction then [ objectType's type ] else [ objectType ];
	objectMap ::= objectType→map;
	<arg «`"target"` : meta»> ++ map fieldAtoms through
	[
		fieldAtom : atom,
		index : natural number
	|
		desc ::= “index”;
		argType ::= if forRestriction
			then [ objectMap[fieldAtom]'s type ]
			else [ objectMap[fieldAtom] ];
		arg «`"arg" ++ desc` : argType»
	]
] : <argument phrase…|2..>;

/* These methods are needed for reconstructor synthesis. */
toMapM ::= method for $"_→map";
ejectM ::= method for $"eject_";
addBindingM ::= method for $"_+_→_";
toObjectM ::= method for $"_→object";
toObjectTypeM ::= method for $"_→object type";

/**
 * Generate and install a reconstructor for the specified object type and tuple
 * of field atoms.
 * 
 * Parameters:
 *    objectType - An object type.
 *    fieldAtoms - A field atoms.
 */
Private method "generate and install_reconstructor for_" is
[
	objectType : object meta,
	fieldAtoms : <atom…|1..>
|
	methodName ::= reconstructor name for fieldAtoms;
	args ::= objectType reconstructor arguments for fieldAtoms;
	/* Construct the body of the mutator method. */
	toMapMSend ::= send toMapM with «<«↓args[1]»>» : field map;
	mapDecl ::= «`"objectMap"` : field map := toMapMSend»;
	assignments ::= map fieldAtoms through
		[
			fieldAtom : atom,
			index : natural number
		|
			ejectSend ::= send ejectM with «<«↑«↓mapDecl»»>» : field map;
			addBindingSend ::= send addBindingM
				with «<ejectSend, ‘`fieldAtom`’, «↓args[index + 1]»>»
				: field map;
			««↓mapDecl» := addBindingSend»
		];
	last ::= send toObjectM with «<«↓mapDecl»>» : objectType;
	statements ::= <mapDecl> ++ assignments ++ <last>;
	newBlock ::= «[ args | statements ] : objectType»;
	reconstructorFunction ::= generate newBlock;
	Method methodName is reconstructorFunction;
] : ⊤;

/**
 * Generate and install a semantic restriction for the reconstructor for the
 * specified object type and tuple of field atoms.
 * 
 * Parameters:
 *    objectType - An object type.
 *    fieldAtoms - A field atoms.
 */
Private method
	"generate and install_reconstructor's semantic restriction for_"
is
[
	objectType : object meta,
	fieldAtoms : <atom…|1..>
|
	methodName ::= reconstructor name for fieldAtoms;
	args ::= objectType reconstructor arguments for fieldAtoms
		(for semantic restriction);
	/* Construct the body of the semantic restriction method. */
	toMapMSend ::= send toMapM with «<«↓args[1]»>» : field type map;
	mapDecl ::= «`"objectMap"` : field type map := toMapMSend»;
	assignments ::= map fieldAtoms through
		[
			fieldAtom : atom,
			index : natural number
		|
			ejectSend ::= send ejectM with «<«↑«↓mapDecl»»>» : field type map;
			addBindingSend ::= send addBindingM
				with «<ejectSend, ‘`fieldAtom`’, «↓args[index + 1]»>»
				: field type map;
			««↓mapDecl» := addBindingSend»
		];
	last ::= send toObjectTypeM with «<«↓mapDecl»>» : objectType's type;
	statements ::= <mapDecl> ++ assignments ++ <last>;
	newBlock ::= «[ args | statements ] : type»;
	Semantic restriction methodName is generate newBlock;
];

/**
 * Define a class. In Avail, a class is simply a named object type supported by
 * 1) a generated method that reliably reproduces the object type, 2) generated
 * methods that provide access to the field definitions, and 3) generated
 * methods that provide access to instance field values. A class is essentially
 * only a lexical construct, and is analogous to the distinction between blocks
 * (lexical) and functions (semantic).
 * 
 * Parameters:
 *    public - `true` if the class should be exported by the defining module,
 *       `false` otherwise.
 *    explicit - `true` if the class should have an artificial identity
 *       introduced (in order to ensure intentional provenance of subtypes),
 *       `false` otherwise.
 *    className - The name of the class. A method will be generated with this
 *       name. This method will answer the object type. The object type will
 *       also be christened with this name.
 *    supertype - The supertype of the class. Type intersection may be used here
 *       to facilitate inheritance from multiple sources.
 *    optionalExtensions - The extension fields of this class. An accessor will
 *       be generated for each field. A reconstructor will be generated for each
 *       field tagged as "reconstructible". Each field tagged as "public" must
 *       be exported by the defining module.
 */
Public method
	"«Public»?«Explicit|explicit»?\
	\|Class|class_extends_\
	\|«with field|fields««public»?«reconstructible»?_:_‡,»»\
	\|«with reconstructor|reconstructors««public»?(«_‡,»)‡,»»"
is
[
	public : boolean,
	explicit : boolean,
	className : nonempty string,
	supertype : object meta,
	optionalExtensions : <<<boolean, boolean, atom, any meta…|4>…|1..>…|0..1>,
	optionalReconstructors : <<<boolean, <atom…|1..>…|2>…|1..>…|0..1>
|
	/* Extract the extensions. */
	extensions : <<boolean, boolean, atom, any meta…|4>…|> := <>;
	newDefinitions : <<atom, any meta…|2>…|> := <>;
	Unless optionalExtensions is empty then
	[
		extensions := optionalExtensions[1];
		newDefinitions := map extensions through
			[
				fieldTuple : <boolean, boolean, atom, any meta…|4>
			|
				fieldTuple[3..4]
			];
	];
	/* Verify the uniqueness of the field atoms. */
	fieldAtoms ::= stripe newDefinitions at 1;
	If |fieldAtoms→set| ≠ |fieldAtoms| then
	[
		early failure function(object-type-extension-contains-duplicates code)
	];
	/* If necessary, then generate a field definition that guarantees
	 * uniqueness among object types.
	 */
	explicitDef : <<atom, any meta…|2>…|0..1> := <>;
	If explicit then
	[
		explicitAtom ::= atom for "explicit-" ++ className;
		explicitDef := <<explicitAtom, explicitAtom's type>>;
	];
	/* Construct and verify the subtype. */
	subtype ::= (supertype→tuple ++ newDefinitions ++ explicitDef)→object type;
	If ¬subtype ⊆ supertype then
	[
		early failure function(
			object-type-extension-did-not-produce-subtype code)
	];
	/* Define the class: give the object type a name, define a method that
	 * answers the object type, and define methods that access the field
	 * definitions and values.
	 */
	subtype's name := className;
	Method className is new []→(subtype's type) applying [ subtype ];
	For each fieldAtoms do
	[
		fieldAtom : atom
	|
		generate and install subtype accessor for fieldAtom;
	];
	/* Determine which reconstructors to create. */
	reconstructors : <<atom…|1..>…|> := map and filter extensions by
		[
			triple : <boolean, boolean, atom, any meta…|4>,
			accept : [<atom…|1..>]→⊤
		|
			If triple[2] then
			[
				accept(<triple[3]>);
			];
		];
	Unless optionalReconstructors is empty then
	[
		specs ::= optionalReconstructors[1];
		reconstructors := eject ↑reconstructors ++ map specs through
			[
				spec : <boolean, <atom…|1..>…|2>
			|
				spec[2]
			];
	];
	/* Generate the reconstructors. */
	For each reconstructors do
	[
		atoms : <atom…|1..>
	|
		generate and install subtype reconstructor for atoms;
		generate and install subtype reconstructor's semantic restriction
			for atoms;
	];
] : ⊤;

/**
 * Class definition statically requires that:
 *
 * - Every field atom of the extension is known.
 * - Each field atom of the extension appears only once during extension.
 * - Each field atom of the extension is either 1) not present in the supertype
 *   or 2) specifies a type which covaries with the field type expressed in the
 *   supertype.
 */
Semantic restriction
	"«Public»?«Explicit|explicit»?\
	\|Class|class_extends_\
	\|«with field|fields««public»?«reconstructible»?_:_‡,»»\
	\|«with reconstructor|reconstructors««public»?(«_‡,»)‡,»»"
is
[
	publicType : boolean's type,
	explicit : boolean's type,
	classNameType : nonempty string's type,
	meta : object meta's type,
	optionalExtensions :
		<<<boolean, boolean, atom, any meta…|4>…|1..>…|0..1>'s type,
	optionalReconstructors : <<<boolean, <atom…|1..>…|2>…|1..>…|0..1>'s type
|
	public ::= publicType's instance;
	publicNames ::= current module's public names;
	If public ∧ [ |classNameType| ≠ 1 ] then
	[
		Reject parse, expected:
			"public class modifier to be provided only when the class name \
			\|is statically known"
	];
	If |classNameType| = 1 then
	[
		className ::= classNameType's instance;
		If public ∧ [ ¬className ∈ publicNames ] then
		[
			Reject parse, expected:
				"\""
				++ className
				++ "\" to be included in the module's \"Names\" section"
		];
	];
	supertype ::= meta's instance;
	oldDefinitions ::= supertype→map;
	newDefinitions : field type map := {};
	From 1 to relevant |optionalExtensions[1]| do
	[
		index : natural number
	|
		def ::= optionalExtensions[1][index];
		publicField ::= def[1]'s instance;
		reconstructible ::= def[2]'s instance;
		atomType ::= def[3];
		newType ::= def[4]'s instance;
		If |atomType| ≠ 1 then
		[
			Reject parse, expected:
				"all field atoms to be known statically"
		];
		fieldAtom ::= atomType's instance;
		accessorName ::= accessor name for fieldAtom;
		If publicField then
		[
			If ¬public then
			[
				Reject parse, expected:
					"\""
					++ accessorName
					++ " to be private (because the class is private)"
			];
			If ¬accessorName ∈ publicNames then
			[
				Reject parse, expected:
					"\""
					++ accessorName
					++ "\" to be included in the module's \"Names\" section\
					\| (because it is public)"
			];
			If reconstructible then
			[
				reconstructorName ::= accessorName ++ ":=_";
				If ¬reconstructorName ∈ publicNames then
				[
					Reject parse, expected:
						"\""
						++ reconstructorName
						++ "\" to be included in the module's \"Names\"\
							\| section (because it is public)"
				];
			];
		];
		If fieldAtom ∈ newDefinitions then
		[
			Reject parse, expected:
				fieldAtom's name
				++ " to appear only once during extension (but it already\
				\| appeared with type = "
				++ “newDefinitions[fieldAtom]”
				++ ")"
		];
		oldType ::= oldDefinitions[fieldAtom] else [ any ];
		If ¬newType ⊆ oldType then
		[
			Reject parse, expected:
				"covariant specialization of "
				++ fieldAtom's name
				++ " (but new field type "
				++ “newType”
				++ " is not a subtype of "
				++ “oldType”
				++ ")"
		];
		newDefinitions := eject ↑newDefinitions + fieldAtom→newType;
	];
	From 1 to relevant |optionalReconstructors[1]| do
	[
		index : natural number
	|
		spec ::= optionalReconstructors[1][index];
		publicSpec ::= spec[1]'s instance;
		atomsType ::= spec[2];
		fieldAtoms : <atom…|> := <>;
		From 1 to relevant |atomsType| do
		[
			atomTypeIndex : natural number
		|
			atomType ::= atomsType[atomTypeIndex];
			If |atomType| ≠ 1 then
			[
				Reject parse, expected:
					"all reconstructor field atoms to be known statically"
			];
			fieldAtoms := eject ↑fieldAtoms ++ <atomType's instance>;
		];
		nonemptyFieldAtoms ::= cast fieldAtoms into [ t : <atom…|1..> | t ];
		reconstructorName ::= reconstructor name for nonemptyFieldAtoms;
		If publicSpec then
		[
			If ¬public then
			[
				Reject parse, expected:
					"\""
					++ reconstructorName
					++ "\" to be private (because the class is private)"
			];
			If ¬reconstructorName ∈ publicNames then
			[
				Reject parse, expected:
					"\""
					++ reconstructorName
					++ "\" to be included in the module's \"Names\" section\
					\| (because it is public)"
			];
		];
	];
	⊤
];

/**
 * Construct and answer an object which is an instance of `objectType` and whose
 * field values are determined by `optional`.
 * 
 * Parameters:
 *    objectType - An object type that must be a supertype of the answer.
 *    optional - A tuple of field assignments. The outermost tuple may be empty
 *       (but only to support the case that `objectType = object`), but usually
 *       contains a single tuple of field assignments. A field assignment is a
 *       2-tuple that consists of 1) an atom that uniquely identifies the field
 *       and 2) the field value.
 * Returns:
 *    The requested object type.
 */
Public method "a|an_«with«_:=_‡,»»" is
[
	objectType : object meta,
	optional : <<<atom, any…|2>…|1..>…|0..1>
|
	assignments ::= if optional is empty then [ <> ] else [ optional[1] ];
	fieldAtoms ::= stripe assignments at 1;
	If |fieldAtoms→set| ≠ |fieldAtoms| then
	[
		early failure function(object-instantiation-contains-duplicates code)
	];
	objectMap ::= objectType→map;
	identityAssignments : <<atom, any…|2>…|> := <>;
	For each objectMap do
	[
		fieldAtom : atom,
		fieldType : any meta
	|
		If |fieldType| = 1 ∧ [ ¬fieldType ⊆ type ] then
		[
			identityAssignments := eject ↑identityAssignments
				++ <<fieldAtom, fieldType's instance>>;
		];
	];
	newObject ::= (assignments ++ identityAssignments)→object;
	If ¬newObject ∈ objectType then
	[
		early failure function(
			object-instantiation-did-not-produce-instance code)
	];
	newObject
] : object;

/**
 * Object instantiation statically requires that:
 *
 * - Every field atom of the instantiation tuple is known.
 * - Each field atom of the instantiation tuple appears only once during
 *   instantiation.
 * - An assigned value conforms to the field type.
 * - An assignment occurs for every field of the object type except those for
 *   which the exact types are known; these will be supplied automatically.
 */
Semantic restriction "a|an_«with«_:=_‡,»»" is
[
	meta : object meta's type,
	optional : <<<atom, any…|2>…|1..>…|0..1>'s type
|
	objectType ::= meta's instance;
	definitions ::= objectType→map;
	assignments : field type map := {};
	From 1 to relevant |optional[1]| do
	[
		index : natural number
	|
		def ::= optional[1][index];
		atomType ::= def[1];
		valueType ::= def[2];
		If |atomType| ≠ 1 then
		[
			Reject parse, expected: "all field atoms to be known statically"
		];
		fieldAtom ::= atomType's instance;
		If fieldAtom ∈ assignments then
		[
			Reject parse, expected:
				fieldAtom's name
				++ " to appear only once during instantiation (but it already\
				\| appeared with type = "
				++ “assignments[fieldAtom]”
				++ ")"
		];
		requiredType ::= definitions[fieldAtom] else [ any ];
		If ¬valueType ⊆ requiredType then
		[
			Reject parse, expected:
				"valid assignment to "
				++ fieldAtom's name
				++ " (but "
				++ “valueType”
				++ " is not a subtype of "
				++ “requiredType”
				++ ")"
		];
		assignments := eject ↑assignments + fieldAtom→valueType;
	];
	For each definitions do
	[
		fieldAtom : atom,
		fieldType : any meta
	|
		If |fieldType| = 1 ∧ [ ¬fieldType ⊆ type ] then
		[
			assignments := eject ↑assignments + fieldAtom→fieldType;
		];
	];
	missing ::= filter definitions' keys by [ a : atom | ¬a ∈ assignments ];
	If |missing| ≠ 0 then
	[
		Reject parse, expected:
			"assignments for all fields of "
			++ “objectType”
			++ " (but assignments are missing for "
			++ “missing”
			++ ")"
	];
	assignments→object type
];

/**
 * Given an object and a target object type, answer an object that retains the
 * field assignments of the original object but which 1) is also an instance of
 * the new object type and 2) reflects the new (optional) field assignments.
 * 
 * Parameters:
 *    instance - An object.
 *    objectType - An object type that must be a supertype of the answer.
 *    optional - An optional tuple of field assignments. A field assignment is
 *       a 2-tuple that consists of 1) an atom that uniquely identifies the
 *       field and 2) the field value.
 * Returns:
 *    The requested object type.
 */
Public method "_as_«with«_:=_‡,»»" is
[
	instance : object,
	objectType : object meta,
	optional : <<<atom, any…|2>…|1..>…|0..1>
|
	assignments ::= if optional is empty then [ <> ] else [ optional[1] ];
	fieldAtoms ::= stripe assignments at 1;
	If |fieldAtoms→set| ≠ |fieldAtoms| then
	[
		early failure function(object-instantiation-contains-duplicates code)
	];
	objectMap ::= objectType→map;
	identityAssignments : <<atom, any…|2>…|> := <>;
	For each objectMap do
	[
		fieldAtom : atom,
		fieldType : any meta
	|
		If |fieldType| = 1 ∧ [ ¬fieldType ⊆ type ] then
		[
			identityAssignments := eject ↑identityAssignments
				++ <<fieldAtom, fieldType's instance>>;
		];
	];
	newObject ::=
		(instance→map's bindings ++ assignments ++ identityAssignments)→object;
	If ¬newObject ∈ objectType then
	[
		early failure function(
			object-instantiation-did-not-produce-instance code)
	];
	newObject
] : object;

/**
 * Object adoption statically requires that:
 *
 * - Every field atom of the instantiation tuple is known.
 * - Each field atom of the instantiation tuple appears only once during
 *   instantiation.
 * - An assigned value conforms to the field type.
 * - An assignment occurs for every field of the object type except those for
 *   which the exact types are known; these will be supplied automatically.
 */
Semantic restriction "_as_«with«_:=_‡,»»" is
[
	instance : object meta,
	meta : object meta's type,
	optional : <<<atom, any…|2>…|1..>…|0..1>'s type
|
	objectType ::= meta's instance;
	definitions ::= objectType→map;
	assignments : field type map := instance→map;
	From 1 to relevant |optional[1]| do
	[
		index : natural number
	|
		def ::= optional[1][index];
		atomType ::= def[1];
		valueType ::= def[2];
		If |atomType| ≠ 1 then
		[
			Reject parse, expected: "all field atoms to be known statically"
		];
		fieldAtom ::= atomType's instance;
		If fieldAtom ∈ assignments then
		[
			Reject parse, expected:
				fieldAtom's name
				++ " to appear only once during instantiation (but it already\
				\| appeared with type = "
				++ “assignments[fieldAtom]”
				++ ")"
		];
		requiredType ::= definitions[fieldAtom] else [ any ];
		If ¬valueType ⊆ requiredType then
		[
			Reject parse, expected:
				"valid assignment to "
				++ fieldAtom's name
				++ " (but "
				++ “valueType”
				++ " is not a subtype of "
				++ “requiredType”
				++ ")"
		];
		assignments := eject ↑assignments + fieldAtom→valueType;
	];
	For each definitions do
	[
		fieldAtom : atom,
		fieldType : any meta
	|
		If |fieldType| = 1 ∧ [ ¬fieldType ⊆ type ] then
		[
			assignments := eject ↑assignments + fieldAtom→fieldType;
		];
	];
	missing ::= filter definitions' keys by [ a : atom | ¬a ∈ assignments ];
	If |missing| ≠ 0 then
	[
		Reject parse, expected:
			"assignments for all fields of "
			++ “objectType”
			++ " (but assignments are missing for "
			++ “missing”
			++ ")"
	];
	assignments→object type
];
