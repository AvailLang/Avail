/*
 * Objects.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Objects"
Versions
	"dev"
Uses
	"Assertions",
	"Bootstrap",
	"Control Structures",
	"Early Definers",
	"Early Error Codes",
	"Early Functions",
	"Early Types",
	"Enumeration Support",
	"Literals",
	"Logic",
	"Maps",
	"Math",
	"Phrases",
	"Sets",
	"Tuples"
Names
	"a|an_«with«_:=_‡,»»",
	"extend_with«_:_‡,»",
	"«Public»?«Explicit|explicit»?\
		\|Class|class_extends_\
		\|«with fields««public»?«reconstructible»?_:_‡,»»\
		\|«with reconstructors««public»?(«_‡,»)‡,»»"
Body

/**
 * Strengthen object type construction. If the enumeration of keys is known,
 * then it is possible to strengthen the object metatype (to one whose keys are
 * drawn from the enumeration and which has the map's value type as the type of
 * each field type).
 * 
 * Parameters:
 *    mapType -
 * Returns:
 *    The strongest possible object metatype for the given argument types.
 */
Semantic restriction "_→object type" is
[
	mapType : field type map's type
|
	/* Leverage an instance type. */
	if |mapType| = 1 then
	[
		(mapType's instance→object type)'s type
	]
	/* If the enumeration of keys is known and equals the cardinality of the
	 * map, then answer the nearest object type supertype with these keys.
	 */
	else if [ |{⎣mapType⎦, ⎡mapType⎤}| = 1
		∧ [ |mapType's key type| = ⎣mapType⎦ ] ] then
	[
		atoms ::= mapType's key type's instances;
		defs ::= atoms→tuple zip |atoms| of mapType's value type's instance;
		(defs→object type)'s type
	]
	/* Can't strengthen. */
	else
	[
		⊤
	]
];

/**
 * Strengthen object type construction.
 * 
 * Parameters:
 *    tupleType -
 * Returns:
 *    The strongest possible object metatype for the given argument types.
 */
Semantic restriction "_→object type" is
[
	tupleType : field type tuple's type
|
	/* Leverage an instance type. */
	if |tupleType| = 1 then
	[
		(tupleType's instance→object type)'s type
	]
	else
	[
		limit ::= |tupleType's leading types| + 1;
		/* `defs` are the guaranteed field definitions. A field definition is
		 * only certain when the field atom is certain.
		 */
		defs : field type map := {};
		/* `constraints` are augmented when a particular definition tuple's
		 * field atom is not statically known. This map is used to weaken `defs`
		 * after all definition tuples have been processed.
		 */
		constraints : field type map := {};
		/* `universal` is the type union of all field types for which the
		 * corresponding field is merely `atom`, i.e., the actual fields are not
		 * statically known. It is used to weaken `defs` after all definition
		 * tuples have been processed.
		 */
		universal : any meta := ⊥;
		From 1 to limit do
		[
			index : natural number
		|
			defTuple ::= tupleType[index];
			atomType ::= defTuple[1];
			defType ::= defTuple[2]'s instance;
			/* The field atom is known exactly. Therefore, we can confidently
			 * say that the resulting object type must contain this field.
			 */
			if |atomType| = 1 then
			[
				fieldAtom ::= atomType's instance;
				fieldType ::= defs[fieldAtom] else [ ⊥ ] ∪ defType;
				defs := eject ↑defs + fieldAtom→fieldType;
			]
			/* We know one or more fields with which this type is associated, so
			 * record this knowledge into `constraints`.
			 */
			else if [ |atomType| ≠ ∞ ] then
			[
				atoms ::= atomType's instances;
				For each atoms do
				[
					fieldAtom : atom
				|
					fieldType ::= constraints[fieldAtom] else [ ⊥ ] ∪ defType;
					constraints := eject ↑constraints + fieldAtom→fieldType;
				];
			]
			/* We don't know anything about the field. Treat the field type as a
			 * universal constraint.
			 */
			else
			[
				Assert: atomType = atom;
				universal := eject ↑universal ∪ defType;
			];
		];
		/* Weaken each value of `defs` by all applicable constraints. */
		defs := map eject ↑defs through
			[
				fieldAtom : atom,
				fieldType : any meta
			|
				fieldType ∪ constraints[fieldAtom] else [ ⊥ ] ∪ universal
			];
		(defs→object type)'s type
	]
];

/**
 * Strengthen object construction.
 *
 * Parameters:
 *    mapType -
 * Returns:
 *    The strongest possible object type for the given argument types.
 */
Semantic restriction "_→object" is
[
	mapType : field map's type
|
	/* Leverage an instance type. */
	if |mapType| = 1 then
	[
		(mapType's instance→object)'s type
	]
	/* If the enumeration of keys is known and equals the cardinality of the
	 * map, then answer the nearest object type supertype with these keys.
	 */
	else if [ |{⎣mapType⎦, ⎡mapType⎤}| = 1
		∧ [ |mapType's key type| = ⎣mapType⎦ ] ] then
	[
		atoms ::= mapType's key type's instances;
		fieldAssignments ::= atoms→tuple zip |atoms| of mapType's value type;
		(fieldAssignments→object)'s type
	]
	/* Can't strengthen. */
	else
	[
		⊤
	]
];

/**
 * Strengthen object construction.
 * 
 * Parameters:
 *    tupleType -
 * Returns:
 *    The strongest possible object type for the given argument types.
 */
Semantic restriction "_→object" is
[
	tupleType : field tuple's type
|
	/* Leverage an instance type. */
	if |tupleType| = 1 then
	[
		(tupleType's instance→object)'s type
	]
	else
	[
		limit ::= |tupleType's leading types| + 1;
		/* `defs` are the guaranteed field definitions. A field definition is
		 * only certain when the field atom is certain.
		 */
		defs : field type map := {};
		/* `constraints` are augmented when a particular definition tuple's
		 * field atom is not statically known. This map is used to weaken `defs`
		 * after all definition tuples have been processed.
		 */
		constraints : field type map := {};
		/* `universal` is the type union of all field types for which the
		 * corresponding field is merely `atom`, i.e., the actual fields are not
		 * statically known. It is used to weaken `defs` after all definition
		 * tuples have been processed.
		 */
		universal : any meta := ⊥;
		From 1 to limit do
		[
			index : natural number
		|
			defTuple ::= tupleType[index];
			atomType ::= defTuple[1];
			defType ::= defTuple[2];
			/* The field atom is known exactly. Therefore, we can confidently
			 * say that the resulting object type must contain this field.
			 */
			if |atomType| = 1 then
			[
				fieldAtom ::= atomType's instance;
				fieldType ::= defs[fieldAtom] else [ ⊥ ] ∪ defType;
				defs := eject ↑defs + fieldAtom→fieldType;
			]
			/* We know one or more fields with which this type is associated, so
			 * record this knowledge into `constraints`.
			 */
			else if [ |atomType| ≠ ∞ ] then
			[
				atoms ::= atomType's instances;
				For each atoms do
				[
					fieldAtom : atom
				|
					fieldType ::= constraints[fieldAtom] else [ ⊥ ] ∪ defType;
					constraints := eject ↑constraints + fieldAtom→fieldType;
				];
			]
			/* We don't know anything about the field. Treat the field type as a
			 * universal constraint.
			 */
			else
			[
				Assert: atomType = atom;
				universal := eject ↑universal ∪ defType;
			];
		];
		/* Weaken each value of `defs` by all applicable constraints. */
		defs := map eject ↑defs through
			[
				fieldAtom : atom,
				fieldType : any meta
			|
				fieldType ∪ constraints[fieldAtom] else [ ⊥ ] ∪ universal
			];
		defs→object type
	]
];

/**
 * Strengthen `_→map`.
 * 
 * Parameters:
 *    anObject -
 * Returns:
 *    The strongest possible map type for the given arguments.
 */
Semantic restriction "_→map" is
[
	anObjectType : object meta
|
	if |anObjectType| = 1 then
	[
		(anObjectType's instance→map)'s type
	]
	else
	[
		objectMap ::= anObjectType→map;
		/* Because we can't know what keys and types the subtypes of the
		 * argument will contain, this is as good as it gets.
		 */
		{atom→any | |objectMap|..}
	]
];

/**
 * Strengthen `_→tuple`.
 * 
 * Parameters:
 *    anObjectType -
 * Returns:
 *    The strongest possible tuple type for the given arguments.
 */
Semantic restriction "_→tuple" is
[
	anObjectType : object meta
|
	objectMap ::= anObjectType→map;
	/* Note that we can't exploit instance types here, because coversion of an
	 * object type to a tuple is an unstable operation. Because we can't know
	 * what keys and types the subtypes of the argument will contain, this is as
	 * good as it gets.
	 */
	<<atom, any…|2>…| |objectMap|..>
];

/**
 * Construct and answer an object type which is a subtype of `supertype`
 * augmented by the specified tuple of field definitions.
 * 
 * Parameters:
 *    supertype - An object type that must be a supertype of the answer.
 *    newDefinitions - A tuple of 2-tuples. Each 2-tuple consists of 1) an atom
 *       that uniquely identifies the field and 2) the field type, i.e., the
 *       type of value that instances of the answer may store in the field. If
 *       the field atom is defined by `supertype`, then the new field type must
 *       be a subtype of the field type as defined in `supertype`, i.e., it must
 *       be covariantly specialized.
 * Returns:
 *    The requested object type.
 */
Public method "extend_with«_:_‡,»" is
[
	supertype : object meta,
	newDefinitions : <<atom, any meta…|2>…|1..>
|
	fieldAtoms ::= stripe newDefinitions at 1;
	If |fieldAtoms→set| ≠ |fieldAtoms| then
	[
		early failure function(object type extension contains duplicates code)
	];
	subtype ::= (supertype→tuple ++ newDefinitions)→object type;
	If ¬subtype ⊆ supertype then
	[
		early failure function(
			object type extension did not produce subtype code)
	];
	subtype
] : object meta;

/**
 * Object type extension statically requires that:
 *
 * - Every field atom of the extension is known.
 * - Each field atom of the extension appears only once during extension.
 * - Each field atom of the extension is either 1) not present in the supertype
 *   or 2) specifies a type which covaries with the field type expressed in the
 *   supertype.
 *
 * Parameters:
 *    meta - The supertype's type.
 *    newDefinitionTypes - A lexical tuple type.
 * Return:
 *    The strongest possible object metatype for the given argument types.
 */
Semantic restriction "extend_with«_:_‡,»" is
[
	meta : object meta's type,
	newDefinitionTypes : <<atom, any meta…|2>…|1..>'s type
|
	supertype ::= meta's instance;
	oldDefinitions ::= supertype→map;
	newDefinitions : field type map := {};
	From 1 to |newDefinitionTypes' leading types| + 1 do
	[
		index : natural number
	|
		def ::= newDefinitionTypes[index];
		atomType ::= def[1];
		newType ::= def[2]'s instance;
		If |atomType| ≠ 1 then
		[
			Reject parse, expected: "all field atoms to be known statically"
		];
		fieldAtom ::= atomType's instance;
		If fieldAtom ∈ newDefinitions then
		[
			Reject parse, expected:
				fieldAtom's name
				++ " to appear only once during extension (but it already\
				\| appeared with type = "
				++ primitive description of newDefinitions[fieldAtom]
				++ ")"
		];
		oldType ::= oldDefinitions[fieldAtom] else [ any ];
		If ¬newType ⊆ oldType then
		[
			Reject parse, expected:
				"covariant specialization of "
				++ fieldAtom's name
				++ " (but new field type "
				++ primitive description of newType
				++ " is not a subtype of "
				++ primitive description of oldType
				++ ")"
		];
		newDefinitions := eject ↑newDefinitions + fieldAtom→newType;
	];
	((supertype→tuple ++ newDefinitions' bindings)→object type)'s type
];

/**
 * Compute and answer the accessor name for the specified field atom.
 * 
 * Parameters:
 *    fieldAtom - A field atom.
 * Returns:
 *    The name of the accessor.
 */
Private method "accessor name for_" is
[
	fieldAtom : atom
|
	"_'s⁇" ++ fieldAtom's name
] : <character…|4..>;

/**
 * Generate and install field type and field value accessors for the specified
 * object type and field atom. Generate and install a semantic restriction for
 * the field value accessor.
 * 
 * Parameters:
 *    objectType - An object type.
 *    fieldAtom - A field atom.
 */
Private method "generate and install_accessor for_" is
[
	objectType : object meta,
	fieldAtom : atom
|
	objectMap ::= objectType→map;
	methodName ::= accessor name for fieldAtom;
	fieldType ::= objectMap[fieldAtom];
	classFunctionType ::= [objectType's type]→(fieldType's type);
	Method methodName is
		new classFunctionType
		applying [ x : object meta | x→map[fieldAtom] ];
	instanceFunctionType ::= [objectType]→fieldType;
	Method methodName is
		new instanceFunctionType
		applying [ x : object | x→map[fieldAtom] ];
	restrictionFunctionType ::= [objectType's type]→any meta;
	Semantic restriction methodName is
		new restrictionFunctionType
		applying [ x : object meta | x→map[fieldAtom] ];
] : ⊤;

/**
 * Construct and answer the name of the object reconstructor method from the
 * specified tuple of field atoms.
 * 
 * Parameters:
 *    fieldAtoms - The atoms of the fields migrated by the reconstructor.
 * Returns:
 *    The appropriate method name.
 */
Private method "reconstructor name for_" is
[
	fieldAtoms : <atom…|1..>
|
	methodName : <character…|7..> := accessor name for fieldAtoms[1] ++ ":=_";
	For each fieldAtoms' tail do
	[
		fieldAtom : atom
	|
		methodName := eject ↑methodName ++ "," ++ fieldAtom's name ++ ":=_";
	];
	methodName
] : <character…|7..>;

/**
 * Construct and answer a tuple of argument declarations for an object
 * reconstructor method (or its semantic restriction).
 * 
 * Parameters:
 *    objectType - The object type.
 *    fieldAtoms - The atoms of the fields migrated by the reconstructor.
 *    forSemanticRestriction - `true` if the argument declarations should be
 *       generated for the semantic restriction, `false` if they should be
 *       generated for the method.
 * Returns:
 *    The requested argument declarations. The first declaration is for the
 *    object type (or metatype) and the remaining correspond to the field atoms.
 */
Private method "_reconstructor arguments for_«(for semantic restriction)»?" is
[
	objectType : object meta,
	fieldAtoms : <atom…|1..>,
	forRestriction : boolean
|
	meta ::= if forRestriction then [ objectType's type ] else [ objectType ];
	objectMap ::= objectType→map;
	<arg “`"target"` : meta”> ++ map fieldAtoms through
	[
		fieldAtom : atom,
		index : natural number
	|
		desc ::= primitive description of index;
		argType ::= if forRestriction
			then [ objectMap[fieldAtom]'s type ]
			else [ objectMap[fieldAtom] ];
		arg “`"arg" ++ desc` : argType”
	]
] : <argument…|2..>;

/* These methods are needed for reconstructor synthesis. */
toMapM ::= method for $"_→map";
ejectM ::= method for $"eject_";
addBindingM ::= method for $"_+_→_";
toObjectM ::= method for $"_→object";
toObjectTypeM ::= method for $"_→object type";

/**
 * Generate and install a reconstructor for the specified object type and tuple
 * of field atoms.
 * 
 * Parameters:
 *    objectType - An object type.
 *    fieldAtoms - A field atoms.
 */
Private method "generate and install_reconstructor for_" is
[
	objectType : object meta,
	fieldAtoms : <atom…|1..>
|
	methodName ::= reconstructor name for fieldAtoms;
	args ::= objectType reconstructor arguments for fieldAtoms;
	/* Construct the body of the mutator method. */
	toMapMSend ::= send toMapM with “<“↓args[1]”>” : field map;
	mapDecl ::= “`"objectMap"` : field map := toMapMSend”;
	assignments ::= map fieldAtoms through
		[
			fieldAtom : atom,
			index : natural number
		|
			ejectSend ::= send ejectM with “<“↑“↓mapDecl””>” : field map;
			addBindingSend ::= send addBindingM
				with “<ejectSend, ‘`fieldAtom`’, “↓args[index + 1]”>”
				: field map;
			““↓mapDecl” := addBindingSend”
		];
	last ::= send toObjectM with “<“↓mapDecl”>” : objectType;
	statements ::= <mapDecl> ++ assignments ++ <last>;
	newBlock ::= “[ args | statements ]”;
	reconstructorFunction ::= generate newBlock;
	Method methodName is reconstructorFunction;
] : ⊤;

/**
 * Generate and install a semantic restriction for the reconstructor for the
 * specified object type and tuple of field atoms.
 * 
 * Parameters:
 *    objectType - An object type.
 *    fieldAtoms - A field atoms.
 */
Private method
	"generate and install_reconstructor's semantic restriction for_"
is
[
	objectType : object meta,
	fieldAtoms : <atom…|1..>
|
	methodName ::= reconstructor name for fieldAtoms;
	args ::= objectType reconstructor arguments for fieldAtoms
		(for semantic restriction);
	/* Construct the body of the semantic restriction method. */
	toMapMSend ::= send toMapM with “<“↓args[1]”>” : field type map;
	mapDecl ::= “`"objectMap"` : field type map := toMapMSend”;
	assignments ::= map fieldAtoms through
		[
			fieldAtom : atom,
			index : natural number
		|
			ejectSend ::= send ejectM with “<“↑“↓mapDecl””>” : field type map;
			addBindingSend ::= send addBindingM
				with “<ejectSend, ‘`fieldAtom`’, “↓args[index + 1]”>”
				: field type map;
			““↓mapDecl” := addBindingSend”
		];
	last ::= send toObjectTypeM with “<“↓mapDecl”>” : objectType's type;
	statements ::= <mapDecl> ++ assignments ++ <last>;
	newBlock ::= “[ args | statements ] : type”;
	Semantic restriction methodName is generate newBlock;
];

/**
 * Define a class. In Avail, a class is simply a named object type supported by
 * 1) a generated method that reliably reproduces the object type, 2) generated
 * methods that provide access to the field definitions, and 3) generated
 * methods that provide access to instance field values. A class is essentially
 * only a lexical construct, and is analogous to the distinction between blocks
 * (lexical) and functions (semantic).
 * 
 * Parameters:
 *    public - `true` if the class should be exported by the defining module,
 *       `false` otherwise.
 *    explicit - `true` if the class should have an artificial identity
 *       introduced (in order to ensure intentional provenance of subtypes),
 *       `false` otherwise.
 *    className - The name of the class. A method will be generated with this
 *       name. This method will answer the object type. The object type will
 *       also be christened with this name.
 *    supertype - The supertype of the class. Type intersection may be used here
 *       to facilitate inheritance from multiple sources.
 *    optionalExtensions - The extension fields of this class. An accessor will
 *       be generated for each field. A reconstructor will be generated for each
 *       field tagged as "reconstructible". Each field tagged as "public" must
 *       be exported by the defining module.
 */
Public method
	"«Public»?«Explicit|explicit»?\
	\|Class|class_extends_\
	\|«with fields««public»?«reconstructible»?_:_‡,»»\
	\|«with reconstructors««public»?(«_‡,»)‡,»»"
is
[
	public : boolean,
	explicit : boolean,
	className : <character…|1..>,
	supertype : object meta,
	optionalExtensions : <<<boolean, boolean, atom, any meta…|4>…|1..>…|0..1>,
	optionalReconstructors : <<<boolean, <atom…|1..>…|2>…|1..>…|0..1>
|
	/* Extract the extensions. */
	extensions : <<boolean, boolean, atom, any meta…|4>…|> := <>;
	newDefinitions : <<atom, any meta…|2>…|> := <>;
	Unless optionalExtensions is empty then
	[
		extensions := optionalExtensions[1];
		newDefinitions := map extensions through
			[
				fieldTuple : <boolean, boolean, atom, any meta…|4>
			|
				fieldTuple[3..4]
			];
	];
	/* Verify the uniqueness of the field atoms. */
	fieldAtoms ::= stripe newDefinitions at 1;
	If |fieldAtoms→set| ≠ |fieldAtoms| then
	[
		early failure function(object type extension contains duplicates code)
	];
	/* If necessary, then generate a field definition that guarantees
	 * uniqueness among object types.
	 */
	explicitDef : <<atom, any meta…|2>…|0..1> := <>;
	If explicit then
	[
		explicitAtom ::= new atom "explicit-" ++ className;
		explicitDef := <<explicitAtom, explicitAtom's type>>;
	];
	/* Construct and verify the subtype. */
	subtype ::= (supertype→tuple ++ newDefinitions ++ explicitDef)→object type;
	subtypeMap ::= subtype→map;
	If ¬subtype ⊆ supertype then
	[
		early failure function(
			object type extension did not produce subtype code)
	];
	/* Define the class: give the object type a name, define a method that
	 * answers the object type, and define methods that access the field
	 * definitions and values.
	 */
	subtype's name := className;
	Method className is new []→(subtype's type) applying [ subtype ];
	newFieldAtoms ::= fieldAtoms→set \ supertype→map's keys;
	For each newFieldAtoms do
	[
		fieldAtom : atom
	|
		generate and install subtype accessor for fieldAtom;
	];
	/* Determine which reconstructors to create. */
	reconstructors : <<atom…|1..>…|> := <>;
	reconstructors := eject ↑reconstructors ++ map and filter extensions by
		[
			triple : <boolean, boolean, atom, any meta…|4>,
			accept : [<atom…|1..>]→⊤
		|
			If triple[2] then
			[
				accept(<triple[3]>);
			];
		];
	Unless optionalReconstructors is empty then
	[
		specs ::= optionalReconstructors[1];
		reconstructors := eject ↑reconstructors ++ map specs through
			[
				spec : <boolean, <atom…|1..>…|2>
			|
				spec[2]
			];
	];
	/* Generate the reconstructors. */
	For each reconstructors do
	[
		atoms : <atom…|1..>
	|
		generate and install subtype reconstructor for atoms;
		generate and install subtype reconstructor's semantic restriction
			for atoms;
	];
] : ⊤;

/**
 * Class definition statically requires that:
 *
 * - Every field atom of the extension is known.
 * - Each field atom of the extension appears only once during extension.
 * - Each field atom of the extension is either 1) not present in the supertype
 *   or 2) specifies a type which covaries with the field type expressed in the
 *   supertype.
 *
 * Parameters:
 *    publicType -
 *    explicit -
 *    classNameType -
 *    meta -
 *    optionalExtensions -
 * Return:
 *    ⊤.
 */
Semantic restriction
	"«Public»?«Explicit|explicit»?\
	\|Class|class_extends_\
	\|«with fields««public»?«reconstructible»?_:_‡,»»\
	\|«with reconstructors««public»?(«_‡,»)‡,»»"
is
[
	publicType : boolean's type,
	explicit : boolean's type,
	classNameType : <character…|1..>'s type,
	meta : object meta's type,
	optionalExtensions :
		<<<boolean, boolean, atom, any meta…|4>…|1..>…|0..1>'s type,
	optionalReconstructors : <<<boolean, <atom…|1..>…|2>…|1..>…|0..1>'s type
|
	If |classNameType| ≠ 1 then
	[
		Reject parse, expected: "class name to be statically known"
	];
	public ::= publicType's instance;
	publicNames ::= current module's public names;
	className ::= classNameType's instance;
	If public ∧ [ ¬className ∈ publicNames ] then
	[
		Reject parse, expected:
			"\""
			++ className
			++ "\" to be included in the module's \"Names\" section"
	];
	supertype ::= meta's instance;
	oldDefinitions ::= supertype→map;
	newDefinitions : field type map := {};
	From 1 to relevant |optionalExtensions[1]| do
	[
		index : natural number
	|
		def ::= optionalExtensions[1][index];
		publicField ::= def[1]'s instance;
		reconstructible ::= def[2]'s instance;
		atomType ::= def[3];
		newType ::= def[4]'s instance;
		If |atomType| ≠ 1 then
		[
			Reject parse, expected:
				"all field atoms to be known statically"
		];
		fieldAtom ::= atomType's instance;
		accessorName ::= accessor name for fieldAtom;
		If publicField then
		[
			If ¬public then
			[
				Reject parse, expected:
					"\""
					++ accessorName
					++ " to be private (because the class is private)"
			];
			If ¬accessorName ∈ publicNames then
			[
				Reject parse, expected:
					"\""
					++ accessorName
					++ "\" to be included in the module's \"Names\" section\
					\| (because it is public)"
			];
			If reconstructible then
			[
				reconstructorName ::= accessorName ++ ":=_";
				If ¬reconstructorName ∈ publicNames then
				[
					Reject parse, expected:
						"\""
						++ reconstructorName
						++ "\" to be included in the module's \"Names\"\
							\| section (because it is public)"
				];
			];
		];
		If fieldAtom ∈ newDefinitions then
		[
			Reject parse, expected:
				fieldAtom's name
				++ " to appear only once during extension (but it already\
				\| appeared with type = "
				++ primitive description of newDefinitions[fieldAtom]
				++ ")"
		];
		oldType ::= oldDefinitions[fieldAtom] else [ any ];
		If ¬newType ⊆ oldType then
		[
			Reject parse, expected:
				"covariant specialization of "
				++ fieldAtom's name
				++ " (but new field type "
				++ primitive description of newType
				++ " is not a subtype of "
				++ primitive description of oldType
				++ ")"
		];
		newDefinitions := eject ↑newDefinitions + fieldAtom→newType;
	];
	From 1 to relevant |optionalReconstructors[1]| do
	[
		index : natural number
	|
		spec ::= optionalReconstructors[1][index];
		publicSpec ::= spec[1]'s instance;
		atomsType ::= spec[2];
		fieldAtoms : <atom…|> := <>;
		From 1 to relevant |atomsType| do
		[
			atomTypeIndex : natural number
		|
			atomType ::= atomsType[atomTypeIndex];
			If |atomType| ≠ 1 then
			[
				Reject parse, expected:
					"all reconstructor field atoms to be known statically"
			];
			fieldAtoms := eject ↑fieldAtoms ++ <atomType's instance>;
		];
		nonemptyFieldAtoms ::= cast fieldAtoms into [ t : <atom…|1..> | t ];
		reconstructorName ::= reconstructor name for nonemptyFieldAtoms;
		If publicSpec then
		[
			If ¬public then
			[
				Reject parse, expected:
					"\""
					++ reconstructorName
					++ "\" to be private (because the class is private)"
			];
			If ¬reconstructorName ∈ publicNames then
			[
				Reject parse, expected:
					"\""
					++ reconstructorName
					++ "\" to be included in the module's \"Names\" section\
					\| (because it is public)"
			];
		];
	];
	⊤
];

/**
 * Construct and answer an object which is an instance of `objectType` and whose
 * field values are determined by `optional`.
 * 
 * Parameters:
 *    objectType - An object type that must be a supertype of the answer.
 *    optional - A tuple of field assignments. The outermost tuple may be empty
 *       (but only to support the case that `objectType = object`), but usually
 *       contains a single tuple of field assignments. A field assignment is a
 *       2-tuple that consists of 1) an atom that uniquely identifies the field
 *       and 2) the field value.
 * Returns:
 *    The requested object type.
 */
Public method "a|an_«with«_:=_‡,»»" is
[
	objectType : object meta,
	optional : <<<atom, any…|2>…|1..>…|0..1>
|
	assignments ::= if optional is empty then [ <> ] else [ optional[1] ];
	fieldAtoms ::= stripe assignments at 1;
	If |fieldAtoms→set| ≠ |fieldAtoms| then
	[
		early failure function(object instantiation contains duplicates code)
	];
	objectMap ::= objectType→map;
	identityAssignments : <<atom, atom…|2>…|> := <>;
	For each objectMap do
	[
		fieldAtom : atom,
		fieldType : any meta
	|
		If |fieldType| = 1 ∧ [ fieldType's instance = fieldAtom ] then
		[
			identityAssignments :=
				eject ↑identityAssignments ++ <2 of fieldAtom>;
		];
	];
	allAssignments ::= assignments ++ identityAssignments;
	If |allAssignments| ≠ |objectMap| then
	[
		early failure function(object instantiation invalid code)
	];
	newObject ::= allAssignments→object;
	If ¬newObject ∈ objectType then
	[
		early failure function(
			object instantiation did not produce instance code)
	];
	newObject
];

/**
 * Object instantiation statically requires that:
 *
 * - Every field atom of the instantiation tuple is known.
 * - Each field atom of the instantiation tuple appears only once during
 *   instantiation.
 * - An assigned value conforms to the field type.
 * - An assignment occurs for every field of the object type.
 *
 * Parameters:
 *    meta - The type of the template object type.
 *    optional - A lexical tuple type.
 * Return:
 *    The strongest possible object type for the given argument types.
 */
Semantic restriction "a|an_«with«_:=_‡,»»" is
[
	meta : object meta's type,
	optional : <<<atom, any…|2>…|1..>…|0..1>'s type
|
	objectType ::= meta's instance;
	definitions ::= objectType→map;
	assignments : field type map := {};
	From 1 to relevant |optional[1]| do
	[
		index : natural number
	|
		def ::= optional[1][index];
		atomType ::= def[1];
		valueType ::= def[2];
		If |atomType| ≠ 1 then
		[
			Reject parse, expected: "all field atoms to be known statically"
		];
		fieldAtom ::= atomType's instance;
		If fieldAtom ∈ assignments then
		[
			Reject parse, expected:
				fieldAtom's name
				++ " to appear only once during instantiation (but it already\
				\| appeared with type = "
				++ primitive description of assignments[fieldAtom]
				++ ")"
		];
		requiredType ::= definitions[fieldAtom] else [ any ];
		If ¬valueType ⊆ requiredType then
		[
			Reject parse, expected:
				"valid assignment to "
				++ fieldAtom's name
				++ " (but "
				++ primitive description of valueType
				++ " is not a subtype of "
				++ primitive description of requiredType
				++ ")"
		];
		assignments := eject ↑assignments + fieldAtom→valueType;
	];
	For each definitions do
	[
		fieldAtom : atom,
		fieldType : any meta
	|
		If |fieldType| = 1 ∧ [ fieldType's instance = fieldAtom ] then
		[
			assignments := eject ↑assignments + fieldAtom→fieldAtom's type;
		];
	];
	missing ::= filter definitions' keys by [ a : atom | ¬a ∈ assignments ];
	If |missing| ≠ 0 then
	[
		Reject parse, expected:
			"assignments for all fields of "
			++ primitive description of objectType
			++ " (but assignments are missing for "
			++ primitive description of missing
			++ ")"
	];
	assignments→object type
];

/* TODO: [TLS] Remove when done!
Class "colorful" extends object
	with fields
		$color : enumeration of
			{"red", "orange", "yellow", "green", "blue", "indigo", "violet"};

Class "textured" extends object
	with fields
		$texture : enumeration of {"rough", "smooth"};

Explicit class "textured RGB" extends colorful ∩ textured
	with fields
		reconstructible $color : enumeration of {"red", "green", "blue"},
		$texture : "smooth"'s type,
		$flavor : enumeration of {"salty", "sweet"}
	with reconstructors
		($color, $flavor);

trgb : textured RGB := a textured RGB with
	$color := "green",
	$texture := "smooth",
	$flavor := "salty";
Print: "trgb=";
Print: primitive description of trgb;
Print: "\n";
Print: "trgb's color=";
Print: primitive description of trgb's color;
Print: "\n";
Print: "trgb's texture=";
Print: primitive description of trgb's texture;
Print: "\n";
mutated ::= trgb's color := "blue", flavor := "sweet";
Print: "mutated=";
Print: primitive description of mutated;
Print: "\n";
*/