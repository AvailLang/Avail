/*
 * Logic.avail
 * Copyright © 1993-2012, Mark van Gulik and Todd L Smith.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

System Module "Logic"
Versions
	"dev"
Extends
	"Early Logic"
Uses
	"Bootstrap",
	"Assertions",
	"Early Control Structures",
	"Early Literals",
	"Early Functions",
	"Early Types",
	"Literals"
Names
	"_⊕_",
	"_↑_",
	"_↓_",
	"_→_",
	"_←_",
	"_↔_",
	"_↛_",
	"_↚_"
Body

/**
 * Compute and answer the logical exclusive disjunction, i.e., XOR, of the
 * arguments. This is equivalent to (a ∧ ¬b) ∨ ((¬a) ∧ b)
 * 
 * Parameters:
 *    a - A boolean.
 *    b - A boolean.
 * Returns:
 *    `a` ⊕ `b`.
 */
Method "_⊕_" is
[
	a : boolean,
	b : boolean
|
	(a ∧ [¬b;]) ∨ [(¬a) ∧ [b;];];
] : boolean;

/**
 * Compute and answer the logical NAND of the arguments. This is equivalent to
 * ¬(`a` ∧ `b`). Short-circuit the computation, i.e., only evaluate `b` if `a`
 * is `true`.
 * 
 * Parameters:
 *    a - A boolean.
 *    b - A boolean function.
 * Returns:
 *    `a` ↑ `b`.
 */
Method "_↑_" is
[
	a : boolean,
	b : []→boolean
|
	¬(a ∧ b);
] : boolean;

/**
 * Compute and answer the logical NAND of the arguments. This is equivalent to
 * ¬(a ∧ b). Short-circuit the computation, i.e., only evaluate `b` if `a` is
 * `true`.
 * 
 * Parameters:
 *    a - A boolean.
 *    b - A boolean function.
 * Returns:
 *    `a` ↑ `b`.
 */
Method "_↑_" is
[
	a : false's type,
	b : []→boolean
|
	true;
] : boolean;

/**
 * If the left-hand argument of `_↑_` is known statically to be `false`, then
 * the expression is also known statically to be `true`.
 *
 * Parameters:
 *    a - The type of `false`.
 *    b - A function type whose instances answer a boolean.
 * Returns:
 *    The type of `true`.
 */
Semantic restriction "_↑_" is
[
	a : false's type's type,
	b : ([]→boolean)'s type
|
	true's type;
];

/**
 * If the left-hand argument of `_↑_` is known statically to be `true`, then
 * the static type of the expression is the negation of `b`'s return type.
 *
 * Parameters:
 *    a - The type of `true`.
 *    b - A function type whose instances answer `true`.
 * Returns:
 *    The return type of `b`.
 */
Semantic restriction "_↑_" is
[
	a : true's type's type,
	b : ([]→true's type)'s type
|
	false's type;
];

/**
 * If the right-hand argument of `_↑_` is known statically to be `true`, then
 * the static type of the expression is the negation of `b`'s return type.
 *
 * Parameters:
 *    a - boolean's type.
 *    b - A function type whose instances answer `false`.
 * Returns:
 *    The type of `true`.
 */
Semantic restriction "_↑_" is
[
	a : boolean's type,
	b : ([]→false's type)'s type
|
	true's type;
];

/* TODO: Eventually move these into a testing module. */
Assert: ¬(true ↑ [true;]) ("true ↑ true");
Assert: true ↑ [false;] ("true ↑ false");
Assert: false ↑ [true;] ("false ↑ true");
Assert: false ↑ [false;] ("false ↑ false");

/**
 * Compute and answer the logical NOR of the arguments. This is equivalent to
 * ¬(`a` ∨ `b`). Short-circuit the computation, i.e., only evaluate `b` if `a`
 * is `false`.
 *
 * Parameters:
 *    a - A boolean.
 *    b - A boolean function.
 * Returns:
 *    `a` ↓ `b`.
 */
Method "_↓_" is
[
	a : boolean,
	b : []→boolean
|
	¬(a ∨ b);
] : boolean;

/**
 * Compute and answer the logical NOR of the arguments. This is equivalent to
 * ¬(`a` ∨ `b`). Short-circuit the computation, i.e., only evaluate `b` if `a`
 * is `false`.
 *
 * Parameters:
 *    a - A boolean.
 *    b - A boolean function.
 * Returns:
 *    `a` ↓ `b`.
 */
Method "_↓_" is
[
	a : true's type,
	b : []→boolean
|
	false;
] : boolean;

/**
 * If the left-hand argument of `_↓_` is known statically to be `true`, then
 * the expression is known statically to be `false`.
 *
 * Parameters:
 *    a - The type of `true`.
 *    b - A function type whose instances answer a boolean.
 * Returns:
 *    The type of `false`.
 */
Semantic restriction "_↓_" is
[
	a : true's type's type,
	b : ([]→boolean)'s type
|
	false's type;
];

/**
 * If the left-hand argument of `_↓_` is known statically to be `false`, then
 * the static type of the expression is the negation of `b`'s return type.
 *
 * Parameters:
 *    a - The type of `false`.
 *    b - A function type whose instances answer `true`.
 * Returns:
 *    The type of `false`.
 */
Semantic restriction "_↓_" is
[
	a : false's type's type,
	b : (function accepting <> and returning true's type)'s type
|
	false's type;
];

/**
 * If the left-hand argument of `_↓_` is known statically to be `false`, then
 * the static type of the expression is the negation of `b`'s return type.
 *
 * Parameters:
 *    a - The type of `false`.
 *    b - A function type whose instances answer `false`.
 * Returns:
 *    The type of `true`.
 */
Semantic restriction "_↓_" is
[
	a : false's type's type,
	b : ([]→false's type)'s type
|
	true's type;
];

/**
 * If the right-hand argument of `_↓_` is known statically to be `false`, then
 * the static type of the expression is `false`.
 *
 * Parameters:
 *    a - Boolean's type.
 *    b - A function type whose instances answer `true`.
 * Returns:
 *    The type of `false`.
 */
Semantic restriction "_↓_" is
[
	a : boolean's type,
	b : ([]→true's type)'s type
|
	false's type;
];

/**
 * Compute and answer the material conditional of the arguments. This is the
 * equivalent of (¬`a`) ∨ `b`. Short-circuit the computation, i.e., only
 * evaluate `b` if `a` is `true`.
 *
 * Parameters:
 *    a - A boolean.
 *    b - A boolean function.
 * Returns:
 *    `a` → `b`.
 */
Method "_→_" is
[
	a : boolean,
	b : []→boolean
|
	(¬a) ∨ b;
] : boolean;

/**
 * Compute and answer the material conditional of the arguments. This is the
 * equivalent of (¬`a`) ∨ `b`. Short-circuit the computation, i.e., only
 * evaluate `b` if `a` is `true`.
 *
 * Parameters:
 *    a - A boolean.
 *    b - A boolean function.
 * Returns:
 *    `a` → `b`.
 */
Method "_→_" is
[
	a : false's type,
	b : []→boolean
|
	true;
] : boolean;

/**
 * If the left-hand argument of `_∧_` is known statically to be `false`, then
 * the expression is known statically to be `true`.
 *
 * Parameters:
 *    a - The type of `false`.
 *    b - A function type whose instances answer a boolean.
 * Returns:
 *    The type of `true`.
 */
Semantic restriction "_→_" is
[
	a : false's type's type,
	b : ([]→boolean)'s type
|
	true's type;
];

/**
 * If the right-hand argument of `_∧_` is known statically to be `true`, then
 * the expression is known statically to be `true`.
 *
 * Parameters:
 *    a - The type of `false`.
 *    b - A function type whose instances answer a boolean.
 * Returns:
 *    The type of `true`.
 */
Semantic restriction "_→_" is
[
	a : boolean's type,
	b : ([]→true's type)'s type
|
	true's type;
];

/**
 * Compute and answer the converse implication of the arguments. This is
 * equivalent to `a` ∨ ¬`b`. Short-circuit the computation, i.e., only evaluate
 * `b` if `a`  is false.
 *
 * Parameters:
 *    a - A boolean.
 *    b - A boolean function.
 * Returns:
 *    `a` ← `b`.
 */
Method "_←_" is
[
	a : boolean,
	b : []→boolean
|
	a ∨ [¬b();];
] : boolean;

/**
 * Compute and answer the converse implication of the arguments. This is
 * equivalent to `a` ∨ ¬`b`. Short-circuit the computation, i.e., only evaluate
 * `b` if `a`  is false.
 *
 * Parameters:
 *    a - A boolean.
 *    b - A boolean function.
 * Returns:
 *    `a` ← `b`.
 */
Method "_←_" is
[
	a : true's type,
	b : []→boolean
|
	true;
] : boolean;

/**
 * If the left-hand argument of `_∧_` is known statically to be `true`, then
 * the static type of the expression is `true`.
 *
 * Parameters:
 *    a - The type of `true`.
 *    b - A function type whose instances answer a boolean.
 * Returns:
 *    The type of `true`.
 */
Semantic restriction "_←_" is
[
	a : true's type's type,
	b : ([]→boolean)'s type
|
	true's type;
];

/**
 * If the right-hand argument of `_←_` is known statically to be `false`, then
 * the static type of the expression is `true`.
 *
 * Parameters:
 *    a - boolean's type.
 *    b - A function type whose instances answer `false`.
 * Returns:
 *    The type of `true`.
 */
Semantic restriction "_←_" is
[
	a : boolean's type,
	b : ([]→false's type)'s type
|
	true's type;
];

/**
 * Compute and answer the logical biconditional of the arguments. This is the
 * negation of XOR and equivalent to (`a` ∧ `b`) ∨ ((¬`a`) ∧ ¬`b`).
 *
 * Parameters:
 *    a - A boolean.
 *    b - A boolean.
 * Returns:
 *    `a` ↔ `b`.
 */
Method "_↔_" is
[
	a : boolean,
	b : boolean
|
	(a ∧ [b;]) ∨ [(¬a) ∧ [¬b;];];
] : boolean;

/**
 * Compute and answer the material nonimplication of the arguments. This is
 * equivalent to `a` ∧ ¬`b`. Short-circuit the computation, i.e., only evaluate
 * `b` if `a` is `true`.
 *
 * Parameters:
 *    a - A boolean.
 *    b - A boolean function.
 * Returns:
 *    `a` ↛ `b`.
 */
Method "_↛_" is
[
	a : boolean,
	b : []→boolean
|
	a ∧ [¬b();];
] : boolean;

/**
 * Compute and answer the material nonimplication of the arguments. This is
 * equivalent to `a` ∧ ¬`b`. Short-circuit the computation, i.e., only evaluate
 * `b` if `a` is `true`.
 *
 * Parameters:
 *    a - A boolean.
 *    b - A boolean function.
 * Returns:
 *    `a` ↛ `b`.
 */
Method "_↛_" is
[
	a : false's type,
	b : []→boolean
|
	false;
] : boolean;

/**
 * If the left-hand argument of `_↛_` is known statically to be `false`, then
 * the static type of the expression is `false`.
 *
 * Parameters:
 *    a - The type of `false`.
 *    b - A function type whose instances answer a boolean.
 * Returns:
 *    The type of `false`.
 */
Semantic restriction "_↛_" is
[
	a : false's type's type,
	b : ([]→boolean)'s type
|
	false's type;
];

/**
 * If the right-hand argument of `_↛_` is known statically to be `true`, then
 * the static type of the expression is `false`.
 *
 * Parameters:
 *    a - The type of boolean.
 *    b - A function type whose instances answer `true`.
 * Returns:
 *    The type of `false`.
 */
Semantic restriction "_↛_" is
[
	a : boolean's type,
	b : ([]→true's type)'s type
|
	false's type;
];

/**
 * Compute and answer the converse nonimplication of the arguments. This is
 * equivalent to (¬`a`) ∧ `b`. Short-circuit the computation, i.e., only
 * evaluate `b` if `a` is `false`.
 *
 * Parameters:
 *    a - A boolean.
 *    b - A boolean function.
 * Returns:
 *    `a` ↚ `b`.
 */
Method "_↚_" is
[
	a : boolean,
	b : []→boolean
|
	(¬a) ∧ [b();];
] : boolean;

/**
 * Compute and answer the converse nonimplication of the arguments. This is
 * equivalent to (¬`a`) ∧ `b`. Short-circuit the computation, i.e., only
 * evaluate `b` if `a` is `false`.
 *
 * Parameters:
 *    a - A boolean.
 *    b - A boolean function.
 * Returns:
 *    `a` ↚ `b`.
 */
Method "_↚_" is
[
	a : true's type,
	b : []→boolean
|
	false;
] : boolean;

/**
 * If the left-hand argument of `_↚_` is known statically to be `true`, then
 * the static type of the expression is `false`.
 *
 * Parameters:
 *    a - The type of `true`.
 *    b - A function type whose instances answer a boolean.
 * Returns:
 *    The type of `false`.
 */
Semantic restriction "_↚_" is
[
	a : true's type's type,
	b : ([]→boolean)'s type
|
	false's type;
];

/**
 * If the right-hand argument of `_↚_` is known statically to be `false`, then
 * the static type of the expression is `false`.
 *
 * Parameters:
 *    a - The type of boolean.
 *    b - A function type whose instances answer a `false`.
 * Returns:
 *    The type of `false`.
 */
Semantic restriction "_↚_" is
[
	a : boolean's type,
	b : ([]→false's type)'s type
|
	false's type;
];

/**
 * If the right-hand argument of `_↚_` is known statically to be `true` and the
 * left-hand argument is known statically to be `false`, then the static type
 * of the expression is `true`.
 *
 * Parameters:
 *    a - The type of boolean.
 *    b - A function type whose instances answer a `false`.
 * Returns:
 *    The type of `false`.
 */
Semantic restriction "_↚_" is
[
	a : false's type's type,
	b : ([]→true's type)'s type
|
	true's type;
];

Grammatical restriction {"¬_"} is
	<{"_∧_", "_∨_", "_⊕_", "_↑_", "_↓_", "_→_", "_←_", "_↔_", "_↛_", "_↚_"}>;
	
Grammatical restriction {"_∧_"} is
	<{"_∨_", "_→_", "_↔_", "_←_", "_⊕_", "_↛_", "_↚_"},
	{"_∧_", "_∨_", "_⊕_", "_→_", "_↔_", "_←_", "_↛_", "_↚_"}>;
	
Grammatical restriction {"_∨_"} is 
	<{"_→_", "_↔_", "_←_", "_⊕_", "_↛_", "_↚_"},
	{"_∨_", "_→_", "_↔_", "_←_", "_⊕_", "_↛_", "_↚_"}>;

Grammatical restriction {"_→_", "_←_", "_↛_", "_↚_"} is 
	<{"_↔_", "_⊕_"}, {"_→_","_↔_", "_←_", "_⊕_", "_↛_", "_↚_"}>;

Grammatical restriction {"_↔_", "_⊕_"} is <∅, {"_↔_", "_⊕_"}>;