/**
 * System/Foundation/Basic Support
 * Copyright (c) 2010, Mark van Gulik.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Basic support utilities for primitive and system methods.
 *
 * @author Todd L Smith &lt;anarakul@gmail.com&gt;
 */
System Module "Basic Support"
Extends
Uses
	"Basic Types"
Names
	/* Definers. */
	"⊶Method_is_and validates with_",

	/* Semantic aliases for type hierarchy extrema. */
	"nothing",
	"does not return",

	/* Procedure adapter. */
	"Statement:_",

	/* Extreme sanction. */
	"Exit:_",
	"Reject parse:_",
	
	/* Assertions. */
	"Assert:_",
	
	/* Kind constructors. */
	"<«_‡,»>",
	"⊶{«_‡,»}",
	
	/* Negative precedence. */
	"⊶_doesn't allow_",
	
	/* Explicit grouping. */
	"(_)",
	
	/* Strong type extraction. */
	"_'s type",
	"_'s expression type",
	
	/* Security (and completeness). */
	"Seal_at_"
Body

/**
 * Semantic alias for {@code ⊤} intended to indicate that a function does not
 * return a value, i.e. is procedure-like rather than function-like.
 *
 * @returns {@code ⊤}.
 */
Method "nothing" is
[
	⊤;
] : ⊶⊤'s type;

/**
 * Semantic alias for {@code ⊥} intended to indicate that a function does not
 * return, i.e. it either raises an exception, jumps into another continuation,
 * or never relinquishes control back to the caller.
 *
 * @return {@code ⊥}.
 */
Method "does not return" is
[
	⊥;
] : ⊶⊥'s type;

/**
 * Explicitly disregard the specified argument. This is normally used to cast an
 * expression to {@code ⊤}, thereby turning it into a statement.
 *
 * @param unwanted
 *        The argument to ignore.
 */
Method "Statement:_" is
[
	unwanted : any
|
	/* No implementation required. */
] : nothing;

/**
 * Exit the current thread. The specified argument will be converted internally
 * into a {@code string} and used to report an error message.
 *
 * @param reason
 *        An object whose display string will be captured for postmortem
 *        presentation.
 */
Method "Exit:_" is
[
	postMortemHint : any
|
	Primitive 256;
] : does not return;

/**
 * Reject the parse currently underway. The compiler should display the
 * specified argument as the reason why the parse aborted. This facility exists
 * to support macros and call-site type checking.
 *
 * @param reason
 *        The reason why the current parse aborted.
 */
Method "Reject parse:_" is
[
	reason : string
|
	Primitive 352;
] : does not return;

/**
 * Assert that the specified argument is {@code true}.
 *
 * <p>Note that this implementation cooperates with a more specific
 * implementation to provide complete coverage of {@code boolean}.</p>
 *
 * @param value
 *        Specialization guarantees that this will actually be {@code true}.
 */
Method "Assert:_" is
[
	value : boolean
|
	/* No implementation required. */
] : nothing;

/**
 * Assert that the specified argument is {@code true}.
 *
 * <p>Note that this implementation cooperates with a more general
 * implementation to provide complete coverage of {@code boolean}.</p>
 *
 * @param value
 *        {@code false}.
 */
Method "Assert:_" is
[
	value : false's type
|
	Exit: "assertion failed";
] : does not return;

/**
 * Define a method. The parse nodes corresponding to the arguments will be
 * checked at compile time against the specified call site validation function.
 *
 * @param methodName
 *        The method name.
 * @param implementation
 *        The function that implements the method.
 * @param validator
 *        A function whose parameters correspond to the parse nodes of the
 *        arguments at the call site at compile time. It should answer a type at
 *        least as strong as the statically ascertained result type of the
 *        implementation function. If the arguments are rejected, then the
 *        function should call "Reject the current parse because_" to provide a
 *        more specific rationale for argument rejection.
 */
Method "⊶Method_is_and validates with_" is
[
	methodName : string,
	implementation : ⊶[…]→⊤,
	validator: ⊶[…]→⊤
|
	Primitive ??? (unusedFailureCode : any);
	Exit: "system error: primitive ??? failed";
] : void;

/**
 * Bootstrap: This must not be called. Only the specialization defined on
 * {@code parse node's type} must be called. This is provided only to simplify
 * link-time strengthening of parse node kind parameterization.
 *
 * @param nodeKind
 *        A parse node kind.
 * @param expressionType
 *        A type.
 * @return A parse node kind.
 */
Method "⊶_⇒_" is
[
	nodeKind : any,
	expressionType : type
|
	parse node's type;
];

/**
 * Bootstrap: Answer a parse node kind that is parameterized by its static
 * expression type.
 *
 * @param nodeKind
 *        A parse node kind.
 * @param expressionType
 *        A type.
 * @return A parse node kind.
 */
Method "⊶_⇒_" is
[
	nodeKind : parse node's type,
	expressionType : type
|
	Primitive ???;
] : parse node's type;

/**
 * Answer the expression type of the specified parse node.
 *
 * @param node
 *        A parse node.
 * @return The expression type of the argument.
 */
Method "_'s expression type" is
[
	node : parse node
|
	Primitive 351;
] : type;

/**
 * Answer the type of the argument. The validation clause ensures
 * metacovariance: {@code ∀T1,T2 ∈ type : T1's type ≤ T2's type}.
 *
 * @param o
 *        An entity.
 */
Method "_'s type" is
[
	o : any
|
	Primitive 30;
] : type
and validates with
[
	argumentNode : parse node
|
	argumentNode's expression type;
];

/**
 * Force a particular order of evaluation of a subexpression. This implements
 * the standard mathematical notation of grouping parentheses.
 *
 * @param argument
 *        An argument, usually the result of a multi-node subexpression.
 * @returns The argument.
 */
⊶Method "(_)" is
[
	argument : any |
	argument;
]
and validates with
[
	argumentNode : parse node
|
	argumentNode's expression type;
];

/**
 * Answer a parse node kind that is parameterized by its static expression type.
 *
 * @param nodeKind
 *        A parse node kind.
 * @param expressionType
 *        A type.
 * @return A parse node kind.
 */
Method "_⇒_" is
[
	nodeKind : parse node's type,
	resultType : type
|
	Primitive ???;
] : parse node's type
and validates with
[
	nodeKindNode : ⊶parse node ⇒ (parse node's type),
	resultTypeNode : ⊶parse node ⇒ type
|
	⊶(nodeKindNode's expression type) ⇒ (resultTypeNode's expression type);
];

/**
 * Construct a tuple from the argument subexpressions.
 *
 * @param argument
 *        A tuple, constructed automatically by the parser during the processing
 *        of the guillemets construct.
 * @return A tuple.
 */
⊶Method "<«_‡,»>" is
[
	argument : ⊶<any..|0..∞>
|
	argument;
]
and validates with
[
	argumentNode : tuple node
|
	argumentNode's expression type;
];

/**
 * Construct a set from the argument subexpressions.
 *
 * @param argument
 *        A tuple, constructed automatically by the parser during the processing
 *        of the guillemets construct.
 * @return A set.
 */
Method "⊶{«_‡,»}" is
[
	argument : ⊶<any..|0..∞>
|
	Primitive 109;
] : ⊶{any|0..∞};

/**
 * Message precedence declaration with a tuple of sets of messages to exclude
 * for each argument position. Note that the tuple's elements should correspond
 * with occurrences of underscore in the method names, *not* with the
 * (top-level) arguments of the method. This distinction is only apparent when
 * chevron notation is used to accept tuples of arguments.
 *
 * <p>Note that it is not desirable to express the restrictions positively. That
 * is, to define "_must have_" rather than "_doesn't allow_". Positive-space
 * restrictions guarantee non-modularity. In particular, the introduction of new
 * methods would require explicit refactoring of existing "_must have_" rules to
 * permit syntactic extension. This is cumbersome, error-prone, and ultimately
 * futile.</p>
 *
 * @param methodNames
 *        The target method names to which the tuple of restrictions apply.
 * @param forbiddenSubexpressions
 *        A tuple of sets of method names. The set at position N corresponds to
 *        the N-th underscore of each target method name. Each set contains
 *        method names that are not allowed at the N-th position.
 */
Method "⊶_doesn't allow_" is
[
	methodNames : ⊶{string|0..∞},
	forbiddenSubexpressions : ⊶<{string|0..∞}|0..∞>
|
	Primitive 255 (unusedFailureCode : ⊶[1..∞));
	Exit: "system error: primitive 255 failed";
] : nothing;

/**
 * Single target message precedence declaration.
 *
 * @param methodNames
 *        The target method name to which the tuple of restrictions apply.
 * @param forbiddenSubexpressions
 *        A tuple of sets of method names. The set at position N corresponds to
 *        the N-th underscore of each target method name. Each set contains
 *        method names that are not allowed at the N-th position.
 */
Method "⊶_doesn't allow_" is
[
	methodName : string,
	forbiddenSubexpressions : ⊶<any..|0..∞>
|
	⊶{methodName} doesn't allow forbiddenSubexpressions;
] : nothing;

/* Disallow spurious parenthetical nesting. */
⊶"(_)" doesn't allow <⊶{"(_)"}>;

/**
 * Seal the multimethod at the specified locus in the implementation
 * specialization hierarchy. That is, do not allow further definitions whose
 * signatures are as or more specific than the one indicated.
 *
 * @param methodName
 *        The method name.
 * @param signature
 *        A function kind.
 */
Method "Seal_at_" is
[
	methodName : string,
	signature : ⊶[…]→⊤
|
	Primitive ??? (unusedFailureCode : ⊶[1..∞));
	Exit: "system error: primitive ??? failed";
] : nothing; 
