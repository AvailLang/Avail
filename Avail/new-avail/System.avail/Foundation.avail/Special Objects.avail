/**
 * System/Foundation/Special Objects
 * Copyright (c) 2010, Mark van Gulik.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Bind nullary methods to the built-in "special objects". Most of the special
 * objects are foundational Avail types, the exceptions being the two intrinsic
 * boolean constants.
 *
 * @author Todd L Smith &lt;anarakul@gmail.com&gt;
 * @author Leslie Schultz &lt;leslie.a.schultz@gmail.com&gt;
 */
System Module "Special Objects"
Extends
Uses
	"Origin"
Names
	"all",
	"boolean",
	"character",
	"closure",
	"closure type",
	"compiled code",
	"container",
	"container type",
	"continuation",
	"continuation type",
	"cyclic type",
	"double",
	"extended integer",
	"false type",
	"float",
	"generalized closure type",
	"integer",
	"integer type",
	"map type",
	"meta",
	"object meta",
	"object meta meta",
	"object type",
	"primitive type",
	"process",
	"set",
	"set type",
	"string",
	"terminates",
	"terminates type",
	"true type",
	"tuple",
	"tuple type",
	"type",
	"void",

	"parse node",
	"marker node",
	"expression node",
	"assignment node",
	"block node",
	"literal node",
	"reference node",
	"send node",
	"supercast node",
	"tuple node",
	"variable use node",
	"declaration node",
	"argument node",
	"label node",
	"local variable node",
	"local constant node",
	"module variable node",
	"module constant node",

	"true", "false",
	
	/* Re-export the defining method for use by subsequent modules. Note that we
	 * explicitly do not export the special object binding method. There should
	 * be no other clients of "special object_".
	 */ 
	"Method_is_"
Body

/*
 * Let's start by capturing the special objects into private module variables.
 */
 
privateAll                    ::= special object 1;
privateBoolean                ::= special object 2;
privateCharacter              ::= special object 3;
privateClosure                ::= special object 4;
privateClosureType            ::= special object 5;
privateCompiledCode           ::= special object 6;
privateContainer              ::= special object 7;
privateContainerType          ::= special object 8;
privateContinuation           ::= special object 9;
privateContinuationType       ::= special object 10;
privateCyclicType             ::= special object 11;
privateDouble                 ::= special object 12;
privateExtendedInteger        ::= special object 13;
privateFalseType              ::= special object 14;
privateFloat                  ::= special object 15;
privateGeneralizedClosureType ::= special object 16;
privateInteger                ::= special object 17;
privateIntegerType            ::= special object 18;
privateMapType                ::= special object 19;
privateMeta                   ::= special object 20;
privateObjectMeta             ::= special object 21;
privateObjectMetaMeta         ::= special object 22;
privateObjectType             ::= special object 23;
privatePrimitiveType          ::= special object 24;
privateProcess                ::= special object 25;
privateSet                    ::= special object 26;
privateSetType                ::= special object 27;
privateString                 ::= special object 28;
privateTerminates             ::= special object 29;
privateTerminatesType         ::= special object 30;
privateTrueType               ::= special object 31;
privateTuple                  ::= special object 32;
privateTupleType              ::= special object 33;
privateType                   ::= special object 34;
privateVoid                   ::= special object 35;

privateParseNode              ::= special object 50;
privateMarkerNode             ::= special object 51;
privateExpressionNode         ::= special object 52;
privateAssignmentNode         ::= special object 53;
privateBlockNode              ::= special object 54;
privateLiteralNode            ::= special object 55;
privateReferenceNode          ::= special object 56;
privateSendNode               ::= special object 57;
privateSuperCastNode          ::= special object 58;
privateTupleNode              ::= special object 59;
privateVariableUseNode        ::= special object 60;
privateDeclarationNode        ::= special object 61;
privateArgumentNode           ::= special object 62;
privateLabelNode              ::= special object 63;
privateLocalVariableNode      ::= special object 64;
privateLocalConstantNode      ::= special object 65;
privateModuleVariableNode     ::= special object 66;
privateModuleConstantNode     ::= special object 67;

privateTrue                   ::= special object 70;
privateFalse                  ::= special object 71;

/*
 * Now we provide nullary methods to return the special objects.
 */

/**
 * Answer the most general type of all instances.
 *
 * @returns The type {@code all}.
 */
Method "all" is
[
	privateAll;
] : privateType;

/**
 * Answer the most specific general type of the boolean intrinsic
 * constants.
 *
 * @returns The type {@code boolean}.
 */
Method "boolean" is
[
	privateBoolean;
] : privatePrimitiveType;

/**
 * Answer the type of an Avail character. Avail characters are Unicode.
 *
 * @returns The type {@code character}.
 */
Method "character" is
[
	privateCharacter;
] : privatePrimitiveType;

/**
 * Answer the supertype of every specific closure type.
 *
 * @return The type {@code closure}.
 */
Method "closure" is
[
	privateClosure;
] : privatePrimitiveType;

/**
 * Answer the type of all compiled code.
 *
 * @return The type {@code code}.
 */
Method "compiled code" is
[
	privateCompiledCode;
] : privatePrimitiveType;

/**
 * Answer the supertype of every specific container type.
 *
 * @return The type {@code container}.
 */
Method "container" is
[
	privateContainer;
] : privateContainerType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code continuation}.
 */
Method "continuation" is
[
	privateContinuation;
] : privatePrimitiveType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code double}.
 */
Method "double" is
[
	privateDouble;
] : privatePrimitiveType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code extendedInteger}.
 */
Method "extended integer" is
[
	privateExtendedInteger;
] : privateIntegerType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code falseType}.
 */
Method "false type" is
[
	privateFalseType;
] : privatePrimitiveType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code float}.
 */
Method "float" is
[
	privateFloat;
] : privatePrimitiveType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code integer}.
 */
Method "integer" is
[
	privateInteger;
] : privateIntegerType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code process}.
 */
Method "process" is
[
	privateProcess;
] : privatePrimitiveType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code set}.
 */
Method "set" is
[
	privateSet;
] : privateSetType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code string}.
 */
Method "string" is
[
	privateString;
] : privateTupleType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code terminates}.
 */
Method "terminates" is
[
	privateTerminates;
] : privateTerminatesType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code trueType}.
 */
Method "true type" is
[
	privateTrueType;
] : privatePrimitiveType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code tuple}.
 */
Method "tuple" is
[
	privateTuple;
] : privateTupleType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code void}.
 */
Method "void" is
[
	privateVoid;
] : privateType;

/* And the meta-types... */

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code integerType}.
 */
Method "integer type" is
[
	privateIntegerType;
] : privateMeta;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code tupleType}.
 */
Method "tuple type" is
[
	privateTupleType;
] : privateMeta;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code setType}.
 */
Method "set type" is
[
	privateSetType;
] : privateMeta;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code mapType}.
 */
Method "map type" is
[
	privateMapType;
] : privateMeta;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code closureType}.
 */
Method "closure type" is
[
	privateClosureType;
] : privateMeta;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code containerType}.
 */
Method "container type" is
[
	privateContainerType;
] : privateMeta;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code continuationType}.
 */
Method "continuation type" is
[
	privateContinuationType;
] : privateMeta;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code generalizedClosureType}.
 */
Method "generalized closure type" is
[
	privateGeneralizedClosureType;
] : privateMeta;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code objectType}.
 */
Method "object type" is
[
	privateObjectType;
] : privateObjectMeta;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code primitive type}.
 */
Method "primitive type" is
[
	privatePrimitiveType;
] : privateMeta;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code terminates type}.
 */
Method "terminates type" is
[
	privateTerminatesType;
] : privateMeta;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code type}.
 */
Method "type" is
[
	privateType;
] : privateMeta;

/* And the meta-meta-types... */

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code cyclic type}.
 */
Method "cyclic type" is
[
	privateCyclicType;
] : privateCyclicType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code meta}.
 */
Method "meta" is
[
	privateMeta;
] : privateMeta;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code object meta}.
 */
Method "object meta" is
[
	privateObjectMeta;
] : privateObjectMetaMeta;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code object meta meta}.
 */
Method "object meta meta" is
[
	privateObjectMetaMeta;
] : privateMeta;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code parse node}.
 */
Method "parse node" is
[
	privateParseNode;
] : privatePrimativeType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code marker node}.
 */
Method "marker node" is
[
	privateMarkerNode;
] : privatePrimativeType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code expression node}.
 */
Method "expression node" is
[
	privateExpressionNode;
] : privatePrimativeType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code assignment node}.
 */
Method "assignment node" is
[
	privateAssignmentNode;
] : privatePrimativeType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code block node}.
 */
Method "block node" is
[
	privateBlockNode;
] : privatePrimativeType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code literal node}.
 */
Method "literal node" is
[
	privateLiteralNode;
] : privatePrimativeType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code reference node}.
 */
Method "reference node" is
[
	privateReferenceNode;
] : privatePrimativeType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code send node}.
 */
Method "send node" is
[
	privateSendNode;
] : privatePrimativeType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code supercast node}.
 */
Method "supercast node" is
[
	privateSuperCastNode;
] : privatePrimativeType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code tuple node}.
 */
Method "tuple node" is
[
	privateTupleNode;
] : privatePrimativeType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code variable use node}.
 */
Method "variable use node" is
[
	privateVariableUseNode;
] : privatePrimativeType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code declaration node}.
 */
Method "declaration node" is
[
	privateDeclarationNode;
] : privatePrimativeType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code argument node}.
 */
Method "argument node" is
[
	privateArgumentNode;
] : privatePrimativeType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code label node}.
 */
Method "label node" is
[
	privateLabelNode;
] : privatePrimativeType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code local variable node}.
 */
Method "local variable node" is
[
	privateLocalVariableNode;
] : privatePrimativeType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code local constant node}.
 */
Method "local constant node" is
[
	privateLocalConstantNode;
] : privatePrimativeType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code module variable node}.
 */
Method "module variable node" is
[
	privateModuleVariableNode;
] : privatePrimativeType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code module constant node}.
 */
Method "module constant node" is
[
	privateModuleConstantNode;
] : privatePrimativeType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code true}.
 */
Method "true" is
[
	privateTrue;
] : privateTrueType;

/**
 * TODO: Really comment this!
 *
 * @returns The type {@code false}.
 */
Method "false" is
[
	privateFalse;
] : privateFalseType;
