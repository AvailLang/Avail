/**
 * System/Foundation/Integer
 * Copyright (c) 2010, Mark van Gulik.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of the contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Provide basic operations to construct integer range kinds and to query their
 * properties. Provide convenient aliases for common integer kinds. Provide
 * bindings for special values.
 *
 * @author Todd L Smith &lt;anarakul@gmail.com&gt;
 */
System Module "Integer"
Extends
Uses
	"Basic Comparison" ("_≤_"),
	"Basic Support" ("_'s type"),
	"Basic Types"
Names
	/* Special values. */
	"∞",
	"-∞",
	
	/* Kind aliases. */
	"extended integer",					/* ⊶[-∞..∞] */
	"integer",							/* ⊶(-∞..∞) */
	"whole number",						/* ⊶[0..∞) */
	"natural number",					/* ⊶[1..∞) */
	
	/* Metakind alias. */
	"integral metakind",				/* extended integer's type */
	
	/* Kind constructors. */
	"integral range from_(inclusive if_)to_(inclusive if_)",
	"[_.._]",							/* Inclusive, inclusive */
	"[_.._)",							/* Inclusive, exclusive */
	"(_.._]",							/* Exclusive, inclusive */
	"(_.._)",							/* Exclusive, exclusive */
	
	/* Bounds extraction. */
	"_'s lower bound",
	"_'s upper bound",
	
	/* Type queries. */
	"_'s lower bound is inclusive",
	"_'s upper bound is inclusive",
	
	/* Instance queries. */
	"_is finite",
	"_is infinite"
Body

/**
 * {@code extended integer} is the complete integral range, including the
 * infinities.
 *
 * @return {@code extended integer}.
 */
Method "extended integer" is
[
	⊶[-∞..∞];
];

/**
 * {@code integer} is the complete finite integral range.
 *
 * @return {@code integer}.
 */
Method "integer" is
[
	⊶(-∞..∞);
];

/**
 * {@code whole number} is the complete range of whole numbers, i.e. the
 * integers ranging from {@code 0} (inclusive) to {@code ∞}, exclusive.
 *
 * @return {@code whole number}.
 */
Method "whole number" is
[
	⊶[0..∞);
];

/**
 * {@code natural number} is the complete range of natural numbers, i.e. the
 * integers ranging from {@code 1} (inclusive) to {@code ∞}, exclusive.
 *
 * @return {@code whole number}.
 */
Method "natural number" is
[
	⊶[1..∞);
];

/**
 * Answer the most general integer metakind.
 *
 * @return {@code extended integer's type}.
 */
Method "integral metakind" is
[
	extended integer's type;
];

/**
 * Answer the lower bound of the specified integral kind. The caller can ask the
 * argument if it includes the answer to determine its inclusivity.
 *
 * @param integralKind
 *        An integral kind.
 * @return The argument's lower bound.
 */
Method "_'s lower bound" is
[
	integralKind : integral metakind
|
	Primitive 8;
] : extended integer;

/**
 * Answer the upper bound of the specified integral kind. The caller can ask the
 * argument if it includes the answer to determine its inclusivity.
 *
 * @param integralKind
 *        An integral kind.
 * @return The argument's upper bound.
 */
Method "_'s upper bound" is
[
	integralKind : integral metakind
|
	Primitive 9;
] : extended integer;

/**
 * Is the argument's lower bound inclusive?
 *
 * @param integralKind
 *        An integralKind.
 * @return {@code true} if the argument's lower bound is inclusive, {@code
 *         false} otherwise.
 */
Method "_'s lower bound is inclusive" is
[
	integralKind : integral metakind
|
	integralKind's lower bound's type ≤ integralKind;
]; 

/**
 * Is the argument's upper bound inclusive?
 *
 * @param integralKind
 *        An integralKind.
 * @return {@code true} if the argument's upper bound is inclusive, {@code
 *         false} otherwise.
 */
Method "_'s upper bound is inclusive" is
[
	integralKind : integral metakind
|
	integralKind's upper bound's type ≤ integralKind;
]; 

/**
 * Answer {@code ∞}.
 *
 * @return {@code ∞}.
 */
Method "∞" is
[
	extended integer's upper bound;
];

/**
 * Answer {@code -∞}.
 *
 * @return {@code -∞}.
 */
Method "-∞" is
[
	extended integer's lower bound;
];

/**
 * Construct an integral kind that ranges from {@code lower} to {@code upper},
 * the inclusivity of each being determined by its subsequent {@code boolean}
 * argument.
 *
 * @param lower
 *        The lower bound.
 * @param lowerIsInclusive
 *        {@code true} if the lower bound is inclusive, {@code false} otherwise.
 * @param upper
 *        The upper bound.
 * @param upperIsInclusive
 *        {@code true} if the upper bound is inclusive, {@code false} otherwise.
 * @return An integral kind.
 */
Method "integral range from_(inclusive if_)to_(inclusive if_)" is
[
	lower : extended integer,
	lowerIsInclusive : boolean,
	upper : extended integer,
	upperIsInclusive : boolean
|
	Primitive 7;
] : integral metakind;

/**
 * Answer the integral kind that ranges from {@code lower} (inclusive) to
 * {@code upper} (inclusive).
 *
 * @return An integral kind.
 */
Method "[_.._]" is
[
	lower : extended integer,
	upper : extended integer
|
	integral range
		from lower (inclusive if true)
		to upper (inclusive if true);
] : integral metakind;

/**
 * Answer the integral kind that ranges from {@code lower} (inclusive) to
 * {@code upper} (exclusive).
 *
 * @return An integral kind.
 */
Method "[_.._)" is
[
	lower : extended integer,
	upper : extended integer
|
	integral range
		from lower (inclusive if true)
		to upper (inclusive if false);
] : integral metakind;

/**
 * Answer the integral kind that ranges from {@code lower} (exclusive) to
 * {@code upper} (inclusive).
 *
 * @return An integral kind.
 */
Method "(_.._]" is
[
	lower : extended integer,
	upper : extended integer
|
	integral range
		from lower (inclusive if false)
		to upper (inclusive if true);
] : integral metakind;

/**
 * Answer the integral kind that ranges from {@code lower} (inclusive) to
 * {@code upper} (inclusive).
 *
 * @return An integral kind.
 */
Method "(_.._)" is
[
	lower : extended integer,
	upper : extended integer
|
	integral range
		from lower (inclusive if false)
		to upper (inclusive if false);
] : integral metakind;

/**
 * Is the argument finite?
 *
 * <p>Note that this implementation cooperates with a more specific
 * implementation defined over {@code integer} to provide complete coverage of
 * {@code extended integer}.</p>
 *
 * @param value
 *        An {@code extended integer}.
 * @return {@code false}, declared as a {@code boolean} to allow covariant
 *         return by the specialization.
 */
Method "_is finite" is
[
	value : extended integer
|
	false;
] : boolean;

/**
 * Is the argument finite?
 *
 * <p>Note that this implementation cooperates with a more general
 * implementation defined over {@code extended integer} to provide complete
 * coverage of {@code extended integer}.</p>
 *
 * @param value
 *        An {@code extended integer}.
 * @return {@code true}.
 */
Method "_is finite" is
[
	value : integer
|
	true;
] : true's type;

/**
 * Is the argument infinite?
 *
 * <p>Note that this implementation cooperates with a more specific
 * implementation defined over {@code integer} to provide complete coverage of
 * {@code extended integer}.</p>
 *
 * @param value
 *        An {@code extended integer}.
 * @return {@code true}, declared as a {@code boolean} to allow covariant
 *         return by the specialization.
 */
Method "_is infinite" is
[
	value : extended integer
|
	true;
] : boolean;

/**
 * Is the argument infinite?
 *
 * <p>Note that this implementation cooperates with a more general
 * implementation defined over {@code extended integer} to provide complete
 * coverage of {@code extended integer}.</p>
 *
 * @param value
 *        An {@code extended integer}.
 * @return {@code false}.
 */
Method "_is infinite" is
[
	value : integer
|
	false;
] : false's type;
